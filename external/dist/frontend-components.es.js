class $T extends HTMLElement {
  static get observedAttributes() {
    return ["color", "label"];
  }
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.render();
  }
  attributeChangedCallback() {
    this.render();
  }
  render() {
    const n = this.getAttribute("color") || "#0078d4", l = this.getAttribute("label") || "Coloured Box";
    this.shadowRoot && (this.shadowRoot.innerHTML = `
        <style>
          .box {
            width: 200px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2px solid #333;
            font-size: 1.2rem;
            color: #fff;
            background: ${n};
          }
        </style>
        <div class="box">${l}</div>
      `);
  }
}
customElements.define("my-box", $T);
class ZT extends HTMLElement {
  #e = 5e3;
  #t = {
    awaiting_start: `
      <p class="govuk-body-l">The service is busier than usual. Your extraction is in the queue.</p>
    `,
    in_progress: `
      <p class="govuk-body-l">Your PDF is being processed. This may take a few minutes.</p>
    `,
    completed: `
      <p class="govuk-body-l">Your PDF has been processed. <span class="govuk-visually-hidden">Click the button below this message or reload the page to continue.</span></p>
      <a href="${window.location.href}" class="govuk-button">View extraction</a>
    `,
    failed: `
      <p class="govuk-body-l">Your PDF has failed to process. Please <a href="/upload">try uploading again</a>.</p>
    `
  };
  connectedCallback() {
    this.#i(), this.#a(), this.querySelector(".loading-spinner__pause-button")?.addEventListener(
      "click",
      this.#r
    );
  }
  disconnectedCallback() {
    this.querySelector(".loading-spinner__pause-button")?.removeEventListener(
      "click",
      this.#r
    );
  }
  #i() {
    this.classList.add("loading-spinner"), this.innerHTML = `
      <div class="loading-spinner__spinner loading-spinner__spinner--active">
        <div class="loading-spinner__spinner-inner"></div>
        <button class="loading-spinner__pause-button">Stop spinner animation</button>
        <span class="loading-spinner__pause-message" tabindex="-1">Animation stopped. This will not affect the extraction process.</span>
      </div>
      <div class="loading-spinner__message" aria-live="assertive"></div>
    `;
  }
  #r = () => this.#n();
  #n(n = !1) {
    const l = this.querySelector(".loading-spinner__spinner");
    l?.classList.remove("loading-spinner__spinner--active"), n ? l?.remove() : this.querySelector(
      ".loading-spinner__pause-message"
    )?.focus();
  }
  /**
   * Check the job status from the backend and update the message.
   */
  async #a() {
    const n = this.querySelector(".loading-spinner__message"), l = this.getAttribute("fetch-url");
    if (!(!this.isConnected || !n || !l))
      try {
        const p = await fetch(l);
        if (!p.ok)
          throw new Error("Error with extraction status response");
        const x = await p.json(), M = x.status, S = this.#t[x.status];
        S && (n.innerHTML = S), M === "completed" || M === "failed" ? this.#n(!0) : window.setTimeout(() => this.#a(), this.#e);
      } catch (p) {
        console.error(`Error fetching extraction status: ${p}`), window.setTimeout(() => this.#a(), this.#e);
      }
  }
}
customElements.define("loading-spinner", ZT);
function HT(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var hg = { exports: {} };
var YT = hg.exports, Fx;
function WT() {
  return Fx || (Fx = 1, (function(a, n) {
    (function(l, p) {
      a.exports = p();
    })(YT, (function() {
      var l = {}, p = {};
      function x(S, u, R) {
        if (p[S] = R, S === "index") {
          var z = "var sharedModule = {}; (" + p.shared + ")(sharedModule); (" + p.worker + ")(sharedModule);", U = {};
          return p.shared(U), p.index(l, U), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([z], { type: "text/javascript" }))), l;
        }
      }
      x("shared", ["exports"], (function(S) {
        function u(i, e, r, c) {
          return new (r || (r = Promise))((function(f, m) {
            function v(P) {
              try {
                k(c.next(P));
              } catch (L) {
                m(L);
              }
            }
            function E(P) {
              try {
                k(c.throw(P));
              } catch (L) {
                m(L);
              }
            }
            function k(P) {
              var L;
              P.done ? f(P.value) : (L = P.value, L instanceof r ? L : new r((function(N) {
                N(L);
              }))).then(v, E);
            }
            k((c = c.apply(i, e || [])).next());
          }));
        }
        function R(i, e) {
          this.x = i, this.y = e;
        }
        function z(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
        }
        var U, $;
        typeof SuppressedError == "function" && SuppressedError, R.prototype = { clone() {
          return new R(this.x, this.y);
        }, add(i) {
          return this.clone()._add(i);
        }, sub(i) {
          return this.clone()._sub(i);
        }, multByPoint(i) {
          return this.clone()._multByPoint(i);
        }, divByPoint(i) {
          return this.clone()._divByPoint(i);
        }, mult(i) {
          return this.clone()._mult(i);
        }, div(i) {
          return this.clone()._div(i);
        }, rotate(i) {
          return this.clone()._rotate(i);
        }, rotateAround(i, e) {
          return this.clone()._rotateAround(i, e);
        }, matMult(i) {
          return this.clone()._matMult(i);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(i) {
          return this.x === i.x && this.y === i.y;
        }, dist(i) {
          return Math.sqrt(this.distSqr(i));
        }, distSqr(i) {
          const e = i.x - this.x, r = i.y - this.y;
          return e * e + r * r;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(i) {
          return Math.atan2(this.y - i.y, this.x - i.x);
        }, angleWith(i) {
          return this.angleWithSep(i.x, i.y);
        }, angleWithSep(i, e) {
          return Math.atan2(this.x * e - this.y * i, this.x * i + this.y * e);
        }, _matMult(i) {
          const e = i[2] * this.x + i[3] * this.y;
          return this.x = i[0] * this.x + i[1] * this.y, this.y = e, this;
        }, _add(i) {
          return this.x += i.x, this.y += i.y, this;
        }, _sub(i) {
          return this.x -= i.x, this.y -= i.y, this;
        }, _mult(i) {
          return this.x *= i, this.y *= i, this;
        }, _div(i) {
          return this.x /= i, this.y /= i, this;
        }, _multByPoint(i) {
          return this.x *= i.x, this.y *= i.y, this;
        }, _divByPoint(i) {
          return this.x /= i.x, this.y /= i.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const i = this.y;
          return this.y = this.x, this.x = -i, this;
        }, _rotate(i) {
          const e = Math.cos(i), r = Math.sin(i), c = r * this.x + e * this.y;
          return this.x = e * this.x - r * this.y, this.y = c, this;
        }, _rotateAround(i, e) {
          const r = Math.cos(i), c = Math.sin(i), f = e.y + c * (this.x - e.x) + r * (this.y - e.y);
          return this.x = e.x + r * (this.x - e.x) - c * (this.y - e.y), this.y = f, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: R }, R.convert = function(i) {
          if (i instanceof R) return i;
          if (Array.isArray(i)) return new R(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new R(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var ee = (function() {
          if ($) return U;
          function i(e, r, c, f) {
            this.cx = 3 * e, this.bx = 3 * (c - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (f - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = c, this.p2y = f;
          }
          return $ = 1, U = i, i.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, r) {
            if (r === void 0 && (r = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var c = e, f = 0; f < 8; f++) {
              var m = this.sampleCurveX(c) - e;
              if (Math.abs(m) < r) return c;
              var v = this.sampleCurveDerivativeX(c);
              if (Math.abs(v) < 1e-6) break;
              c -= m / v;
            }
            var E = 0, k = 1;
            for (c = e, f = 0; f < 20 && (m = this.sampleCurveX(c), !(Math.abs(m - e) < r)); f++) e > m ? E = c : k = c, c = 0.5 * (k - E) + E;
            return c;
          }, solve: function(e, r) {
            return this.sampleCurveY(this.solveCurveX(e, r));
          } }, U;
        })(), le = z(ee);
        let ce, _e;
        function ne() {
          return ce == null && (ce = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ce;
        }
        function Pe() {
          if (_e == null && (_e = !1, ne())) {
            const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (e) {
              for (let c = 0; c < 25; c++) {
                const f = 4 * c;
                e.fillStyle = `rgb(${f},${f + 1},${f + 2})`, e.fillRect(c % 5, Math.floor(c / 5), 1, 1);
              }
              const r = e.getImageData(0, 0, 5, 5).data;
              for (let c = 0; c < 100; c++) if (c % 4 != 3 && r[c] !== c) {
                _e = !0;
                break;
              }
            }
          }
          return _e || !1;
        }
        var ve = 1e-6, Ue = typeof Float32Array < "u" ? Float32Array : Array;
        function Qe() {
          var i = new Ue(9);
          return Ue != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i;
        }
        function et(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
        }
        function Xe() {
          var i = new Ue(3);
          return Ue != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i;
        }
        function ut(i) {
          var e = i[0], r = i[1], c = i[2];
          return Math.sqrt(e * e + r * r + c * c);
        }
        function Q(i, e, r) {
          var c = new Ue(3);
          return c[0] = i, c[1] = e, c[2] = r, c;
        }
        function se(i, e, r) {
          return i[0] = e[0] + r[0], i[1] = e[1] + r[1], i[2] = e[2] + r[2], i;
        }
        function ge(i, e, r) {
          return i[0] = e[0] * r, i[1] = e[1] * r, i[2] = e[2] * r, i;
        }
        function Se(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = r[0], E = r[1], k = r[2];
          return i[0] = f * k - m * E, i[1] = m * v - c * k, i[2] = c * E - f * v, i;
        }
        var Ie, ze = ut;
        function Re(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = e[3];
          return i[0] = r[0] * c + r[4] * f + r[8] * m + r[12] * v, i[1] = r[1] * c + r[5] * f + r[9] * m + r[13] * v, i[2] = r[2] * c + r[6] * f + r[10] * m + r[14] * v, i[3] = r[3] * c + r[7] * f + r[11] * m + r[15] * v, i;
        }
        function De() {
          var i = new Ue(4);
          return Ue != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i;
        }
        function Ne(i, e, r, c) {
          var f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", m = Math.PI / 360;
          e *= m, c *= m, r *= m;
          var v = Math.sin(e), E = Math.cos(e), k = Math.sin(r), P = Math.cos(r), L = Math.sin(c), N = Math.cos(c);
          switch (f) {
            case "xyz":
              i[0] = v * P * N + E * k * L, i[1] = E * k * N - v * P * L, i[2] = E * P * L + v * k * N, i[3] = E * P * N - v * k * L;
              break;
            case "xzy":
              i[0] = v * P * N - E * k * L, i[1] = E * k * N - v * P * L, i[2] = E * P * L + v * k * N, i[3] = E * P * N + v * k * L;
              break;
            case "yxz":
              i[0] = v * P * N + E * k * L, i[1] = E * k * N - v * P * L, i[2] = E * P * L - v * k * N, i[3] = E * P * N + v * k * L;
              break;
            case "yzx":
              i[0] = v * P * N + E * k * L, i[1] = E * k * N + v * P * L, i[2] = E * P * L - v * k * N, i[3] = E * P * N - v * k * L;
              break;
            case "zxy":
              i[0] = v * P * N - E * k * L, i[1] = E * k * N + v * P * L, i[2] = E * P * L + v * k * N, i[3] = E * P * N - v * k * L;
              break;
            case "zyx":
              i[0] = v * P * N - E * k * L, i[1] = E * k * N + v * P * L, i[2] = E * P * L - v * k * N, i[3] = E * P * N + v * k * L;
              break;
            default:
              throw new Error("Unknown angle order " + f);
          }
          return i;
        }
        function Ge() {
          var i = new Ue(2);
          return Ue != Float32Array && (i[0] = 0, i[1] = 0), i;
        }
        function qe(i, e) {
          var r = new Ue(2);
          return r[0] = i, r[1] = e, r;
        }
        Xe(), Ie = new Ue(4), Ue != Float32Array && (Ie[0] = 0, Ie[1] = 0, Ie[2] = 0, Ie[3] = 0), Xe(), Q(1, 0, 0), Q(0, 1, 0), De(), De(), Qe(), Ge();
        const Je = 8192;
        function ft(i, e, r) {
          return e * (Je / (i.tileSize * Math.pow(2, r - i.tileID.overscaledZ)));
        }
        function Tt(i, e) {
          return (i % e + e) % e;
        }
        function Zt(i, e, r) {
          return i * (1 - r) + e * r;
        }
        function zt(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const e = i * i, r = e * i;
          return 4 * (i < 0.5 ? r : 3 * (i - e) + r - 0.75);
        }
        function At(i, e, r, c) {
          const f = new le(i, e, r, c);
          return (m) => f.solve(m);
        }
        const Dt = At(0.25, 0.1, 0.25, 1);
        function Yt(i, e, r) {
          return Math.min(r, Math.max(e, i));
        }
        function mr(i, e, r) {
          const c = r - e, f = ((i - e) % c + c) % c + e;
          return f === e ? r : f;
        }
        function He(i, ...e) {
          for (const r of e) for (const c in r) i[c] = r[c];
          return i;
        }
        let yi = 1;
        function fr(i, e, r) {
          const c = {};
          for (const f in i) c[f] = e.call(this, i[f], f, i);
          return c;
        }
        function Bt(i, e, r) {
          const c = {};
          for (const f in i) e.call(this, i[f], f, i) && (c[f] = i[f]);
          return c;
        }
        function Me(i) {
          return Array.isArray(i) ? i.map(Me) : typeof i == "object" && i ? fr(i, Me) : i;
        }
        const br = {};
        function ur(i) {
          br[i] || (typeof console < "u" && console.warn(i), br[i] = !0);
        }
        function rr(i, e, r) {
          return (r.y - i.y) * (e.x - i.x) > (e.y - i.y) * (r.x - i.x);
        }
        function ni(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
        }
        let Dr = null;
        function ii(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
        }
        const Mt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Zi(i, e, r, c, f) {
          return u(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const m = new VideoFrame(i, { timestamp: 0 });
            try {
              const v = m?.format;
              if (!v || !v.startsWith("BGR") && !v.startsWith("RGB")) throw new Error(`Unrecognized format ${v}`);
              const E = v.startsWith("BGR"), k = new Uint8ClampedArray(c * f * 4);
              if (yield m.copyTo(k, (function(P, L, N, G, j) {
                const Z = 4 * Math.max(-L, 0), Y = (Math.max(0, N) - N) * G * 4 + Z, J = 4 * G, ie = Math.max(0, L), ye = Math.max(0, N);
                return { rect: { x: ie, y: ye, width: Math.min(P.width, L + G) - ie, height: Math.min(P.height, N + j) - ye }, layout: [{ offset: Y, stride: J }] };
              })(i, e, r, c, f)), E) for (let P = 0; P < k.length; P += 4) {
                const L = k[P];
                k[P] = k[P + 2], k[P + 2] = L;
              }
              return k;
            } finally {
              m.close();
            }
          }));
        }
        let Ti, jn;
        function Ls(i, e, r, c) {
          return i.addEventListener(e, r, c), { unsubscribe: () => {
            i.removeEventListener(e, r, c);
          } };
        }
        function tr(i) {
          return i * Math.PI / 180;
        }
        function ln(i) {
          return i / Math.PI * 180;
        }
        const Vn = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, Un = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, Jt = "AbortError";
        class os extends Error {
          constructor(e = Jt) {
            super(e instanceof Error ? e.message : e), this.name = Jt, e instanceof Error && e.stack && (this.stack = e.stack);
          }
        }
        function Fe(i) {
          return i.name === Jt;
        }
        const H = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function K(i) {
          return H.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
        }
        const re = "global-dispatcher";
        class Te extends Error {
          constructor(e, r, c, f) {
            super(`AJAXError: ${r} (${e}): ${c}`), this.status = e, this.statusText = r, this.url = c, this.body = f;
          }
        }
        const me = () => ni(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ye = function(i, e) {
          if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
            const c = K(i.url);
            if (c) return c(i, e);
            if (ni(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: re }, e);
          }
          if (!(/^file:/.test(r = i.url) || /^file:/.test(me()) && !/^\w+:/.test(r))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(c, f) {
              return u(this, void 0, void 0, (function* () {
                const m = new Request(c.url, { method: c.method || "GET", body: c.body, credentials: c.credentials, headers: c.headers, cache: c.cache, referrer: me(), signal: f.signal });
                let v, E;
                c.type !== "json" || m.headers.has("Accept") || m.headers.set("Accept", "application/json");
                try {
                  v = yield fetch(m);
                } catch (P) {
                  throw Fe(P) ? P : new Te(0, P.message, c.url, new Blob());
                }
                if (!v.ok) {
                  const P = yield v.blob();
                  throw new Te(v.status, v.statusText, c.url, P);
                }
                E = c.type === "arrayBuffer" || c.type === "image" ? v.arrayBuffer() : c.type === "json" ? v.json() : v.text();
                const k = yield E;
                return f.signal.throwIfAborted(), { data: k, cacheControl: v.headers.get("Cache-Control"), expires: v.headers.get("Expires") };
              }));
            })(i, e);
            if (ni(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: re }, e);
          }
          var r;
          return (function(c, f) {
            return new Promise(((m, v) => {
              var E;
              const k = new XMLHttpRequest();
              k.open(c.method || "GET", c.url, !0), c.type !== "arrayBuffer" && c.type !== "image" || (k.responseType = "arraybuffer");
              for (const P in c.headers) k.setRequestHeader(P, c.headers[P]);
              c.type === "json" && (k.responseType = "text", !((E = c.headers) === null || E === void 0) && E.Accept || k.setRequestHeader("Accept", "application/json")), k.withCredentials = c.credentials === "include", k.onerror = () => {
                v(new Error(k.statusText));
              }, k.onload = () => {
                if (!f.signal.aborted) if ((k.status >= 200 && k.status < 300 || k.status === 0) && k.response !== null) {
                  let P = k.response;
                  if (c.type === "json") try {
                    P = JSON.parse(k.response);
                  } catch (L) {
                    return void v(L);
                  }
                  m({ data: P, cacheControl: k.getResponseHeader("Cache-Control"), expires: k.getResponseHeader("Expires") });
                } else {
                  const P = new Blob([k.response], { type: k.getResponseHeader("Content-Type") });
                  v(new Te(k.status, k.statusText, c.url, P));
                }
              }, f.signal.addEventListener("abort", (() => {
                k.abort(), v(new os(f.signal.reason));
              })), k.send(c.body);
            }));
          })(i, e);
        };
        function We(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const e = new URL(i), r = window.location;
          return e.protocol === r.protocol && e.host === r.host;
        }
        function Ve(i, e, r) {
          r[i] && r[i].indexOf(e) !== -1 || (r[i] = r[i] || [], r[i].push(e));
        }
        function $e(i, e, r) {
          if (r && r[i]) {
            const c = r[i].indexOf(e);
            c !== -1 && r[i].splice(c, 1);
          }
        }
        class gt {
          constructor(e, r = {}) {
            He(this, r), this.type = e;
          }
        }
        class st extends gt {
          constructor(e, r = {}) {
            super("error", He({ error: e }, r));
          }
        }
        class vt {
          on(e, r) {
            return this._listeners = this._listeners || {}, Ve(e, r, this._listeners), { unsubscribe: () => {
              this.off(e, r);
            } };
          }
          off(e, r) {
            return $e(e, r, this._listeners), $e(e, r, this._oneTimeListeners), this;
          }
          once(e, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ve(e, r, this._oneTimeListeners), this) : new Promise(((c) => this.once(e, c)));
          }
          fire(e, r) {
            typeof e == "string" && (e = new gt(e, r || {}));
            const c = e.type;
            if (this.listens(c)) {
              e.target = this;
              const f = this._listeners && this._listeners[c] ? this._listeners[c].slice() : [];
              for (const E of f) E.call(this, e);
              const m = this._oneTimeListeners && this._oneTimeListeners[c] ? this._oneTimeListeners[c].slice() : [];
              for (const E of m) $e(c, E, this._oneTimeListeners), E.call(this, e);
              const v = this._eventedParent;
              v && (He(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(e));
            } else e instanceof st && console.error(e.error);
            return this;
          }
          listens(e) {
            return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
          }
          setEventedParent(e, r) {
            return this._eventedParent = e, this._eventedParentData = r, this;
          }
        }
        var Be = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number", length: 2 }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "fontFaces" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "filter" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, filter: { type: "boolean", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "expression_name", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } }, interpolation: { type: "array", value: "interpolation_name", minimum: 1 }, interpolation_name: { type: "enum", values: { linear: { syntax: { overloads: [{ parameters: [], "output-type": "interpolation" }], parameters: [] } }, exponential: { syntax: { overloads: [{ parameters: ["base"], "output-type": "interpolation" }], parameters: [{ name: "base", type: "number literal" }] } }, "cubic-bezier": { syntax: { overloads: [{ parameters: ["x1", "y1", "x2", "y2"], "output-type": "interpolation" }], parameters: [{ name: "x1", type: "number literal" }, { name: "y1", type: "number literal" }, { name: "x2", type: "number literal" }, { name: "y2", type: "number literal" }] } } } } };
        const Qt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Cr(i, e) {
          const r = {};
          for (const c in i) c !== "ref" && (r[c] = i[c]);
          return Qt.forEach(((c) => {
            c in e && (r[c] = e[c]);
          })), r;
        }
        function kt(i, e) {
          if (Array.isArray(i)) {
            if (!Array.isArray(e) || i.length !== e.length) return !1;
            for (let r = 0; r < i.length; r++) if (!kt(i[r], e[r])) return !1;
            return !0;
          }
          if (typeof i == "object" && i !== null && e !== null) {
            if (typeof e != "object" || Object.keys(i).length !== Object.keys(e).length) return !1;
            for (const r in i) if (!kt(i[r], e[r])) return !1;
            return !0;
          }
          return i === e;
        }
        function lt(i, e) {
          i.push(e);
        }
        function nr(i, e, r) {
          lt(r, { command: "addSource", args: [i, e[i]] });
        }
        function Fr(i, e, r) {
          lt(e, { command: "removeSource", args: [i] }), r[i] = !0;
        }
        function wr(i, e, r, c) {
          Fr(i, r, c), nr(i, e, r);
        }
        function un(i, e, r) {
          let c;
          for (c in i[r]) if (Object.prototype.hasOwnProperty.call(i[r], c) && c !== "data" && !kt(i[r][c], e[r][c])) return !1;
          for (c in e[r]) if (Object.prototype.hasOwnProperty.call(e[r], c) && c !== "data" && !kt(i[r][c], e[r][c])) return !1;
          return !0;
        }
        function Qr(i, e, r, c, f, m) {
          i = i || {}, e = e || {};
          for (const v in i) Object.prototype.hasOwnProperty.call(i, v) && (kt(i[v], e[v]) || r.push({ command: m, args: [c, v, e[v], f] }));
          for (const v in e) Object.prototype.hasOwnProperty.call(e, v) && !Object.prototype.hasOwnProperty.call(i, v) && (kt(i[v], e[v]) || r.push({ command: m, args: [c, v, e[v], f] }));
        }
        function Ur(i) {
          return i.id;
        }
        function Ir(i, e) {
          return i[e.id] = e, i;
        }
        class pt {
          constructor(e, r, c, f) {
            this.message = (e ? `${e}: ` : "") + c, f && (this.identifier = f), r != null && r.__line__ && (this.line = r.__line__);
          }
        }
        function jr(i, ...e) {
          for (const r of e) for (const c in r) i[c] = r[c];
          return i;
        }
        class Wn extends Error {
          constructor(e, r) {
            super(r), this.message = r, this.key = e;
          }
        }
        class Hi {
          constructor(e, r = []) {
            this.parent = e, this.bindings = {};
            for (const [c, f] of r) this.bindings[c] = f;
          }
          concat(e) {
            return new Hi(this, e);
          }
          get(e) {
            if (this.bindings[e]) return this.bindings[e];
            if (this.parent) return this.parent.get(e);
            throw new Error(`${e} not found in scope.`);
          }
          has(e) {
            return !!this.bindings[e] || !!this.parent && this.parent.has(e);
          }
        }
        const Wr = { kind: "null" }, yt = { kind: "number" }, er = { kind: "string" }, ir = { kind: "boolean" }, mn = { kind: "color" }, Bi = { kind: "projectionDefinition" }, Gi = { kind: "object" }, we = { kind: "value" }, Gt = { kind: "collator" }, wt = { kind: "formatted" }, Sr = { kind: "padding" }, en = { kind: "colorArray" }, Mr = { kind: "numberArray" }, Mn = { kind: "resolvedImage" }, Dn = { kind: "variableAnchorOffsetCollection" };
        function Nr(i, e) {
          return { kind: "array", itemType: i, N: e };
        }
        function Er(i) {
          if (i.kind === "array") {
            const e = Er(i.itemType);
            return typeof i.N == "number" ? `array<${e}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${e}>`;
          }
          return i.kind;
        }
        const _n = [Wr, yt, er, ir, mn, Bi, wt, Gi, Nr(we), Sr, Mr, en, Mn, Dn];
        function Rn(i, e) {
          if (e.kind === "error") return null;
          if (i.kind === "array") {
            if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Rn(i.itemType, e.itemType)) && (typeof i.N != "number" || i.N === e.N)) return null;
          } else {
            if (i.kind === e.kind) return null;
            if (i.kind === "value") {
              for (const r of _n) if (!Rn(r, e)) return null;
            }
          }
          return `Expected ${Er(i)} but found ${Er(e)} instead.`;
        }
        function Yi(i, e) {
          return e.some(((r) => r.kind === i.kind));
        }
        function Ds(i, e) {
          return e.some(((r) => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i));
        }
        function si(i, e) {
          return i.kind === "array" && e.kind === "array" ? i.itemType.kind === e.itemType.kind && typeof i.N == "number" : i.kind === e.kind;
        }
        const yl = 0.96422, ba = 0.82521, vl = 4 / 29, cn = 6 / 29, su = 3 * cn * cn, au = cn * cn * cn, ea = Math.PI / 180, bs = 180 / Math.PI;
        function Rs(i) {
          return (i %= 360) < 0 && (i += 360), i;
        }
        function ou([i, e, r, c]) {
          let f, m;
          const v = lu((0.2225045 * (i = Fs(i)) + 0.7168786 * (e = Fs(e)) + 0.0606169 * (r = Fs(r))) / 1);
          i === e && e === r ? f = m = v : (f = lu((0.4360747 * i + 0.3850649 * e + 0.1430804 * r) / yl), m = lu((0.0139322 * i + 0.0971045 * e + 0.7141733 * r) / ba));
          const E = 116 * v - 16;
          return [E < 0 ? 0 : E, 500 * (f - v), 200 * (v - m), c];
        }
        function Fs(i) {
          return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
        }
        function lu(i) {
          return i > au ? Math.pow(i, 1 / 3) : i / su + vl;
        }
        function uu([i, e, r, c]) {
          let f = (i + 16) / 116, m = isNaN(e) ? f : f + e / 500, v = isNaN(r) ? f : f - r / 200;
          return f = 1 * hu(f), m = yl * hu(m), v = ba * hu(v), [cu(3.1338561 * m - 1.6168667 * f - 0.4906146 * v), cu(-0.9787684 * m + 1.9161415 * f + 0.033454 * v), cu(0.0719453 * m - 0.2289914 * f + 1.4052427 * v), c];
        }
        function cu(i) {
          return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
        }
        function hu(i) {
          return i > cn ? i * i * i : su * (i - vl);
        }
        const wc = Object.hasOwn || function(i, e) {
          return Object.prototype.hasOwnProperty.call(i, e);
        };
        function Ns(i, e) {
          return wc(i, e) ? i[e] : void 0;
        }
        function Ao(i) {
          return parseInt(i.padEnd(2, i), 16) / 255;
        }
        function Ec(i, e) {
          return wa(e ? i / 100 : i, 0, 1);
        }
        function wa(i, e, r) {
          return Math.min(Math.max(e, i), r);
        }
        function du(i) {
          return !i.some(Number.isNaN);
        }
        const Ea = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Pr(i, e, r) {
          return i + r * (e - i);
        }
        function Wi(i, e, r) {
          return i.map(((c, f) => Pr(c, e[f], r)));
        }
        class cr {
          constructor(e, r, c, f = 1, m = !0) {
            this.r = e, this.g = r, this.b = c, this.a = f, m || (this.r *= f, this.g *= f, this.b *= f, f || this.overwriteGetter("rgb", [e, r, c, f]));
          }
          static parse(e) {
            if (e instanceof cr) return e;
            if (typeof e != "string") return;
            const r = (function(c) {
              if ((c = c.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const f = Ns(Ea, c);
              if (f) {
                const [v, E, k] = f;
                return [v / 255, E / 255, k / 255, 1];
              }
              if (c.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(c)) {
                const v = c.length < 6 ? 1 : 2;
                let E = 1;
                return [Ao(c.slice(E, E += v)), Ao(c.slice(E, E += v)), Ao(c.slice(E, E += v)), Ao(c.slice(E, E + v) || "ff")];
              }
              if (c.startsWith("rgb")) {
                const v = c.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (v) {
                  const [E, k, P, L, N, G, j, Z, Y, J, ie, ye] = v, ae = [L || " ", j || " ", J].join("");
                  if (ae === "  " || ae === "  /" || ae === ",," || ae === ",,,") {
                    const ue = [P, G, Y].join(""), Ee = ue === "%%%" ? 100 : ue === "" ? 255 : 0;
                    if (Ee) {
                      const Le = [wa(+k / Ee, 0, 1), wa(+N / Ee, 0, 1), wa(+Z / Ee, 0, 1), ie ? Ec(+ie, ye) : 1];
                      if (du(Le)) return Le;
                    }
                  }
                  return;
                }
              }
              const m = c.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (m) {
                const [v, E, k, P, L, N, G, j, Z] = m, Y = [k || " ", L || " ", G].join("");
                if (Y === "  " || Y === "  /" || Y === ",," || Y === ",,,") {
                  const J = [+E, wa(+P, 0, 100), wa(+N, 0, 100), j ? Ec(+j, Z) : 1];
                  if (du(J)) return (function([ie, ye, ae, ue]) {
                    function Ee(Le) {
                      const Ke = (Le + ie / 30) % 12, dt = ye * Math.min(ae, 1 - ae);
                      return ae - dt * Math.max(-1, Math.min(Ke - 3, 9 - Ke, 1));
                    }
                    return ie = Rs(ie), ye /= 100, ae /= 100, [Ee(0), Ee(8), Ee(4), ue];
                  })(J);
                }
              }
            })(e);
            return r ? new cr(...r, !1) : void 0;
          }
          get rgb() {
            const { r: e, g: r, b: c, a: f } = this, m = f || 1 / 0;
            return this.overwriteGetter("rgb", [e / m, r / m, c / m, f]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(e) {
              const [r, c, f, m] = ou(e), v = Math.sqrt(c * c + f * f);
              return [Math.round(1e4 * v) ? Rs(Math.atan2(f, c) * bs) : NaN, v, r, m];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", ou(this.rgb));
          }
          overwriteGetter(e, r) {
            return Object.defineProperty(this, e, { value: r }), r;
          }
          toString() {
            const [e, r, c, f] = this.rgb;
            return `rgba(${[e, r, c].map(((m) => Math.round(255 * m))).join(",")},${f})`;
          }
          static interpolate(e, r, c, f = "rgb") {
            switch (f) {
              case "rgb": {
                const [m, v, E, k] = Wi(e.rgb, r.rgb, c);
                return new cr(m, v, E, k, !1);
              }
              case "hcl": {
                const [m, v, E, k] = e.hcl, [P, L, N, G] = r.hcl;
                let j, Z;
                if (isNaN(m) || isNaN(P)) isNaN(m) ? isNaN(P) ? j = NaN : (j = P, E !== 1 && E !== 0 || (Z = L)) : (j = m, N !== 1 && N !== 0 || (Z = v));
                else {
                  let ae = P - m;
                  P > m && ae > 180 ? ae -= 360 : P < m && m - P > 180 && (ae += 360), j = m + c * ae;
                }
                const [Y, J, ie, ye] = (function([ae, ue, Ee, Le]) {
                  return ae = isNaN(ae) ? 0 : ae * ea, uu([Ee, Math.cos(ae) * ue, Math.sin(ae) * ue, Le]);
                })([j, Z ?? Pr(v, L, c), Pr(E, N, c), Pr(k, G, c)]);
                return new cr(Y, J, ie, ye, !1);
              }
              case "lab": {
                const [m, v, E, k] = uu(Wi(e.lab, r.lab, c));
                return new cr(m, v, E, k, !1);
              }
            }
          }
        }
        cr.black = new cr(0, 0, 0, 1), cr.white = new cr(1, 1, 1, 1), cr.transparent = new cr(0, 0, 0, 0), cr.red = new cr(1, 0, 0, 1);
        class Lo {
          constructor(e, r, c) {
            this.sensitivity = e ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = c, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(e, r) {
            return this.collator.compare(e, r);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Xi = ["bottom", "center", "top"];
        class ki {
          constructor(e, r, c, f, m, v) {
            this.text = e, this.image = r, this.scale = c, this.fontStack = f, this.textColor = m, this.verticalAlign = v;
          }
        }
        class Xn {
          constructor(e) {
            this.sections = e;
          }
          static fromString(e) {
            return new Xn([new ki(e, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0));
          }
          static factory(e) {
            return e instanceof Xn ? e : Xn.fromString(e);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((e) => e.text)).join("");
          }
        }
        class ai {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof ai) return e;
            if (typeof e == "number") return new ai([e, e, e, e]);
            if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
              for (const r of e) if (typeof r != "number") return;
              switch (e.length) {
                case 1:
                  e = [e[0], e[0], e[0], e[0]];
                  break;
                case 2:
                  e = [e[0], e[1], e[0], e[1]];
                  break;
                case 3:
                  e = [e[0], e[1], e[2], e[1]];
              }
              return new ai(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c) {
            return new ai(Wi(e.values, r.values, c));
          }
        }
        class tn {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof tn) return e;
            if (typeof e == "number") return new tn([e]);
            if (Array.isArray(e)) {
              for (const r of e) if (typeof r != "number") return;
              return new tn(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c) {
            return new tn(Wi(e.values, r.values, c));
          }
        }
        class Kt {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof Kt) return e;
            if (typeof e == "string") {
              const c = cr.parse(e);
              return c ? new Kt([c]) : void 0;
            }
            if (!Array.isArray(e)) return;
            const r = [];
            for (const c of e) {
              if (typeof c != "string") return;
              const f = cr.parse(c);
              if (!f) return;
              r.push(f);
            }
            return new Kt(r);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c, f = "rgb") {
            const m = [];
            if (e.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let v = 0; v < e.values.length; v++) m.push(cr.interpolate(e.values[v], r.values[v], c, f));
            return new Kt(m);
          }
        }
        class Ar extends Error {
          constructor(e) {
            super(e), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const ta = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class oi {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof oi) return e;
            if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
              for (let r = 0; r < e.length; r += 2) {
                const c = e[r], f = e[r + 1];
                if (typeof c != "string" || !ta.has(c) || !Array.isArray(f) || f.length !== 2 || typeof f[0] != "number" || typeof f[1] != "number") return;
              }
              return new oi(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c) {
            const f = e.values, m = r.values;
            if (f.length !== m.length) throw new Ar(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${r.toString()}`);
            const v = [];
            for (let E = 0; E < f.length; E += 2) {
              if (f[E] !== m[E]) throw new Ar(`Cannot interpolate values containing mismatched anchors. from[${E}]: ${f[E]}, to[${E}]: ${m[E]}`);
              v.push(f[E]);
              const [k, P] = f[E + 1], [L, N] = m[E + 1];
              v.push([Pr(k, L, c), Pr(P, N, c)]);
            }
            return new oi(v);
          }
        }
        class hr {
          constructor(e) {
            this.name = e.name, this.available = e.available;
          }
          toString() {
            return this.name;
          }
          static fromString(e) {
            return e ? new hr({ name: e, available: !1 }) : null;
          }
        }
        class rn {
          constructor(e, r, c) {
            this.from = e, this.to = r, this.transition = c;
          }
          static interpolate(e, r, c) {
            return new rn(e, r, c);
          }
          static parse(e) {
            return e instanceof rn ? e : Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number" ? new rn(e[0], e[1], e[2]) : typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number" ? new rn(e.from, e.to, e.transition) : typeof e == "string" ? new rn(e, e, 1) : void 0;
          }
        }
        function ra(i, e, r, c) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? c === void 0 || typeof c == "number" && c >= 0 && c <= 1 ? null : `Invalid rgba value [${[i, e, r, c].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof c == "number" ? [i, e, r, c] : [i, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Os(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof rn || i instanceof cr || i instanceof Lo || i instanceof Xn || i instanceof ai || i instanceof tn || i instanceof Kt || i instanceof oi || i instanceof hr) return !0;
          if (Array.isArray(i)) {
            for (const e of i) if (!Os(e)) return !1;
            return !0;
          }
          if (typeof i == "object") {
            for (const e in i) if (!Os(i[e])) return !1;
            return !0;
          }
          return !1;
        }
        function qr(i) {
          if (i === null) return Wr;
          if (typeof i == "string") return er;
          if (typeof i == "boolean") return ir;
          if (typeof i == "number") return yt;
          if (i instanceof cr) return mn;
          if (i instanceof rn) return Bi;
          if (i instanceof Lo) return Gt;
          if (i instanceof Xn) return wt;
          if (i instanceof ai) return Sr;
          if (i instanceof tn) return Mr;
          if (i instanceof Kt) return en;
          if (i instanceof oi) return Dn;
          if (i instanceof hr) return Mn;
          if (Array.isArray(i)) {
            const e = i.length;
            let r;
            for (const c of i) {
              const f = qr(c);
              if (r) {
                if (r === f) continue;
                r = we;
                break;
              }
              r = f;
            }
            return Nr(r || we, e);
          }
          return Gi;
        }
        function na(i) {
          const e = typeof i;
          return i === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(i) : i instanceof cr || i instanceof rn || i instanceof Xn || i instanceof ai || i instanceof tn || i instanceof Kt || i instanceof oi || i instanceof hr ? i.toString() : JSON.stringify(i);
        }
        class nn {
          constructor(e, r) {
            this.type = e, this.value = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (!Os(e[1])) return r.error("invalid value");
            const c = e[1];
            let f = qr(c);
            const m = r.expectedType;
            return f.kind !== "array" || f.N !== 0 || !m || m.kind !== "array" || typeof m.N == "number" && m.N !== 0 || (f = m), new nn(f, c);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Do = { string: er, number: yt, boolean: ir, object: Gi };
        class li {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            let c, f = 1;
            const m = e[0];
            if (m === "array") {
              let E, k;
              if (e.length > 2) {
                const P = e[1];
                if (typeof P != "string" || !(P in Do) || P === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                E = Do[P], f++;
              } else E = we;
              if (e.length > 3) {
                if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                k = e[2], f++;
              }
              c = Nr(E, k);
            } else {
              if (!Do[m]) throw new Error(`Types doesn't contain name = ${m}`);
              c = Do[m];
            }
            const v = [];
            for (; f < e.length; f++) {
              const E = r.parse(e[f], f, we);
              if (!E) return null;
              v.push(E);
            }
            return new li(c, v);
          }
          evaluate(e) {
            for (let r = 0; r < this.args.length; r++) {
              const c = this.args[r].evaluate(e);
              if (!Rn(this.type, qr(c))) return c;
              if (r === this.args.length - 1) throw new Ar(`Expected value to be of type ${Er(this.type)}, but found ${Er(qr(c))} instead.`);
            }
            throw new Error();
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        const ia = { "to-boolean": ir, "to-color": mn, "to-number": yt, "to-string": er };
        class ws {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            const c = e[0];
            if (!ia[c]) throw new Error(`Can't parse ${c} as it is not part of the known types`);
            if ((c === "to-boolean" || c === "to-string") && e.length !== 2) return r.error("Expected one argument.");
            const f = ia[c], m = [];
            for (let v = 1; v < e.length; v++) {
              const E = r.parse(e[v], v, we);
              if (!E) return null;
              m.push(E);
            }
            return new ws(f, m);
          }
          evaluate(e) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(e);
              case "color": {
                let r, c;
                for (const f of this.args) {
                  if (r = f.evaluate(e), c = null, r instanceof cr) return r;
                  if (typeof r == "string") {
                    const m = e.parseColor(r);
                    if (m) return m;
                  } else if (Array.isArray(r) && (c = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : ra(r[0], r[1], r[2], r[3]), !c)) return new cr(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
                }
                throw new Ar(c || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "padding": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = ai.parse(r);
                  if (f) return f;
                }
                throw new Ar(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "numberArray": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = tn.parse(r);
                  if (f) return f;
                }
                throw new Ar(`Could not parse numberArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "colorArray": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = Kt.parse(r);
                  if (f) return f;
                }
                throw new Ar(`Could not parse colorArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = oi.parse(r);
                  if (f) return f;
                }
                throw new Ar(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "number": {
                let r = null;
                for (const c of this.args) {
                  if (r = c.evaluate(e), r === null) return 0;
                  const f = Number(r);
                  if (!isNaN(f)) return f;
                }
                throw new Ar(`Could not convert ${JSON.stringify(r)} to number.`);
              }
              case "formatted":
                return Xn.fromString(na(this.args[0].evaluate(e)));
              case "resolvedImage":
                return hr.fromString(na(this.args[0].evaluate(e)));
              case "projectionDefinition":
                return this.args[0].evaluate(e);
              default:
                return na(this.args[0].evaluate(e));
            }
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        const Sc = ["Unknown", "Point", "LineString", "Polygon"];
        class xl {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Sc[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(e) {
            let r = this._parseColorCache.get(e);
            return r || (r = cr.parse(e), this._parseColorCache.set(e, r)), r;
          }
        }
        class vi {
          constructor(e, r, c = [], f, m = new Hi(), v = []) {
            this.registry = e, this.path = c, this.key = c.map(((E) => `[${E}]`)).join(""), this.scope = m, this.errors = v, this.expectedType = f, this._isConstant = r;
          }
          parse(e, r, c, f, m = {}) {
            return r ? this.concat(r, c, f)._parse(e, m) : this._parse(e, m);
          }
          _parse(e, r) {
            function c(f, m, v) {
              return v === "assert" ? new li(m, [f]) : v === "coerce" ? new ws(m, [f]) : f;
            }
            if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
              if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const f = e[0];
              if (typeof f != "string") return this.error(`Expression name must be a string, but found ${typeof f} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const m = this.registry[f];
              if (m) {
                let v = m.parse(e, this);
                if (!v) return null;
                if (this.expectedType) {
                  const E = this.expectedType, k = v.type;
                  if (E.kind !== "string" && E.kind !== "number" && E.kind !== "boolean" && E.kind !== "object" && E.kind !== "array" || k.kind !== "value") {
                    if (E.kind === "projectionDefinition" && ["string", "array"].includes(k.kind) || ["color", "formatted", "resolvedImage"].includes(E.kind) && ["value", "string"].includes(k.kind) || ["padding", "numberArray"].includes(E.kind) && ["value", "number", "array"].includes(k.kind) || E.kind === "colorArray" && ["value", "string", "array"].includes(k.kind) || E.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(k.kind)) v = c(v, E, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(E, k)) return null;
                  } else v = c(v, E, r.typeAnnotation || "assert");
                }
                if (!(v instanceof nn) && v.type.kind !== "resolvedImage" && this._isConstant(v)) {
                  const E = new xl();
                  try {
                    v = new nn(v.type, v.evaluate(E));
                  } catch (k) {
                    return this.error(k.message), null;
                  }
                }
                return v;
              }
              return this.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
          }
          concat(e, r, c) {
            const f = typeof e == "number" ? this.path.concat(e) : this.path, m = c ? this.scope.concat(c) : this.scope;
            return new vi(this.registry, this._isConstant, f, r || null, m, this.errors);
          }
          error(e, ...r) {
            const c = `${this.key}${r.map(((f) => `[${f}]`)).join("")}`;
            this.errors.push(new Wn(c, e));
          }
          checkSubtype(e, r) {
            const c = Rn(e, r);
            return c && this.error(c), c;
          }
        }
        class Lr {
          constructor(e, r) {
            this.type = r.type, this.bindings = [].concat(e), this.result = r;
          }
          evaluate(e) {
            return this.result.evaluate(e);
          }
          eachChild(e) {
            for (const r of this.bindings) e(r[1]);
            e(this.result);
          }
          static parse(e, r) {
            if (e.length < 4) return r.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
            const c = [];
            for (let m = 1; m < e.length - 1; m += 2) {
              const v = e[m];
              if (typeof v != "string") return r.error(`Expected string, but found ${typeof v} instead.`, m);
              if (/[^a-zA-Z0-9_]/.test(v)) return r.error("Variable names must contain only alphanumeric characters or '_'.", m);
              const E = r.parse(e[m + 1], m + 1);
              if (!E) return null;
              c.push([v, E]);
            }
            const f = r.parse(e[e.length - 1], e.length - 1, r.expectedType, c);
            return f ? new Lr(c, f) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Qa {
          constructor(e, r) {
            this.type = r.type, this.name = e, this.boundExpression = r;
          }
          static parse(e, r) {
            if (e.length !== 2 || typeof e[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const c = e[1];
            return r.scope.has(c) ? new Qa(c, r.scope.get(c)) : r.error(`Unknown variable "${c}". Make sure "${c}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(e) {
            return this.boundExpression.evaluate(e);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class ar {
          constructor(e, r, c) {
            this.type = e, this.index = r, this.input = c;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, yt), f = r.parse(e[2], 2, Nr(r.expectedType || we));
            return c && f ? new ar(f.type.itemType, c, f) : null;
          }
          evaluate(e) {
            const r = this.index.evaluate(e), c = this.input.evaluate(e);
            if (r < 0) throw new Ar(`Array index out of bounds: ${r} < 0.`);
            if (r >= c.length) throw new Ar(`Array index out of bounds: ${r} > ${c.length - 1}.`);
            if (r !== Math.floor(r)) throw new Ar(`Array index must be an integer, but found ${r} instead.`);
            return c[r];
          }
          eachChild(e) {
            e(this.index), e(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class sr {
          constructor(e, r) {
            this.type = ir, this.needle = e, this.haystack = r;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, we), f = r.parse(e[2], 2, we);
            return c && f ? Yi(c.type, [ir, er, yt, Wr, we]) ? new sr(c, f) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Er(c.type)} instead`) : null;
          }
          evaluate(e) {
            const r = this.needle.evaluate(e), c = this.haystack.evaluate(e);
            if (!c) return !1;
            if (!Ds(r, ["boolean", "string", "number", "null"])) throw new Ar(`Expected first argument to be of type boolean, string, number or null, but found ${Er(qr(r))} instead.`);
            if (!Ds(c, ["string", "array"])) throw new Ar(`Expected second argument to be of type array or string, but found ${Er(qr(c))} instead.`);
            return c.indexOf(r) >= 0;
          }
          eachChild(e) {
            e(this.needle), e(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class eo {
          constructor(e, r, c) {
            this.type = yt, this.needle = e, this.haystack = r, this.fromIndex = c;
          }
          static parse(e, r) {
            if (e.length <= 2 || e.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, we), f = r.parse(e[2], 2, we);
            if (!c || !f) return null;
            if (!Yi(c.type, [ir, er, yt, Wr, we])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Er(c.type)} instead`);
            if (e.length === 4) {
              const m = r.parse(e[3], 3, yt);
              return m ? new eo(c, f, m) : null;
            }
            return new eo(c, f);
          }
          evaluate(e) {
            const r = this.needle.evaluate(e), c = this.haystack.evaluate(e);
            if (!Ds(r, ["boolean", "string", "number", "null"])) throw new Ar(`Expected first argument to be of type boolean, string, number or null, but found ${Er(qr(r))} instead.`);
            let f;
            if (this.fromIndex && (f = this.fromIndex.evaluate(e)), Ds(c, ["string"])) {
              const m = c.indexOf(r, f);
              return m === -1 ? -1 : [...c.slice(0, m)].length;
            }
            if (Ds(c, ["array"])) return c.indexOf(r, f);
            throw new Ar(`Expected second argument to be of type array or string, but found ${Er(qr(c))} instead.`);
          }
          eachChild(e) {
            e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class pr {
          constructor(e, r, c, f, m, v) {
            this.inputType = e, this.type = r, this.input = c, this.cases = f, this.outputs = m, this.otherwise = v;
          }
          static parse(e, r) {
            if (e.length < 5) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let c, f;
            r.expectedType && r.expectedType.kind !== "value" && (f = r.expectedType);
            const m = {}, v = [];
            for (let P = 2; P < e.length - 1; P += 2) {
              let L = e[P];
              const N = e[P + 1];
              Array.isArray(L) || (L = [L]);
              const G = r.concat(P);
              if (L.length === 0) return G.error("Expected at least one branch label.");
              for (const Z of L) {
                if (typeof Z != "number" && typeof Z != "string") return G.error("Branch labels must be numbers or strings.");
                if (typeof Z == "number" && Math.abs(Z) > Number.MAX_SAFE_INTEGER) return G.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof Z == "number" && Math.floor(Z) !== Z) return G.error("Numeric branch labels must be integer values.");
                if (c) {
                  if (G.checkSubtype(c, qr(Z))) return null;
                } else c = qr(Z);
                if (m[String(Z)] !== void 0) return G.error("Branch labels must be unique.");
                m[String(Z)] = v.length;
              }
              const j = r.parse(N, P, f);
              if (!j) return null;
              f = f || j.type, v.push(j);
            }
            const E = r.parse(e[1], 1, we);
            if (!E) return null;
            const k = r.parse(e[e.length - 1], e.length - 1, f);
            return k ? E.type.kind !== "value" && r.concat(1).checkSubtype(c, E.type) ? null : new pr(c, f, E, m, v, k) : null;
          }
          evaluate(e) {
            const r = this.input.evaluate(e);
            return (qr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(e);
          }
          eachChild(e) {
            e(this.input), this.outputs.forEach(e), e(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class to {
          constructor(e, r, c) {
            this.type = e, this.branches = r, this.otherwise = c;
          }
          static parse(e, r) {
            if (e.length < 4) return r.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const f = [];
            for (let v = 1; v < e.length - 1; v += 2) {
              const E = r.parse(e[v], v, ir);
              if (!E) return null;
              const k = r.parse(e[v + 1], v + 1, c);
              if (!k) return null;
              f.push([E, k]), c = c || k.type;
            }
            const m = r.parse(e[e.length - 1], e.length - 1, c);
            if (!m) return null;
            if (!c) throw new Error("Can't infer output type");
            return new to(c, f, m);
          }
          evaluate(e) {
            for (const [r, c] of this.branches) if (r.evaluate(e)) return c.evaluate(e);
            return this.otherwise.evaluate(e);
          }
          eachChild(e) {
            for (const [r, c] of this.branches) e(r), e(c);
            e(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([e, r]) => r.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Jn {
          constructor(e, r, c, f) {
            this.type = e, this.input = r, this.beginIndex = c, this.endIndex = f;
          }
          static parse(e, r) {
            if (e.length <= 2 || e.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, we), f = r.parse(e[2], 2, yt);
            if (!c || !f) return null;
            if (!Yi(c.type, [Nr(we), er, we])) return r.error(`Expected first argument to be of type array or string, but found ${Er(c.type)} instead`);
            if (e.length === 4) {
              const m = r.parse(e[3], 3, yt);
              return m ? new Jn(c.type, c, f, m) : null;
            }
            return new Jn(c.type, c, f);
          }
          evaluate(e) {
            const r = this.input.evaluate(e), c = this.beginIndex.evaluate(e);
            let f;
            if (this.endIndex && (f = this.endIndex.evaluate(e)), Ds(r, ["string"])) return [...r].slice(c, f).join("");
            if (Ds(r, ["array"])) return r.slice(c, f);
            throw new Ar(`Expected first argument to be of type array or string, but found ${Er(qr(r))} instead.`);
          }
          eachChild(e) {
            e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function ro(i, e) {
          const r = i.length - 1;
          let c, f, m = 0, v = r, E = 0;
          for (; m <= v; ) if (E = Math.floor((m + v) / 2), c = i[E], f = i[E + 1], c <= e) {
            if (E === r || e < f) return E;
            m = E + 1;
          } else {
            if (!(c > e)) throw new Ar("Input is not a number.");
            v = E - 1;
          }
          return 0;
        }
        class Kn {
          constructor(e, r, c) {
            this.type = e, this.input = r, this.labels = [], this.outputs = [];
            for (const [f, m] of c) this.labels.push(f), this.outputs.push(m);
          }
          static parse(e, r) {
            if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const c = r.parse(e[1], 1, yt);
            if (!c) return null;
            const f = [];
            let m = null;
            r.expectedType && r.expectedType.kind !== "value" && (m = r.expectedType);
            for (let v = 1; v < e.length; v += 2) {
              const E = v === 1 ? -1 / 0 : e[v], k = e[v + 1], P = v, L = v + 1;
              if (typeof E != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', P);
              if (f.length && f[f.length - 1][0] >= E) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', P);
              const N = r.parse(k, L, m);
              if (!N) return null;
              m = m || N.type, f.push([E, N]);
            }
            return new Kn(m, c, f);
          }
          evaluate(e) {
            const r = this.labels, c = this.outputs;
            if (r.length === 1) return c[0].evaluate(e);
            const f = this.input.evaluate(e);
            if (f <= r[0]) return c[0].evaluate(e);
            const m = r.length;
            return f >= r[m - 1] ? c[m - 1].evaluate(e) : c[ro(r, f)].evaluate(e);
          }
          eachChild(e) {
            e(this.input);
            for (const r of this.outputs) e(r);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined()));
          }
        }
        function fu(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
        }
        var Ro, pu, Kh = (function() {
          if (pu) return Ro;
          function i(e, r, c, f) {
            this.cx = 3 * e, this.bx = 3 * (c - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (f - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = c, this.p2y = f;
          }
          return pu = 1, Ro = i, i.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, r) {
            if (r === void 0 && (r = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var c = e, f = 0; f < 8; f++) {
              var m = this.sampleCurveX(c) - e;
              if (Math.abs(m) < r) return c;
              var v = this.sampleCurveDerivativeX(c);
              if (Math.abs(v) < 1e-6) break;
              c -= m / v;
            }
            var E = 0, k = 1;
            for (c = e, f = 0; f < 20 && (m = this.sampleCurveX(c), !(Math.abs(m - e) < r)); f++) e > m ? E = c : k = c, c = 0.5 * (k - E) + E;
            return c;
          }, solve: function(e, r) {
            return this.sampleCurveY(this.solveCurveX(e, r));
          } }, Ro;
        })(), Tc = fu(Kh);
        class xi {
          constructor(e, r, c, f, m) {
            this.type = e, this.operator = r, this.interpolation = c, this.input = f, this.labels = [], this.outputs = [];
            for (const [v, E] of m) this.labels.push(v), this.outputs.push(E);
          }
          static interpolationFactor(e, r, c, f) {
            let m = 0;
            if (e.name === "exponential") m = Es(r, e.base, c, f);
            else if (e.name === "linear") m = Es(r, 1, c, f);
            else if (e.name === "cubic-bezier") {
              const v = e.controlPoints;
              m = new Tc(v[0], v[1], v[2], v[3]).solve(Es(r, 1, c, f));
            }
            return m;
          }
          static parse(e, r) {
            let [c, f, m, ...v] = e;
            if (!Array.isArray(f) || f.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (f[0] === "linear") f = { name: "linear" };
            else if (f[0] === "exponential") {
              const P = f[1];
              if (typeof P != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              f = { name: "exponential", base: P };
            } else {
              if (f[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(f[0])}`, 1, 0);
              {
                const P = f.slice(1);
                if (P.length !== 4 || P.some(((L) => typeof L != "number" || L < 0 || L > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                f = { name: "cubic-bezier", controlPoints: P };
              }
            }
            if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (m = r.parse(m, 2, yt), !m) return null;
            const E = [];
            let k = null;
            c !== "interpolate-hcl" && c !== "interpolate-lab" || r.expectedType == en ? r.expectedType && r.expectedType.kind !== "value" && (k = r.expectedType) : k = mn;
            for (let P = 0; P < v.length; P += 2) {
              const L = v[P], N = v[P + 1], G = P + 3, j = P + 4;
              if (typeof L != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', G);
              if (E.length && E[E.length - 1][0] >= L) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', G);
              const Z = r.parse(N, j, k);
              if (!Z) return null;
              k = k || Z.type, E.push([L, Z]);
            }
            return si(k, yt) || si(k, Bi) || si(k, mn) || si(k, Sr) || si(k, Mr) || si(k, en) || si(k, Dn) || si(k, Nr(yt)) ? new xi(k, c, f, m, E) : r.error(`Type ${Er(k)} is not interpolatable.`);
          }
          evaluate(e) {
            const r = this.labels, c = this.outputs;
            if (r.length === 1) return c[0].evaluate(e);
            const f = this.input.evaluate(e);
            if (f <= r[0]) return c[0].evaluate(e);
            const m = r.length;
            if (f >= r[m - 1]) return c[m - 1].evaluate(e);
            const v = ro(r, f), E = xi.interpolationFactor(this.interpolation, f, r[v], r[v + 1]), k = c[v].evaluate(e), P = c[v + 1].evaluate(e);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Pr(k, P, E);
                  case "color":
                    return cr.interpolate(k, P, E);
                  case "padding":
                    return ai.interpolate(k, P, E);
                  case "colorArray":
                    return Kt.interpolate(k, P, E);
                  case "numberArray":
                    return tn.interpolate(k, P, E);
                  case "variableAnchorOffsetCollection":
                    return oi.interpolate(k, P, E);
                  case "array":
                    return Wi(k, P, E);
                  case "projectionDefinition":
                    return rn.interpolate(k, P, E);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return cr.interpolate(k, P, E, "hcl");
                  case "colorArray":
                    return Kt.interpolate(k, P, E, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return cr.interpolate(k, P, E, "lab");
                  case "colorArray":
                    return Kt.interpolate(k, P, E, "lab");
                }
            }
          }
          eachChild(e) {
            e(this.input);
            for (const r of this.outputs) e(r);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined()));
          }
        }
        function Es(i, e, r, c) {
          const f = c - r, m = i - r;
          return f === 0 ? 0 : e === 1 ? m / f : (Math.pow(e, m) - 1) / (Math.pow(e, f) - 1);
        }
        const Xr = { color: cr.interpolate, number: Pr, padding: ai.interpolate, numberArray: tn.interpolate, colorArray: Kt.interpolate, variableAnchorOffsetCollection: oi.interpolate, array: Wi };
        class ji {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            let c = null;
            const f = r.expectedType;
            f && f.kind !== "value" && (c = f);
            const m = [];
            for (const E of e.slice(1)) {
              const k = r.parse(E, 1 + m.length, c, void 0, { typeAnnotation: "omit" });
              if (!k) return null;
              c = c || k.type, m.push(k);
            }
            if (!c) throw new Error("No output type");
            const v = f && m.some(((E) => Rn(f, E.type)));
            return new ji(v ? we : c, m);
          }
          evaluate(e) {
            let r, c = null, f = 0;
            for (const m of this.args) if (f++, c = m.evaluate(e), c && c instanceof hr && !c.available && (r || (r = c.name), c = null, f === this.args.length && (c = r)), c !== null) break;
            return c;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        function bi(i, e) {
          return i === "==" || i === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
        }
        function Fo(i, e, r, c) {
          return c.compare(e, r) === 0;
        }
        function sn(i, e, r) {
          const c = i !== "==" && i !== "!=";
          return class G1 {
            constructor(m, v, E) {
              this.type = ir, this.lhs = m, this.rhs = v, this.collator = E, this.hasUntypedArgument = m.type.kind === "value" || v.type.kind === "value";
            }
            static parse(m, v) {
              if (m.length !== 3 && m.length !== 4) return v.error("Expected two or three arguments.");
              const E = m[0];
              let k = v.parse(m[1], 1, we);
              if (!k) return null;
              if (!bi(E, k.type)) return v.concat(1).error(`"${E}" comparisons are not supported for type '${Er(k.type)}'.`);
              let P = v.parse(m[2], 2, we);
              if (!P) return null;
              if (!bi(E, P.type)) return v.concat(2).error(`"${E}" comparisons are not supported for type '${Er(P.type)}'.`);
              if (k.type.kind !== P.type.kind && k.type.kind !== "value" && P.type.kind !== "value") return v.error(`Cannot compare types '${Er(k.type)}' and '${Er(P.type)}'.`);
              c && (k.type.kind === "value" && P.type.kind !== "value" ? k = new li(P.type, [k]) : k.type.kind !== "value" && P.type.kind === "value" && (P = new li(k.type, [P])));
              let L = null;
              if (m.length === 4) {
                if (k.type.kind !== "string" && P.type.kind !== "string" && k.type.kind !== "value" && P.type.kind !== "value") return v.error("Cannot use collator to compare non-string types.");
                if (L = v.parse(m[3], 3, Gt), !L) return null;
              }
              return new G1(k, P, L);
            }
            evaluate(m) {
              const v = this.lhs.evaluate(m), E = this.rhs.evaluate(m);
              if (c && this.hasUntypedArgument) {
                const k = qr(v), P = qr(E);
                if (k.kind !== P.kind || k.kind !== "string" && k.kind !== "number") throw new Ar(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${k.kind}, ${P.kind}) instead.`);
              }
              if (this.collator && !c && this.hasUntypedArgument) {
                const k = qr(v), P = qr(E);
                if (k.kind !== "string" || P.kind !== "string") return e(m, v, E);
              }
              return this.collator ? r(m, v, E, this.collator.evaluate(m)) : e(m, v, E);
            }
            eachChild(m) {
              m(this.lhs), m(this.rhs), this.collator && m(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const kc = sn("==", (function(i, e, r) {
          return e === r;
        }), Fo), No = sn("!=", (function(i, e, r) {
          return e !== r;
        }), (function(i, e, r, c) {
          return !Fo(0, e, r, c);
        })), gu = sn("<", (function(i, e, r) {
          return e < r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) < 0;
        })), mu = sn(">", (function(i, e, r) {
          return e > r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) > 0;
        })), Sa = sn("<=", (function(i, e, r) {
          return e <= r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) <= 0;
        })), Ii = sn(">=", (function(i, e, r) {
          return e >= r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) >= 0;
        }));
        class Ta {
          constructor(e, r, c) {
            this.type = Gt, this.locale = c, this.caseSensitive = e, this.diacriticSensitive = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error("Expected one argument.");
            const c = e[1];
            if (typeof c != "object" || Array.isArray(c)) return r.error("Collator options argument must be an object.");
            const f = r.parse(c["case-sensitive"] !== void 0 && c["case-sensitive"], 1, ir);
            if (!f) return null;
            const m = r.parse(c["diacritic-sensitive"] !== void 0 && c["diacritic-sensitive"], 1, ir);
            if (!m) return null;
            let v = null;
            return c.locale && (v = r.parse(c.locale, 1, er), !v) ? null : new Ta(f, m, v);
          }
          evaluate(e) {
            return new Lo(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
          }
          eachChild(e) {
            e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class wi {
          constructor(e, r, c, f, m) {
            this.type = er, this.number = e, this.locale = r, this.currency = c, this.minFractionDigits = f, this.maxFractionDigits = m;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error("Expected two arguments.");
            const c = r.parse(e[1], 1, yt);
            if (!c) return null;
            const f = e[2];
            if (typeof f != "object" || Array.isArray(f)) return r.error("NumberFormat options argument must be an object.");
            let m = null;
            if (f.locale && (m = r.parse(f.locale, 1, er), !m)) return null;
            let v = null;
            if (f.currency && (v = r.parse(f.currency, 1, er), !v)) return null;
            let E = null;
            if (f["min-fraction-digits"] && (E = r.parse(f["min-fraction-digits"], 1, yt), !E)) return null;
            let k = null;
            return f["max-fraction-digits"] && (k = r.parse(f["max-fraction-digits"], 1, yt), !k) ? null : new wi(c, m, v, E, k);
          }
          evaluate(e) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
          }
          eachChild(e) {
            e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class zs {
          constructor(e) {
            this.type = wt, this.sections = e;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            const c = e[1];
            if (!Array.isArray(c) && typeof c == "object") return r.error("First argument must be an image or text section.");
            const f = [];
            let m = !1;
            for (let v = 1; v <= e.length - 1; ++v) {
              const E = e[v];
              if (m && typeof E == "object" && !Array.isArray(E)) {
                m = !1;
                let k = null;
                if (E["font-scale"] && (k = r.parse(E["font-scale"], 1, yt), !k)) return null;
                let P = null;
                if (E["text-font"] && (P = r.parse(E["text-font"], 1, Nr(er)), !P)) return null;
                let L = null;
                if (E["text-color"] && (L = r.parse(E["text-color"], 1, mn), !L)) return null;
                let N = null;
                if (E["vertical-align"]) {
                  if (typeof E["vertical-align"] == "string" && !Xi.includes(E["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${E["vertical-align"]}' instead.`);
                  if (N = r.parse(E["vertical-align"], 1, er), !N) return null;
                }
                const G = f[f.length - 1];
                G.scale = k, G.font = P, G.textColor = L, G.verticalAlign = N;
              } else {
                const k = r.parse(e[v], 1, we);
                if (!k) return null;
                const P = k.type.kind;
                if (P !== "string" && P !== "value" && P !== "null" && P !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                m = !0, f.push({ content: k, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new zs(f);
          }
          evaluate(e) {
            return new Xn(this.sections.map(((r) => {
              const c = r.content.evaluate(e);
              return qr(c) === Mn ? new ki("", c, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null) : new ki(na(c), null, r.scale ? r.scale.evaluate(e) : null, r.font ? r.font.evaluate(e).join(",") : null, r.textColor ? r.textColor.evaluate(e) : null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null);
            })));
          }
          eachChild(e) {
            for (const r of this.sections) e(r.content), r.scale && e(r.scale), r.font && e(r.font), r.textColor && e(r.textColor), r.verticalAlign && e(r.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class no {
          constructor(e) {
            this.type = Mn, this.input = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error("Expected two arguments.");
            const c = r.parse(e[1], 1, er);
            return c ? new no(c) : r.error("No image name provided.");
          }
          evaluate(e) {
            const r = this.input.evaluate(e), c = hr.fromString(r);
            return c && e.availableImages && (c.available = e.availableImages.indexOf(r) > -1), c;
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class ka {
          constructor(e) {
            this.type = yt, this.input = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1);
            return c ? c.type.kind !== "array" && c.type.kind !== "string" && c.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Er(c.type)} instead.`) : new ka(c) : null;
          }
          evaluate(e) {
            const r = this.input.evaluate(e);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new Ar(`Expected value to be of type string or array, but found ${Er(qr(r))} instead.`);
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const En = 8192;
        function _u(i, e) {
          const r = (180 + i[0]) / 360, c = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, f = Math.pow(2, e.z);
          return [Math.round(r * f * En), Math.round(c * f * En)];
        }
        function sa(i, e) {
          const r = Math.pow(2, e.z);
          return [(f = (i[0] / En + e.x) / r, 360 * f - 180), (c = (i[1] / En + e.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90)];
          var c, f;
        }
        function Oo(i, e) {
          i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), i[2] = Math.max(i[2], e[0]), i[3] = Math.max(i[3], e[1]);
        }
        function Ia(i, e) {
          return !(i[0] <= e[0] || i[2] >= e[2] || i[1] <= e[1] || i[3] >= e[3]);
        }
        function Qh(i, e, r) {
          const c = i[0] - e[0], f = i[1] - e[1], m = i[0] - r[0], v = i[1] - r[1];
          return c * v - m * f == 0 && c * m <= 0 && f * v <= 0;
        }
        function bl(i, e, r, c) {
          return (f = [c[0] - r[0], c[1] - r[1]])[0] * (m = [e[0] - i[0], e[1] - i[1]])[1] - f[1] * m[0] != 0 && !(!vu(i, e, r, c) || !vu(r, c, i, e));
          var f, m;
        }
        function ed(i, e, r) {
          for (const c of r) for (let f = 0; f < c.length - 1; ++f) if (bl(i, e, c[f], c[f + 1])) return !0;
          return !1;
        }
        function io(i, e, r = !1) {
          let c = !1;
          for (const E of e) for (let k = 0; k < E.length - 1; k++) {
            if (Qh(i, E[k], E[k + 1])) return r;
            (m = E[k])[1] > (f = i)[1] != (v = E[k + 1])[1] > f[1] && f[0] < (v[0] - m[0]) * (f[1] - m[1]) / (v[1] - m[1]) + m[0] && (c = !c);
          }
          var f, m, v;
          return c;
        }
        function wl(i, e) {
          for (const r of e) if (io(i, r)) return !0;
          return !1;
        }
        function Ic(i, e) {
          for (const r of i) if (!io(r, e)) return !1;
          for (let r = 0; r < i.length - 1; ++r) if (ed(i[r], i[r + 1], e)) return !1;
          return !0;
        }
        function yu(i, e) {
          for (const r of e) if (Ic(i, r)) return !0;
          return !1;
        }
        function vu(i, e, r, c) {
          const f = c[0] - r[0], m = c[1] - r[1], v = (i[0] - r[0]) * m - f * (i[1] - r[1]), E = (e[0] - r[0]) * m - f * (e[1] - r[1]);
          return v > 0 && E < 0 || v < 0 && E > 0;
        }
        function El(i, e, r) {
          const c = [];
          for (let f = 0; f < i.length; f++) {
            const m = [];
            for (let v = 0; v < i[f].length; v++) {
              const E = _u(i[f][v], r);
              Oo(e, E), m.push(E);
            }
            c.push(m);
          }
          return c;
        }
        function xu(i, e, r) {
          const c = [];
          for (let f = 0; f < i.length; f++) {
            const m = El(i[f], e, r);
            c.push(m);
          }
          return c;
        }
        function Mc(i, e, r, c) {
          if (i[0] < r[0] || i[0] > r[2]) {
            const f = 0.5 * c;
            let m = i[0] - r[0] > f ? -c : r[0] - i[0] > f ? c : 0;
            m === 0 && (m = i[0] - r[2] > f ? -c : r[2] - i[0] > f ? c : 0), i[0] += m;
          }
          Oo(e, i);
        }
        function Cc(i, e, r, c) {
          const f = Math.pow(2, c.z) * En, m = [c.x * En, c.y * En], v = [];
          for (const E of i) for (const k of E) {
            const P = [k.x + m[0], k.y + m[1]];
            Mc(P, e, r, f), v.push(P);
          }
          return v;
        }
        function Pc(i, e, r, c) {
          const f = Math.pow(2, c.z) * En, m = [c.x * En, c.y * En], v = [];
          for (const k of i) {
            const P = [];
            for (const L of k) {
              const N = [L.x + m[0], L.y + m[1]];
              Oo(e, N), P.push(N);
            }
            v.push(P);
          }
          if (e[2] - e[0] <= f / 2) {
            (E = e)[0] = E[1] = 1 / 0, E[2] = E[3] = -1 / 0;
            for (const k of v) for (const P of k) Mc(P, e, r, f);
          }
          var E;
          return v;
        }
        class Ma {
          constructor(e, r) {
            this.type = ir, this.geojson = e, this.geometries = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (Os(e[1])) {
              const c = e[1];
              if (c.type === "FeatureCollection") {
                const f = [];
                for (const m of c.features) {
                  const { type: v, coordinates: E } = m.geometry;
                  v === "Polygon" && f.push(E), v === "MultiPolygon" && f.push(...E);
                }
                if (f.length) return new Ma(c, { type: "MultiPolygon", coordinates: f });
              } else if (c.type === "Feature") {
                const f = c.geometry.type;
                if (f === "Polygon" || f === "MultiPolygon") return new Ma(c, c.geometry);
              } else if (c.type === "Polygon" || c.type === "MultiPolygon") return new Ma(c, c);
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return (function(r, c) {
                const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = r.canonicalID();
                if (c.type === "Polygon") {
                  const E = El(c.coordinates, m, v), k = Cc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!io(P, E)) return !1;
                }
                if (c.type === "MultiPolygon") {
                  const E = xu(c.coordinates, m, v), k = Cc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!wl(P, E)) return !1;
                }
                return !0;
              })(e, this.geometries);
              if (e.geometryType() === "LineString") return (function(r, c) {
                const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = r.canonicalID();
                if (c.type === "Polygon") {
                  const E = El(c.coordinates, m, v), k = Pc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!Ic(P, E)) return !1;
                }
                if (c.type === "MultiPolygon") {
                  const E = xu(c.coordinates, m, v), k = Pc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!yu(P, E)) return !1;
                }
                return !0;
              })(e, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Ac = class {
          constructor(i = [], e = (r, c) => r < c ? -1 : r > c ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = e, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
          }
          push(i) {
            this.data.push(i), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0], e = this.data.pop();
            return --this.length > 0 && (this.data[0] = e, this._down(0)), i;
          }
          peek() {
            return this.data[0];
          }
          _up(i) {
            const { data: e, compare: r } = this, c = e[i];
            for (; i > 0; ) {
              const f = i - 1 >> 1, m = e[f];
              if (r(c, m) >= 0) break;
              e[i] = m, i = f;
            }
            e[i] = c;
          }
          _down(i) {
            const { data: e, compare: r } = this, c = this.length >> 1, f = e[i];
            for (; i < c; ) {
              let m = 1 + (i << 1);
              const v = m + 1;
              if (v < this.length && r(e[v], e[m]) < 0 && (m = v), r(e[m], f) >= 0) break;
              e[i] = e[m], i = m;
            }
            e[i] = f;
          }
        };
        function bu(i, e, r = 0, c = i.length - 1, f = wu) {
          for (; c > r; ) {
            if (c - r > 600) {
              const k = c - r + 1, P = e - r + 1, L = Math.log(k), N = 0.5 * Math.exp(2 * L / 3), G = 0.5 * Math.sqrt(L * N * (k - N) / k) * (P - k / 2 < 0 ? -1 : 1);
              bu(i, e, Math.max(r, Math.floor(e - P * N / k + G)), Math.min(c, Math.floor(e + (k - P) * N / k + G)), f);
            }
            const m = i[e];
            let v = r, E = c;
            for (Ca(i, r, e), f(i[c], m) > 0 && Ca(i, r, c); v < E; ) {
              for (Ca(i, v, E), v++, E--; f(i[v], m) < 0; ) v++;
              for (; f(i[E], m) > 0; ) E--;
            }
            f(i[r], m) === 0 ? Ca(i, r, E) : (E++, Ca(i, E, c)), E <= e && (r = E + 1), e <= E && (c = E - 1);
          }
        }
        function Ca(i, e, r) {
          const c = i[e];
          i[e] = i[r], i[r] = c;
        }
        function wu(i, e) {
          return i < e ? -1 : i > e ? 1 : 0;
        }
        function zo(i, e) {
          if (i.length <= 1) return [i];
          const r = [];
          let c, f;
          for (const m of i) {
            const v = Lc(m);
            v !== 0 && (m.area = Math.abs(v), f === void 0 && (f = v < 0), f === v < 0 ? (c && r.push(c), c = [m]) : c.push(m));
          }
          if (c && r.push(c), e > 1) for (let m = 0; m < r.length; m++) r[m].length <= e || (bu(r[m], e, 1, r[m].length - 1, td), r[m] = r[m].slice(0, e));
          return r;
        }
        function td(i, e) {
          return e.area - i.area;
        }
        function Lc(i) {
          let e = 0;
          for (let r, c, f = 0, m = i.length, v = m - 1; f < m; v = f++) r = i[f], c = i[v], e += (c.x - r.x) * (r.y + c.y);
          return e;
        }
        const Sl = 1 / 298.257223563, Bo = Sl * (2 - Sl), Eu = Math.PI / 180;
        class Tl {
          constructor(e) {
            const r = 6378.137 * Eu * 1e3, c = Math.cos(e * Eu), f = 1 / (1 - Bo * (1 - c * c)), m = Math.sqrt(f);
            this.kx = r * m * c, this.ky = r * m * f * (1 - Bo);
          }
          distance(e, r) {
            const c = this.wrap(e[0] - r[0]) * this.kx, f = (e[1] - r[1]) * this.ky;
            return Math.sqrt(c * c + f * f);
          }
          pointOnLine(e, r) {
            let c, f, m, v, E = 1 / 0;
            for (let k = 0; k < e.length - 1; k++) {
              let P = e[k][0], L = e[k][1], N = this.wrap(e[k + 1][0] - P) * this.kx, G = (e[k + 1][1] - L) * this.ky, j = 0;
              N === 0 && G === 0 || (j = (this.wrap(r[0] - P) * this.kx * N + (r[1] - L) * this.ky * G) / (N * N + G * G), j > 1 ? (P = e[k + 1][0], L = e[k + 1][1]) : j > 0 && (P += N / this.kx * j, L += G / this.ky * j)), N = this.wrap(r[0] - P) * this.kx, G = (r[1] - L) * this.ky;
              const Z = N * N + G * G;
              Z < E && (E = Z, c = P, f = L, m = k, v = j);
            }
            return { point: [c, f], index: m, t: Math.max(0, Math.min(1, v)) };
          }
          wrap(e) {
            for (; e < -180; ) e += 360;
            for (; e > 180; ) e -= 360;
            return e;
          }
        }
        function Dc(i, e) {
          return e[0] - i[0];
        }
        function kl(i) {
          return i[1] - i[0] + 1;
        }
        function ui(i, e) {
          return i[1] >= i[0] && i[1] < e;
        }
        function Il(i, e) {
          if (i[0] > i[1]) return [null, null];
          const r = kl(i);
          if (e) {
            if (r === 2) return [i, null];
            const f = Math.floor(r / 2);
            return [[i[0], i[0] + f], [i[0] + f, i[1]]];
          }
          if (r === 1) return [i, null];
          const c = Math.floor(r / 2) - 1;
          return [[i[0], i[0] + c], [i[0] + c + 1, i[1]]];
        }
        function Ml(i, e) {
          if (!ui(e, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let c = e[0]; c <= e[1]; ++c) Oo(r, i[c]);
          return r;
        }
        function Mi(i) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of i) for (const c of r) Oo(e, c);
          return e;
        }
        function Ji(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
        }
        function y(i, e, r) {
          if (!Ji(i) || !Ji(e)) return NaN;
          let c = 0, f = 0;
          return i[2] < e[0] && (c = e[0] - i[2]), i[0] > e[2] && (c = i[0] - e[2]), i[1] > e[3] && (f = i[1] - e[3]), i[3] < e[1] && (f = e[1] - i[3]), r.distance([0, 0], [c, f]);
        }
        function o(i, e, r) {
          const c = r.pointOnLine(e, i);
          return r.distance(i, c.point);
        }
        function h(i, e, r, c, f) {
          const m = Math.min(o(i, [r, c], f), o(e, [r, c], f)), v = Math.min(o(r, [i, e], f), o(c, [i, e], f));
          return Math.min(m, v);
        }
        function _(i, e, r, c, f) {
          if (!ui(e, i.length) || !ui(c, r.length)) return 1 / 0;
          let m = 1 / 0;
          for (let v = e[0]; v < e[1]; ++v) {
            const E = i[v], k = i[v + 1];
            for (let P = c[0]; P < c[1]; ++P) {
              const L = r[P], N = r[P + 1];
              if (bl(E, k, L, N)) return 0;
              m = Math.min(m, h(E, k, L, N, f));
            }
          }
          return m;
        }
        function I(i, e, r, c, f) {
          if (!ui(e, i.length) || !ui(c, r.length)) return NaN;
          let m = 1 / 0;
          for (let v = e[0]; v <= e[1]; ++v) for (let E = c[0]; E <= c[1]; ++E) if (m = Math.min(m, f.distance(i[v], r[E])), m === 0) return m;
          return m;
        }
        function D(i, e, r) {
          if (io(i, e, !0)) return 0;
          let c = 1 / 0;
          for (const f of e) {
            const m = f[0], v = f[f.length - 1];
            if (m !== v && (c = Math.min(c, o(i, [v, m], r)), c === 0)) return c;
            const E = r.pointOnLine(f, i);
            if (c = Math.min(c, r.distance(i, E.point)), c === 0) return c;
          }
          return c;
        }
        function B(i, e, r, c) {
          if (!ui(e, i.length)) return NaN;
          for (let m = e[0]; m <= e[1]; ++m) if (io(i[m], r, !0)) return 0;
          let f = 1 / 0;
          for (let m = e[0]; m < e[1]; ++m) {
            const v = i[m], E = i[m + 1];
            for (const k of r) for (let P = 0, L = k.length, N = L - 1; P < L; N = P++) {
              const G = k[N], j = k[P];
              if (bl(v, E, G, j)) return 0;
              f = Math.min(f, h(v, E, G, j, c));
            }
          }
          return f;
        }
        function W(i, e) {
          for (const r of i) for (const c of r) if (io(c, e, !0)) return !0;
          return !1;
        }
        function oe(i, e, r, c = 1 / 0) {
          const f = Mi(i), m = Mi(e);
          if (c !== 1 / 0 && y(f, m, r) >= c) return c;
          if (Ia(f, m)) {
            if (W(i, e)) return 0;
          } else if (W(e, i)) return 0;
          let v = 1 / 0;
          for (const E of i) for (let k = 0, P = E.length, L = P - 1; k < P; L = k++) {
            const N = E[L], G = E[k];
            for (const j of e) for (let Z = 0, Y = j.length, J = Y - 1; Z < Y; J = Z++) {
              const ie = j[J], ye = j[Z];
              if (bl(N, G, ie, ye)) return 0;
              v = Math.min(v, h(N, G, ie, ye, r));
            }
          }
          return v;
        }
        function de(i, e, r, c, f, m) {
          if (!m) return;
          const v = y(Ml(c, m), f, r);
          v < e && i.push([v, m, [0, 0]]);
        }
        function Ze(i, e, r, c, f, m, v) {
          if (!m || !v) return;
          const E = y(Ml(c, m), Ml(f, v), r);
          E < e && i.push([E, m, v]);
        }
        function rt(i, e, r, c, f = 1 / 0) {
          let m = Math.min(c.distance(i[0], r[0][0]), f);
          if (m === 0) return m;
          const v = new Ac([[0, [0, i.length - 1], [0, 0]]], Dc), E = Mi(r);
          for (; v.length > 0; ) {
            const k = v.pop();
            if (k[0] >= m) continue;
            const P = k[1], L = e ? 50 : 100;
            if (kl(P) <= L) {
              if (!ui(P, i.length)) return NaN;
              if (e) {
                const N = B(i, P, r, c);
                if (isNaN(N) || N === 0) return N;
                m = Math.min(m, N);
              } else for (let N = P[0]; N <= P[1]; ++N) {
                const G = D(i[N], r, c);
                if (m = Math.min(m, G), m === 0) return 0;
              }
            } else {
              const N = Il(P, e);
              de(v, m, c, i, E, N[0]), de(v, m, c, i, E, N[1]);
            }
          }
          return m;
        }
        function xt(i, e, r, c, f, m = 1 / 0) {
          let v = Math.min(m, f.distance(i[0], r[0]));
          if (v === 0) return v;
          const E = new Ac([[0, [0, i.length - 1], [0, r.length - 1]]], Dc);
          for (; E.length > 0; ) {
            const k = E.pop();
            if (k[0] >= v) continue;
            const P = k[1], L = k[2], N = e ? 50 : 100, G = c ? 50 : 100;
            if (kl(P) <= N && kl(L) <= G) {
              if (!ui(P, i.length) && ui(L, r.length)) return NaN;
              let j;
              if (e && c) j = _(i, P, r, L, f), v = Math.min(v, j);
              else if (e && !c) {
                const Z = i.slice(P[0], P[1] + 1);
                for (let Y = L[0]; Y <= L[1]; ++Y) if (j = o(r[Y], Z, f), v = Math.min(v, j), v === 0) return v;
              } else if (!e && c) {
                const Z = r.slice(L[0], L[1] + 1);
                for (let Y = P[0]; Y <= P[1]; ++Y) if (j = o(i[Y], Z, f), v = Math.min(v, j), v === 0) return v;
              } else j = I(i, P, r, L, f), v = Math.min(v, j);
            } else {
              const j = Il(P, e), Z = Il(L, c);
              Ze(E, v, f, i, r, j[0], Z[0]), Ze(E, v, f, i, r, j[0], Z[1]), Ze(E, v, f, i, r, j[1], Z[0]), Ze(E, v, f, i, r, j[1], Z[1]);
            }
          }
          return v;
        }
        function jt(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map(((e) => ({ type: "Polygon", coordinates: e }))) : i.type === "MultiLineString" ? i.coordinates.map(((e) => ({ type: "LineString", coordinates: e }))) : i.type === "MultiPoint" ? i.coordinates.map(((e) => ({ type: "Point", coordinates: e }))) : [i];
        }
        class qt {
          constructor(e, r) {
            this.type = yt, this.geojson = e, this.geometries = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (Os(e[1])) {
              const c = e[1];
              if (c.type === "FeatureCollection") return new qt(c, c.features.map(((f) => jt(f.geometry))).flat());
              if (c.type === "Feature") return new qt(c, jt(c.geometry));
              if ("type" in c && "coordinates" in c) return new qt(c, jt(c));
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return (function(r, c) {
                const f = r.geometry(), m = f.flat().map(((k) => sa([k.x, k.y], r.canonical)));
                if (f.length === 0) return NaN;
                const v = new Tl(m[0][1]);
                let E = 1 / 0;
                for (const k of c) {
                  switch (k.type) {
                    case "Point":
                      E = Math.min(E, xt(m, !1, [k.coordinates], !1, v, E));
                      break;
                    case "LineString":
                      E = Math.min(E, xt(m, !1, k.coordinates, !0, v, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, rt(m, !1, k.coordinates, v, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              })(e, this.geometries);
              if (e.geometryType() === "LineString") return (function(r, c) {
                const f = r.geometry(), m = f.flat().map(((k) => sa([k.x, k.y], r.canonical)));
                if (f.length === 0) return NaN;
                const v = new Tl(m[0][1]);
                let E = 1 / 0;
                for (const k of c) {
                  switch (k.type) {
                    case "Point":
                      E = Math.min(E, xt(m, !0, [k.coordinates], !1, v, E));
                      break;
                    case "LineString":
                      E = Math.min(E, xt(m, !0, k.coordinates, !0, v, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, rt(m, !0, k.coordinates, v, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              })(e, this.geometries);
              if (e.geometryType() === "Polygon") return (function(r, c) {
                const f = r.geometry();
                if (f.length === 0 || f[0].length === 0) return NaN;
                const m = zo(f, 0).map(((k) => k.map(((P) => P.map(((L) => sa([L.x, L.y], r.canonical))))))), v = new Tl(m[0][0][0][1]);
                let E = 1 / 0;
                for (const k of c) for (const P of m) {
                  switch (k.type) {
                    case "Point":
                      E = Math.min(E, rt([k.coordinates], !1, P, v, E));
                      break;
                    case "LineString":
                      E = Math.min(E, rt(k.coordinates, !0, P, v, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, oe(P, k.coordinates, v, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              })(e, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class Wt {
          constructor(e) {
            this.type = we, this.key = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const c = e[1];
            return c == null ? r.error("Global state property must be defined.") : typeof c != "string" ? r.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new Wt(c);
          }
          evaluate(e) {
            var r;
            const c = (r = e.globals) === null || r === void 0 ? void 0 : r.globalState;
            return c && Object.keys(c).length !== 0 ? Ns(c, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const _r = { "==": kc, "!=": No, ">": mu, "<": gu, ">=": Ii, "<=": Sa, array: li, at: ar, boolean: li, case: to, coalesce: ji, collator: Ta, format: zs, image: no, in: sr, "index-of": eo, interpolate: xi, "interpolate-hcl": xi, "interpolate-lab": xi, length: ka, let: Lr, literal: nn, match: pr, number: li, "number-format": wi, object: li, slice: Jn, step: Kn, string: li, "to-boolean": ws, "to-color": ws, "to-number": ws, "to-string": ws, var: Qa, within: Ma, distance: qt, "global-state": Wt };
        class lr {
          constructor(e, r, c, f) {
            this.name = e, this.type = r, this._evaluate = c, this.args = f;
          }
          evaluate(e) {
            return this._evaluate(e, this.args);
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return !1;
          }
          static parse(e, r) {
            const c = e[0], f = lr.definitions[c];
            if (!f) return r.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const m = Array.isArray(f) ? f[0] : f.type, v = Array.isArray(f) ? [[f[1], f[2]]] : f.overloads, E = v.filter((([P]) => !Array.isArray(P) || P.length === e.length - 1));
            let k = null;
            for (const [P, L] of E) {
              k = new vi(r.registry, aa, r.path, null, r.scope);
              const N = [];
              let G = !1;
              for (let j = 1; j < e.length; j++) {
                const Z = e[j], Y = Array.isArray(P) ? P[j - 1] : P.type, J = k.parse(Z, 1 + N.length, Y);
                if (!J) {
                  G = !0;
                  break;
                }
                N.push(J);
              }
              if (!G) if (Array.isArray(P) && P.length !== N.length) k.error(`Expected ${P.length} arguments, but found ${N.length} instead.`);
              else {
                for (let j = 0; j < N.length; j++) {
                  const Z = Array.isArray(P) ? P[j] : P.type, Y = N[j];
                  k.concat(j + 1).checkSubtype(Z, Y.type);
                }
                if (k.errors.length === 0) return new lr(c, m, L, N);
              }
            }
            if (E.length === 1) r.errors.push(...k.errors);
            else {
              const P = (E.length ? E : v).map((([N]) => {
                return G = N, Array.isArray(G) ? `(${G.map(Er).join(", ")})` : `(${Er(G.type)}...)`;
                var G;
              })).join(" | "), L = [];
              for (let N = 1; N < e.length; N++) {
                const G = r.parse(e[N], 1 + L.length);
                if (!G) return null;
                L.push(Er(G.type));
              }
              r.error(`Expected arguments of type ${P}, but found (${L.join(", ")}) instead.`);
            }
            return null;
          }
          static register(e, r) {
            lr.definitions = r;
            for (const c in r) e[c] = lr;
          }
        }
        function Br(i, [e, r, c, f]) {
          e = e.evaluate(i), r = r.evaluate(i), c = c.evaluate(i);
          const m = f ? f.evaluate(i) : 1, v = ra(e, r, c, m);
          if (v) throw new Ar(v);
          return new cr(e / 255, r / 255, c / 255, m, !1);
        }
        function qn(i, e) {
          return i in e;
        }
        function $n(i, e) {
          const r = e[i];
          return r === void 0 ? null : r;
        }
        function Vi(i) {
          return { type: i };
        }
        function aa(i) {
          if (i instanceof Qa) return aa(i.boundExpression);
          if (i instanceof lr && i.name === "error" || i instanceof Ta || i instanceof Ma || i instanceof qt || i instanceof Wt) return !1;
          const e = i instanceof ws || i instanceof li;
          let r = !0;
          return i.eachChild(((c) => {
            r = e ? r && aa(c) : r && c instanceof nn;
          })), !!r && Go(i) && jo(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Go(i) {
          if (i instanceof lr && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Ma || i instanceof qt) return !1;
          let e = !0;
          return i.eachChild(((r) => {
            e && !Go(r) && (e = !1);
          })), e;
        }
        function so(i) {
          if (i instanceof lr && i.name === "feature-state") return !1;
          let e = !0;
          return i.eachChild(((r) => {
            e && !so(r) && (e = !1);
          })), e;
        }
        function jo(i, e) {
          if (i instanceof lr && e.indexOf(i.name) >= 0) return !1;
          let r = !0;
          return i.eachChild(((c) => {
            r && !jo(c, e) && (r = !1);
          })), r;
        }
        function Su(i) {
          return { result: "success", value: i };
        }
        function Pa(i) {
          return { result: "error", value: i };
        }
        function Aa(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
        }
        function Cl(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
        }
        function Vo(i) {
          return !!i.expression && i.expression.interpolated;
        }
        function gr(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
        }
        function Rc(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && qr(i) === Gi;
        }
        function nm(i) {
          return i;
        }
        function Zf(i, e) {
          const r = i.stops && typeof i.stops[0][0] == "object", c = r || !(r || i.property !== void 0), f = i.type || (Vo(e) ? "exponential" : "interval"), m = (function(L) {
            switch (L.type) {
              case "color":
                return cr.parse;
              case "padding":
                return ai.parse;
              case "numberArray":
                return tn.parse;
              case "colorArray":
                return Kt.parse;
              default:
                return null;
            }
          })(e);
          if (m && ((i = jr({}, i)).stops && (i.stops = i.stops.map(((L) => [L[0], m(L[1])]))), i.default = m(i.default ? i.default : e.default)), i.colorSpace && (v = i.colorSpace) !== "rgb" && v !== "hcl" && v !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var v;
          const E = (function(L) {
            switch (L) {
              case "exponential":
                return Hf;
              case "interval":
                return sm;
              case "categorical":
                return im;
              case "identity":
                return am;
              default:
                throw new Error(`Unknown function type "${L}"`);
            }
          })(f);
          let k, P;
          if (f === "categorical") {
            k = /* @__PURE__ */ Object.create(null);
            for (const L of i.stops) k[L[0]] = L[1];
            P = typeof i.stops[0][0];
          }
          if (r) {
            const L = {}, N = [];
            for (let Z = 0; Z < i.stops.length; Z++) {
              const Y = i.stops[Z], J = Y[0].zoom;
              L[J] === void 0 && (L[J] = { zoom: J, type: i.type, property: i.property, default: i.default, stops: [] }, N.push(J)), L[J].stops.push([Y[0].value, Y[1]]);
            }
            const G = [];
            for (const Z of N) G.push([L[Z].zoom, Zf(L[Z], e)]);
            const j = { name: "linear" };
            return { kind: "composite", interpolationType: j, interpolationFactor: xi.interpolationFactor.bind(void 0, j), zoomStops: G.map(((Z) => Z[0])), evaluate: ({ zoom: Z }, Y) => Hf({ stops: G, base: i.base }, e, Z).evaluate(Z, Y) };
          }
          if (c) {
            const L = f === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
            return { kind: "camera", interpolationType: L, interpolationFactor: xi.interpolationFactor.bind(void 0, L), zoomStops: i.stops.map(((N) => N[0])), evaluate: ({ zoom: N }) => E(i, e, N, k, P) };
          }
          return { kind: "source", evaluate(L, N) {
            const G = N && N.properties ? N.properties[i.property] : void 0;
            return G === void 0 ? Tu(i.default, e.default) : E(i, e, G, k, P);
          } };
        }
        function Tu(i, e, r) {
          return i !== void 0 ? i : e !== void 0 ? e : r !== void 0 ? r : void 0;
        }
        function im(i, e, r, c, f) {
          return Tu(typeof r === f ? c[r] : void 0, i.default, e.default);
        }
        function sm(i, e, r) {
          if (gr(r) !== "number") return Tu(i.default, e.default);
          const c = i.stops.length;
          if (c === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[c - 1][0]) return i.stops[c - 1][1];
          const f = ro(i.stops.map(((m) => m[0])), r);
          return i.stops[f][1];
        }
        function Hf(i, e, r) {
          const c = i.base !== void 0 ? i.base : 1;
          if (gr(r) !== "number") return Tu(i.default, e.default);
          const f = i.stops.length;
          if (f === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[f - 1][0]) return i.stops[f - 1][1];
          const m = ro(i.stops.map(((L) => L[0])), r), v = (function(L, N, G, j) {
            const Z = j - G, Y = L - G;
            return Z === 0 ? 0 : N === 1 ? Y / Z : (Math.pow(N, Y) - 1) / (Math.pow(N, Z) - 1);
          })(r, c, i.stops[m][0], i.stops[m + 1][0]), E = i.stops[m][1], k = i.stops[m + 1][1], P = Xr[e.type] || nm;
          return typeof E.evaluate == "function" ? { evaluate(...L) {
            const N = E.evaluate.apply(void 0, L), G = k.evaluate.apply(void 0, L);
            if (N !== void 0 && G !== void 0) return P(N, G, v, i.colorSpace);
          } } : P(E, k, v, i.colorSpace);
        }
        function am(i, e, r) {
          switch (e.type) {
            case "color":
              r = cr.parse(r);
              break;
            case "formatted":
              r = Xn.fromString(r.toString());
              break;
            case "resolvedImage":
              r = hr.fromString(r.toString());
              break;
            case "padding":
              r = ai.parse(r);
              break;
            case "colorArray":
              r = Kt.parse(r);
              break;
            case "numberArray":
              r = tn.parse(r);
              break;
            default:
              gr(r) === e.type || e.type === "enum" && e.values[r] || (r = void 0);
          }
          return Tu(r, i.default, e.default);
        }
        lr.register(_r, { error: [{ kind: "error" }, [er], (i, [e]) => {
          throw new Ar(e.evaluate(i));
        }], typeof: [er, [we], (i, [e]) => Er(qr(e.evaluate(i)))], "to-rgba": [Nr(yt, 4), [mn], (i, [e]) => {
          const [r, c, f, m] = e.evaluate(i).rgb;
          return [255 * r, 255 * c, 255 * f, m];
        }], rgb: [mn, [yt, yt, yt], Br], rgba: [mn, [yt, yt, yt, yt], Br], has: { type: ir, overloads: [[[er], (i, [e]) => qn(e.evaluate(i), i.properties())], [[er, Gi], (i, [e, r]) => qn(e.evaluate(i), r.evaluate(i))]] }, get: { type: we, overloads: [[[er], (i, [e]) => $n(e.evaluate(i), i.properties())], [[er, Gi], (i, [e, r]) => $n(e.evaluate(i), r.evaluate(i))]] }, "feature-state": [we, [er], (i, [e]) => $n(e.evaluate(i), i.featureState || {})], properties: [Gi, [], (i) => i.properties()], "geometry-type": [er, [], (i) => i.geometryType()], id: [we, [], (i) => i.id()], zoom: [yt, [], (i) => i.globals.zoom], "heatmap-density": [yt, [], (i) => i.globals.heatmapDensity || 0], elevation: [yt, [], (i) => i.globals.elevation || 0], "line-progress": [yt, [], (i) => i.globals.lineProgress || 0], accumulated: [we, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [yt, Vi(yt), (i, e) => {
          let r = 0;
          for (const c of e) r += c.evaluate(i);
          return r;
        }], "*": [yt, Vi(yt), (i, e) => {
          let r = 1;
          for (const c of e) r *= c.evaluate(i);
          return r;
        }], "-": { type: yt, overloads: [[[yt, yt], (i, [e, r]) => e.evaluate(i) - r.evaluate(i)], [[yt], (i, [e]) => -e.evaluate(i)]] }, "/": [yt, [yt, yt], (i, [e, r]) => e.evaluate(i) / r.evaluate(i)], "%": [yt, [yt, yt], (i, [e, r]) => e.evaluate(i) % r.evaluate(i)], ln2: [yt, [], () => Math.LN2], pi: [yt, [], () => Math.PI], e: [yt, [], () => Math.E], "^": [yt, [yt, yt], (i, [e, r]) => Math.pow(e.evaluate(i), r.evaluate(i))], sqrt: [yt, [yt], (i, [e]) => Math.sqrt(e.evaluate(i))], log10: [yt, [yt], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN10], ln: [yt, [yt], (i, [e]) => Math.log(e.evaluate(i))], log2: [yt, [yt], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN2], sin: [yt, [yt], (i, [e]) => Math.sin(e.evaluate(i))], cos: [yt, [yt], (i, [e]) => Math.cos(e.evaluate(i))], tan: [yt, [yt], (i, [e]) => Math.tan(e.evaluate(i))], asin: [yt, [yt], (i, [e]) => Math.asin(e.evaluate(i))], acos: [yt, [yt], (i, [e]) => Math.acos(e.evaluate(i))], atan: [yt, [yt], (i, [e]) => Math.atan(e.evaluate(i))], min: [yt, Vi(yt), (i, e) => Math.min(...e.map(((r) => r.evaluate(i))))], max: [yt, Vi(yt), (i, e) => Math.max(...e.map(((r) => r.evaluate(i))))], abs: [yt, [yt], (i, [e]) => Math.abs(e.evaluate(i))], round: [yt, [yt], (i, [e]) => {
          const r = e.evaluate(i);
          return r < 0 ? -Math.round(-r) : Math.round(r);
        }], floor: [yt, [yt], (i, [e]) => Math.floor(e.evaluate(i))], ceil: [yt, [yt], (i, [e]) => Math.ceil(e.evaluate(i))], "filter-==": [ir, [er, we], (i, [e, r]) => i.properties()[e.value] === r.value], "filter-id-==": [ir, [we], (i, [e]) => i.id() === e.value], "filter-type-==": [ir, [er], (i, [e]) => i.geometryType() === e.value], "filter-<": [ir, [er, we], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c < f;
        }], "filter-id-<": [ir, [we], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r < c;
        }], "filter->": [ir, [er, we], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c > f;
        }], "filter-id->": [ir, [we], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r > c;
        }], "filter-<=": [ir, [er, we], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c <= f;
        }], "filter-id-<=": [ir, [we], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r <= c;
        }], "filter->=": [ir, [er, we], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c >= f;
        }], "filter-id->=": [ir, [we], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r >= c;
        }], "filter-has": [ir, [we], (i, [e]) => e.value in i.properties()], "filter-has-id": [ir, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [ir, [Nr(er)], (i, [e]) => e.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [ir, [Nr(we)], (i, [e]) => e.value.indexOf(i.id()) >= 0], "filter-in-small": [ir, [er, Nr(we)], (i, [e, r]) => r.value.indexOf(i.properties()[e.value]) >= 0], "filter-in-large": [ir, [er, Nr(we)], (i, [e, r]) => (function(c, f, m, v) {
          for (; m <= v; ) {
            const E = m + v >> 1;
            if (f[E] === c) return !0;
            f[E] > c ? v = E - 1 : m = E + 1;
          }
          return !1;
        })(i.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: ir, overloads: [[[ir, ir], (i, [e, r]) => e.evaluate(i) && r.evaluate(i)], [Vi(ir), (i, e) => {
          for (const r of e) if (!r.evaluate(i)) return !1;
          return !0;
        }]] }, any: { type: ir, overloads: [[[ir, ir], (i, [e, r]) => e.evaluate(i) || r.evaluate(i)], [Vi(ir), (i, e) => {
          for (const r of e) if (r.evaluate(i)) return !0;
          return !1;
        }]] }, "!": [ir, [ir], (i, [e]) => !e.evaluate(i)], "is-supported-script": [ir, [er], (i, [e]) => {
          const r = i.globals && i.globals.isSupportedScript;
          return !r || r(e.evaluate(i));
        }], upcase: [er, [er], (i, [e]) => e.evaluate(i).toUpperCase()], downcase: [er, [er], (i, [e]) => e.evaluate(i).toLowerCase()], concat: [er, Vi(we), (i, e) => e.map(((r) => na(r.evaluate(i)))).join("")], "resolved-locale": [er, [Gt], (i, [e]) => e.evaluate(i).resolvedLocale()] });
        class rd {
          constructor(e, r, c) {
            this.expression = e, this._warningHistory = {}, this._evaluator = new xl(), this._defaultValue = r ? (function(f) {
              if (f.type === "color" && Rc(f.default)) return new cr(0, 0, 0, 0);
              switch (f.type) {
                case "color":
                  return cr.parse(f.default) || null;
                case "padding":
                  return ai.parse(f.default) || null;
                case "numberArray":
                  return tn.parse(f.default) || null;
                case "colorArray":
                  return Kt.parse(f.default) || null;
                case "variableAnchorOffsetCollection":
                  return oi.parse(f.default) || null;
                case "projectionDefinition":
                  return rn.parse(f.default) || null;
                default:
                  return f.default === void 0 ? null : f.default;
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = c;
          }
          evaluateWithoutErrorHandling(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = r, this._evaluator.featureState = c, this._evaluator.canonical = f, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
          }
          evaluate(e, r, c, f, m, v) {
            this._globalState && (e = Uo(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = r || null, this._evaluator.featureState = c || null, this._evaluator.canonical = f, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = v || null;
            try {
              const E = this.expression.evaluate(this._evaluator);
              if (E == null || typeof E == "number" && E != E) return this._defaultValue;
              if (this._enumValues && !(E in this._enumValues)) throw new Ar(`Expected value to be one of ${Object.keys(this._enumValues).map(((k) => JSON.stringify(k))).join(", ")}, but found ${JSON.stringify(E)} instead.`);
              return E;
            } catch (E) {
              return this._warningHistory[E.message] || (this._warningHistory[E.message] = !0, typeof console < "u" && console.warn(E.message)), this._defaultValue;
            }
          }
        }
        function Pl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in _r;
        }
        function ku(i, e, r) {
          const c = new vi(_r, aa, [], e ? (function(m) {
            const v = { color: mn, string: er, number: yt, enum: er, boolean: ir, formatted: wt, padding: Sr, numberArray: Mr, colorArray: en, projectionDefinition: Bi, resolvedImage: Mn, variableAnchorOffsetCollection: Dn };
            return m.type === "array" ? Nr(v[m.value] || we, m.length) : v[m.type];
          })(e) : void 0), f = c.parse(i, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return f ? Su(new rd(f, e, r)) : Pa(c.errors);
        }
        class Fc {
          constructor(e, r, c) {
            this.kind = e, this._styleExpression = r, this.isStateDependent = e !== "constant" && !so(r.expression), this.globalStateRefs = ao(r.expression), this._globalState = c;
          }
          evaluateWithoutErrorHandling(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, r, c, f, m, v);
          }
          evaluate(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluate(e, r, c, f, m, v);
          }
        }
        class nd {
          constructor(e, r, c, f, m) {
            this.kind = e, this.zoomStops = c, this._styleExpression = r, this.isStateDependent = e !== "camera" && !so(r.expression), this.globalStateRefs = ao(r.expression), this.interpolationType = f, this._globalState = m;
          }
          evaluateWithoutErrorHandling(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, r, c, f, m, v);
          }
          evaluate(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluate(e, r, c, f, m, v);
          }
          interpolationFactor(e, r, c) {
            return this.interpolationType ? xi.interpolationFactor(this.interpolationType, e, r, c) : 0;
          }
        }
        function id(i, e, r) {
          const c = ku(i, e, r);
          if (c.result === "error") return c;
          const f = c.value.expression, m = Go(f);
          if (!m && !Aa(e)) return Pa([new Wn("", "data expressions not supported")]);
          const v = jo(f, ["zoom"]);
          if (!v && !Cl(e)) return Pa([new Wn("", "zoom expressions not supported")]);
          const E = Oc(f);
          return E || v ? E instanceof Wn ? Pa([E]) : E instanceof xi && !Vo(e) ? Pa([new Wn("", '"interpolate" expressions cannot be used with this property')]) : Su(E ? new nd(m ? "camera" : "composite", c.value, E.labels, E instanceof xi ? E.interpolation : void 0, r) : new Fc(m ? "constant" : "source", c.value, r)) : Pa([new Wn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Nc {
          constructor(e, r) {
            this._parameters = e, this._specification = r, jr(this, Zf(this._parameters, this._specification));
          }
          static deserialize(e) {
            return new Nc(e._parameters, e._specification);
          }
          static serialize(e) {
            return { _parameters: e._parameters, _specification: e._specification };
          }
        }
        function Oc(i) {
          let e = null;
          if (i instanceof Lr) e = Oc(i.result);
          else if (i instanceof ji) {
            for (const r of i.args) if (e = Oc(r), e) break;
          } else (i instanceof Kn || i instanceof xi) && i.input instanceof lr && i.input.name === "zoom" && (e = i);
          return e instanceof Wn || i.eachChild(((r) => {
            const c = Oc(r);
            c instanceof Wn ? e = c : !e && c ? e = new Wn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && c && e !== c && (e = new Wn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), e;
        }
        function ao(i, e = /* @__PURE__ */ new Set()) {
          return i instanceof Wt && e.add(i.key), i.eachChild(((r) => {
            ao(r, e);
          })), e;
        }
        function Uo(i, e) {
          const { zoom: r, heatmapDensity: c, elevation: f, lineProgress: m, isSupportedScript: v, accumulated: E } = i ?? {};
          return { zoom: r, heatmapDensity: c, elevation: f, lineProgress: m, isSupportedScript: v, accumulated: E, globalState: e };
        }
        function sd(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const e of i.slice(1)) if (!sd(e) && typeof e != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const om = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Iu(i, e) {
          if (i == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          sd(i) || (i = Mu(i));
          const r = ku(i, om, e);
          if (r.result === "error") throw new Error(r.value.map(((c) => `${c.key}: ${c.message}`)).join(", "));
          return { filter: (c, f, m) => r.value.evaluate(c, f, {}, m), needGeometry: Yf(i), getGlobalStateRefs: () => ao(r.value.expression) };
        }
        function lm(i, e) {
          return i < e ? -1 : i > e ? 1 : 0;
        }
        function Yf(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let e = 1; e < i.length; e++) if (Yf(i[e])) return !0;
          return !1;
        }
        function Mu(i) {
          if (!i) return !0;
          const e = i[0];
          return i.length <= 1 ? e !== "any" : e === "==" ? zc(i[1], i[2], "==") : e === "!=" ? Cu(zc(i[1], i[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? zc(i[1], i[2], e) : e === "any" ? (r = i.slice(1), ["any"].concat(r.map(Mu))) : e === "all" ? ["all"].concat(i.slice(1).map(Mu)) : e === "none" ? ["all"].concat(i.slice(1).map(Mu).map(Cu)) : e === "in" ? Wf(i[1], i.slice(2)) : e === "!in" ? Cu(Wf(i[1], i.slice(2))) : e === "has" ? Xf(i[1]) : e !== "!has" || Cu(Xf(i[1]));
          var r;
        }
        function zc(i, e, r) {
          switch (i) {
            case "$type":
              return [`filter-type-${r}`, e];
            case "$id":
              return [`filter-id-${r}`, e];
            default:
              return [`filter-${r}`, i, e];
          }
        }
        function Wf(i, e) {
          if (e.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", e]];
            case "$id":
              return ["filter-id-in", ["literal", e]];
            default:
              return e.length > 200 && !e.some(((r) => typeof r != typeof e[0])) ? ["filter-in-large", i, ["literal", e.sort(lm)]] : ["filter-in-small", i, ["literal", e]];
          }
        }
        function Xf(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i];
          }
        }
        function Cu(i) {
          return ["!", i];
        }
        function Bc(i) {
          const e = typeof i;
          if (e === "number" || e === "boolean" || e === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let f = "[";
            for (const m of i) f += `${Bc(m)},`;
            return `${f}]`;
          }
          const r = Object.keys(i).sort();
          let c = "{";
          for (let f = 0; f < r.length; f++) c += `${JSON.stringify(r[f])}:${Bc(i[r[f]])},`;
          return `${c}}`;
        }
        function Jf(i) {
          let e = "";
          for (const r of Qt) e += `/${Bc(i[r])}`;
          return e;
        }
        function Kf(i) {
          const e = i.value;
          return e ? [new pt(i.key, e, "constants have been deprecated as of v8")] : [];
        }
        function Cn(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
        }
        function qo(i) {
          if (Array.isArray(i)) return i.map(qo);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const e = {};
            for (const r in i) e[r] = qo(i[r]);
            return e;
          }
          return Cn(i);
        }
        function ls(i) {
          const e = i.key, r = i.value, c = i.valueSpec || {}, f = i.objectElementValidators || {}, m = i.style, v = i.styleSpec, E = i.validateSpec;
          let k = [];
          const P = gr(r);
          if (P !== "object") return [new pt(e, r, `object expected, ${P} found`)];
          for (const L in r) {
            const N = L.split(".")[0], G = Ns(c, N) || c["*"];
            let j;
            if (Ns(f, N)) j = f[N];
            else if (Ns(c, N)) {
              if (r[L] === void 0) continue;
              j = E;
            } else if (f["*"]) j = f["*"];
            else {
              if (!c["*"]) {
                k.push(new pt(e, r[L], `unknown property "${L}"`));
                continue;
              }
              j = E;
            }
            k = k.concat(j({ key: (e && `${e}.`) + L, value: r[L], valueSpec: G, style: m, styleSpec: v, object: r, objectKey: L, validateSpec: E }, r));
          }
          for (const L in c) f[L] || c[L].required && c[L].default === void 0 && r[L] === void 0 && k.push(new pt(e, r, `missing required property "${L}"`));
          return k;
        }
        function Gc(i) {
          const e = i.value, r = i.valueSpec, c = i.style, f = i.styleSpec, m = i.key, v = i.arrayElementValidator || i.validateSpec;
          if (gr(e) !== "array") return [new pt(m, e, `array expected, ${gr(e)} found`)];
          if (r.length && e.length !== r.length) return [new pt(m, e, `array length ${r.length} expected, length ${e.length} found`)];
          let E = { type: r.value, values: r.values };
          f.$version < 7 && (E.function = r.function), gr(r.value) === "object" && (E = r.value);
          let k = [];
          for (let P = 0; P < e.length; P++) k = k.concat(v({ array: e, arrayIndex: P, value: e[P], valueSpec: E, validateSpec: i.validateSpec, style: c, styleSpec: f, key: `${m}[${P}]` }));
          return k;
        }
        function Pu(i) {
          const e = i.key, r = i.value, c = i.valueSpec;
          let f = gr(r);
          return f === "number" && r != r && (f = "NaN"), f !== "number" ? [new pt(e, r, `number expected, ${f} found`)] : "minimum" in c && r < c.minimum ? [new pt(e, r, `${r} is less than the minimum value ${c.minimum}`)] : "maximum" in c && r > c.maximum ? [new pt(e, r, `${r} is greater than the maximum value ${c.maximum}`)] : [];
        }
        function jc(i) {
          const e = i.valueSpec, r = Cn(i.value.type);
          let c, f, m, v = {};
          const E = r !== "categorical" && i.value.property === void 0, k = !E, P = gr(i.value.stops) === "array" && gr(i.value.stops[0]) === "array" && gr(i.value.stops[0][0]) === "object", L = ls({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(j) {
            if (r === "identity") return [new pt(j.key, j.value, 'identity function may not have a "stops" property')];
            let Z = [];
            const Y = j.value;
            return Z = Z.concat(Gc({ key: j.key, value: Y, valueSpec: j.valueSpec, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec, arrayElementValidator: N })), gr(Y) === "array" && Y.length === 0 && Z.push(new pt(j.key, Y, "array must have at least one stop")), Z;
          }, default: function(j) {
            return j.validateSpec({ key: j.key, value: j.value, valueSpec: e, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec });
          } } });
          return r === "identity" && E && L.push(new pt(i.key, i.value, 'missing required property "property"')), r === "identity" || i.value.stops || L.push(new pt(i.key, i.value, 'missing required property "stops"')), r === "exponential" && i.valueSpec.expression && !Vo(i.valueSpec) && L.push(new pt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (k && !Aa(i.valueSpec) ? L.push(new pt(i.key, i.value, "property functions not supported")) : E && !Cl(i.valueSpec) && L.push(new pt(i.key, i.value, "zoom functions not supported"))), r !== "categorical" && !P || i.value.property !== void 0 || L.push(new pt(i.key, i.value, '"property" property is required')), L;
          function N(j) {
            let Z = [];
            const Y = j.value, J = j.key;
            if (gr(Y) !== "array") return [new pt(J, Y, `array expected, ${gr(Y)} found`)];
            if (Y.length !== 2) return [new pt(J, Y, `array length 2 expected, length ${Y.length} found`)];
            if (P) {
              if (gr(Y[0]) !== "object") return [new pt(J, Y, `object expected, ${gr(Y[0])} found`)];
              if (Y[0].zoom === void 0) return [new pt(J, Y, "object stop key must have zoom")];
              if (Y[0].value === void 0) return [new pt(J, Y, "object stop key must have value")];
              if (m && m > Cn(Y[0].zoom)) return [new pt(J, Y[0].zoom, "stop zoom values must appear in ascending order")];
              Cn(Y[0].zoom) !== m && (m = Cn(Y[0].zoom), f = void 0, v = {}), Z = Z.concat(ls({ key: `${J}[0]`, value: Y[0], valueSpec: { zoom: {} }, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec, objectElementValidators: { zoom: Pu, value: G } }));
            } else Z = Z.concat(G({ key: `${J}[0]`, value: Y[0], validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec }, Y));
            return Pl(qo(Y[1])) ? Z.concat([new pt(`${J}[1]`, Y[1], "expressions are not allowed in function stops.")]) : Z.concat(j.validateSpec({ key: `${J}[1]`, value: Y[1], valueSpec: e, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec }));
          }
          function G(j, Z) {
            const Y = gr(j.value), J = Cn(j.value), ie = j.value !== null ? j.value : Z;
            if (c) {
              if (Y !== c) return [new pt(j.key, ie, `${Y} stop domain type must match previous stop domain type ${c}`)];
            } else c = Y;
            if (Y !== "number" && Y !== "string" && Y !== "boolean") return [new pt(j.key, ie, "stop domain value must be a number, string, or boolean")];
            if (Y !== "number" && r !== "categorical") {
              let ye = `number expected, ${Y} found`;
              return Aa(e) && r === void 0 && (ye += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new pt(j.key, ie, ye)];
            }
            return r !== "categorical" || Y !== "number" || isFinite(J) && Math.floor(J) === J ? r !== "categorical" && Y === "number" && f !== void 0 && J < f ? [new pt(j.key, ie, "stop domain values must appear in ascending order")] : (f = J, r === "categorical" && J in v ? [new pt(j.key, ie, "stop domain values must be unique")] : (v[J] = !0, [])) : [new pt(j.key, ie, `integer expected, found ${J}`)];
          }
        }
        function oo(i) {
          const e = (i.expressionContext === "property" ? id : ku)(qo(i.value), i.valueSpec);
          if (e.result === "error") return e.value.map(((c) => new pt(`${i.key}${c.key}`, i.value, c.message)));
          const r = e.value.expression || e.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined()) return [new pt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !so(r)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !so(r)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!jo(r, ["zoom", "feature-state"])) return [new pt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !Go(r)) return [new pt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Au(i) {
          const e = i.key, r = i.value, c = gr(r);
          return c !== "string" ? [new pt(e, r, `color expected, ${c} found`)] : cr.parse(String(r)) ? [] : [new pt(e, r, `color expected, "${r}" found`)];
        }
        function $o(i) {
          const e = i.key, r = i.value, c = i.valueSpec, f = [];
          return Array.isArray(c.values) ? c.values.indexOf(Cn(r)) === -1 && f.push(new pt(e, r, `expected one of [${c.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(c.values).indexOf(Cn(r)) === -1 && f.push(new pt(e, r, `expected one of [${Object.keys(c.values).join(", ")}], ${JSON.stringify(r)} found`)), f;
        }
        function Al(i) {
          return sd(qo(i.value)) ? oo(jr({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Qf(i);
        }
        function Qf(i) {
          const e = i.value, r = i.key;
          if (gr(e) !== "array") return [new pt(r, e, `array expected, ${gr(e)} found`)];
          const c = i.styleSpec;
          let f, m = [];
          if (e.length < 1) return [new pt(r, e, "filter array must have at least 1 element")];
          switch (m = m.concat($o({ key: `${r}[0]`, value: e[0], valueSpec: c.filter_operator, style: i.style, styleSpec: i.styleSpec })), Cn(e[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e.length >= 2 && Cn(e[1]) === "$type" && m.push(new pt(r, e, `"$type" cannot be use with operator "${e[0]}"`));
            case "==":
            case "!=":
              e.length !== 3 && m.push(new pt(r, e, `filter array for operator "${e[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e.length >= 2 && (f = gr(e[1]), f !== "string" && m.push(new pt(`${r}[1]`, e[1], `string expected, ${f} found`)));
              for (let v = 2; v < e.length; v++) f = gr(e[v]), Cn(e[1]) === "$type" ? m = m.concat($o({ key: `${r}[${v}]`, value: e[v], valueSpec: c.geometry_type, style: i.style, styleSpec: i.styleSpec })) : f !== "string" && f !== "number" && f !== "boolean" && m.push(new pt(`${r}[${v}]`, e[v], `string, number, or boolean expected, ${f} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let v = 1; v < e.length; v++) m = m.concat(Qf({ key: `${r}[${v}]`, value: e[v], style: i.style, styleSpec: i.styleSpec }));
              break;
            case "has":
            case "!has":
              f = gr(e[1]), e.length !== 2 ? m.push(new pt(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : f !== "string" && m.push(new pt(`${r}[1]`, e[1], `string expected, ${f} found`));
          }
          return m;
        }
        function ep(i, e) {
          const r = i.key, c = i.validateSpec, f = i.style, m = i.styleSpec, v = i.value, E = i.objectKey, k = m[`${e}_${i.layerType}`];
          if (!k) return [];
          const P = E.match(/^(.*)-transition$/);
          if (e === "paint" && P && k[P[1]] && k[P[1]].transition) return c({ key: r, value: v, valueSpec: m.transition, style: f, styleSpec: m });
          const L = i.valueSpec || k[E];
          if (!L) return [new pt(r, v, `unknown property "${E}"`)];
          let N;
          if (gr(v) === "string" && Aa(L) && !L.tokens && (N = /^{([^}]+)}$/.exec(v))) return [new pt(r, v, `"${E}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(N[1])} }\`.`)];
          const G = [];
          return i.layerType === "symbol" && E === "text-font" && Rc(qo(v)) && Cn(v.type) === "identity" && G.push(new pt(r, v, '"text-font" does not support identity functions')), G.concat(c({ key: i.key, value: v, valueSpec: L, style: f, styleSpec: m, expressionContext: "property", propertyType: e, propertyKey: E }));
        }
        function tp(i) {
          return ep(i, "paint");
        }
        function rp(i) {
          return ep(i, "layout");
        }
        function np(i) {
          let e = [];
          const r = i.value, c = i.key, f = i.style, m = i.styleSpec;
          if (gr(r) !== "object") return [new pt(c, r, `object expected, ${gr(r)} found`)];
          r.type || r.ref || e.push(new pt(c, r, 'either "type" or "ref" is required'));
          let v = Cn(r.type);
          const E = Cn(r.ref);
          if (r.id) {
            const k = Cn(r.id);
            for (let P = 0; P < i.arrayIndex; P++) {
              const L = f.layers[P];
              Cn(L.id) === k && e.push(new pt(c, r.id, `duplicate layer id "${r.id}", previously used at line ${L.id.__line__}`));
            }
          }
          if ("ref" in r) {
            let k;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((P) => {
              P in r && e.push(new pt(c, r[P], `"${P}" is prohibited for ref layers`));
            })), f.layers.forEach(((P) => {
              Cn(P.id) === E && (k = P);
            })), k ? k.ref ? e.push(new pt(c, r.ref, "ref cannot reference another ref layer")) : v = Cn(k.type) : e.push(new pt(c, r.ref, `ref layer "${E}" not found`));
          } else if (v !== "background") if (r.source) {
            const k = f.sources && f.sources[r.source], P = k && Cn(k.type);
            k ? P === "vector" && v === "raster" ? e.push(new pt(c, r.source, `layer "${r.id}" requires a raster source`)) : P !== "raster-dem" && v === "hillshade" || P !== "raster-dem" && v === "color-relief" ? e.push(new pt(c, r.source, `layer "${r.id}" requires a raster-dem source`)) : P === "raster" && v !== "raster" ? e.push(new pt(c, r.source, `layer "${r.id}" requires a vector source`)) : P !== "vector" || r["source-layer"] ? P === "raster-dem" && v !== "hillshade" && v !== "color-relief" ? e.push(new pt(c, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : v !== "line" || !r.paint || !r.paint["line-gradient"] || P === "geojson" && k.lineMetrics || e.push(new pt(c, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new pt(c, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new pt(c, r.source, `source "${r.source}" not found`));
          } else e.push(new pt(c, r, 'missing required property "source"'));
          return e = e.concat(ls({ key: c, value: r, valueSpec: m.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${c}.type`, value: r.type, valueSpec: m.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: r, objectKey: "type" }), filter: Al, layout: (k) => ls({ layer: r, key: k.key, value: k.value, style: k.style, styleSpec: k.styleSpec, validateSpec: k.validateSpec, objectElementValidators: { "*": (P) => rp(jr({ layerType: v }, P)) } }), paint: (k) => ls({ layer: r, key: k.key, value: k.value, style: k.style, styleSpec: k.styleSpec, validateSpec: k.validateSpec, objectElementValidators: { "*": (P) => tp(jr({ layerType: v }, P)) } }) } })), e;
        }
        function lo(i) {
          const e = i.value, r = i.key, c = gr(e);
          return c !== "string" ? [new pt(r, e, `string expected, ${c} found`)] : [];
        }
        const ad = { promoteId: function({ key: i, value: e }) {
          if (gr(e) === "string") return lo({ key: i, value: e });
          {
            const r = [];
            for (const c in e) r.push(...lo({ key: `${i}.${c}`, value: e[c] }));
            return r;
          }
        } };
        function od(i) {
          const e = i.value, r = i.key, c = i.styleSpec, f = i.style, m = i.validateSpec;
          if (!e.type) return [new pt(r, e, '"type" is required')];
          const v = Cn(e.type);
          let E;
          switch (v) {
            case "vector":
            case "raster":
              return E = ls({ key: r, value: e, valueSpec: c[`source_${v.replace("-", "_")}`], style: i.style, styleSpec: c, objectElementValidators: ad, validateSpec: m }), E;
            case "raster-dem":
              return E = (function(k) {
                var P;
                const L = (P = k.sourceName) !== null && P !== void 0 ? P : "", N = k.value, G = k.styleSpec, j = G.source_raster_dem, Z = k.style;
                let Y = [];
                const J = gr(N);
                if (N === void 0) return Y;
                if (J !== "object") return Y.push(new pt("source_raster_dem", N, `object expected, ${J} found`)), Y;
                const ie = Cn(N.encoding) === "custom", ye = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ae = k.value.encoding ? `"${k.value.encoding}"` : "Default";
                for (const ue in N) !ie && ye.includes(ue) ? Y.push(new pt(ue, N[ue], `In "${L}": "${ue}" is only valid when "encoding" is set to "custom". ${ae} encoding found`)) : j[ue] ? Y = Y.concat(k.validateSpec({ key: ue, value: N[ue], valueSpec: j[ue], validateSpec: k.validateSpec, style: Z, styleSpec: G })) : Y.push(new pt(ue, N[ue], `unknown property "${ue}"`));
                return Y;
              })({ sourceName: r, value: e, style: i.style, styleSpec: c, validateSpec: m }), E;
            case "geojson":
              if (E = ls({ key: r, value: e, valueSpec: c.source_geojson, style: f, styleSpec: c, validateSpec: m, objectElementValidators: ad }), e.cluster) for (const k in e.clusterProperties) {
                const [P, L] = e.clusterProperties[k], N = typeof P == "string" ? [P, ["accumulated"], ["get", k]] : P;
                E.push(...oo({ key: `${r}.${k}.map`, value: L, expressionContext: "cluster-map" })), E.push(...oo({ key: `${r}.${k}.reduce`, value: N, expressionContext: "cluster-reduce" }));
              }
              return E;
            case "video":
              return ls({ key: r, value: e, valueSpec: c.source_video, style: f, validateSpec: m, styleSpec: c });
            case "image":
              return ls({ key: r, value: e, valueSpec: c.source_image, style: f, validateSpec: m, styleSpec: c });
            case "canvas":
              return [new pt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return $o({ key: `${r}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Lu(i) {
          const e = i.value, r = i.styleSpec, c = r.light, f = i.style;
          let m = [];
          const v = gr(e);
          if (e === void 0) return m;
          if (v !== "object") return m = m.concat([new pt("light", e, `object expected, ${v} found`)]), m;
          for (const E in e) {
            const k = E.match(/^(.*)-transition$/);
            m = m.concat(k && c[k[1]] && c[k[1]].transition ? i.validateSpec({ key: E, value: e[E], valueSpec: r.transition, validateSpec: i.validateSpec, style: f, styleSpec: r }) : c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], validateSpec: i.validateSpec, style: f, styleSpec: r }) : [new pt(E, e[E], `unknown property "${E}"`)]);
          }
          return m;
        }
        function ip(i) {
          const e = i.value, r = i.styleSpec, c = r.sky, f = i.style, m = gr(e);
          if (e === void 0) return [];
          if (m !== "object") return [new pt("sky", e, `object expected, ${m} found`)];
          let v = [];
          for (const E in e) v = v.concat(c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], style: f, styleSpec: r }) : [new pt(E, e[E], `unknown property "${E}"`)]);
          return v;
        }
        function ld(i) {
          const e = i.value, r = i.styleSpec, c = r.terrain, f = i.style;
          let m = [];
          const v = gr(e);
          if (e === void 0) return m;
          if (v !== "object") return m = m.concat([new pt("terrain", e, `object expected, ${v} found`)]), m;
          for (const E in e) m = m.concat(c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], validateSpec: i.validateSpec, style: f, styleSpec: r }) : [new pt(E, e[E], `unknown property "${E}"`)]);
          return m;
        }
        function ud(i) {
          let e = [];
          const r = i.value, c = i.key;
          if (Array.isArray(r)) {
            const f = [], m = [];
            for (const v in r) r[v].id && f.includes(r[v].id) && e.push(new pt(c, r, `all the sprites' ids must be unique, but ${r[v].id} is duplicated`)), f.push(r[v].id), r[v].url && m.includes(r[v].url) && e.push(new pt(c, r, `all the sprites' URLs must be unique, but ${r[v].url} is duplicated`)), m.push(r[v].url), e = e.concat(ls({ key: `${c}[${v}]`, value: r[v], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
            return e;
          }
          return lo({ key: c, value: r });
        }
        function sp(i) {
          return !!i && i.constructor === Object;
        }
        function cd(i) {
          return sp(i.value) ? [] : [new pt(i.key, i.value, `object expected, ${gr(i.value)} found`)];
        }
        const hd = { "*": () => [], array: Gc, boolean: function(i) {
          const e = i.value, r = i.key, c = gr(e);
          return c !== "boolean" ? [new pt(r, e, `boolean expected, ${c} found`)] : [];
        }, number: Pu, color: Au, constants: Kf, enum: $o, filter: Al, function: jc, layer: np, object: ls, source: od, light: Lu, sky: ip, terrain: ld, projection: function(i) {
          const e = i.value, r = i.styleSpec, c = r.projection, f = i.style, m = gr(e);
          if (e === void 0) return [];
          if (m !== "object") return [new pt("projection", e, `object expected, ${m} found`)];
          let v = [];
          for (const E in e) v = v.concat(c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], style: f, styleSpec: r }) : [new pt(E, e[E], `unknown property "${E}"`)]);
          return v;
        }, projectionDefinition: function(i) {
          const e = i.key;
          let r = i.value;
          r = r instanceof String ? r.valueOf() : r;
          const c = gr(r);
          return c !== "array" || (function(f) {
            return Array.isArray(f) && f.length === 3 && typeof f[0] == "string" && typeof f[1] == "string" && typeof f[2] == "number";
          })(r) || (function(f) {
            return !!["interpolate", "step", "literal"].includes(f[0]);
          })(r) ? ["array", "string"].includes(c) ? [] : [new pt(e, r, `projection expected, invalid type "${c}" found`)] : [new pt(e, r, `projection expected, invalid array ${JSON.stringify(r)} found`)];
        }, string: lo, formatted: function(i) {
          return lo(i).length === 0 ? [] : oo(i);
        }, resolvedImage: function(i) {
          return lo(i).length === 0 ? [] : oo(i);
        }, padding: function(i) {
          const e = i.key, r = i.value;
          if (gr(r) === "array") {
            if (r.length < 1 || r.length > 4) return [new pt(e, r, `padding requires 1 to 4 values; ${r.length} values found`)];
            const c = { type: "number" };
            let f = [];
            for (let m = 0; m < r.length; m++) f = f.concat(i.validateSpec({ key: `${e}[${m}]`, value: r[m], validateSpec: i.validateSpec, valueSpec: c }));
            return f;
          }
          return Pu({ key: e, value: r, valueSpec: {} });
        }, numberArray: function(i) {
          const e = i.key, r = i.value;
          if (gr(r) === "array") {
            const c = { type: "number" };
            if (r.length < 1) return [new pt(e, r, "array length at least 1 expected, length 0 found")];
            let f = [];
            for (let m = 0; m < r.length; m++) f = f.concat(i.validateSpec({ key: `${e}[${m}]`, value: r[m], validateSpec: i.validateSpec, valueSpec: c }));
            return f;
          }
          return Pu({ key: e, value: r, valueSpec: {} });
        }, colorArray: function(i) {
          const e = i.key, r = i.value;
          if (gr(r) === "array") {
            if (r.length < 1) return [new pt(e, r, "array length at least 1 expected, length 0 found")];
            let c = [];
            for (let f = 0; f < r.length; f++) c = c.concat(Au({ key: `${e}[${f}]`, value: r[f] }));
            return c;
          }
          return Au({ key: e, value: r });
        }, variableAnchorOffsetCollection: function(i) {
          const e = i.key, r = i.value, c = gr(r), f = i.styleSpec;
          if (c !== "array" || r.length < 1 || r.length % 2 != 0) return [new pt(e, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let m = [];
          for (let v = 0; v < r.length; v += 2) m = m.concat($o({ key: `${e}[${v}]`, value: r[v], valueSpec: f.layout_symbol["text-anchor"] })), m = m.concat(Gc({ key: `${e}[${v + 1}]`, value: r[v + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: f }));
          return m;
        }, sprite: ud, state: cd, fontFaces: function(i) {
          const e = i.key, r = i.value, c = i.validateSpec, f = i.styleSpec, m = i.style;
          if (!sp(r)) return [new pt(e, r, `object expected, ${gr(r)} found`)];
          const v = [];
          for (const E in r) {
            const k = r[E], P = gr(k);
            if (P === "string") v.push(...lo({ key: `${e}.${E}`, value: k }));
            else if (P === "array") {
              const L = { url: { type: "string", required: !0 }, "unicode-range": { type: "array", value: "string" } };
              for (const [N, G] of k.entries()) v.push(...ls({ key: `${e}.${E}[${N}]`, value: G, valueSpec: L, styleSpec: f, style: m, validateSpec: c }));
            } else v.push(new pt(`${e}.${E}`, k, `string or array expected, ${P} found`));
          }
          return v;
        } };
        function uo(i) {
          const e = i.value, r = i.valueSpec, c = i.styleSpec;
          return i.validateSpec = uo, r.expression && Rc(Cn(e)) ? jc(i) : r.expression && Pl(qo(e)) ? oo(i) : r.type && hd[r.type] ? hd[r.type](i) : ls(jr({}, i, { valueSpec: r.type ? c[r.type] : r }));
        }
        function ap(i) {
          const e = i.value, r = i.key, c = lo(i);
          return c.length || (e.indexOf("{fontstack}") === -1 && c.push(new pt(r, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && c.push(new pt(r, e, '"glyphs" url must include a "{range}" token'))), c;
        }
        function Ss(i, e = Be) {
          let r = [];
          return r = r.concat(uo({ key: "", value: i, valueSpec: e.$root, styleSpec: e, style: i, validateSpec: uo, objectElementValidators: { glyphs: ap, "*": () => [] } })), i.constants && (r = r.concat(Kf({ key: "constants", value: i.constants }))), op(r);
        }
        function Bs(i) {
          return function(e) {
            return i(Object.assign({}, e, { validateSpec: uo }));
          };
        }
        function op(i) {
          return [].concat(i).sort(((e, r) => e.line - r.line));
        }
        function Gs(i) {
          return function(...e) {
            return op(i.apply(this, e));
          };
        }
        Ss.source = Gs(Bs(od)), Ss.sprite = Gs(Bs(ud)), Ss.glyphs = Gs(Bs(ap)), Ss.light = Gs(Bs(Lu)), Ss.sky = Gs(Bs(ip)), Ss.terrain = Gs(Bs(ld)), Ss.state = Gs(Bs(cd)), Ss.layer = Gs(Bs(np)), Ss.filter = Gs(Bs(Al)), Ss.paintProperty = Gs(Bs(tp)), Ss.layoutProperty = Gs(Bs(rp));
        const um = { type: "enum", "property-type": "data-constant", expression: { interpolated: !1, parameters: ["global-state"] }, values: { visible: {}, none: {} }, transition: !1, default: "visible" };
        class Du {
          constructor(e, r) {
            this._globalState = r, this.setValue(e);
          }
          evaluate() {
            var e;
            return (e = this._literalValue) !== null && e !== void 0 ? e : this._compiledValue.evaluate({});
          }
          setValue(e) {
            if (e == null || e === "visible" || e === "none") return this._literalValue = e === "none" ? "none" : "visible", this._compiledValue = void 0, void (this._globalStateRefs = /* @__PURE__ */ new Set());
            const r = ku(e, um, this._globalState);
            if (r.result === "error") throw this._literalValue = "visible", this._compiledValue = void 0, new Error(r.value.map(((c) => `${c.key}: ${c.message}`)).join(", "));
            this._literalValue = void 0, this._compiledValue = r.value, this._globalStateRefs = ao(r.value.expression);
          }
          getGlobalStateRefs() {
            return this._globalStateRefs;
          }
        }
        const Ru = Be, ci = Ss, Fu = ci.light, lp = ci.sky, cm = ci.paintProperty, hm = ci.layoutProperty;
        function Ll(i, e) {
          let r = !1;
          if (e && e.length) for (const c of e) i.fire(new st(new Error(c.message))), r = !0;
          return r;
        }
        class Dl {
          constructor(e, r, c) {
            const f = this.cells = [];
            if (e instanceof ArrayBuffer) {
              this.arrayBuffer = e;
              const v = new Int32Array(this.arrayBuffer);
              e = v[0], this.d = (r = v[1]) + 2 * (c = v[2]);
              for (let k = 0; k < this.d * this.d; k++) {
                const P = v[3 + k], L = v[3 + k + 1];
                f.push(P === L ? null : v.subarray(P, L));
              }
              const E = v[3 + f.length + 1];
              this.keys = v.subarray(v[3 + f.length], E), this.bboxes = v.subarray(E), this.insert = this._insertReadonly;
            } else {
              this.d = r + 2 * c;
              for (let v = 0; v < this.d * this.d; v++) f.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = r, this.extent = e, this.padding = c, this.scale = r / e, this.uid = 0;
            const m = c / r * e;
            this.min = -m, this.max = e + m;
          }
          insert(e, r, c, f, m) {
            this._forEachCell(r, c, f, m, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(r), this.bboxes.push(c), this.bboxes.push(f), this.bboxes.push(m);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(e, r, c, f, m, v) {
            this.cells[m].push(v);
          }
          query(e, r, c, f, m) {
            const v = this.min, E = this.max;
            if (e <= v && r <= v && E <= c && E <= f && !m) return Array.prototype.slice.call(this.keys);
            {
              const k = [];
              return this._forEachCell(e, r, c, f, this._queryCell, k, {}, m), k;
            }
          }
          _queryCell(e, r, c, f, m, v, E, k) {
            const P = this.cells[m];
            if (P !== null) {
              const L = this.keys, N = this.bboxes;
              for (let G = 0; G < P.length; G++) {
                const j = P[G];
                if (E[j] === void 0) {
                  const Z = 4 * j;
                  (k ? k(N[Z + 0], N[Z + 1], N[Z + 2], N[Z + 3]) : e <= N[Z + 2] && r <= N[Z + 3] && c >= N[Z + 0] && f >= N[Z + 1]) ? (E[j] = !0, v.push(L[j])) : E[j] = !1;
                }
              }
            }
          }
          _forEachCell(e, r, c, f, m, v, E, k) {
            const P = this._convertToCellCoord(e), L = this._convertToCellCoord(r), N = this._convertToCellCoord(c), G = this._convertToCellCoord(f);
            for (let j = P; j <= N; j++) for (let Z = L; Z <= G; Z++) {
              const Y = this.d * Z + j;
              if ((!k || k(this._convertFromCellCoord(j), this._convertFromCellCoord(Z), this._convertFromCellCoord(j + 1), this._convertFromCellCoord(Z + 1))) && m.call(this, e, r, c, f, Y, v, E, k)) return;
            }
          }
          _convertFromCellCoord(e) {
            return (e - this.padding) / this.scale;
          }
          _convertToCellCoord(e) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const e = this.cells, r = 3 + this.cells.length + 1 + 1;
            let c = 0;
            for (let v = 0; v < this.cells.length; v++) c += this.cells[v].length;
            const f = new Int32Array(r + c + this.keys.length + this.bboxes.length);
            f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
            let m = r;
            for (let v = 0; v < e.length; v++) {
              const E = e[v];
              f[3 + v] = m, f.set(E, m), m += E.length;
            }
            return f[3 + e.length] = m, f.set(this.keys, m), m += this.keys.length, f[3 + e.length + 1] = m, f.set(this.bboxes, m), m += this.bboxes.length, f.buffer;
          }
          static serialize(e, r) {
            const c = e.toArrayBuffer();
            return r && r.push(c), { buffer: c };
          }
          static deserialize(e) {
            return new Dl(e.buffer);
          }
        }
        const js = {};
        function Vt(i, e, r = {}) {
          if (js[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(e, "_classRegistryKey", { value: i, writeable: !1 }), js[i] = { klass: e, omit: r.omit || [], shallow: r.shallow || [] };
        }
        Vt("Object", Object), Vt("Set", Set), Vt("TransferableGridIndex", Dl), Vt("Color", cr), Vt("Error", Error), Vt("AJAXError", Te), Vt("ResolvedImage", hr), Vt("StylePropertyFunction", Nc), Vt("StyleExpression", rd, { omit: ["_evaluator"] }), Vt("ZoomDependentExpression", nd), Vt("ZoomConstantExpression", Fc), Vt("CompoundExpression", lr, { omit: ["_evaluate"] });
        for (const i in _r) _r[i]._classRegistryKey || Vt(`Expression_${i}`, _r[i]);
        function Vc(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
        }
        function dd(i) {
          return i.$name || i.constructor._classRegistryKey;
        }
        function Rl(i) {
          return !(function(e) {
            if (e === null || typeof e != "object") return !1;
            const r = dd(e);
            return !(!r || r === "Object");
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Vc(i) || ii(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
        }
        function Nu(i, e) {
          if (Rl(i)) return (Vc(i) || ii(i)) && e && e.push(i), ArrayBuffer.isView(i) && e && e.push(i.buffer), i instanceof ImageData && e && e.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const m = [];
            for (const v of i) m.push(Nu(v, e));
            return m;
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const r = dd(i);
          if (!r) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!js[r]) throw new Error(`${r} is not registered.`);
          const { klass: c } = js[r], f = c.serialize ? c.serialize(i, e) : {};
          if (c.serialize) {
            if (e && f === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const m in i) {
              if (!i.hasOwnProperty(m) || js[r].omit.indexOf(m) >= 0) continue;
              const v = i[m];
              f[m] = js[r].shallow.indexOf(m) >= 0 ? v : Nu(v, e);
            }
            i instanceof Error && (f.message = i.message);
          }
          if (f.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (f.$name = r), f;
        }
        function Ou(i) {
          if (Rl(i)) return i;
          if (Array.isArray(i)) return i.map(Ou);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const e = dd(i) || "Object";
          if (!js[e]) throw new Error(`can't deserialize unregistered class ${e}`);
          const { klass: r } = js[e];
          if (!r) throw new Error(`can't deserialize unregistered class ${e}`);
          if (r.deserialize) return r.deserialize(i);
          const c = Object.create(r.prototype);
          for (const f of Object.keys(i)) {
            if (f === "$name") continue;
            const m = i[f];
            c[f] = js[e].shallow.indexOf(f) >= 0 ? m : Ou(m);
          }
          return c;
        }
        class fd {
          constructor() {
            this.first = !0;
          }
          update(e, r) {
            const c = Math.floor(e);
            return this.first ? (this.first = !1, this.lastIntegerZoom = c, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = c, !0) : (this.lastFloorZoom > c ? (this.lastIntegerZoom = c + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < c && (this.lastIntegerZoom = c, this.lastIntegerZoomTime = r), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = c, !0));
          }
        }
        function zu(i) {
          return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }
        function pd(i) {
          return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }
        function up(i) {
          return /\s/u.test(String.fromCodePoint(i));
        }
        function Fl(i) {
          for (const e of i) if (pd(e.codePointAt(0))) return !0;
          return !1;
        }
        function dm(i) {
          for (const e of i) if (!cp(e.codePointAt(0))) return !1;
          return !0;
        }
        function Uc(i) {
          const e = i.map(((r) => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((r) => r));
          return new RegExp(e.join("|"), "u");
        }
        const qc = Uc(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function cp(i) {
          return !qc.test(String.fromCodePoint(i));
        }
        function gd(i) {
          return !(pd(i) || (e = i, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(e))));
          var e;
        }
        const hp = Uc(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function md(i) {
          return hp.test(String.fromCodePoint(i));
        }
        function _d(i, e) {
          return !(!e && md(i) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(i)));
        }
        function dp(i) {
          for (const e of i) if (md(e.codePointAt(0))) return !0;
          return !1;
        }
        const co = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(i) {
            if (co.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(i, e) {
            return u(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const r = i.pluginURL, c = new Promise(((m) => {
                this.loadScriptResolve = m;
              }));
              e(r);
              const f = new Promise(((m) => setTimeout((() => m()), this.TIMEOUT)));
              if (yield Promise.race([c, f]), this.isParsed()) {
                const m = { pluginStatus: "loaded", pluginURL: r };
                return this.setState(m), m;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${r}`);
            }));
          }
        }();
        class Vr {
          constructor(e, r) {
            this.isSupportedScript = fm, this.zoom = e, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new fd(), this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new fd(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const e = this.zoom, r = e - Math.floor(e), c = this.crossFadingFactor();
            return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r + (1 - r) * c } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - c) * r };
          }
        }
        function fm(i) {
          return (function(e, r) {
            for (const c of e) if (!_d(c.codePointAt(0), r)) return !1;
            return !0;
          })(i, co.getRTLTextPluginStatus() === "loaded");
        }
        const Bu = "-transition";
        class $c {
          constructor(e, r, c) {
            this.property = e, this.value = r, this.expression = (function(f, m, v) {
              if (Rc(f)) return new Nc(f, m);
              if (Pl(f)) {
                const E = id(f, m, v);
                if (E.result === "error") throw new Error(E.value.map(((k) => `${k.key}: ${k.message}`)).join(", "));
                return E.value;
              }
              {
                let E = f;
                return m.type === "color" && typeof f == "string" ? E = cr.parse(f) : m.type !== "padding" || typeof f != "number" && !Array.isArray(f) ? m.type !== "numberArray" || typeof f != "number" && !Array.isArray(f) ? m.type !== "colorArray" || typeof f != "string" && !Array.isArray(f) ? m.type === "variableAnchorOffsetCollection" && Array.isArray(f) ? E = oi.parse(f) : m.type === "projectionDefinition" && typeof f == "string" && (E = rn.parse(f)) : E = Kt.parse(f) : E = tn.parse(f) : E = ai.parse(f), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => E };
              }
            })(r === void 0 ? e.specification.default : r, e.specification, c);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(e, r, c) {
            return this.property.possiblyEvaluate(this, e, r, c);
          }
        }
        class Zc {
          constructor(e, r) {
            this.property = e, this.value = new $c(e, void 0, r);
          }
          transitioned(e, r) {
            return new fp(this.property, this.value, r, He({}, e.transition, this.transition), e.now);
          }
          untransitioned() {
            return new fp(this.property, this.value, null, {}, 0);
          }
        }
        class yd {
          constructor(e, r) {
            this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._globalState = r;
          }
          getValue(e) {
            return Me(this._values[e].value.value);
          }
          setValue(e, r) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Zc(this._values[e].property, this._globalState)), this._values[e].value = new $c(this._values[e].property, r === null ? void 0 : Me(r), this._globalState);
          }
          getTransition(e) {
            return Me(this._values[e].transition);
          }
          setTransition(e, r) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Zc(this._values[e].property, this._globalState)), this._values[e].transition = Me(r) || void 0;
          }
          serialize() {
            const e = {};
            for (const r of Object.keys(this._values)) {
              const c = this.getValue(r);
              c !== void 0 && (e[r] = c);
              const f = this.getTransition(r);
              f !== void 0 && (e[`${r}${Bu}`] = f);
            }
            return e;
          }
          transitioned(e, r) {
            const c = new pp(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].transitioned(e, r._values[f]);
            return c;
          }
          untransitioned() {
            const e = new pp(this._properties);
            for (const r of Object.keys(this._values)) e._values[r] = this._values[r].untransitioned();
            return e;
          }
        }
        class fp {
          constructor(e, r, c, f, m) {
            this.property = e, this.value = r, this.begin = m + f.delay || 0, this.end = this.begin + f.duration || 0, e.specification.transition && (f.delay || f.duration) && (this.prior = c);
          }
          possiblyEvaluate(e, r, c) {
            const f = e.now || 0, m = this.value.possiblyEvaluate(e, r, c), v = this.prior;
            if (v) {
              if (f > this.end) return this.prior = null, m;
              if (this.value.isDataDriven()) return this.prior = null, m;
              if (f < this.begin) return v.possiblyEvaluate(e, r, c);
              {
                const E = (f - this.begin) / (this.end - this.begin);
                return this.property.interpolate(v.possiblyEvaluate(e, r, c), m, zt(E));
              }
            }
            return m;
          }
        }
        class pp {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(e, r, c) {
            const f = new Gu(this._properties);
            for (const m of Object.keys(this._values)) f._values[m] = this._values[m].possiblyEvaluate(e, r, c);
            return f;
          }
          hasTransition() {
            for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
            return !1;
          }
        }
        class gp {
          constructor(e, r) {
            this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._globalState = r;
          }
          hasValue(e) {
            return this._values[e].value !== void 0;
          }
          getValue(e) {
            return Me(this._values[e].value);
          }
          setValue(e, r) {
            this._values[e] = new $c(this._values[e].property, r === null ? void 0 : Me(r), this._globalState);
          }
          serialize() {
            const e = {};
            for (const r of Object.keys(this._values)) {
              const c = this.getValue(r);
              c !== void 0 && (e[r] = c);
            }
            return e;
          }
          possiblyEvaluate(e, r, c) {
            const f = new Gu(this._properties);
            for (const m of Object.keys(this._values)) f._values[m] = this._values[m].possiblyEvaluate(e, r, c);
            return f;
          }
        }
        class Vs {
          constructor(e, r, c) {
            this.property = e, this.value = r, this.parameters = c;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(e) {
            return this.value.kind === "constant" ? this.value.value : e;
          }
          evaluate(e, r, c, f) {
            return this.property.evaluate(this.value, this.parameters, e, r, c, f);
          }
        }
        class Gu {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
          }
          get(e) {
            return this._values[e];
          }
        }
        class $t {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r) {
            if (e.isDataDriven()) throw new Error("Value should not be data driven");
            return e.expression.evaluate(r);
          }
          interpolate(e, r, c) {
            const f = Xr[this.specification.type];
            return f ? f(e, r, c) : e;
          }
        }
        class Xt {
          constructor(e, r) {
            this.specification = e, this.overrides = r;
          }
          possiblyEvaluate(e, r, c, f) {
            return new Vs(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(r, null, {}, c, f) } : e.expression, r);
          }
          interpolate(e, r, c) {
            if (e.value.kind !== "constant" || r.value.kind !== "constant") return e;
            if (e.value.value === void 0 || r.value.value === void 0) return new Vs(this, { kind: "constant", value: void 0 }, e.parameters);
            const f = Xr[this.specification.type];
            if (f) {
              const m = f(e.value.value, r.value.value, c);
              return new Vs(this, { kind: "constant", value: m }, e.parameters);
            }
            return e;
          }
          evaluate(e, r, c, f, m, v) {
            return e.kind === "constant" ? e.value : e.evaluate(r, c, f, m, v);
          }
        }
        class ju extends Xt {
          possiblyEvaluate(e, r, c, f) {
            if (e.value === void 0) return new Vs(this, { kind: "constant", value: void 0 }, r);
            if (e.expression.kind === "constant") {
              const m = e.expression.evaluate(r, null, {}, c, f), v = e.property.specification.type === "resolvedImage" && typeof m != "string" ? m.name : m, E = this._calculate(v, v, v, r);
              return new Vs(this, { kind: "constant", value: E }, r);
            }
            if (e.expression.kind === "camera") {
              const m = this._calculate(e.expression.evaluate({ zoom: r.zoom - 1 }), e.expression.evaluate({ zoom: r.zoom }), e.expression.evaluate({ zoom: r.zoom + 1 }), r);
              return new Vs(this, { kind: "constant", value: m }, r);
            }
            return new Vs(this, e.expression, r);
          }
          evaluate(e, r, c, f, m, v) {
            if (e.kind === "source") {
              const E = e.evaluate(r, c, f, m, v);
              return this._calculate(E, E, E, r);
            }
            return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(r.zoom) - 1 }, c, f), e.evaluate({ zoom: Math.floor(r.zoom) }, c, f), e.evaluate({ zoom: Math.floor(r.zoom) + 1 }, c, f), r) : e.value;
          }
          _calculate(e, r, c, f) {
            return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: c, to: r };
          }
          interpolate(e) {
            return e;
          }
        }
        class Hc {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r, c, f) {
            if (e.value !== void 0) {
              if (e.expression.kind === "constant") {
                const m = e.expression.evaluate(r, null, {}, c, f);
                return this._calculate(m, m, m, r);
              }
              return this._calculate(e.expression.evaluate(new Vr(Math.floor(r.zoom - 1), r)), e.expression.evaluate(new Vr(Math.floor(r.zoom), r)), e.expression.evaluate(new Vr(Math.floor(r.zoom + 1), r)), r);
            }
          }
          _calculate(e, r, c, f) {
            return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: c, to: r };
          }
          interpolate(e) {
            return e;
          }
        }
        class Yc {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r, c, f) {
            return !!e.expression.evaluate(r, null, {}, c, f);
          }
          interpolate() {
            return !1;
          }
        }
        class Ui {
          constructor(e) {
            this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in e) {
              const c = e[r];
              c.specification.overridable && this.overridableProperties.push(r);
              const f = this.defaultPropertyValues[r] = new $c(c, void 0, void 0), m = this.defaultTransitionablePropertyValues[r] = new Zc(c, void 0);
              this.defaultTransitioningPropertyValues[r] = m.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = f.possiblyEvaluate({});
            }
          }
        }
        Vt("DataDrivenProperty", Xt), Vt("DataConstantProperty", $t), Vt("CrossFadedDataDrivenProperty", ju), Vt("CrossFadedProperty", Hc), Vt("ColorRampProperty", Yc);
        class Ts extends vt {
          constructor(e, r, c) {
            if (super(), this.id = e.id, this.type = e.type, this._globalState = c, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, this._visibilityExpression = (function(f, m) {
              return new Du(f, m);
            })(this.visibility, c), e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter, this._featureFilter = Iu(e.filter, c)), r.layout && (this._unevaluatedLayout = new gp(r.layout, c)), r.paint)) {
              this._transitionablePaint = new yd(r.paint, c);
              for (const f in e.paint) this.setPaintProperty(f, e.paint[f], { validate: !1 });
              for (const f in e.layout) this.setLayoutProperty(f, e.layout[f], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Gu(r.paint);
            }
          }
          setFilter(e) {
            this.filter = e, this._featureFilter = Iu(e, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(e) {
            return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
          }
          getLayoutAffectingGlobalStateRefs() {
            const e = /* @__PURE__ */ new Set();
            for (const r of this._visibilityExpression.getGlobalStateRefs()) e.add(r);
            if (this._unevaluatedLayout) for (const r in this._unevaluatedLayout._values) {
              const c = this._unevaluatedLayout._values[r];
              for (const f of c.getGlobalStateRefs()) e.add(f);
            }
            for (const r of this._featureFilter.getGlobalStateRefs()) e.add(r);
            return e;
          }
          getPaintAffectingGlobalStateRefs() {
            var e;
            const r = new globalThis.Map();
            if (this._transitionablePaint) for (const c in this._transitionablePaint._values) {
              const f = this._transitionablePaint._values[c].value;
              for (const m of f.getGlobalStateRefs()) {
                const v = (e = r.get(m)) !== null && e !== void 0 ? e : [];
                v.push({ name: c, value: f.value }), r.set(m, v);
              }
            }
            return r;
          }
          getVisibilityAffectingGlobalStateRefs() {
            return this._visibilityExpression.getGlobalStateRefs();
          }
          setLayoutProperty(e, r, c = {}) {
            if (r == null || !this._validate(hm, `layers.${this.id}.layout.${e}`, e, r, c)) return e === "visibility" ? (this.visibility = r, this._visibilityExpression.setValue(r), void this.recalculateVisibility()) : void this._unevaluatedLayout.setValue(e, r);
          }
          getPaintProperty(e) {
            return e.endsWith(Bu) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
          }
          setPaintProperty(e, r, c = {}) {
            if (r != null && this._validate(cm, `layers.${this.id}.paint.${e}`, e, r, c)) return !1;
            if (e.endsWith(Bu)) return this._transitionablePaint.setTransition(e.slice(0, -11), r || void 0), !1;
            {
              const f = this._transitionablePaint._values[e], m = f.property.specification["property-type"] === "cross-faded-data-driven", v = f.value.isDataDriven(), E = f.value;
              this._transitionablePaint.setValue(e, r), this._handleSpecialPaintPropertyUpdate(e);
              const k = this._transitionablePaint._values[e].value;
              return k.isDataDriven() || v || m || this._handleOverridablePaintPropertyUpdate(e, E, k);
            }
          }
          _handleSpecialPaintPropertyUpdate(e) {
          }
          _handleOverridablePaintPropertyUpdate(e, r, c) {
            return !1;
          }
          isHidden(e = this.minzoom, r = !1) {
            return !!(this.minzoom && e < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e >= this.maxzoom) || this._evaluatedVisibility === "none";
          }
          updateTransitions(e) {
            this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculateVisibility() {
            this._evaluatedVisibility = this._visibilityExpression.evaluate();
          }
          recalculate(e, r) {
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, r);
          }
          serialize() {
            const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), Bt(e, ((r, c) => !(r === void 0 || c === "layout" && !Object.keys(r).length || c === "paint" && !Object.keys(r).length)));
          }
          _validate(e, r, c, f, m = {}) {
            return (!m || m.validate !== !1) && Ll(this, e.call(ci, { key: r, layerType: this.type, objectKey: c, value: f, styleSpec: Be, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const e in this.paint._values) {
              const r = this.paint.get(e);
              if (r instanceof Vs && Aa(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        let vd;
        var mp = { get paint() {
          return vd = vd || new Ui({ "raster-opacity": new $t(Be.paint_raster["raster-opacity"]), "raster-hue-rotate": new $t(Be.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new $t(Be.paint_raster["raster-brightness-min"]), "raster-brightness-max": new $t(Be.paint_raster["raster-brightness-max"]), "raster-saturation": new $t(Be.paint_raster["raster-saturation"]), "raster-contrast": new $t(Be.paint_raster["raster-contrast"]), "raster-resampling": new $t(Be.paint_raster["raster-resampling"]), "raster-fade-duration": new $t(Be.paint_raster["raster-fade-duration"]) });
        } };
        class pm extends Ts {
          constructor(e, r) {
            super(e, mp, r);
          }
        }
        const gm = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Vu {
          constructor(e, r) {
            this._structArray = e, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class yn {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(e, r) {
            return e._trim(), r && (e.isTransferred = !0, r.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
          }
          static deserialize(e) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = e.arrayBuffer, r.length = e.length, r.capacity = e.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(e) {
            this.reserve(e), this.length = e;
          }
          reserve(e) {
            if (e > this.capacity) {
              this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Pn(i, e = 1) {
          let r = 0, c = 0;
          return { members: i.map(((f) => {
            const m = gm[f.type].BYTES_PER_ELEMENT, v = r = Zo(r, Math.max(e, m)), E = f.components || 1;
            return c = Math.max(c, m), r += m * E, { name: f.name, type: f.type, components: E, offset: v };
          })), size: Zo(r, Math.max(c, e)), alignment: e };
        }
        function Zo(i, e) {
          return Math.ceil(i / e) * e;
        }
        class Uu extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, r);
          }
          emplace(e, r, c) {
            const f = 2 * e;
            return this.int16[f + 0] = r, this.int16[f + 1] = c, e;
          }
        }
        Uu.prototype.bytesPerElement = 4, Vt("StructArrayLayout2i4", Uu);
        class Wc extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.int16[m + 0] = r, this.int16[m + 1] = c, this.int16[m + 2] = f, e;
          }
        }
        Wc.prototype.bytesPerElement = 6, Vt("StructArrayLayout3i6", Wc);
        class xd extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, e, r, c, f);
          }
          emplace(e, r, c, f, m) {
            const v = 4 * e;
            return this.int16[v + 0] = r, this.int16[v + 1] = c, this.int16[v + 2] = f, this.int16[v + 3] = m, e;
          }
        }
        xd.prototype.bytesPerElement = 8, Vt("StructArrayLayout4i8", xd);
        class Xc extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 6 * e;
            return this.int16[k + 0] = r, this.int16[k + 1] = c, this.int16[k + 2] = f, this.int16[k + 3] = m, this.int16[k + 4] = v, this.int16[k + 5] = E, e;
          }
        }
        Xc.prototype.bytesPerElement = 12, Vt("StructArrayLayout2i4i12", Xc);
        class bd extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 4 * e, P = 8 * e;
            return this.int16[k + 0] = r, this.int16[k + 1] = c, this.uint8[P + 4] = f, this.uint8[P + 5] = m, this.uint8[P + 6] = v, this.uint8[P + 7] = E, e;
          }
        }
        bd.prototype.bytesPerElement = 8, Vt("StructArrayLayout2i4ub8", bd);
        class qu extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, r);
          }
          emplace(e, r, c) {
            const f = 2 * e;
            return this.float32[f + 0] = r, this.float32[f + 1] = c, e;
          }
        }
        qu.prototype.bytesPerElement = 8, Vt("StructArrayLayout2f8", qu);
        class La extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, e, r, c, f, m, v, E, k, P, L);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N) {
            const G = 10 * e;
            return this.uint16[G + 0] = r, this.uint16[G + 1] = c, this.uint16[G + 2] = f, this.uint16[G + 3] = m, this.uint16[G + 4] = v, this.uint16[G + 5] = E, this.uint16[G + 6] = k, this.uint16[G + 7] = P, this.uint16[G + 8] = L, this.uint16[G + 9] = N, e;
          }
        }
        La.prototype.bytesPerElement = 20, Vt("StructArrayLayout10ui20", La);
        class Jc extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, e, r, c, f, m, v, E, k);
          }
          emplace(e, r, c, f, m, v, E, k, P) {
            const L = 8 * e;
            return this.uint16[L + 0] = r, this.uint16[L + 1] = c, this.uint16[L + 2] = f, this.uint16[L + 3] = m, this.uint16[L + 4] = v, this.uint16[L + 5] = E, this.uint16[L + 6] = k, this.uint16[L + 7] = P, e;
          }
        }
        Jc.prototype.bytesPerElement = 16, Vt("StructArrayLayout8ui16", Jc);
        class $u extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L, N, G) {
            const j = this.length;
            return this.resize(j + 1), this.emplace(j, e, r, c, f, m, v, E, k, P, L, N, G);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N, G, j) {
            const Z = 12 * e;
            return this.int16[Z + 0] = r, this.int16[Z + 1] = c, this.int16[Z + 2] = f, this.int16[Z + 3] = m, this.uint16[Z + 4] = v, this.uint16[Z + 5] = E, this.uint16[Z + 6] = k, this.uint16[Z + 7] = P, this.int16[Z + 8] = L, this.int16[Z + 9] = N, this.int16[Z + 10] = G, this.int16[Z + 11] = j, e;
          }
        }
        $u.prototype.bytesPerElement = 24, Vt("StructArrayLayout4i4ui4i24", $u);
        class Kc extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.float32[m + 0] = r, this.float32[m + 1] = c, this.float32[m + 2] = f, e;
          }
        }
        Kc.prototype.bytesPerElement = 12, Vt("StructArrayLayout3f12", Kc);
        class Zu extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint32[1 * e + 0] = r, e;
          }
        }
        Zu.prototype.bytesPerElement = 4, Vt("StructArrayLayout1ul4", Zu);
        class wd extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, e, r, c, f, m, v, E, k, P);
          }
          emplace(e, r, c, f, m, v, E, k, P, L) {
            const N = 10 * e, G = 5 * e;
            return this.int16[N + 0] = r, this.int16[N + 1] = c, this.int16[N + 2] = f, this.int16[N + 3] = m, this.int16[N + 4] = v, this.int16[N + 5] = E, this.uint32[G + 3] = k, this.uint16[N + 8] = P, this.uint16[N + 9] = L, e;
          }
        }
        wd.prototype.bytesPerElement = 20, Vt("StructArrayLayout6i1ul2ui20", wd);
        class Nl extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 6 * e;
            return this.int16[k + 0] = r, this.int16[k + 1] = c, this.int16[k + 2] = f, this.int16[k + 3] = m, this.int16[k + 4] = v, this.int16[k + 5] = E, e;
          }
        }
        Nl.prototype.bytesPerElement = 12, Vt("StructArrayLayout2i2i2i12", Nl);
        class Ho extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, e, r, c, f, m);
          }
          emplace(e, r, c, f, m, v) {
            const E = 4 * e, k = 8 * e;
            return this.float32[E + 0] = r, this.float32[E + 1] = c, this.float32[E + 2] = f, this.int16[k + 6] = m, this.int16[k + 7] = v, e;
          }
        }
        Ho.prototype.bytesPerElement = 16, Vt("StructArrayLayout2f1f2i16", Ho);
        class Ed extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 16 * e, P = 4 * e, L = 8 * e;
            return this.uint8[k + 0] = r, this.uint8[k + 1] = c, this.float32[P + 1] = f, this.float32[P + 2] = m, this.int16[L + 6] = v, this.int16[L + 7] = E, e;
          }
        }
        Ed.prototype.bytesPerElement = 16, Vt("StructArrayLayout2ub2f2i16", Ed);
        class Hu extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.uint16[m + 0] = r, this.uint16[m + 1] = c, this.uint16[m + 2] = f, e;
          }
        }
        Hu.prototype.bytesPerElement = 6, Vt("StructArrayLayout3ui6", Hu);
        class Yo extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie) {
            const ye = this.length;
            return this.resize(ye + 1), this.emplace(ye, e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie, ye) {
            const ae = 24 * e, ue = 12 * e, Ee = 48 * e;
            return this.int16[ae + 0] = r, this.int16[ae + 1] = c, this.uint16[ae + 2] = f, this.uint16[ae + 3] = m, this.uint32[ue + 2] = v, this.uint32[ue + 3] = E, this.uint32[ue + 4] = k, this.uint16[ae + 10] = P, this.uint16[ae + 11] = L, this.uint16[ae + 12] = N, this.float32[ue + 7] = G, this.float32[ue + 8] = j, this.uint8[Ee + 36] = Z, this.uint8[Ee + 37] = Y, this.uint8[Ee + 38] = J, this.uint32[ue + 10] = ie, this.int16[ae + 22] = ye, e;
          }
        }
        Yo.prototype.bytesPerElement = 48, Vt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Yo);
        class Sd extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie, ye, ae, ue, Ee, Le, Ke, dt, ht, mt, Pt, bt) {
            const ct = this.length;
            return this.resize(ct + 1), this.emplace(ct, e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie, ye, ae, ue, Ee, Le, Ke, dt, ht, mt, Pt, bt);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie, ye, ae, ue, Ee, Le, Ke, dt, ht, mt, Pt, bt, ct) {
            const ot = 32 * e, Nt = 16 * e;
            return this.int16[ot + 0] = r, this.int16[ot + 1] = c, this.int16[ot + 2] = f, this.int16[ot + 3] = m, this.int16[ot + 4] = v, this.int16[ot + 5] = E, this.int16[ot + 6] = k, this.int16[ot + 7] = P, this.uint16[ot + 8] = L, this.uint16[ot + 9] = N, this.uint16[ot + 10] = G, this.uint16[ot + 11] = j, this.uint16[ot + 12] = Z, this.uint16[ot + 13] = Y, this.uint16[ot + 14] = J, this.uint16[ot + 15] = ie, this.uint16[ot + 16] = ye, this.uint16[ot + 17] = ae, this.uint16[ot + 18] = ue, this.uint16[ot + 19] = Ee, this.uint16[ot + 20] = Le, this.uint16[ot + 21] = Ke, this.uint16[ot + 22] = dt, this.uint32[Nt + 12] = ht, this.float32[Nt + 13] = mt, this.float32[Nt + 14] = Pt, this.uint16[ot + 30] = bt, this.uint16[ot + 31] = ct, e;
          }
        }
        Sd.prototype.bytesPerElement = 64, Vt("StructArrayLayout8i15ui1ul2f2ui64", Sd);
        class Qc extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.float32[1 * e + 0] = r, e;
          }
        }
        Qc.prototype.bytesPerElement = 4, Vt("StructArrayLayout1f4", Qc);
        class eh extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.uint16[6 * e + 0] = r, this.float32[m + 1] = c, this.float32[m + 2] = f, e;
          }
        }
        eh.prototype.bytesPerElement = 12, Vt("StructArrayLayout1ui2f12", eh);
        class Td extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 4 * e;
            return this.uint32[2 * e + 0] = r, this.uint16[m + 2] = c, this.uint16[m + 3] = f, e;
          }
        }
        Td.prototype.bytesPerElement = 8, Vt("StructArrayLayout1ul2ui8", Td);
        class b extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, r);
          }
          emplace(e, r, c) {
            const f = 2 * e;
            return this.uint16[f + 0] = r, this.uint16[f + 1] = c, e;
          }
        }
        b.prototype.bytesPerElement = 4, Vt("StructArrayLayout2ui4", b);
        class t extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint16[1 * e + 0] = r, e;
          }
        }
        t.prototype.bytesPerElement = 2, Vt("StructArrayLayout1ui2", t);
        class s extends yn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, e, r, c, f);
          }
          emplace(e, r, c, f, m) {
            const v = 4 * e;
            return this.float32[v + 0] = r, this.float32[v + 1] = c, this.float32[v + 2] = f, this.float32[v + 3] = m, e;
          }
        }
        s.prototype.bytesPerElement = 16, Vt("StructArrayLayout4f16", s);
        class d extends Vu {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new R(this.anchorPointX, this.anchorPointY);
          }
        }
        d.prototype.size = 20;
        class g extends wd {
          get(e) {
            return new d(this, e);
          }
        }
        Vt("CollisionBoxArray", g);
        class w extends Vu {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(e) {
            this._structArray.uint8[this._pos1 + 37] = e;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(e) {
            this._structArray.uint8[this._pos1 + 38] = e;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 10] = e;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        w.prototype.size = 48;
        class T extends Yo {
          get(e) {
            return new w(this, e);
          }
        }
        Vt("PlacedSymbolArray", T);
        class C extends Vu {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 12] = e;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        C.prototype.size = 64;
        class A extends Sd {
          get(e) {
            return new C(this, e);
          }
        }
        Vt("SymbolInstanceArray", A);
        class F extends Qc {
          getoffsetX(e) {
            return this.float32[1 * e + 0];
          }
        }
        Vt("GlyphOffsetArray", F);
        class O extends Wc {
          getx(e) {
            return this.int16[3 * e + 0];
          }
          gety(e) {
            return this.int16[3 * e + 1];
          }
          gettileUnitDistanceFromAnchor(e) {
            return this.int16[3 * e + 2];
          }
        }
        Vt("SymbolLineVertexArray", O);
        class q extends Vu {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        q.prototype.size = 12;
        class V extends eh {
          get(e) {
            return new q(this, e);
          }
        }
        Vt("TextAnchorOffsetArray", V);
        class X extends Vu {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        X.prototype.size = 8;
        class te extends Td {
          get(e) {
            return new X(this, e);
          }
        }
        Vt("FeatureIndexArray", te);
        class he extends Uu {
        }
        class pe extends Uu {
        }
        class fe extends Uu {
        }
        class be extends Xc {
        }
        class Ae extends bd {
        }
        class xe extends qu {
        }
        class Ce extends La {
        }
        class Oe extends Jc {
        }
        class ke extends $u {
        }
        class je extends Kc {
        }
        class at extends Zu {
        }
        class tt extends Nl {
        }
        class nt extends Ed {
        }
        class it extends Hu {
        }
        class St extends b {
        }
        const It = Pn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: _t } = It;
        class Lt {
          constructor(e = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = e;
          }
          prepareSegment(e, r, c, f) {
            const m = this.segments[this.segments.length - 1];
            return e > Lt.MAX_VERTEX_ARRAY_LENGTH && ur(`Max vertices per segment is ${Lt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Lt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !m || m.vertexLength + e > Lt.MAX_VERTEX_ARRAY_LENGTH || m.sortKey !== f ? this.createNewSegment(r, c, f) : m;
          }
          createNewSegment(e, r, c) {
            const f = { vertexOffset: e.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return c !== void 0 && (f.sortKey = c), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(f), f;
          }
          getOrCreateLatestSegment(e, r, c) {
            return this.prepareSegment(0, e, r, c);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const e of this.segments) for (const r in e.vaos) e.vaos[r].destroy();
          }
          static simpleSegment(e, r, c, f) {
            return new Lt([{ vertexOffset: e, primitiveOffset: r, vertexLength: c, primitiveLength: f, vaos: {}, sortKey: 0 }]);
          }
        }
        function or(i, e) {
          return 256 * (i = Yt(Math.floor(i), 0, 255)) + Yt(Math.floor(e), 0, 255);
        }
        Lt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Vt("SegmentVector", Lt);
        const Or = Pn([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), an = Pn([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var $r, hn, Zr, Sn = { exports: {} }, dn = { exports: {} }, hi = { exports: {} }, Fn = (function() {
          if (Zr) return Sn.exports;
          Zr = 1;
          var i = ($r || ($r = 1, dn.exports = function(r, c) {
            var f, m, v, E, k, P, L, N;
            for (m = r.length - (f = 3 & r.length), v = c, k = 3432918353, P = 461845907, N = 0; N < m; ) L = 255 & r.charCodeAt(N) | (255 & r.charCodeAt(++N)) << 8 | (255 & r.charCodeAt(++N)) << 16 | (255 & r.charCodeAt(++N)) << 24, ++N, v = 27492 + (65535 & (E = 5 * (65535 & (v = (v ^= L = (65535 & (L = (L = (65535 & L) * k + (((L >>> 16) * k & 65535) << 16) & 4294967295) << 15 | L >>> 17)) * P + (((L >>> 16) * P & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (E >>> 16) & 65535) << 16);
            switch (L = 0, f) {
              case 3:
                L ^= (255 & r.charCodeAt(N + 2)) << 16;
              case 2:
                L ^= (255 & r.charCodeAt(N + 1)) << 8;
              case 1:
                v ^= L = (65535 & (L = (L = (65535 & (L ^= 255 & r.charCodeAt(N))) * k + (((L >>> 16) * k & 65535) << 16) & 4294967295) << 15 | L >>> 17)) * P + (((L >>> 16) * P & 65535) << 16) & 4294967295;
            }
            return v ^= r.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
          }), dn.exports), e = (hn || (hn = 1, hi.exports = function(r, c) {
            for (var f, m = r.length, v = c ^ m, E = 0; m >= 4; ) f = 1540483477 * (65535 & (f = 255 & r.charCodeAt(E) | (255 & r.charCodeAt(++E)) << 8 | (255 & r.charCodeAt(++E)) << 16 | (255 & r.charCodeAt(++E)) << 24)) + ((1540483477 * (f >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (f = 1540483477 * (65535 & (f ^= f >>> 24)) + ((1540483477 * (f >>> 16) & 65535) << 16)), m -= 4, ++E;
            switch (m) {
              case 3:
                v ^= (255 & r.charCodeAt(E + 2)) << 16;
              case 2:
                v ^= (255 & r.charCodeAt(E + 1)) << 8;
              case 1:
                v = 1540483477 * (65535 & (v ^= 255 & r.charCodeAt(E))) + ((1540483477 * (v >>> 16) & 65535) << 16);
            }
            return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
          }), hi.exports);
          return Sn.exports = i, Sn.exports.murmur3 = i, Sn.exports.murmur2 = e, Sn.exports;
        })(), An = z(Fn);
        class Ei {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(e, r, c, f) {
            this.ids.push(ho(e)), this.positions.push(r, c, f);
          }
          getPositions(e) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = ho(e);
            let c = 0, f = this.ids.length - 1;
            for (; c < f; ) {
              const v = c + f >> 1;
              this.ids[v] >= r ? f = v : c = v + 1;
            }
            const m = [];
            for (; this.ids[c] === r; ) m.push({ index: this.positions[3 * c], start: this.positions[3 * c + 1], end: this.positions[3 * c + 2] }), c++;
            return m;
          }
          static serialize(e, r) {
            const c = new Float64Array(e.ids), f = new Uint32Array(e.positions);
            return Da(c, f, 0, c.length - 1), r && r.push(c.buffer, f.buffer), { ids: c, positions: f };
          }
          static deserialize(e) {
            const r = new Ei();
            return r.ids = e.ids, r.positions = e.positions, r.indexed = !0, r;
          }
        }
        function ho(i) {
          const e = +i;
          return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : An(String(i));
        }
        function Da(i, e, r, c) {
          for (; r < c; ) {
            const f = i[r + c >> 1];
            let m = r - 1, v = c + 1;
            for (; ; ) {
              do
                m++;
              while (i[m] < f);
              do
                v--;
              while (i[v] > f);
              if (m >= v) break;
              oa(i, m, v), oa(e, 3 * m, 3 * v), oa(e, 3 * m + 1, 3 * v + 1), oa(e, 3 * m + 2, 3 * v + 2);
            }
            v - r < c - v ? (Da(i, e, r, v), r = v + 1) : (Da(i, e, v + 1, c), c = v);
          }
        }
        function oa(i, e, r) {
          const c = i[e];
          i[e] = i[r], i[r] = c;
        }
        Vt("FeaturePositionMap", Ei);
        class Ki {
          constructor(e, r) {
            this.gl = e.gl, this.location = r;
          }
        }
        class Wo extends Ki {
          constructor(e, r) {
            super(e, r), this.current = 0;
          }
          set(e) {
            this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
          }
        }
        class Yu extends Ki {
          constructor(e, r) {
            super(e, r), this.current = [0, 0, 0, 0];
          }
          set(e) {
            e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
          }
        }
        class Xo extends Ki {
          constructor(e, r) {
            super(e, r), this.current = cr.transparent;
          }
          set(e) {
            e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
          }
        }
        const ks = new Float32Array(16);
        function la(i) {
          return [or(255 * i.r, 255 * i.g), or(255 * i.b, 255 * i.a)];
        }
        class Us {
          constructor(e, r, c) {
            this.value = e, this.uniformNames = r.map(((f) => `u_${f}`)), this.type = c;
          }
          setUniform(e, r, c) {
            e.set(c.constantOr(this.value));
          }
          getBinding(e, r, c) {
            return this.type === "color" ? new Xo(e, r) : new Wo(e, r);
          }
        }
        class qs {
          constructor(e, r) {
            this.uniformNames = r.map(((c) => `u_${c}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(e, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = e.tlbr;
          }
          setConstantDashPositions(e, r) {
            this.dashTo = [0, e.y, e.height, e.width], this.dashFrom = [0, r.y, r.height, r.width];
          }
          setUniform(e, r, c, f) {
            let m = null;
            f === "u_pattern_to" ? m = this.patternTo : f === "u_pattern_from" ? m = this.patternFrom : f === "u_dasharray_to" ? m = this.dashTo : f === "u_dasharray_from" ? m = this.dashFrom : f === "u_pixel_ratio_to" ? m = this.pixelRatioTo : f === "u_pixel_ratio_from" && (m = this.pixelRatioFrom), m !== null && e.set(m);
          }
          getBinding(e, r, c) {
            return c.substr(0, 9) === "u_pattern" || c.substr(0, 12) === "u_dasharray_" ? new Yu(e, r) : new Wo(e, r);
          }
        }
        class Jr {
          constructor(e, r, c, f) {
            this.expression = e, this.type = c, this.maxValue = 0, this.paintVertexAttributes = r.map(((m) => ({ name: `a_${m}`, type: "Float32", components: c === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new f();
          }
          populatePaintArray(e, r, c) {
            const f = this.paintVertexArray.length, m = this.expression.evaluate(new Vr(0, c), r, {}, c.canonical, [], c.formattedSection);
            this.paintVertexArray.resize(e), this._setPaintValue(f, e, m);
          }
          updatePaintArray(e, r, c, f, m) {
            const v = this.expression.evaluate(new Vr(0, m), c, f);
            this._setPaintValue(e, r, v);
          }
          _setPaintValue(e, r, c) {
            if (this.type === "color") {
              const f = la(c);
              for (let m = e; m < r; m++) this.paintVertexArray.emplace(m, f[0], f[1]);
            } else {
              for (let f = e; f < r; f++) this.paintVertexArray.emplace(f, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(c));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Hr {
          constructor(e, r, c, f, m, v) {
            this.expression = e, this.uniformNames = r.map(((E) => `u_${E}_t`)), this.type = c, this.useIntegerZoom = f, this.zoom = m, this.maxValue = 0, this.paintVertexAttributes = r.map(((E) => ({ name: `a_${E}`, type: "Float32", components: c === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new v();
          }
          populatePaintArray(e, r, c) {
            const f = this.expression.evaluate(new Vr(this.zoom, c), r, {}, c.canonical, [], c.formattedSection), m = this.expression.evaluate(new Vr(this.zoom + 1, c), r, {}, c.canonical, [], c.formattedSection), v = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValue(v, e, f, m);
          }
          updatePaintArray(e, r, c, f, m) {
            const v = this.expression.evaluate(new Vr(this.zoom, m), c, f), E = this.expression.evaluate(new Vr(this.zoom + 1, m), c, f);
            this._setPaintValue(e, r, v, E);
          }
          _setPaintValue(e, r, c, f) {
            if (this.type === "color") {
              const m = la(c), v = la(f);
              for (let E = e; E < r; E++) this.paintVertexArray.emplace(E, m[0], m[1], v[0], v[1]);
            } else {
              for (let m = e; m < r; m++) this.paintVertexArray.emplace(m, c, f);
              this.maxValue = Math.max(this.maxValue, Math.abs(c), Math.abs(f));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(e, r) {
            const c = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, f = Yt(this.expression.interpolationFactor(c, this.zoom, this.zoom + 1), 0, 1);
            e.set(f);
          }
          getBinding(e, r, c) {
            return new Wo(e, r);
          }
        }
        class Qn {
          constructor(e, r, c, f, m, v) {
            this.expression = e, this.type = r, this.useIntegerZoom = c, this.zoom = f, this.layerId = v, this.zoomInPaintVertexArray = new m(), this.zoomOutPaintVertexArray = new m();
          }
          populatePaintArray(e, r, c) {
            const f = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(f, e, this.getPositionIds(r), c);
          }
          updatePaintArray(e, r, c, f, m) {
            this._setPaintValues(e, r, this.getPositionIds(c), m);
          }
          _setPaintValues(e, r, c, f) {
            const m = this.getPositions(f);
            if (!m || !c) return;
            const v = m[c.min], E = m[c.mid], k = m[c.max];
            if (v && E && k) for (let P = e; P < r; P++) this.emplace(this.zoomInPaintVertexArray, P, E, v), this.emplace(this.zoomOutPaintVertexArray, P, E, k);
          }
          upload(e) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const r = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class ei extends Qn {
          getPositions(e) {
            return e.imagePositions;
          }
          getPositionIds(e) {
            return e.patterns && e.patterns[this.layerId];
          }
          getVertexAttributes() {
            return Or.members;
          }
          emplace(e, r, c, f) {
            e.emplace(r, c.tlbr[0], c.tlbr[1], c.tlbr[2], c.tlbr[3], f.tlbr[0], f.tlbr[1], f.tlbr[2], f.tlbr[3], c.pixelRatio, f.pixelRatio);
          }
        }
        class _p extends Qn {
          getPositions(e) {
            return e.dashPositions;
          }
          getPositionIds(e) {
            return e.dashes && e.dashes[this.layerId];
          }
          getVertexAttributes() {
            return an.members;
          }
          emplace(e, r, c, f) {
            e.emplace(r, 0, c.y, c.height, c.width, 0, f.y, f.height, f.width);
          }
        }
        class yp {
          constructor(e, r, c) {
            this.binders = {}, this._buffers = [];
            const f = [];
            for (const m in e.paint._values) {
              if (!c(m)) continue;
              const v = e.paint.get(m);
              if (!(v instanceof Vs && Aa(v.property.specification))) continue;
              const E = mm(m, e.type), k = v.value, P = v.property.specification.type, L = v.property.useIntegerZoom, N = v.property.specification["property-type"], G = N === "cross-faded" || N === "cross-faded-data-driven";
              if (k.kind === "constant") this.binders[m] = G ? new qs(k.value, E) : new Us(k.value, E, P), f.push(`/u_${m}`);
              else if (k.kind === "source" || G) {
                const j = vp(m, P, "source");
                this.binders[m] = G ? m === "line-dasharray" ? new _p(k, P, L, r, j, e.id) : new ei(k, P, L, r, j, e.id) : new Jr(k, E, P, j), f.push(`/a_${m}`);
              } else {
                const j = vp(m, P, "composite");
                this.binders[m] = new Hr(k, E, P, L, r, j), f.push(`/z_${m}`);
              }
            }
            this.cacheKey = f.sort().join("");
          }
          getMaxValue(e) {
            const r = this.binders[e];
            return r instanceof Jr || r instanceof Hr ? r.maxValue : 0;
          }
          populatePaintArrays(e, r, c) {
            for (const f in this.binders) {
              const m = this.binders[f];
              (m instanceof Jr || m instanceof Hr || m instanceof Qn) && m.populatePaintArray(e, r, c);
            }
          }
          setConstantPatternPositions(e, r) {
            for (const c in this.binders) {
              const f = this.binders[c];
              f instanceof qs && f.setConstantPatternPositions(e, r);
            }
          }
          setConstantDashPositions(e, r) {
            for (const c in this.binders) {
              const f = this.binders[c];
              f instanceof qs && f.setConstantDashPositions(e, r);
            }
          }
          updatePaintArrays(e, r, c, f, m) {
            let v = !1;
            for (const E in e) {
              const k = r.getPositions(E);
              for (const P of k) {
                const L = c.feature(P.index);
                for (const N in this.binders) {
                  const G = this.binders[N];
                  if ((G instanceof Jr || G instanceof Hr || G instanceof Qn) && G.expression.isStateDependent === !0) {
                    const j = f.paint.get(N);
                    G.expression = j.value, G.updatePaintArray(P.start, P.end, L, e[E], m), v = !0;
                  }
                }
              }
            }
            return v;
          }
          defines() {
            const e = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              (c instanceof Us || c instanceof qs) && e.push(...c.uniformNames.map(((f) => `#define HAS_UNIFORM_${f}`)));
            }
            return e;
          }
          getBinderAttributes() {
            const e = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (c instanceof Jr || c instanceof Hr) for (let f = 0; f < c.paintVertexAttributes.length; f++) e.push(c.paintVertexAttributes[f].name);
              else if (c instanceof Qn) {
                const f = c.getVertexAttributes();
                for (const m of f) e.push(m.name);
              }
            }
            return e;
          }
          getBinderUniforms() {
            const e = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (c instanceof Us || c instanceof qs || c instanceof Hr) for (const f of c.uniformNames) e.push(f);
            }
            return e;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(e, r) {
            const c = [];
            for (const f in this.binders) {
              const m = this.binders[f];
              if (m instanceof Us || m instanceof qs || m instanceof Hr) {
                for (const v of m.uniformNames) if (r[v]) {
                  const E = m.getBinding(e, r[v], v);
                  c.push({ name: v, property: f, binding: E });
                }
              }
            }
            return c;
          }
          setUniforms(e, r, c, f) {
            for (const { name: m, property: v, binding: E } of r) this.binders[v].setUniform(E, f, c.get(v), m);
          }
          updatePaintBuffers(e) {
            this._buffers = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (e && c instanceof Qn) {
                const f = e.fromScale === 2 ? c.zoomInPaintVertexBuffer : c.zoomOutPaintVertexBuffer;
                f && this._buffers.push(f);
              } else (c instanceof Jr || c instanceof Hr) && c.paintVertexBuffer && this._buffers.push(c.paintVertexBuffer);
            }
          }
          upload(e) {
            for (const r in this.binders) {
              const c = this.binders[r];
              (c instanceof Jr || c instanceof Hr || c instanceof Qn) && c.upload(e);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const e in this.binders) {
              const r = this.binders[e];
              (r instanceof Jr || r instanceof Hr || r instanceof Qn) && r.destroy();
            }
          }
        }
        class Jo {
          constructor(e, r, c = () => !0) {
            this.programConfigurations = {};
            for (const f of e) this.programConfigurations[f.id] = new yp(f, r, c);
            this.needsUpload = !1, this._featureMap = new Ei(), this._bufferOffset = 0;
          }
          populatePaintArrays(e, r, c, f) {
            for (const m in this.programConfigurations) this.programConfigurations[m].populatePaintArrays(e, r, f);
            r.id !== void 0 && this._featureMap.add(r.id, c, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
          }
          updatePaintArrays(e, r, c, f) {
            for (const m of c) this.needsUpload = this.programConfigurations[m.id].updatePaintArrays(e, this._featureMap, r, m, f) || this.needsUpload;
          }
          get(e) {
            return this.programConfigurations[e];
          }
          upload(e) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(e);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
          }
        }
        function mm(i, e) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${e}-`, "").replace(/-/g, "_")];
        }
        function vp(i, e, r) {
          const c = { color: { source: qu, composite: s }, number: { source: Qc, composite: qu } }, f = (function(m) {
            return { "line-pattern": { source: Ce, composite: Ce }, "fill-pattern": { source: Ce, composite: Ce }, "fill-extrusion-pattern": { source: Ce, composite: Ce }, "line-dasharray": { source: Oe, composite: Oe } }[m];
          })(i);
          return f && f[r] || c[e][r];
        }
        Vt("ConstantBinder", Us), Vt("CrossFadedConstantBinder", qs), Vt("SourceExpressionBinder", Jr), Vt("CrossFadedPatternBinder", ei), Vt("CrossFadedDasharrayBinder", _p), Vt("CompositeExpressionBinder", Hr), Vt("ProgramConfiguration", yp, { omit: ["_buffers"] }), Vt("ProgramConfigurationSet", Jo);
        const kd = Math.pow(2, 14) - 1, fo = -kd - 1;
        function po(i) {
          const e = Je / i.extent, r = i.loadGeometry();
          for (let c = 0; c < r.length; c++) {
            const f = r[c];
            for (let m = 0; m < f.length; m++) {
              const v = f[m], E = Math.round(v.x * e), k = Math.round(v.y * e);
              v.x = Yt(E, fo, kd), v.y = Yt(k, fo, kd), (E < v.x || E > v.x + 1 || k < v.y || k > v.y + 1) && ur("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r;
        }
        function go(i, e) {
          return { type: i.type, id: i.id, properties: i.properties, geometry: e ? po(i) : [] };
        }
        const Id = -32768;
        function Md(i, e, r, c, f) {
          i.emplaceBack(Id + 8 * e + c, Id + 8 * r + f);
        }
        class th {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new pe(), this.indexArray = new it(), this.segments = new Lt(), this.programConfigurations = new Jo(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            const f = this.layers[0], m = [];
            let v = null, E = !1, k = f.type === "heatmap";
            if (f.type === "circle") {
              const L = f;
              v = L.layout.get("circle-sort-key"), E = !v.isConstant(), k = k || L.paint.get("circle-pitch-alignment") === "map";
            }
            const P = k ? r.subdivisionGranularity.circle : 1;
            for (const { feature: L, id: N, index: G, sourceLayerIndex: j } of e) {
              const Z = this.layers[0]._featureFilter.needGeometry, Y = go(L, Z);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), Y, c)) continue;
              const J = E ? v.evaluate(Y, {}, c) : void 0, ie = { id: N, properties: L.properties, type: L.type, sourceLayerIndex: j, index: G, geometry: Z ? Y.geometry : po(L), patterns: {}, sortKey: J };
              m.push(ie);
            }
            E && m.sort(((L, N) => L.sortKey - N.sortKey));
            for (const L of m) {
              const { geometry: N, index: G, sourceLayerIndex: j } = L, Z = e[G].feature;
              this.addFeature(L, N, G, c, P), r.featureIndex.insert(Z, N, G, j, this.index);
            }
          }
          update(e, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, _t), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(e, r, c, f, m = 1) {
            let v;
            switch (m) {
              case 1:
                v = [0, 7];
                break;
              case 3:
                v = [0, 2, 5, 7];
                break;
              case 5:
                v = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                v = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${m}; valid values are 1, 3, 5, 7.`);
            }
            const E = v.length;
            for (const k of r) for (const P of k) {
              const L = P.x, N = P.y;
              if (L < 0 || L >= Je || N < 0 || N >= Je) continue;
              const G = this.segments.prepareSegment(E * E, this.layoutVertexArray, this.indexArray, e.sortKey), j = G.vertexLength;
              for (let Z = 0; Z < E; Z++) for (let Y = 0; Y < E; Y++) Md(this.layoutVertexArray, L, N, v[Y], v[Z]);
              for (let Z = 0; Z < E - 1; Z++) for (let Y = 0; Y < E - 1; Y++) {
                const J = j + Z * E + Y, ie = j + (Z + 1) * E + Y;
                this.indexArray.emplaceBack(J, ie + 1, J + 1), this.indexArray.emplaceBack(J, ie, ie + 1);
              }
              G.vertexLength += E * E, G.primitiveLength += (E - 1) * (E - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: {}, canonical: f });
          }
        }
        function rh(i, e) {
          for (let r = 0; r < i.length; r++) if (nh(e, i[r])) return !0;
          for (let r = 0; r < e.length; r++) if (nh(i, e[r])) return !0;
          return !!_m(i, e);
        }
        function xp(i, e, r) {
          return !!nh(i, e) || !!ym(e, i, r);
        }
        function Sv(i, e) {
          if (i.length === 1) return kv(e, i[0]);
          for (let r = 0; r < e.length; r++) {
            const c = e[r];
            for (let f = 0; f < c.length; f++) if (nh(i, c[f])) return !0;
          }
          for (let r = 0; r < i.length; r++) if (kv(e, i[r])) return !0;
          for (let r = 0; r < e.length; r++) if (_m(i, e[r])) return !0;
          return !1;
        }
        function bE(i, e, r) {
          if (i.length > 1) {
            if (_m(i, e)) return !0;
            for (let c = 0; c < e.length; c++) if (ym(e[c], i, r)) return !0;
          }
          for (let c = 0; c < i.length; c++) if (ym(i[c], e, r)) return !0;
          return !1;
        }
        function _m(i, e) {
          if (i.length === 0 || e.length === 0) return !1;
          for (let r = 0; r < i.length - 1; r++) {
            const c = i[r], f = i[r + 1];
            for (let m = 0; m < e.length - 1; m++) if (wE(c, f, e[m], e[m + 1])) return !0;
          }
          return !1;
        }
        function wE(i, e, r, c) {
          return rr(i, r, c) !== rr(e, r, c) && rr(i, e, r) !== rr(i, e, c);
        }
        function ym(i, e, r) {
          const c = r * r;
          if (e.length === 1) return i.distSqr(e[0]) < c;
          for (let f = 1; f < e.length; f++) if (Tv(i, e[f - 1], e[f]) < c) return !0;
          return !1;
        }
        function Tv(i, e, r) {
          const c = e.distSqr(r);
          if (c === 0) return i.distSqr(e);
          const f = ((i.x - e.x) * (r.x - e.x) + (i.y - e.y) * (r.y - e.y)) / c;
          return i.distSqr(f < 0 ? e : f > 1 ? r : r.sub(e)._mult(f)._add(e));
        }
        function kv(i, e) {
          let r, c, f, m = !1;
          for (let v = 0; v < i.length; v++) {
            r = i[v];
            for (let E = 0, k = r.length - 1; E < r.length; k = E++) c = r[E], f = r[k], c.y > e.y != f.y > e.y && e.x < (f.x - c.x) * (e.y - c.y) / (f.y - c.y) + c.x && (m = !m);
          }
          return m;
        }
        function nh(i, e) {
          let r = !1;
          for (let c = 0, f = i.length - 1; c < i.length; f = c++) {
            const m = i[c], v = i[f];
            m.y > e.y != v.y > e.y && e.x < (v.x - m.x) * (e.y - m.y) / (v.y - m.y) + m.x && (r = !r);
          }
          return r;
        }
        function EE(i, e, r) {
          const c = r[0], f = r[2];
          if (i.x < c.x && e.x < c.x || i.x > f.x && e.x > f.x || i.y < c.y && e.y < c.y || i.y > f.y && e.y > f.y) return !1;
          const m = rr(i, e, r[0]);
          return m !== rr(i, e, r[1]) || m !== rr(i, e, r[2]) || m !== rr(i, e, r[3]);
        }
        function ih(i, e, r) {
          const c = e.paint.get(i).value;
          return c.kind === "constant" ? c.value : r.programConfigurations.get(e.id).getMaxValue(i);
        }
        function bp(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
        }
        function wp(i, e, r, c, f) {
          if (!e[0] && !e[1]) return i;
          const m = R.convert(e)._mult(f);
          r === "viewport" && m._rotate(-c);
          const v = [];
          for (let E = 0; E < i.length; E++) v.push(i[E].sub(m));
          return v;
        }
        function SE(i) {
          const e = [];
          for (let r = 0; r < i.length; r++) {
            const c = i[r], f = e.at(-1);
            (r === 0 || f && !c.equals(f)) && e.push(c);
          }
          return e;
        }
        function TE({ queryGeometry: i, size: e }, r) {
          return xp(i, r, e);
        }
        function kE({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f }, m) {
          return xp(i, m, e * (r.projectTileCoordinates(m.x, m.y, c, f).signedDistanceFromCamera / r.cameraToCenterDistance));
        }
        function IE({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f }, m) {
          const v = r.projectTileCoordinates(m.x, m.y, c, f).signedDistanceFromCamera, E = e * (r.cameraToCenterDistance / v);
          return xp(i, vm(m, r, c, f), E);
        }
        function ME({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f }, m) {
          return xp(i, vm(m, r, c, f), e);
        }
        function Iv({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f, pitchAlignment: m = "map", pitchScale: v = "map" }, E) {
          const k = m === "map" ? v === "map" ? TE : kE : v === "map" ? IE : ME, P = { queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f };
          for (const L of E) for (const N of L) if (k(P, N)) return !0;
          return !1;
        }
        function vm(i, e, r, c) {
          const f = e.projectTileCoordinates(i.x, i.y, r, c).point;
          return new R((0.5 * f.x + 0.5) * e.width, (0.5 * -f.y + 0.5) * e.height);
        }
        let Mv, Cv;
        Vt("CircleBucket", th, { omit: ["layers"] });
        var CE = { get paint() {
          return Cv = Cv || new Ui({ "circle-radius": new Xt(Be.paint_circle["circle-radius"]), "circle-color": new Xt(Be.paint_circle["circle-color"]), "circle-blur": new Xt(Be.paint_circle["circle-blur"]), "circle-opacity": new Xt(Be.paint_circle["circle-opacity"]), "circle-translate": new $t(Be.paint_circle["circle-translate"]), "circle-translate-anchor": new $t(Be.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new $t(Be.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new $t(Be.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Xt(Be.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Xt(Be.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Xt(Be.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Mv = Mv || new Ui({ "circle-sort-key": new Xt(Be.layout_circle["circle-sort-key"]) });
        } };
        class PE extends Ts {
          constructor(e, r) {
            super(e, CE, r);
          }
          createBucket(e) {
            return new th(e);
          }
          queryRadius(e) {
            const r = e;
            return ih("circle-radius", this, r) + ih("circle-stroke-width", this, r) + bp(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v, unwrappedTileID: E, getElevation: k }) {
            const P = wp(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -m.bearingInRadians, v), L = this.paint.get("circle-radius").evaluate(r, c) + this.paint.get("circle-stroke-width").evaluate(r, c), N = this.paint.get("circle-pitch-scale"), G = this.paint.get("circle-pitch-alignment");
            let j, Z;
            return G === "map" ? (j = P, Z = L * v) : (j = (function(Y, J, ie, ye) {
              return Y.map(((ae) => vm(ae, J, ie, ye)));
            })(P, m, E, k), Z = L), Iv({ queryGeometry: j, size: Z, transform: m, unwrappedTileID: E, getElevation: k, pitchAlignment: G, pitchScale: N }, f);
          }
        }
        class Pv extends th {
        }
        let Av;
        Vt("HeatmapBucket", Pv, { omit: ["layers"] });
        var AE = { get paint() {
          return Av = Av || new Ui({ "heatmap-radius": new Xt(Be.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Xt(Be.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new $t(Be.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Yc(Be.paint_heatmap["heatmap-color"]), "heatmap-opacity": new $t(Be.paint_heatmap["heatmap-opacity"]) });
        } };
        function xm(i, { width: e, height: r }, c, f) {
          if (f) {
            if (f instanceof Uint8ClampedArray) f = new Uint8Array(f.buffer);
            else if (f.length !== e * r * c) throw new RangeError(`mismatched image size. expected: ${f.length} but got: ${e * r * c}`);
          } else f = new Uint8Array(e * r * c);
          return i.width = e, i.height = r, i.data = f, i;
        }
        function Lv(i, { width: e, height: r }, c) {
          if (e === i.width && r === i.height) return;
          const f = xm({}, { width: e, height: r }, c);
          bm(i, f, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, e), height: Math.min(i.height, r) }, c), i.width = e, i.height = r, i.data = f.data;
        }
        function bm(i, e, r, c, f, m) {
          if (f.width === 0 || f.height === 0) return e;
          if (f.width > i.width || f.height > i.height || r.x > i.width - f.width || r.y > i.height - f.height) throw new RangeError("out of range source coordinates for image copy");
          if (f.width > e.width || f.height > e.height || c.x > e.width - f.width || c.y > e.height - f.height) throw new RangeError("out of range destination coordinates for image copy");
          const v = i.data, E = e.data;
          if (v === E) throw new Error("srcData equals dstData, so image is already copied");
          for (let k = 0; k < f.height; k++) {
            const P = ((r.y + k) * i.width + r.x) * m, L = ((c.y + k) * e.width + c.x) * m;
            for (let N = 0; N < f.width * m; N++) E[L + N] = v[P + N];
          }
          return e;
        }
        class Cd {
          constructor(e, r) {
            xm(this, e, 1, r);
          }
          resize(e) {
            Lv(this, e, 1);
          }
          clone() {
            return new Cd({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, r, c, f, m) {
            bm(e, r, c, f, m, 1);
          }
        }
        class us {
          constructor(e, r) {
            xm(this, e, 4, r);
          }
          resize(e) {
            Lv(this, e, 4);
          }
          replace(e, r) {
            r ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
          }
          clone() {
            return new us({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, r, c, f, m) {
            bm(e, r, c, f, m, 4);
          }
          setPixel(e, r, c) {
            const f = 4 * (e * this.width + r);
            this.data[f + 0] = Math.round(255 * c.r / c.a), this.data[f + 1] = Math.round(255 * c.g / c.a), this.data[f + 2] = Math.round(255 * c.b / c.a), this.data[f + 3] = Math.round(255 * c.a);
          }
        }
        function Dv(i) {
          const e = {}, r = i.resolution || 256, c = i.clips ? i.clips.length : 1, f = i.image || new us({ width: r, height: c });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const m = (v, E, k) => {
            e[i.evaluationKey] = k;
            const P = i.expression.evaluate(e);
            f.setPixel(v / 4 / r, E / 4, P);
          };
          if (i.clips) for (let v = 0, E = 0; v < c; ++v, E += 4 * r) for (let k = 0, P = 0; k < r; k++, P += 4) {
            const L = k / (r - 1), { start: N, end: G } = i.clips[v];
            m(E, P, N * (1 - L) + G * L);
          }
          else for (let v = 0, E = 0; v < r; v++, E += 4) m(0, E, v / (r - 1));
          return f;
        }
        Vt("AlphaImage", Cd), Vt("RGBAImage", us);
        const wm = "big-fb";
        class LE extends Ts {
          createBucket(e) {
            return new Pv(e);
          }
          constructor(e, r) {
            super(e, AE, r), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Dv({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(wm) && this.heatmapFbos.delete(wm);
          }
          queryRadius(e) {
            return ih("heatmap-radius", this, e);
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v, unwrappedTileID: E, getElevation: k }) {
            return Iv({ queryGeometry: e, size: this.paint.get("heatmap-radius").evaluate(r, c) * v, transform: m, unwrappedTileID: E, getElevation: k }, f);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && !this.isHidden();
          }
        }
        let Rv;
        var DE = { get paint() {
          return Rv = Rv || new Ui({ "hillshade-illumination-direction": new $t(Be.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new $t(Be.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new $t(Be.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new $t(Be.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new $t(Be.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new $t(Be.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new $t(Be.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new $t(Be.paint_hillshade["hillshade-method"]) });
        } };
        class RE extends Ts {
          constructor(e, r) {
            super(e, DE, r), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let e = this.paint.get("hillshade-illumination-direction").values, r = this.paint.get("hillshade-illumination-altitude").values, c = this.paint.get("hillshade-highlight-color").values, f = this.paint.get("hillshade-shadow-color").values;
            const m = Math.max(e.length, r.length, c.length, f.length);
            e = e.concat(Array(m - e.length).fill(e.at(-1))), r = r.concat(Array(m - r.length).fill(r.at(-1))), c = c.concat(Array(m - c.length).fill(c.at(-1))), f = f.concat(Array(m - f.length).fill(f.at(-1)));
            const v = r.map(tr);
            return { directionRadians: e.map(tr), altitudeRadians: v, shadowColor: f, highlightColor: c };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && !this.isHidden();
          }
        }
        let Fv;
        var FE = { get paint() {
          return Fv = Fv || new Ui({ "color-relief-opacity": new $t(Be["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Yc(Be["paint_color-relief"]["color-relief-color"]) });
        } };
        class Em {
          constructor(e, r, c, f) {
            this.context = e, this.format = c, this.texture = e.gl.createTexture(), this.update(r, f);
          }
          update(e, r, c) {
            const { width: f, height: m } = e, v = !(this.size && this.size[0] === f && this.size[1] === m || c), { context: E } = this, { gl: k } = E;
            if (this.useMipmap = !!(r && r.useMipmap), k.bindTexture(k.TEXTURE_2D, this.texture), E.pixelStoreUnpackFlipY.set(!1), E.pixelStoreUnpack.set(1), E.pixelStoreUnpackPremultiplyAlpha.set(this.format === k.RGBA && (!r || r.premultiply !== !1)), v) this.size = [f, m], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ii(e) ? k.texImage2D(k.TEXTURE_2D, 0, this.format, this.format, k.UNSIGNED_BYTE, e) : k.texImage2D(k.TEXTURE_2D, 0, this.format, f, m, 0, this.format, k.UNSIGNED_BYTE, e.data);
            else {
              const { x: P, y: L } = c || { x: 0, y: 0 };
              e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ii(e) ? k.texSubImage2D(k.TEXTURE_2D, 0, P, L, k.RGBA, k.UNSIGNED_BYTE, e) : k.texSubImage2D(k.TEXTURE_2D, 0, P, L, f, m, k.RGBA, k.UNSIGNED_BYTE, e.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && k.generateMipmap(k.TEXTURE_2D), E.pixelStoreUnpackFlipY.setDefault(), E.pixelStoreUnpack.setDefault(), E.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(e, r, c) {
            const { context: f } = this, { gl: m } = f;
            m.bindTexture(m.TEXTURE_2D, this.texture), c !== m.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (c = m.LINEAR), e !== this.filter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, e), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, c || e), this.filter = e), r !== this.wrap && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, r), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, r), this.wrap = r);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Nv {
          constructor(e, r, c, f = 1, m = 1, v = 1, E = 0) {
            if (this.uid = e, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (c && !["mapbox", "terrarium", "custom"].includes(c)) return void ur(`"${c}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const k = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), c) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = f, this.greenFactor = m, this.blueFactor = v, this.baseShift = E;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let P = 0; P < k; P++) this.data[this._idx(-1, P)] = this.data[this._idx(0, P)], this.data[this._idx(k, P)] = this.data[this._idx(k - 1, P)], this.data[this._idx(P, -1)] = this.data[this._idx(P, 0)], this.data[this._idx(P, k)] = this.data[this._idx(P, k - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(k, -1)] = this.data[this._idx(k - 1, 0)], this.data[this._idx(-1, k)] = this.data[this._idx(0, k - 1)], this.data[this._idx(k, k)] = this.data[this._idx(k - 1, k - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let P = 0; P < k; P++) for (let L = 0; L < k; L++) {
              const N = this.get(P, L);
              N > this.max && (this.max = N), N < this.min && (this.min = N);
            }
          }
          get(e, r) {
            const c = new Uint8Array(this.data.buffer), f = 4 * this._idx(e, r);
            return this.unpack(c[f], c[f + 1], c[f + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(e, r) {
            if (e < -1 || e >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError(`Out of range source coordinates for DEM data. x: ${e}, y: ${r}, dim: ${this.dim}`);
            return (r + 1) * this.stride + (e + 1);
          }
          unpack(e, r, c) {
            return e * this.redFactor + r * this.greenFactor + c * this.blueFactor - this.baseShift;
          }
          pack(e) {
            return Ov(e, this.getUnpackVector());
          }
          getPixels() {
            return new us({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(e, r, c) {
            if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
            let f = r * this.dim, m = r * this.dim + this.dim, v = c * this.dim, E = c * this.dim + this.dim;
            switch (r) {
              case -1:
                f = m - 1;
                break;
              case 1:
                m = f + 1;
            }
            switch (c) {
              case -1:
                v = E - 1;
                break;
              case 1:
                E = v + 1;
            }
            const k = -r * this.dim, P = -c * this.dim;
            for (let L = v; L < E; L++) for (let N = f; N < m; N++) this.data[this._idx(N, L)] = e.data[this._idx(N + k, L + P)];
          }
        }
        function Ov(i, e) {
          const r = e[0], c = e[1], f = e[2], m = e[3], v = Math.min(r, c, f), E = Math.round((i + m) / v);
          return { r: Math.floor(E * v / r) % 256, g: Math.floor(E * v / c) % 256, b: Math.floor(E * v / f) % 256 };
        }
        Vt("DEMData", Nv);
        class NE extends Ts {
          constructor(e, r) {
            super(e, FE, r);
          }
          _createColorRamp(e) {
            const r = { elevationStops: [], colorStops: [] }, c = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (c instanceof Fc && c._styleExpression.expression instanceof xi) {
              this.colorRampExpression = c;
              const v = c._styleExpression.expression;
              r.elevationStops = v.labels, r.colorStops = [];
              for (const E of r.elevationStops) r.colorStops.push(v.evaluate({ globals: { elevation: E } }));
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [cr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= e) return r;
            const f = { elevationStops: [], colorStops: [] }, m = (r.elevationStops.length - 1) / (e - 1);
            for (let v = 0; v < r.elevationStops.length - 0.5; v += m) f.elevationStops.push(r.elevationStops[Math.round(v)]), f.colorStops.push(r.colorStops[Math.round(v)]);
            return ur(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${e}, provided: ${r.elevationStops.length}`), f;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(e, r, c) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const f = this._createColorRamp(r), m = new us({ width: f.colorStops.length, height: 1 }), v = new us({ width: f.colorStops.length, height: 1 });
            for (let E = 0; E < f.elevationStops.length; E++) {
              const k = Ov(f.elevationStops[E], c);
              v.setPixel(0, E, new cr(k.r / 255, k.g / 255, k.b / 255, 1)), m.setPixel(0, E, f.colorStops[E]);
            }
            return this.colorRampTextures = { elevationTexture: new Em(e, v, e.gl.RGBA), colorTexture: new Em(e, m, e.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return !this.isHidden() && !!this.colorRampTextures;
          }
        }
        const OE = Pn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: zE } = OE;
        function Ep(i, e, r) {
          const c = r.patternDependencies;
          let f = !1;
          for (const m of e) {
            const v = m.paint.get(`${i}-pattern`);
            v.isConstant() || (f = !0);
            const E = v.constantOr(null);
            E && (f = !0, c[E.to] = !0, c[E.from] = !0);
          }
          return f;
        }
        function Sm(i, e, r, c, f) {
          const { zoom: m } = c, v = f.patternDependencies;
          for (const E of e) {
            const k = E.paint.get(`${i}-pattern`).value;
            if (k.kind !== "constant") {
              let P = k.evaluate({ zoom: m - 1 }, r, {}, f.availableImages), L = k.evaluate({ zoom: m }, r, {}, f.availableImages), N = k.evaluate({ zoom: m + 1 }, r, {}, f.availableImages);
              P = P && P.name ? P.name : P, L = L && L.name ? L.name : L, N = N && N.name ? N.name : N, v[P] = !0, v[L] = !0, v[N] = !0, r.patterns[E.id] = { min: P, mid: L, max: N };
            }
          }
          return r;
        }
        function zv(i, e, r, c, f) {
          let m;
          if (f === (function(v, E, k, P) {
            let L = 0;
            for (let N = E, G = k - P; N < k; N += P) L += (v[G] - v[N]) * (v[N + 1] + v[G + 1]), G = N;
            return L;
          })(i, e, r, c) > 0) for (let v = e; v < r; v += c) m = Vv(v / c | 0, i[v], i[v + 1], m);
          else for (let v = r - c; v >= e; v -= c) m = Vv(v / c | 0, i[v], i[v + 1], m);
          return m && sh(m, m.next) && (Dd(m), m = m.next), m;
        }
        function Wu(i, e) {
          if (!i) return i;
          e || (e = i);
          let r, c = i;
          do
            if (r = !1, c.steiner || !sh(c, c.next) && Nn(c.prev, c, c.next) !== 0) c = c.next;
            else {
              if (Dd(c), c = e = c.prev, c === c.next) break;
              r = !0;
            }
          while (r || c !== e);
          return e;
        }
        function Pd(i, e, r, c, f, m, v) {
          if (!i) return;
          !v && m && (function(k, P, L, N) {
            let G = k;
            do
              G.z === 0 && (G.z = Tm(G.x, G.y, P, L, N)), G.prevZ = G.prev, G.nextZ = G.next, G = G.next;
            while (G !== k);
            G.prevZ.nextZ = null, G.prevZ = null, (function(j) {
              let Z, Y = 1;
              do {
                let J, ie = j;
                j = null;
                let ye = null;
                for (Z = 0; ie; ) {
                  Z++;
                  let ae = ie, ue = 0;
                  for (let Le = 0; Le < Y && (ue++, ae = ae.nextZ, ae); Le++) ;
                  let Ee = Y;
                  for (; ue > 0 || Ee > 0 && ae; ) ue !== 0 && (Ee === 0 || !ae || ie.z <= ae.z) ? (J = ie, ie = ie.nextZ, ue--) : (J = ae, ae = ae.nextZ, Ee--), ye ? ye.nextZ = J : j = J, J.prevZ = ye, ye = J;
                  ie = ae;
                }
                ye.nextZ = null, Y *= 2;
              } while (Z > 1);
            })(G);
          })(i, c, f, m);
          let E = i;
          for (; i.prev !== i.next; ) {
            const k = i.prev, P = i.next;
            if (m ? GE(i, c, f, m) : BE(i)) e.push(k.i, i.i, P.i), Dd(i), i = P.next, E = P.next;
            else if ((i = P) === E) {
              v ? v === 1 ? Pd(i = jE(Wu(i), e), e, r, c, f, m, 2) : v === 2 && VE(i, e, r, c, f, m) : Pd(Wu(i), e, r, c, f, m, 1);
              break;
            }
          }
        }
        function BE(i) {
          const e = i.prev, r = i, c = i.next;
          if (Nn(e, r, c) >= 0) return !1;
          const f = e.x, m = r.x, v = c.x, E = e.y, k = r.y, P = c.y, L = Math.min(f, m, v), N = Math.min(E, k, P), G = Math.max(f, m, v), j = Math.max(E, k, P);
          let Z = c.next;
          for (; Z !== e; ) {
            if (Z.x >= L && Z.x <= G && Z.y >= N && Z.y <= j && Ad(f, E, m, k, v, P, Z.x, Z.y) && Nn(Z.prev, Z, Z.next) >= 0) return !1;
            Z = Z.next;
          }
          return !0;
        }
        function GE(i, e, r, c) {
          const f = i.prev, m = i, v = i.next;
          if (Nn(f, m, v) >= 0) return !1;
          const E = f.x, k = m.x, P = v.x, L = f.y, N = m.y, G = v.y, j = Math.min(E, k, P), Z = Math.min(L, N, G), Y = Math.max(E, k, P), J = Math.max(L, N, G), ie = Tm(j, Z, e, r, c), ye = Tm(Y, J, e, r, c);
          let ae = i.prevZ, ue = i.nextZ;
          for (; ae && ae.z >= ie && ue && ue.z <= ye; ) {
            if (ae.x >= j && ae.x <= Y && ae.y >= Z && ae.y <= J && ae !== f && ae !== v && Ad(E, L, k, N, P, G, ae.x, ae.y) && Nn(ae.prev, ae, ae.next) >= 0 || (ae = ae.prevZ, ue.x >= j && ue.x <= Y && ue.y >= Z && ue.y <= J && ue !== f && ue !== v && Ad(E, L, k, N, P, G, ue.x, ue.y) && Nn(ue.prev, ue, ue.next) >= 0)) return !1;
            ue = ue.nextZ;
          }
          for (; ae && ae.z >= ie; ) {
            if (ae.x >= j && ae.x <= Y && ae.y >= Z && ae.y <= J && ae !== f && ae !== v && Ad(E, L, k, N, P, G, ae.x, ae.y) && Nn(ae.prev, ae, ae.next) >= 0) return !1;
            ae = ae.prevZ;
          }
          for (; ue && ue.z <= ye; ) {
            if (ue.x >= j && ue.x <= Y && ue.y >= Z && ue.y <= J && ue !== f && ue !== v && Ad(E, L, k, N, P, G, ue.x, ue.y) && Nn(ue.prev, ue, ue.next) >= 0) return !1;
            ue = ue.nextZ;
          }
          return !0;
        }
        function jE(i, e) {
          let r = i;
          do {
            const c = r.prev, f = r.next.next;
            !sh(c, f) && Gv(c, r, r.next, f) && Ld(c, f) && Ld(f, c) && (e.push(c.i, r.i, f.i), Dd(r), Dd(r.next), r = i = f), r = r.next;
          } while (r !== i);
          return Wu(r);
        }
        function VE(i, e, r, c, f, m) {
          let v = i;
          do {
            let E = v.next.next;
            for (; E !== v.prev; ) {
              if (v.i !== E.i && HE(v, E)) {
                let k = jv(v, E);
                return v = Wu(v, v.next), k = Wu(k, k.next), Pd(v, e, r, c, f, m, 0), void Pd(k, e, r, c, f, m, 0);
              }
              E = E.next;
            }
            v = v.next;
          } while (v !== i);
        }
        function UE(i, e) {
          let r = i.x - e.x;
          return r === 0 && (r = i.y - e.y, r === 0) && (r = (i.next.y - i.y) / (i.next.x - i.x) - (e.next.y - e.y) / (e.next.x - e.x)), r;
        }
        function qE(i, e) {
          const r = (function(f, m) {
            let v = m;
            const E = f.x, k = f.y;
            let P, L = -1 / 0;
            if (sh(f, v)) return v;
            do {
              if (sh(f, v.next)) return v.next;
              if (k <= v.y && k >= v.next.y && v.next.y !== v.y) {
                const Y = v.x + (k - v.y) * (v.next.x - v.x) / (v.next.y - v.y);
                if (Y <= E && Y > L && (L = Y, P = v.x < v.next.x ? v : v.next, Y === E)) return P;
              }
              v = v.next;
            } while (v !== m);
            if (!P) return null;
            const N = P, G = P.x, j = P.y;
            let Z = 1 / 0;
            v = P;
            do {
              if (E >= v.x && v.x >= G && E !== v.x && Bv(k < j ? E : L, k, G, j, k < j ? L : E, k, v.x, v.y)) {
                const Y = Math.abs(k - v.y) / (E - v.x);
                Ld(v, f) && (Y < Z || Y === Z && (v.x > P.x || v.x === P.x && $E(P, v))) && (P = v, Z = Y);
              }
              v = v.next;
            } while (v !== N);
            return P;
          })(i, e);
          if (!r) return e;
          const c = jv(r, i);
          return Wu(c, c.next), Wu(r, r.next);
        }
        function $E(i, e) {
          return Nn(i.prev, i, e.prev) < 0 && Nn(e.next, i, i.next) < 0;
        }
        function Tm(i, e, r, c, f) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * f | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - c) * f | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function ZE(i) {
          let e = i, r = i;
          do
            (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
          while (e !== i);
          return r;
        }
        function Bv(i, e, r, c, f, m, v, E) {
          return (f - v) * (e - E) >= (i - v) * (m - E) && (i - v) * (c - E) >= (r - v) * (e - E) && (r - v) * (m - E) >= (f - v) * (c - E);
        }
        function Ad(i, e, r, c, f, m, v, E) {
          return !(i === v && e === E) && Bv(i, e, r, c, f, m, v, E);
        }
        function HE(i, e) {
          return i.next.i !== e.i && i.prev.i !== e.i && !(function(r, c) {
            let f = r;
            do {
              if (f.i !== r.i && f.next.i !== r.i && f.i !== c.i && f.next.i !== c.i && Gv(f, f.next, r, c)) return !0;
              f = f.next;
            } while (f !== r);
            return !1;
          })(i, e) && (Ld(i, e) && Ld(e, i) && (function(r, c) {
            let f = r, m = !1;
            const v = (r.x + c.x) / 2, E = (r.y + c.y) / 2;
            do
              f.y > E != f.next.y > E && f.next.y !== f.y && v < (f.next.x - f.x) * (E - f.y) / (f.next.y - f.y) + f.x && (m = !m), f = f.next;
            while (f !== r);
            return m;
          })(i, e) && (Nn(i.prev, i, e.prev) || Nn(i, e.prev, e)) || sh(i, e) && Nn(i.prev, i, i.next) > 0 && Nn(e.prev, e, e.next) > 0);
        }
        function Nn(i, e, r) {
          return (e.y - i.y) * (r.x - e.x) - (e.x - i.x) * (r.y - e.y);
        }
        function sh(i, e) {
          return i.x === e.x && i.y === e.y;
        }
        function Gv(i, e, r, c) {
          const f = Tp(Nn(i, e, r)), m = Tp(Nn(i, e, c)), v = Tp(Nn(r, c, i)), E = Tp(Nn(r, c, e));
          return f !== m && v !== E || !(f !== 0 || !Sp(i, r, e)) || !(m !== 0 || !Sp(i, c, e)) || !(v !== 0 || !Sp(r, i, c)) || !(E !== 0 || !Sp(r, e, c));
        }
        function Sp(i, e, r) {
          return e.x <= Math.max(i.x, r.x) && e.x >= Math.min(i.x, r.x) && e.y <= Math.max(i.y, r.y) && e.y >= Math.min(i.y, r.y);
        }
        function Tp(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0;
        }
        function Ld(i, e) {
          return Nn(i.prev, i, i.next) < 0 ? Nn(i, e, i.next) >= 0 && Nn(i, i.prev, e) >= 0 : Nn(i, e, i.prev) < 0 || Nn(i, i.next, e) < 0;
        }
        function jv(i, e) {
          const r = km(i.i, i.x, i.y), c = km(e.i, e.x, e.y), f = i.next, m = e.prev;
          return i.next = e, e.prev = i, r.next = f, f.prev = r, c.next = r, r.prev = c, m.next = c, c.prev = m, c;
        }
        function Vv(i, e, r, c) {
          const f = km(i, e, r);
          return c ? (f.next = c.next, f.prev = c, c.next.prev = f, c.next = f) : (f.prev = f, f.next = f), f;
        }
        function Dd(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
        }
        function km(i, e, r) {
          return { i, x: e, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class ah {
          constructor(e, r) {
            if (r > e) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = e, this._minGranularity = r;
          }
          getGranularityForZoomLevel(e) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << e)), this._minGranularity, 1);
          }
        }
        class kp {
          constructor(e) {
            this.fill = e.fill, this.line = e.line, this.tile = e.tile, this.stencil = e.stencil, this.circle = e.circle;
          }
        }
        kp.noSubdivision = new kp({ fill: new ah(0, 0), line: new ah(0, 0), tile: new ah(0, 0), stencil: new ah(0, 0), circle: 1 }), Vt("SubdivisionGranularityExpression", ah), Vt("SubdivisionGranularitySetting", kp);
        const oh = -32768, Rd = 32767;
        class YE {
          constructor(e, r) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = e, this._granularityCellSize = Je / e, this._canonical = r;
          }
          _getKey(e, r) {
            return (e += 32768) << 16 | r + 32768;
          }
          _vertexToIndex(e, r) {
            if (e < -32768 || r < -32768 || e > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const c = 0 | Math.round(e), f = 0 | Math.round(r), m = this._getKey(c, f);
            if (this._vertexDictionary.has(m)) return this._vertexDictionary.get(m);
            const v = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(m, v), this._vertexBuffer.push(c, f), v;
          }
          _subdivideTrianglesScanline(e) {
            if (this._granularity < 2) return (function(f, m) {
              const v = [];
              for (let E = 0; E < m.length; E += 3) {
                const k = m[E], P = m[E + 1], L = m[E + 2], N = f[2 * k], G = f[2 * k + 1];
                (f[2 * P] - N) * (f[2 * L + 1] - G) - (f[2 * P + 1] - G) * (f[2 * L] - N) > 0 ? (v.push(k), v.push(L), v.push(P)) : (v.push(k), v.push(P), v.push(L));
              }
              return v;
            })(this._vertexBuffer, e);
            const r = [], c = e.length;
            for (let f = 0; f < c; f += 3) {
              const m = [e[f + 0], e[f + 1], e[f + 2]], v = [this._vertexBuffer[2 * e[f + 0] + 0], this._vertexBuffer[2 * e[f + 0] + 1], this._vertexBuffer[2 * e[f + 1] + 0], this._vertexBuffer[2 * e[f + 1] + 1], this._vertexBuffer[2 * e[f + 2] + 0], this._vertexBuffer[2 * e[f + 2] + 1]];
              let E = 1 / 0, k = 1 / 0, P = -1 / 0, L = -1 / 0;
              for (let Y = 0; Y < 3; Y++) {
                const J = v[2 * Y], ie = v[2 * Y + 1];
                E = Math.min(E, J), P = Math.max(P, J), k = Math.min(k, ie), L = Math.max(L, ie);
              }
              if (E === P || k === L) continue;
              const N = Math.floor(E / this._granularityCellSize), G = Math.ceil(P / this._granularityCellSize), j = Math.floor(k / this._granularityCellSize), Z = Math.ceil(L / this._granularityCellSize);
              if (N !== G || j !== Z) for (let Y = j; Y < Z; Y++) {
                const J = this._scanlineGenerateVertexRingForCellRow(Y, v, m);
                WE(this._vertexBuffer, J, r);
              }
              else r.push(...m);
            }
            return r;
          }
          _scanlineGenerateVertexRingForCellRow(e, r, c) {
            const f = e * this._granularityCellSize, m = f + this._granularityCellSize, v = [];
            for (let E = 0; E < 3; E++) {
              const k = r[2 * E], P = r[2 * E + 1], L = r[2 * (E + 1) % 6], N = r[(2 * (E + 1) + 1) % 6], G = r[2 * (E + 2) % 6], j = r[(2 * (E + 2) + 1) % 6], Z = L - k, Y = N - P, J = Z === 0, ie = Y === 0, ye = (f - P) / Y, ae = (m - P) / Y, ue = Math.min(ye, ae), Ee = Math.max(ye, ae);
              if (!ie && (ue >= 1 || Ee <= 0) || ie && (P < f || P > m)) {
                N >= f && N <= m && v.push(c[(E + 1) % 3]);
                continue;
              }
              !ie && ue > 0 && v.push(this._vertexToIndex(k + Z * ue, P + Y * ue));
              const Le = k + Z * Math.max(ue, 0), Ke = k + Z * Math.min(Ee, 1);
              J || this._generateIntraEdgeVertices(v, k, P, L, N, Le, Ke), !ie && Ee < 1 && v.push(this._vertexToIndex(k + Z * Ee, P + Y * Ee)), (ie || N >= f && N <= m) && v.push(c[(E + 1) % 3]), !ie && (N <= f || N >= m) && this._generateInterEdgeVertices(v, k, P, L, N, G, j, Ke, f, m);
            }
            return v;
          }
          _generateIntraEdgeVertices(e, r, c, f, m, v, E) {
            const k = f - r, P = m - c, L = P === 0, N = L ? Math.min(r, f) : Math.min(v, E), G = L ? Math.max(r, f) : Math.max(v, E), j = Math.floor(N / this._granularityCellSize) + 1, Z = Math.ceil(G / this._granularityCellSize) - 1;
            if (L ? r < f : v < E) for (let Y = j; Y <= Z; Y++) {
              const J = Y * this._granularityCellSize;
              e.push(this._vertexToIndex(J, c + P * (J - r) / k));
            }
            else for (let Y = Z; Y >= j; Y--) {
              const J = Y * this._granularityCellSize;
              e.push(this._vertexToIndex(J, c + P * (J - r) / k));
            }
          }
          _generateInterEdgeVertices(e, r, c, f, m, v, E, k, P, L) {
            const N = m - c, G = v - f, j = E - m, Z = (P - m) / j, Y = (L - m) / j, J = Math.min(Z, Y), ie = Math.max(Z, Y), ye = f + G * J;
            let ae = Math.floor(Math.min(ye, k) / this._granularityCellSize) + 1, ue = Math.ceil(Math.max(ye, k) / this._granularityCellSize) - 1, Ee = k < ye;
            const Le = j === 0;
            if (Le && (E === P || E === L)) return;
            if (Le || J >= 1 || ie <= 0) {
              const dt = c - E, ht = v + (r - v) * Math.min((P - E) / dt, (L - E) / dt);
              ae = Math.floor(Math.min(ht, k) / this._granularityCellSize) + 1, ue = Math.ceil(Math.max(ht, k) / this._granularityCellSize) - 1, Ee = k < ht;
            }
            const Ke = N > 0 ? L : P;
            if (Ee) for (let dt = ae; dt <= ue; dt++) e.push(this._vertexToIndex(dt * this._granularityCellSize, Ke));
            else for (let dt = ue; dt >= ae; dt--) e.push(this._vertexToIndex(dt * this._granularityCellSize, Ke));
          }
          _generateOutline(e) {
            const r = [];
            for (const c of e) {
              const f = Xu(c, this._granularity, !0), m = this._pointArrayToIndices(f), v = [];
              for (let E = 1; E < m.length; E++) v.push(m[E - 1]), v.push(m[E]);
              r.push(v);
            }
            return r;
          }
          _handlePoles(e) {
            let r = !1, c = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (c = !0)), (r || c) && this._fillPoles(e, r, c);
          }
          _ensureNoPoleVertices() {
            const e = this._vertexBuffer;
            for (let r = 0; r < e.length; r += 2) {
              const c = e[r + 1];
              c === oh && (e[r + 1] = -32767), c === Rd && (e[r + 1] = 32766);
            }
          }
          _generatePoleQuad(e, r, c, f, m, v) {
            f > m != (v === oh) ? (e.push(r), e.push(c), e.push(this._vertexToIndex(f, v)), e.push(c), e.push(this._vertexToIndex(m, v)), e.push(this._vertexToIndex(f, v))) : (e.push(c), e.push(r), e.push(this._vertexToIndex(f, v)), e.push(this._vertexToIndex(m, v)), e.push(c), e.push(this._vertexToIndex(f, v)));
          }
          _fillPoles(e, r, c) {
            const f = this._vertexBuffer, m = Je, v = e.length;
            for (let E = 2; E < v; E += 3) {
              const k = e[E - 2], P = e[E - 1], L = e[E], N = f[2 * k], G = f[2 * k + 1], j = f[2 * P], Z = f[2 * P + 1], Y = f[2 * L], J = f[2 * L + 1];
              r && (G === 0 && Z === 0 && this._generatePoleQuad(e, k, P, N, j, oh), Z === 0 && J === 0 && this._generatePoleQuad(e, P, L, j, Y, oh), J === 0 && G === 0 && this._generatePoleQuad(e, L, k, Y, N, oh)), c && (G === m && Z === m && this._generatePoleQuad(e, k, P, N, j, Rd), Z === m && J === m && this._generatePoleQuad(e, P, L, j, Y, Rd), J === m && G === m && this._generatePoleQuad(e, L, k, Y, N, Rd));
            }
          }
          _initializeVertices(e) {
            for (let r = 0; r < e.length; r += 2) this._vertexToIndex(e[r], e[r + 1]);
          }
          subdividePolygonInternal(e, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: c, holeIndices: f } = (function(E) {
              const k = [], P = [];
              for (const L of E) if (L.length !== 0) {
                L !== E[0] && k.push(P.length / 2);
                for (let N = 0; N < L.length; N++) P.push(L[N].x), P.push(L[N].y);
              }
              return { flattened: P, holeIndices: k };
            })(e);
            let m;
            this._initializeVertices(c);
            try {
              const E = (function(P, L, N = 2) {
                const G = L && L.length, j = G ? L[0] * N : P.length;
                let Z = zv(P, 0, j, N, !0);
                const Y = [];
                if (!Z || Z.next === Z.prev) return Y;
                let J, ie, ye;
                if (G && (Z = (function(ae, ue, Ee, Le) {
                  const Ke = [];
                  for (let dt = 0, ht = ue.length; dt < ht; dt++) {
                    const mt = zv(ae, ue[dt] * Le, dt < ht - 1 ? ue[dt + 1] * Le : ae.length, Le, !1);
                    mt === mt.next && (mt.steiner = !0), Ke.push(ZE(mt));
                  }
                  Ke.sort(UE);
                  for (let dt = 0; dt < Ke.length; dt++) Ee = qE(Ke[dt], Ee);
                  return Ee;
                })(P, L, Z, N)), P.length > 80 * N) {
                  J = P[0], ie = P[1];
                  let ae = J, ue = ie;
                  for (let Ee = N; Ee < j; Ee += N) {
                    const Le = P[Ee], Ke = P[Ee + 1];
                    Le < J && (J = Le), Ke < ie && (ie = Ke), Le > ae && (ae = Le), Ke > ue && (ue = Ke);
                  }
                  ye = Math.max(ae - J, ue - ie), ye = ye !== 0 ? 32767 / ye : 0;
                }
                return Pd(Z, Y, N, J, ie, ye, 0), Y;
              })(c, f), k = this._convertIndices(c, E);
              m = this._subdivideTrianglesScanline(k);
            } catch (E) {
              console.error(E);
            }
            let v = [];
            return r && (v = this._generateOutline(e)), this._ensureNoPoleVertices(), this._handlePoles(m), { verticesFlattened: this._vertexBuffer, indicesTriangles: m, indicesLineList: v };
          }
          _convertIndices(e, r) {
            const c = [];
            for (let f = 0; f < r.length; f++) c.push(this._vertexToIndex(e[2 * r[f]], e[2 * r[f] + 1]));
            return c;
          }
          _pointArrayToIndices(e) {
            const r = [];
            for (let c = 0; c < e.length; c++) {
              const f = e[c];
              r.push(this._vertexToIndex(f.x, f.y));
            }
            return r;
          }
        }
        function Uv(i, e, r, c = !0) {
          return new YE(r, e).subdividePolygonInternal(i, c);
        }
        function Xu(i, e, r = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const c = i[0], f = i[i.length - 1], m = r && (c.x !== f.x || c.y !== f.y);
          if (e < 2) return m ? [...i, i[0]] : [...i];
          const v = Math.floor(Je / e), E = [];
          E.push(new R(i[0].x, i[0].y));
          const k = i.length, P = m ? k : k - 1;
          for (let L = 0; L < P; L++) {
            const N = i[L], G = L < k - 1 ? i[L + 1] : i[0], j = N.x, Z = N.y, Y = G.x, J = G.y, ie = j !== Y, ye = Z !== J;
            if (!ie && !ye) continue;
            const ae = Y - j, ue = J - Z, Ee = Math.abs(ae), Le = Math.abs(ue);
            let Ke = j, dt = Z;
            for (; ; ) {
              const mt = ae > 0 ? (Math.floor(Ke / v) + 1) * v : (Math.ceil(Ke / v) - 1) * v, Pt = ue > 0 ? (Math.floor(dt / v) + 1) * v : (Math.ceil(dt / v) - 1) * v, bt = Math.abs(Ke - mt), ct = Math.abs(dt - Pt), ot = Math.abs(Ke - Y), Nt = Math.abs(dt - J), Rt = ie ? bt / Ee : Number.POSITIVE_INFINITY, Ut = ye ? ct / Le : Number.POSITIVE_INFINITY;
              if ((ot <= bt || !ie) && (Nt <= ct || !ye)) break;
              if (Rt < Ut && ie || !ye) {
                Ke = mt, dt += ue * Rt;
                const Ft = new R(Ke, Math.round(dt));
                E[E.length - 1].x === Ft.x && E[E.length - 1].y === Ft.y || E.push(Ft);
              } else {
                Ke += ae * Ut, dt = Pt;
                const Ft = new R(Math.round(Ke), dt);
                E[E.length - 1].x === Ft.x && E[E.length - 1].y === Ft.y || E.push(Ft);
              }
            }
            const ht = new R(Y, J);
            E[E.length - 1].x === ht.x && E[E.length - 1].y === ht.y || E.push(ht);
          }
          return E;
        }
        function WE(i, e, r) {
          if (e.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let c = 0, f = i[2 * e[0]];
          for (let k = 1; k < e.length; k++) {
            const P = i[2 * e[k]];
            P < f && (f = P, c = k);
          }
          const m = e.length;
          let v = c, E = (v + 1) % m;
          for (; ; ) {
            const k = v - 1 >= 0 ? v - 1 : m - 1, P = (E + 1) % m, L = i[2 * e[k]], N = i[2 * e[P]], G = i[2 * e[v]], j = i[2 * e[v] + 1], Z = i[2 * e[E] + 1];
            let Y = !1;
            if (L < N) Y = !0;
            else if (L > N) Y = !1;
            else {
              const J = Z - j, ie = -(i[2 * e[E]] - G), ye = j < Z ? 1 : -1;
              ((L - G) * J + (i[2 * e[k] + 1] - j) * ie) * ye > ((N - G) * J + (i[2 * e[P] + 1] - j) * ie) * ye && (Y = !0);
            }
            if (Y) {
              const J = e[k], ie = e[v], ye = e[E];
              J !== ie && J !== ye && ie !== ye && r.push(ye, ie, J), v--, v < 0 && (v = m - 1);
            } else {
              const J = e[P], ie = e[v], ye = e[E];
              J !== ie && J !== ye && ie !== ye && r.push(ye, ie, J), E++, E >= m && (E = 0);
            }
            if (k === P) break;
          }
        }
        function qv(i, e, r, c, f, m, v, E, k) {
          const P = f.length / 2, L = v && E && k;
          if (P < Lt.MAX_VERTEX_ARRAY_LENGTH) {
            const N = e.prepareSegment(P, r, c), G = N.vertexLength;
            for (let Y = 0; Y < m.length; Y += 3) c.emplaceBack(G + m[Y], G + m[Y + 1], G + m[Y + 2]);
            let j, Z;
            N.vertexLength += P, N.primitiveLength += m.length / 3, L && (Z = v.prepareSegment(P, r, E), j = Z.vertexLength, Z.vertexLength += P);
            for (let Y = 0; Y < f.length; Y += 2) i(f[Y], f[Y + 1]);
            if (L) for (let Y = 0; Y < k.length; Y++) {
              const J = k[Y];
              for (let ie = 1; ie < J.length; ie += 2) E.emplaceBack(j + J[ie - 1], j + J[ie]);
              Z.primitiveLength += J.length / 2;
            }
          } else (function(N, G, j, Z, Y, J) {
            const ie = [];
            for (let Le = 0; Le < Z.length / 2; Le++) ie.push(-1);
            const ye = { count: 0 };
            let ae = 0, ue = N.getOrCreateLatestSegment(G, j), Ee = ue.vertexLength;
            for (let Le = 2; Le < Y.length; Le += 3) {
              const Ke = Y[Le - 2], dt = Y[Le - 1], ht = Y[Le];
              let mt = ie[Ke] < ae, Pt = ie[dt] < ae, bt = ie[ht] < ae;
              ue.vertexLength + ((mt ? 1 : 0) + (Pt ? 1 : 0) + (bt ? 1 : 0)) > Lt.MAX_VERTEX_ARRAY_LENGTH && (ue = N.createNewSegment(G, j), ae = ye.count, mt = !0, Pt = !0, bt = !0, Ee = 0);
              const ct = Fd(ie, Z, J, ye, Ke, mt, ue), ot = Fd(ie, Z, J, ye, dt, Pt, ue), Nt = Fd(ie, Z, J, ye, ht, bt, ue);
              j.emplaceBack(Ee + ct - ae, Ee + ot - ae, Ee + Nt - ae), ue.primitiveLength++;
            }
          })(e, r, c, f, m, i), L && (function(N, G, j, Z, Y, J) {
            const ie = [];
            for (let Le = 0; Le < Z.length / 2; Le++) ie.push(-1);
            const ye = { count: 0 };
            let ae = 0, ue = N.getOrCreateLatestSegment(G, j), Ee = ue.vertexLength;
            for (let Le = 0; Le < Y.length; Le++) {
              const Ke = Y[Le];
              for (let dt = 1; dt < Y[Le].length; dt += 2) {
                const ht = Ke[dt - 1], mt = Ke[dt];
                let Pt = ie[ht] < ae, bt = ie[mt] < ae;
                ue.vertexLength + ((Pt ? 1 : 0) + (bt ? 1 : 0)) > Lt.MAX_VERTEX_ARRAY_LENGTH && (ue = N.createNewSegment(G, j), ae = ye.count, Pt = !0, bt = !0, Ee = 0);
                const ct = Fd(ie, Z, J, ye, ht, Pt, ue), ot = Fd(ie, Z, J, ye, mt, bt, ue);
                j.emplaceBack(Ee + ct - ae, Ee + ot - ae), ue.primitiveLength++;
              }
            }
          })(v, r, E, f, k, i), e.forceNewSegmentOnNextPrepare(), v?.forceNewSegmentOnNextPrepare();
        }
        function Fd(i, e, r, c, f, m, v) {
          if (m) {
            const E = c.count;
            return r(e[2 * f], e[2 * f + 1]), i[f] = c.count, c.count++, v.vertexLength++, E;
          }
          return i[f];
        }
        class Im {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new fe(), this.indexArray = new it(), this.indexArray2 = new St(), this.programConfigurations = new Jo(e.layers, e.zoom), this.segments = new Lt(), this.segments2 = new Lt(), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            this.hasDependencies = Ep("fill", this.layers, r);
            const f = this.layers[0].layout.get("fill-sort-key"), m = !f.isConstant(), v = [];
            for (const { feature: E, id: k, index: P, sourceLayerIndex: L } of e) {
              const N = this.layers[0]._featureFilter.needGeometry, G = go(E, N);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), G, c)) continue;
              const j = m ? f.evaluate(G, {}, c, r.availableImages) : void 0, Z = { id: k, properties: E.properties, type: E.type, sourceLayerIndex: L, index: P, geometry: N ? G.geometry : po(E), patterns: {}, sortKey: j };
              v.push(Z);
            }
            m && v.sort(((E, k) => E.sortKey - k.sortKey));
            for (const E of v) {
              const { geometry: k, index: P, sourceLayerIndex: L } = E;
              if (this.hasDependencies) {
                const N = Sm("fill", this.layers, E, { zoom: this.zoom }, r);
                this.patternFeatures.push(N);
              } else this.addFeature(E, k, P, c, {}, r.subdivisionGranularity);
              r.featureIndex.insert(e[P].feature, k, P, L, this.index);
            }
          }
          update(e, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c });
          }
          addFeatures(e, r, c) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, r, c, e.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, zE), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(e, r, c, f, m, v) {
            for (const E of zo(r, 500)) {
              const k = Uv(E, f, v.fill.getGranularityForZoomLevel(f.z)), P = this.layoutVertexArray;
              qv(((L, N) => {
                P.emplaceBack(L, N);
              }), this.segments, this.layoutVertexArray, this.indexArray, k.verticesFlattened, k.indicesTriangles, this.segments2, this.indexArray2, k.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: m, canonical: f });
          }
        }
        let $v, Zv;
        Vt("FillBucket", Im, { omit: ["layers", "patternFeatures"] });
        var XE = { get paint() {
          return Zv = Zv || new Ui({ "fill-antialias": new $t(Be.paint_fill["fill-antialias"]), "fill-opacity": new Xt(Be.paint_fill["fill-opacity"]), "fill-color": new Xt(Be.paint_fill["fill-color"]), "fill-outline-color": new Xt(Be.paint_fill["fill-outline-color"]), "fill-translate": new $t(Be.paint_fill["fill-translate"]), "fill-translate-anchor": new $t(Be.paint_fill["fill-translate-anchor"]), "fill-pattern": new ju(Be.paint_fill["fill-pattern"]) });
        }, get layout() {
          return $v = $v || new Ui({ "fill-sort-key": new Xt(Be.layout_fill["fill-sort-key"]) });
        } };
        class JE extends Ts {
          constructor(e, r) {
            super(e, XE, r);
          }
          recalculate(e, r) {
            super.recalculate(e, r);
            const c = this.paint._values["fill-outline-color"];
            c.value.kind === "constant" && c.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(e) {
            return new Im(e);
          }
          queryRadius() {
            return bp(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, geometry: r, transform: c, pixelsToTileUnits: f }) {
            return Sv(wp(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -c.bearingInRadians, f), r);
          }
          isTileClipped() {
            return !0;
          }
        }
        const KE = Pn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), QE = Pn([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: eS } = KE;
        class Nd {
          constructor(e, r, c, f, m) {
            this.properties = {}, this.extent = c, this.type = 0, this.id = void 0, this._pbf = e, this._geometry = -1, this._keys = f, this._values = m, e.readFields(tS, this, r);
          }
          loadGeometry() {
            const e = this._pbf;
            e.pos = this._geometry;
            const r = e.readVarint() + e.pos, c = [];
            let f, m = 1, v = 0, E = 0, k = 0;
            for (; e.pos < r; ) {
              if (v <= 0) {
                const P = e.readVarint();
                m = 7 & P, v = P >> 3;
              }
              if (v--, m === 1 || m === 2) E += e.readSVarint(), k += e.readSVarint(), m === 1 && (f && c.push(f), f = []), f && f.push(new R(E, k));
              else {
                if (m !== 7) throw new Error(`unknown command ${m}`);
                f && f.push(f[0].clone());
              }
            }
            return f && c.push(f), c;
          }
          bbox() {
            const e = this._pbf;
            e.pos = this._geometry;
            const r = e.readVarint() + e.pos;
            let c = 1, f = 0, m = 0, v = 0, E = 1 / 0, k = -1 / 0, P = 1 / 0, L = -1 / 0;
            for (; e.pos < r; ) {
              if (f <= 0) {
                const N = e.readVarint();
                c = 7 & N, f = N >> 3;
              }
              if (f--, c === 1 || c === 2) m += e.readSVarint(), v += e.readSVarint(), m < E && (E = m), m > k && (k = m), v < P && (P = v), v > L && (L = v);
              else if (c !== 7) throw new Error(`unknown command ${c}`);
            }
            return [E, P, k, L];
          }
          toGeoJSON(e, r, c) {
            const f = this.extent * Math.pow(2, c), m = this.extent * e, v = this.extent * r, E = this.loadGeometry();
            function k(G) {
              return [360 * (G.x + m) / f - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (G.y + v) / f) * Math.PI)) - 90];
            }
            function P(G) {
              return G.map(k);
            }
            let L;
            if (this.type === 1) {
              const G = [];
              for (const Z of E) G.push(Z[0]);
              const j = P(G);
              L = G.length === 1 ? { type: "Point", coordinates: j[0] } : { type: "MultiPoint", coordinates: j };
            } else if (this.type === 2) {
              const G = E.map(P);
              L = G.length === 1 ? { type: "LineString", coordinates: G[0] } : { type: "MultiLineString", coordinates: G };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const G = Hv(E), j = [];
                for (const Z of G) j.push(Z.map(P));
                L = j.length === 1 ? { type: "Polygon", coordinates: j[0] } : { type: "MultiPolygon", coordinates: j };
              }
            }
            const N = { type: "Feature", geometry: L, properties: this.properties };
            return this.id != null && (N.id = this.id), N;
          }
        }
        function tS(i, e, r) {
          i === 1 ? e.id = r.readVarint() : i === 2 ? (function(c, f) {
            const m = c.readVarint() + c.pos;
            for (; c.pos < m; ) {
              const v = f._keys[c.readVarint()], E = f._values[c.readVarint()];
              f.properties[v] = E;
            }
          })(r, e) : i === 3 ? e.type = r.readVarint() : i === 4 && (e._geometry = r.pos);
        }
        function Hv(i) {
          const e = i.length;
          if (e <= 1) return [i];
          const r = [];
          let c, f;
          for (let m = 0; m < e; m++) {
            const v = rS(i[m]);
            v !== 0 && (f === void 0 && (f = v < 0), f === v < 0 ? (c && r.push(c), c = [i[m]]) : c && c.push(i[m]));
          }
          return c && r.push(c), r;
        }
        function rS(i) {
          let e = 0;
          for (let r, c, f = 0, m = i.length, v = m - 1; f < m; v = f++) r = i[f], c = i[v], e += (c.x - r.x) * (r.y + c.y);
          return e;
        }
        Nd.types = ["Unknown", "Point", "LineString", "Polygon"];
        class nS {
          constructor(e, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(iS, this, r), this.length = this._features.length;
          }
          feature(e) {
            if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[e];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new Nd(this._pbf, r, this.extent, this._keys, this._values);
          }
        }
        function iS(i, e, r) {
          i === 15 ? e.version = r.readVarint() : i === 1 ? e.name = r.readString() : i === 5 ? e.extent = r.readVarint() : i === 2 ? e._features.push(r.pos) : i === 3 ? e._keys.push(r.readString()) : i === 4 && e._values.push((function(c) {
            let f = null;
            const m = c.readVarint() + c.pos;
            for (; c.pos < m; ) {
              const v = c.readVarint() >> 3;
              f = v === 1 ? c.readString() : v === 2 ? c.readFloat() : v === 3 ? c.readDouble() : v === 4 ? c.readVarint64() : v === 5 ? c.readVarint() : v === 6 ? c.readSVarint() : v === 7 ? c.readBoolean() : null;
            }
            if (f == null) throw new Error("unknown feature value");
            return f;
          })(r));
        }
        class Yv {
          constructor(e, r) {
            this.layers = e.readFields(sS, {}, r);
          }
        }
        function sS(i, e, r) {
          if (i === 3) {
            const c = new nS(r, r.readVarint() + r.pos);
            c.length && (e[c.name] = c);
          }
        }
        const Mm = Math.pow(2, 13);
        function Od(i, e, r, c, f, m, v, E) {
          i.emplaceBack(e, r, 2 * Math.floor(c * Mm) + v, f * Mm * 2, m * Mm * 2, Math.round(E));
        }
        class Cm {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new be(), this.centroidVertexArray = new he(), this.indexArray = new it(), this.programConfigurations = new Jo(e.layers, e.zoom), this.segments = new Lt(), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            this.features = [], this.hasDependencies = Ep("fill-extrusion", this.layers, r);
            for (const { feature: f, id: m, index: v, sourceLayerIndex: E } of e) {
              const k = this.layers[0]._featureFilter.needGeometry, P = go(f, k);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), P, c)) continue;
              const L = { id: m, sourceLayerIndex: E, index: v, geometry: k ? P.geometry : po(f), properties: f.properties, type: f.type, patterns: {} };
              this.hasDependencies ? this.features.push(Sm("fill-extrusion", this.layers, L, { zoom: this.zoom }, r)) : this.addFeature(L, L.geometry, v, c, {}, r.subdivisionGranularity), r.featureIndex.insert(f, L.geometry, v, E, this.index, !0);
            }
          }
          addFeatures(e, r, c) {
            for (const f of this.features) {
              const { geometry: m } = f;
              this.addFeature(f, m, f.index, r, c, e.subdivisionGranularity);
            }
          }
          update(e, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, eS), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, QE.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(e, r, c, f, m, v) {
            for (const E of zo(r, 500)) {
              const k = { x: 0, y: 0, sampleCount: 0 }, P = this.layoutVertexArray.length;
              this.processPolygon(k, f, e, E, v);
              const L = this.layoutVertexArray.length - P, N = Math.floor(k.x / k.sampleCount), G = Math.floor(k.y / k.sampleCount);
              for (let j = 0; j < L; j++) this.centroidVertexArray.emplaceBack(N, G);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: m, canonical: f });
          }
          processPolygon(e, r, c, f, m) {
            if (f.length < 1 || Wv(f[0])) return;
            for (const N of f) N.length !== 0 && aS(e, N);
            const v = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, E = m.fill.getGranularityForZoomLevel(r.z), k = Nd.types[c.type] === "Polygon";
            for (const N of f) {
              if (N.length === 0 || Wv(N)) continue;
              const G = Xu(N, E, k);
              this._generateSideFaces(G, v);
            }
            if (!k) return;
            const P = Uv(f, r, E, !1), L = this.layoutVertexArray;
            qv(((N, G) => {
              Od(L, N, G, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, P.verticesFlattened, P.indicesTriangles);
          }
          _generateSideFaces(e, r) {
            let c = 0;
            for (let f = 1; f < e.length; f++) {
              const m = e[f], v = e[f - 1];
              if (oS(m, v)) continue;
              r.segment.vertexLength + 4 > Lt.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const E = m.sub(v)._perp()._unit(), k = v.dist(m);
              c + k > 32768 && (c = 0), Od(this.layoutVertexArray, m.x, m.y, E.x, E.y, 0, 0, c), Od(this.layoutVertexArray, m.x, m.y, E.x, E.y, 0, 1, c), c += k, Od(this.layoutVertexArray, v.x, v.y, E.x, E.y, 0, 0, c), Od(this.layoutVertexArray, v.x, v.y, E.x, E.y, 0, 1, c);
              const P = r.segment.vertexLength;
              this.indexArray.emplaceBack(P, P + 2, P + 1), this.indexArray.emplaceBack(P + 1, P + 2, P + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2;
            }
          }
        }
        function aS(i, e) {
          for (let r = 0; r < e.length; r++) {
            const c = e[r];
            r === e.length - 1 && e[0].x === c.x && e[0].y === c.y || (i.x += c.x, i.y += c.y, i.sampleCount++);
          }
        }
        function oS(i, e) {
          return i.x === e.x && (i.x < 0 || i.x > Je) || i.y === e.y && (i.y < 0 || i.y > Je);
        }
        function Wv(i) {
          return i.every(((e) => e.x < 0)) || i.every(((e) => e.x > Je)) || i.every(((e) => e.y < 0)) || i.every(((e) => e.y > Je));
        }
        let Xv;
        Vt("FillExtrusionBucket", Cm, { omit: ["layers", "features"] });
        var lS = { get paint() {
          return Xv = Xv || new Ui({ "fill-extrusion-opacity": new $t(Be["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Xt(Be["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new $t(Be["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new $t(Be["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ju(Be["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Xt(Be["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Xt(Be["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new $t(Be["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class uS extends Ts {
          constructor(e, r) {
            super(e, lS, r);
          }
          createBucket(e) {
            return new Cm(e);
          }
          queryRadius() {
            return bp(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v, pixelPosMatrix: E }) {
            const k = wp(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -m.bearingInRadians, v), P = this.paint.get("fill-extrusion-height").evaluate(r, c), L = this.paint.get("fill-extrusion-base").evaluate(r, c), N = (function(j, Z) {
              const Y = [];
              for (const J of j) {
                const ie = [J.x, J.y, 0, 1];
                Re(ie, ie, Z), Y.push(new R(ie[0] / ie[3], ie[1] / ie[3]));
              }
              return Y;
            })(k, E), G = (function(j, Z, Y, J) {
              const ie = [], ye = [], ae = J[8] * Z, ue = J[9] * Z, Ee = J[10] * Z, Le = J[11] * Z, Ke = J[8] * Y, dt = J[9] * Y, ht = J[10] * Y, mt = J[11] * Y;
              for (const Pt of j) {
                const bt = [], ct = [];
                for (const ot of Pt) {
                  const Nt = ot.x, Rt = ot.y, Ut = J[0] * Nt + J[4] * Rt + J[12], Ft = J[1] * Nt + J[5] * Rt + J[13], Ht = J[2] * Nt + J[6] * Rt + J[14], Tr = J[3] * Nt + J[7] * Rt + J[15], yr = Ht + Ee, fn = Tr + Le, Ai = Ut + Ke, Zn = Ft + dt, pn = Ht + ht, on = Tr + mt, Rr = new R((Ut + ae) / fn, (Ft + ue) / fn);
                  Rr.z = yr / fn, bt.push(Rr);
                  const Tn = new R(Ai / on, Zn / on);
                  Tn.z = pn / on, ct.push(Tn);
                }
                ie.push(bt), ye.push(ct);
              }
              return [ie, ye];
            })(f, L, P, E);
            return (function(j, Z, Y) {
              let J = 1 / 0;
              Sv(Y, Z) && (J = Jv(Y, Z[0]));
              for (let ie = 0; ie < Z.length; ie++) {
                const ye = Z[ie], ae = j[ie];
                for (let ue = 0; ue < ye.length - 1; ue++) {
                  const Ee = ye[ue], Le = [Ee, ye[ue + 1], ae[ue + 1], ae[ue], Ee];
                  rh(Y, Le) && (J = Math.min(J, Jv(Y, Le)));
                }
              }
              return J !== 1 / 0 && J;
            })(G[0], G[1], N);
          }
        }
        function zd(i, e) {
          return i.x * e.x + i.y * e.y;
        }
        function Jv(i, e) {
          if (i.length === 1) {
            let r = 0;
            const c = e[r++];
            let f;
            for (; !f || c.equals(f); ) if (f = e[r++], !f) return 1 / 0;
            for (; r < e.length; r++) {
              const m = e[r], v = i[0], E = f.sub(c), k = m.sub(c), P = v.sub(c), L = zd(E, E), N = zd(E, k), G = zd(k, k), j = zd(P, E), Z = zd(P, k), Y = L * G - N * N, J = (G * j - N * Z) / Y, ie = (L * Z - N * j) / Y, ye = c.z * (1 - J - ie) + f.z * J + m.z * ie;
              if (isFinite(ye)) return ye;
            }
            return 1 / 0;
          }
          {
            let r = 1 / 0;
            for (const c of e) r = Math.min(r, c.z);
            return r;
          }
        }
        const cS = Pn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hS } = cS, dS = Pn([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: fS } = dS, pS = Math.cos(Math.PI / 180 * 37.5), Kv = Math.pow(2, 14) / 0.5;
        class Pm {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((r) => {
              this.gradients[r.id] = {};
            })), this.layoutVertexArray = new Ae(), this.layoutVertexArray2 = new xe(), this.indexArray = new it(), this.programConfigurations = new Jo(e.layers, e.zoom), this.segments = new Lt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            this.hasDependencies = Ep("line", this.layers, r) || this.hasLineDasharray(this.layers);
            const f = this.layers[0].layout.get("line-sort-key"), m = !f.isConstant(), v = [];
            for (const { feature: E, id: k, index: P, sourceLayerIndex: L } of e) {
              const N = this.layers[0]._featureFilter.needGeometry, G = go(E, N);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), G, c)) continue;
              const j = m ? f.evaluate(G, {}, c) : void 0, Z = { id: k, properties: E.properties, type: E.type, sourceLayerIndex: L, index: P, geometry: N ? G.geometry : po(E), patterns: {}, dashes: {}, sortKey: j };
              v.push(Z);
            }
            m && v.sort(((E, k) => E.sortKey - k.sortKey));
            for (const E of v) {
              const { geometry: k, index: P, sourceLayerIndex: L } = E;
              this.hasDependencies ? (Ep("line", this.layers, r) ? Sm("line", this.layers, E, { zoom: this.zoom }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, E, this.zoom, r), this.patternFeatures.push(E)) : this.addFeature(E, k, P, c, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(e[P].feature, k, P, L, this.index);
            }
          }
          update(e, r, c, f) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c, dashPositions: f });
          }
          addFeatures(e, r, c, f) {
            for (const m of this.patternFeatures) this.addFeature(m, m.geometry, m.index, r, c, f, e.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, fS)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, hS), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(e) {
            if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
          }
          addFeature(e, r, c, f, m, v, E) {
            const k = this.layers[0].layout, P = k.get("line-join").evaluate(e, {}), L = k.get("line-cap"), N = k.get("line-miter-limit"), G = k.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(e);
            for (const j of r) this.addLine(j, e, P, L, N, G, f, E);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: m, dashPositions: v, canonical: f });
          }
          addLine(e, r, c, f, m, v, E, k) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e = Xu(e, E ? k.line.getGranularityForZoomLevel(E.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ae = 0; ae < e.length - 1; ae++) this.totalDistance += e[ae].dist(e[ae + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const P = Nd.types[r.type] === "Polygon";
            let L = e.length;
            for (; L >= 2 && e[L - 1].equals(e[L - 2]); ) L--;
            let N = 0;
            for (; N < L - 1 && e[N].equals(e[N + 1]); ) N++;
            if (L < (P ? 3 : 2)) return;
            c === "bevel" && (m = 1.05);
            const G = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, j = this.segments.prepareSegment(10 * L, this.layoutVertexArray, this.indexArray);
            let Z, Y, J, ie, ye;
            this.e1 = this.e2 = -1, P && (Z = e[L - 2], ye = e[N].sub(Z)._unit()._perp());
            for (let ae = N; ae < L; ae++) {
              if (J = ae === L - 1 ? P ? e[N + 1] : void 0 : e[ae + 1], J && e[ae].equals(J)) continue;
              ye && (ie = ye), Z && (Y = Z), Z = e[ae], ye = J ? J.sub(Z)._unit()._perp() : ie, ie = ie || ye;
              let ue = ie.add(ye);
              ue.x === 0 && ue.y === 0 || ue._unit();
              const Ee = ie.x * ye.x + ie.y * ye.y, Le = ue.x * ye.x + ue.y * ye.y, Ke = Le !== 0 ? 1 / Le : 1 / 0, dt = 2 * Math.sqrt(2 - 2 * Le), ht = Le < pS && Y && J, mt = ie.x * ye.y - ie.y * ye.x > 0;
              if (ht && ae > N) {
                const ct = Z.dist(Y);
                if (ct > 2 * G) {
                  const ot = Z.sub(Z.sub(Y)._mult(G / ct)._round());
                  this.updateDistance(Y, ot), this.addCurrentVertex(ot, ie, 0, 0, j), Y = ot;
                }
              }
              const Pt = Y && J;
              let bt = Pt ? c : P ? "butt" : f;
              if (Pt && bt === "round" && (Ke < v ? bt = "miter" : Ke <= 2 && (bt = "fakeround")), bt === "miter" && Ke > m && (bt = "bevel"), bt === "bevel" && (Ke > 2 && (bt = "flipbevel"), Ke < m && (bt = "miter")), Y && this.updateDistance(Y, Z), bt === "miter") ue._mult(Ke), this.addCurrentVertex(Z, ue, 0, 0, j);
              else if (bt === "flipbevel") {
                if (Ke > 100) ue = ye.mult(-1);
                else {
                  const ct = Ke * ie.add(ye).mag() / ie.sub(ye).mag();
                  ue._perp()._mult(ct * (mt ? -1 : 1));
                }
                this.addCurrentVertex(Z, ue, 0, 0, j), this.addCurrentVertex(Z, ue.mult(-1), 0, 0, j);
              } else if (bt === "bevel" || bt === "fakeround") {
                const ct = -Math.sqrt(Ke * Ke - 1), ot = mt ? ct : 0, Nt = mt ? 0 : ct;
                if (Y && this.addCurrentVertex(Z, ie, ot, Nt, j), bt === "fakeround") {
                  const Rt = Math.round(180 * dt / Math.PI / 20);
                  for (let Ut = 1; Ut < Rt; Ut++) {
                    let Ft = Ut / Rt;
                    if (Ft !== 0.5) {
                      const Tr = Ft - 0.5;
                      Ft += Ft * Tr * (Ft - 1) * ((1.0904 + Ee * (Ee * (3.55645 - 1.43519 * Ee) - 3.2452)) * Tr * Tr + (0.848013 + Ee * (0.215638 * Ee - 1.06021)));
                    }
                    const Ht = ye.sub(ie)._mult(Ft)._add(ie)._unit()._mult(mt ? -1 : 1);
                    this.addHalfVertex(Z, Ht.x, Ht.y, !1, mt, 0, j);
                  }
                }
                J && this.addCurrentVertex(Z, ye, -ot, -Nt, j);
              } else if (bt === "butt") this.addCurrentVertex(Z, ue, 0, 0, j);
              else if (bt === "square") {
                const ct = Y ? 1 : -1;
                this.addCurrentVertex(Z, ue, ct, ct, j);
              } else bt === "round" && (Y && (this.addCurrentVertex(Z, ie, 0, 0, j), this.addCurrentVertex(Z, ie, 1, 1, j, !0)), J && (this.addCurrentVertex(Z, ye, -1, -1, j, !0), this.addCurrentVertex(Z, ye, 0, 0, j)));
              if (ht && ae < L - 1) {
                const ct = Z.dist(J);
                if (ct > 2 * G) {
                  const ot = Z.add(J.sub(Z)._mult(G / ct)._round());
                  this.updateDistance(Z, ot), this.addCurrentVertex(ot, ye, 0, 0, j), Z = ot;
                }
              }
            }
          }
          addCurrentVertex(e, r, c, f, m, v = !1) {
            const E = r.y * f - r.x, k = -r.y - r.x * f;
            this.addHalfVertex(e, r.x + r.y * c, r.y - r.x * c, v, !1, c, m), this.addHalfVertex(e, E, k, v, !0, -f, m), this.distance > Kv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, r, c, f, m, v));
          }
          addHalfVertex({ x: e, y: r }, c, f, m, v, E, k) {
            const P = 0.5 * (this.lineClips ? this.scaledDistance * (Kv - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((e << 1) + (m ? 1 : 0), (r << 1) + (v ? 1 : 0), Math.round(63 * c) + 128, Math.round(63 * f) + 128, 1 + (E === 0 ? 0 : E < 0 ? -1 : 1) | (63 & P) << 2, P >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const L = k.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, L, this.e2), k.primitiveLength++), v ? this.e2 = L : this.e1 = L;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(e, r) {
            this.distance += e.dist(r), this.updateScaledDistance();
          }
          hasLineDasharray(e) {
            for (const r of e) {
              const c = r.paint.get("line-dasharray");
              if (c && !c.isConstant()) return !0;
            }
            return !1;
          }
          addLineDashDependencies(e, r, c, f) {
            for (const m of e) {
              const v = m.paint.get("line-dasharray");
              if (!v || v.value.kind === "constant") continue;
              const E = m.layout.get("line-cap") === "round", k = { dasharray: v.value.evaluate({ zoom: c - 1 }, r, {}), round: E }, P = { dasharray: v.value.evaluate({ zoom: c }, r, {}), round: E }, L = { dasharray: v.value.evaluate({ zoom: c + 1 }, r, {}), round: E }, N = `${k.dasharray.join(",")},${k.round}`, G = `${P.dasharray.join(",")},${P.round}`, j = `${L.dasharray.join(",")},${L.round}`;
              f.dashDependencies[N] = k, f.dashDependencies[G] = P, f.dashDependencies[j] = L, r.dashes[m.id] = { min: N, mid: G, max: j };
            }
          }
        }
        let Qv, e0;
        Vt("LineBucket", Pm, { omit: ["layers", "patternFeatures"] });
        var t0 = { get paint() {
          return e0 = e0 || new Ui({ "line-opacity": new Xt(Be.paint_line["line-opacity"]), "line-color": new Xt(Be.paint_line["line-color"]), "line-translate": new $t(Be.paint_line["line-translate"]), "line-translate-anchor": new $t(Be.paint_line["line-translate-anchor"]), "line-width": new Xt(Be.paint_line["line-width"]), "line-gap-width": new Xt(Be.paint_line["line-gap-width"]), "line-offset": new Xt(Be.paint_line["line-offset"]), "line-blur": new Xt(Be.paint_line["line-blur"]), "line-dasharray": new ju(Be.paint_line["line-dasharray"]), "line-pattern": new ju(Be.paint_line["line-pattern"]), "line-gradient": new Yc(Be.paint_line["line-gradient"]) });
        }, get layout() {
          return Qv = Qv || new Ui({ "line-cap": new $t(Be.layout_line["line-cap"]), "line-join": new Xt(Be.layout_line["line-join"]), "line-miter-limit": new $t(Be.layout_line["line-miter-limit"]), "line-round-limit": new $t(Be.layout_line["line-round-limit"]), "line-sort-key": new Xt(Be.layout_line["line-sort-key"]) });
        } };
        class gS extends Xt {
          possiblyEvaluate(e, r) {
            return r = new Vr(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, zoomHistory: r.zoomHistory, transition: r.transition }), super.possiblyEvaluate(e, r);
          }
          evaluate(e, r, c, f) {
            return r = He({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(e, r, c, f);
          }
        }
        let Ip;
        class mS extends Ts {
          constructor(e, r) {
            super(e, t0, r), this.gradientVersion = 0, Ip || (Ip = new gS(t0.paint.properties["line-width"].specification), Ip.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(e) {
            if (e === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(c) {
                return c._styleExpression !== void 0;
              })(r) && r._styleExpression.expression instanceof Kn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(e, r) {
            super.recalculate(e, r), this.paint._values["line-floorwidth"] = Ip.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
          }
          createBucket(e) {
            return new Pm(e);
          }
          queryRadius(e) {
            const r = e, c = r0(ih("line-width", this, r), ih("line-gap-width", this, r)), f = ih("line-offset", this, r);
            return c / 2 + Math.abs(f) + bp(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v }) {
            const E = wp(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -m.bearingInRadians, v), k = v / 2 * r0(this.paint.get("line-width").evaluate(r, c), this.paint.get("line-gap-width").evaluate(r, c)), P = this.paint.get("line-offset").evaluate(r, c);
            return P && (f = (function(L, N) {
              const G = [];
              for (let j = 0; j < L.length; j++) {
                const Z = SE(L[j]), Y = [];
                for (let J = 0; J < Z.length; J++) {
                  const ie = Z[J], ye = Z[J - 1], ae = Z[J + 1], ue = J === 0 ? new R(0, 0) : ie.sub(ye)._unit()._perp(), Ee = J === Z.length - 1 ? new R(0, 0) : ae.sub(ie)._unit()._perp(), Le = ue._add(Ee)._unit(), Ke = Le.x * Ee.x + Le.y * Ee.y;
                  Ke !== 0 && Le._mult(1 / Ke), Y.push(Le._mult(N)._add(ie));
                }
                G.push(Y);
              }
              return G;
            })(f, P * v)), (function(L, N, G) {
              for (let j = 0; j < N.length; j++) {
                const Z = N[j];
                if (L.length >= 3) {
                  for (let Y = 0; Y < Z.length; Y++) if (nh(L, Z[Y])) return !0;
                }
                if (bE(L, Z, G)) return !0;
              }
              return !1;
            })(E, f, k);
          }
          isTileClipped() {
            return !0;
          }
        }
        function r0(i, e) {
          return e > 0 ? e + 2 * i : i;
        }
        const _S = Pn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), yS = Pn([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Pn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const vS = Pn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Pn([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const n0 = Pn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), xS = Pn([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function bS(i, e, r) {
          return i.sections.forEach(((c) => {
            c.text = (function(f, m, v) {
              const E = m.layout.get("text-transform").evaluate(v, {});
              return E === "uppercase" ? f = f.toLocaleUpperCase() : E === "lowercase" && (f = f.toLocaleLowerCase()), co.applyArabicShaping && (f = co.applyArabicShaping(f)), f;
            })(c.text, e, r);
          })), i;
        }
        Pn([{ name: "triangle", components: 3, type: "Uint16" }]), Pn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Pn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Pn([{ type: "Float32", name: "offsetX" }]), Pn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Pn([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        var di = 24;
        const Bd = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, wS = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, ES = { 40: !0 };
        function i0(i, e, r, c, f, m) {
          if ("fontStack" in e) {
            const v = r[e.fontStack], E = v && v[i];
            return E ? E.metrics.advance * e.scale + f : 0;
          }
          {
            const v = c[e.imageName];
            return v ? v.displaySize[0] * e.scale * di / m + f : 0;
          }
        }
        function s0(i, e, r, c) {
          const f = Math.pow(i - e, 2);
          return c ? i < e ? f / 2 : 2 * f : f + Math.abs(r) * r;
        }
        function SS(i, e, r) {
          let c = 0;
          return i === 10 && (c -= 1e4), r && (c += 150), i !== 40 && i !== 65288 || (c += 50), e !== 41 && e !== 65289 || (c += 50), c;
        }
        function a0(i, e, r, c, f, m) {
          let v = null, E = s0(e, r, f, m);
          for (const k of c) {
            const P = s0(e - k.x, r, f, m) + k.badness;
            P <= E && (v = k, E = P);
          }
          return { index: i, x: e, priorBreak: v, badness: E };
        }
        function o0(i) {
          return i ? o0(i.priorBreak).concat(i.index) : [];
        }
        class lh {
          constructor(e = "", r = [], c = []) {
            this.text = e, this.sections = r, this.sectionIndex = c, this.imageSectionID = null;
          }
          static fromFeature(e, r) {
            const c = new lh();
            for (let f = 0; f < e.sections.length; f++) {
              const m = e.sections[f];
              m.image ? c.addImageSection(m) : c.addTextSection(m, r);
            }
            return c;
          }
          length() {
            return [...this.text].length;
          }
          getSection(e) {
            return this.sections[this.sectionIndex[e]];
          }
          getSectionIndex(e) {
            return this.sectionIndex[e];
          }
          verticalizePunctuation() {
            this.text = (function(e) {
              let r = "", c = { premature: !0, value: void 0 };
              const f = e[Symbol.iterator]();
              let m = f.next();
              const v = e[Symbol.iterator]();
              v.next();
              let E = v.next();
              for (; !m.done; ) r += !E.done && gd(E.value.codePointAt(0)) && !Bd[E.value] || !c.premature && gd(c.value.codePointAt(0)) && !Bd[c.value] || !Bd[m.value] ? m.value : Bd[m.value], c = { value: m.value, premature: !1 }, m = f.next(), E = v.next();
              return r;
            })(this.text);
          }
          hasZeroWidthSpaces() {
            return this.text.includes("");
          }
          trim() {
            const e = this.text.match(/^\s*/), r = e ? e[0].length : 0, c = this.text.match(/\S\s*$/), f = c ? c[0].length - 1 : 0;
            this.text = this.text.substring(r, this.text.length - f), this.sectionIndex = this.sectionIndex.slice(r, this.sectionIndex.length - f);
          }
          substring(e, r) {
            const c = [...this.text].slice(e, r).join(""), f = this.sectionIndex.slice(e, r);
            return new lh(c, this.sections, f);
          }
          toCodeUnitIndex(e) {
            return [...this.text].slice(0, e).join("").length;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((e, r) => Math.max(e, this.sections[r].scale)), 0);
          }
          getMaxImageSize(e) {
            let r = 0, c = 0;
            for (let f = 0; f < this.length(); f++) {
              const m = this.getSection(f);
              if ("imageName" in m) {
                const v = e[m.imageName];
                if (!v) continue;
                const E = v.displaySize;
                r = Math.max(r, E[0]), c = Math.max(c, E[1]);
              }
            }
            return { maxImageWidth: r, maxImageHeight: c };
          }
          addTextSection(e, r) {
            this.text += e.text, this.sections.push({ scale: e.scale || 1, verticalAlign: e.verticalAlign || "bottom", fontStack: e.fontStack || r });
            const c = this.sections.length - 1;
            this.sectionIndex.push(...[...e.text].map((() => c)));
          }
          addImageSection(e) {
            const r = e.image ? e.image.name : "";
            if (r.length === 0) return void ur("Can't add FormattedSection with an empty image.");
            const c = this.getNextImageSectionCharCode();
            c ? (this.text += String.fromCharCode(c), this.sections.push({ scale: 1, verticalAlign: e.verticalAlign || "bottom", imageName: r }), this.sectionIndex.push(this.sections.length - 1)) : ur("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
          determineLineBreaks(e, r, c, f, m) {
            const v = [], E = this.determineAverageLineWidth(e, r, c, f, m), k = this.hasZeroWidthSpaces();
            let P = 0, L = 0;
            const N = this.text[Symbol.iterator]();
            let G = N.next();
            const j = this.text[Symbol.iterator]();
            j.next();
            let Z = j.next();
            const Y = this.text[Symbol.iterator]();
            Y.next(), Y.next();
            let J = Y.next();
            for (; !G.done; ) {
              const ie = this.getSection(L), ye = G.value.codePointAt(0);
              if (up(ye) || (P += i0(ye, ie, c, f, e, m)), !Z.done) {
                const ae = zu(ye), ue = Z.value.codePointAt(0);
                (wS[ye] || ae || "imageName" in ie || !J.done && ES[ue]) && v.push(a0(L + 1, P, E, v, SS(ye, ue, ae && k), !1));
              }
              L++, G = N.next(), Z = j.next(), J = Y.next();
            }
            return o0(a0(this.length(), P, E, v, 0, !0));
          }
          determineAverageLineWidth(e, r, c, f, m) {
            let v = 0, E = 0;
            for (const k of this.text) {
              const P = this.getSection(E);
              v += i0(k.codePointAt(0), P, c, f, e, m), E++;
            }
            return v / Math.max(1, Math.ceil(v / r));
          }
        }
        const Am = 4294967296, l0 = 1 / Am, u0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Mp {
          constructor(e = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(e, r, c = this.length) {
            for (; this.pos < c; ) {
              const f = this.readVarint(), m = f >> 3, v = this.pos;
              this.type = 7 & f, e(m, r, this), this.pos === v && this.skip(f);
            }
            return r;
          }
          readMessage(e, r) {
            return this.readFields(e, r, this.readVarint() + this.pos);
          }
          readFixed32() {
            const e = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, e;
          }
          readSFixed32() {
            const e = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, e;
          }
          readFixed64() {
            const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Am;
            return this.pos += 8, e;
          }
          readSFixed64() {
            const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Am;
            return this.pos += 8, e;
          }
          readFloat() {
            const e = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, e;
          }
          readDouble() {
            const e = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, e;
          }
          readVarint(e) {
            const r = this.buf;
            let c, f;
            return f = r[this.pos++], c = 127 & f, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 7, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 14, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 21, f < 128 ? c : (f = r[this.pos], c |= (15 & f) << 28, (function(m, v, E) {
              const k = E.buf;
              let P, L;
              if (L = k[E.pos++], P = (112 & L) >> 4, L < 128 || (L = k[E.pos++], P |= (127 & L) << 3, L < 128) || (L = k[E.pos++], P |= (127 & L) << 10, L < 128) || (L = k[E.pos++], P |= (127 & L) << 17, L < 128) || (L = k[E.pos++], P |= (127 & L) << 24, L < 128) || (L = k[E.pos++], P |= (1 & L) << 31, L < 128)) return uh(m, P, v);
              throw new Error("Expected varint not more than 10 bytes");
            })(c, e, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const e = this.readVarint();
            return e % 2 == 1 ? (e + 1) / -2 : e / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const e = this.readVarint() + this.pos, r = this.pos;
            return this.pos = e, e - r >= 12 && u0 ? u0.decode(this.buf.subarray(r, e)) : (function(c, f, m) {
              let v = "", E = f;
              for (; E < m; ) {
                const k = c[E];
                let P, L, N, G = null, j = k > 239 ? 4 : k > 223 ? 3 : k > 191 ? 2 : 1;
                if (E + j > m) break;
                j === 1 ? k < 128 && (G = k) : j === 2 ? (P = c[E + 1], (192 & P) == 128 && (G = (31 & k) << 6 | 63 & P, G <= 127 && (G = null))) : j === 3 ? (P = c[E + 1], L = c[E + 2], (192 & P) == 128 && (192 & L) == 128 && (G = (15 & k) << 12 | (63 & P) << 6 | 63 & L, (G <= 2047 || G >= 55296 && G <= 57343) && (G = null))) : j === 4 && (P = c[E + 1], L = c[E + 2], N = c[E + 3], (192 & P) == 128 && (192 & L) == 128 && (192 & N) == 128 && (G = (15 & k) << 18 | (63 & P) << 12 | (63 & L) << 6 | 63 & N, (G <= 65535 || G >= 1114112) && (G = null))), G === null ? (G = 65533, j = 1) : G > 65535 && (G -= 65536, v += String.fromCharCode(G >>> 10 & 1023 | 55296), G = 56320 | 1023 & G), v += String.fromCharCode(G), E += j;
              }
              return v;
            })(this.buf, r, e);
          }
          readBytes() {
            const e = this.readVarint() + this.pos, r = this.buf.subarray(this.pos, e);
            return this.pos = e, r;
          }
          readPackedVarint(e = [], r) {
            const c = this.readPackedEnd();
            for (; this.pos < c; ) e.push(this.readVarint(r));
            return e;
          }
          readPackedSVarint(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readSVarint());
            return e;
          }
          readPackedBoolean(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readBoolean());
            return e;
          }
          readPackedFloat(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readFloat());
            return e;
          }
          readPackedDouble(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readDouble());
            return e;
          }
          readPackedFixed32(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readFixed32());
            return e;
          }
          readPackedSFixed32(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readSFixed32());
            return e;
          }
          readPackedFixed64(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readFixed64());
            return e;
          }
          readPackedSFixed64(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readSFixed64());
            return e;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(e) {
            const r = 7 & e;
            if (r === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8;
            }
          }
          writeTag(e, r) {
            this.writeVarint(e << 3 | r);
          }
          realloc(e) {
            let r = this.length || 16;
            for (; r < this.pos + e; ) r *= 2;
            if (r !== this.length) {
              const c = new Uint8Array(r);
              c.set(this.buf), this.buf = c, this.dataView = new DataView(c.buffer), this.length = r;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(e) {
            this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
          }
          writeSFixed32(e) {
            this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
          }
          writeFixed64(e) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * l0), !0), this.pos += 8;
          }
          writeSFixed64(e) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * l0), !0), this.pos += 8;
          }
          writeVarint(e) {
            (e = +e || 0) > 268435455 || e < 0 ? (function(r, c) {
              let f, m;
              if (r >= 0 ? (f = r % 4294967296 | 0, m = r / 4294967296 | 0) : (f = ~(-r % 4294967296), m = ~(-r / 4294967296), 4294967295 ^ f ? f = f + 1 | 0 : (f = 0, m = m + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              c.realloc(10), (function(v, E, k) {
                k.buf[k.pos++] = 127 & v | 128, v >>>= 7, k.buf[k.pos++] = 127 & v | 128, v >>>= 7, k.buf[k.pos++] = 127 & v | 128, v >>>= 7, k.buf[k.pos++] = 127 & v | 128, k.buf[k.pos] = 127 & (v >>>= 7);
              })(f, 0, c), (function(v, E) {
                const k = (7 & v) << 4;
                E.buf[E.pos++] |= k | ((v >>>= 3) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v)))));
              })(m, c);
            })(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127))));
          }
          writeSVarint(e) {
            this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
          }
          writeBoolean(e) {
            this.writeVarint(+e);
          }
          writeString(e) {
            e = String(e), this.realloc(4 * e.length), this.pos++;
            const r = this.pos;
            this.pos = (function(f, m, v) {
              for (let E, k, P = 0; P < m.length; P++) {
                if (E = m.charCodeAt(P), E > 55295 && E < 57344) {
                  if (!k) {
                    E > 56319 || P + 1 === m.length ? (f[v++] = 239, f[v++] = 191, f[v++] = 189) : k = E;
                    continue;
                  }
                  if (E < 56320) {
                    f[v++] = 239, f[v++] = 191, f[v++] = 189, k = E;
                    continue;
                  }
                  E = k - 55296 << 10 | E - 56320 | 65536, k = null;
                } else k && (f[v++] = 239, f[v++] = 191, f[v++] = 189, k = null);
                E < 128 ? f[v++] = E : (E < 2048 ? f[v++] = E >> 6 | 192 : (E < 65536 ? f[v++] = E >> 12 | 224 : (f[v++] = E >> 18 | 240, f[v++] = E >> 12 & 63 | 128), f[v++] = E >> 6 & 63 | 128), f[v++] = 63 & E | 128);
              }
              return v;
            })(this.buf, e, this.pos);
            const c = this.pos - r;
            c >= 128 && c0(r, c, this), this.pos = r - 1, this.writeVarint(c), this.pos += c;
          }
          writeFloat(e) {
            this.realloc(4), this.dataView.setFloat32(this.pos, e, !0), this.pos += 4;
          }
          writeDouble(e) {
            this.realloc(8), this.dataView.setFloat64(this.pos, e, !0), this.pos += 8;
          }
          writeBytes(e) {
            const r = e.length;
            this.writeVarint(r), this.realloc(r);
            for (let c = 0; c < r; c++) this.buf[this.pos++] = e[c];
          }
          writeRawMessage(e, r) {
            this.pos++;
            const c = this.pos;
            e(r, this);
            const f = this.pos - c;
            f >= 128 && c0(c, f, this), this.pos = c - 1, this.writeVarint(f), this.pos += f;
          }
          writeMessage(e, r, c) {
            this.writeTag(e, 2), this.writeRawMessage(r, c);
          }
          writePackedVarint(e, r) {
            r.length && this.writeMessage(e, TS, r);
          }
          writePackedSVarint(e, r) {
            r.length && this.writeMessage(e, kS, r);
          }
          writePackedBoolean(e, r) {
            r.length && this.writeMessage(e, CS, r);
          }
          writePackedFloat(e, r) {
            r.length && this.writeMessage(e, IS, r);
          }
          writePackedDouble(e, r) {
            r.length && this.writeMessage(e, MS, r);
          }
          writePackedFixed32(e, r) {
            r.length && this.writeMessage(e, PS, r);
          }
          writePackedSFixed32(e, r) {
            r.length && this.writeMessage(e, AS, r);
          }
          writePackedFixed64(e, r) {
            r.length && this.writeMessage(e, LS, r);
          }
          writePackedSFixed64(e, r) {
            r.length && this.writeMessage(e, DS, r);
          }
          writeBytesField(e, r) {
            this.writeTag(e, 2), this.writeBytes(r);
          }
          writeFixed32Field(e, r) {
            this.writeTag(e, 5), this.writeFixed32(r);
          }
          writeSFixed32Field(e, r) {
            this.writeTag(e, 5), this.writeSFixed32(r);
          }
          writeFixed64Field(e, r) {
            this.writeTag(e, 1), this.writeFixed64(r);
          }
          writeSFixed64Field(e, r) {
            this.writeTag(e, 1), this.writeSFixed64(r);
          }
          writeVarintField(e, r) {
            this.writeTag(e, 0), this.writeVarint(r);
          }
          writeSVarintField(e, r) {
            this.writeTag(e, 0), this.writeSVarint(r);
          }
          writeStringField(e, r) {
            this.writeTag(e, 2), this.writeString(r);
          }
          writeFloatField(e, r) {
            this.writeTag(e, 5), this.writeFloat(r);
          }
          writeDoubleField(e, r) {
            this.writeTag(e, 1), this.writeDouble(r);
          }
          writeBooleanField(e, r) {
            this.writeVarintField(e, +r);
          }
        }
        function uh(i, e, r) {
          return r ? 4294967296 * e + (i >>> 0) : 4294967296 * (e >>> 0) + (i >>> 0);
        }
        function c0(i, e, r) {
          const c = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
          r.realloc(c);
          for (let f = r.pos - 1; f >= i; f--) r.buf[f + c] = r.buf[f];
        }
        function TS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeVarint(i[r]);
        }
        function kS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeSVarint(i[r]);
        }
        function IS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeFloat(i[r]);
        }
        function MS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeDouble(i[r]);
        }
        function CS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeBoolean(i[r]);
        }
        function PS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeFixed32(i[r]);
        }
        function AS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeSFixed32(i[r]);
        }
        function LS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeFixed64(i[r]);
        }
        function DS(i, e) {
          for (let r = 0; r < i.length; r++) e.writeSFixed64(i[r]);
        }
        function RS(i, e, r) {
          i === 1 && r.readMessage(FS, e);
        }
        function FS(i, e, r) {
          if (i === 3) {
            const { id: c, bitmap: f, width: m, height: v, left: E, top: k, advance: P } = r.readMessage(NS, {});
            e.push({ id: c, bitmap: new Cd({ width: m + 6, height: v + 6 }, f), metrics: { width: m, height: v, left: E, top: k, advance: P } });
          }
        }
        function NS(i, e, r) {
          i === 1 ? e.id = r.readVarint() : i === 2 ? e.bitmap = r.readBytes() : i === 3 ? e.width = r.readVarint() : i === 4 ? e.height = r.readVarint() : i === 5 ? e.left = r.readSVarint() : i === 6 ? e.top = r.readSVarint() : i === 7 && (e.advance = r.readVarint());
        }
        function h0(i) {
          let e = 0, r = 0;
          for (const v of i) e += v.w * v.h, r = Math.max(r, v.w);
          i.sort(((v, E) => E.h - v.h));
          const c = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), r), h: 1 / 0 }];
          let f = 0, m = 0;
          for (const v of i) for (let E = c.length - 1; E >= 0; E--) {
            const k = c[E];
            if (!(v.w > k.w || v.h > k.h)) {
              if (v.x = k.x, v.y = k.y, m = Math.max(m, v.y + v.h), f = Math.max(f, v.x + v.w), v.w === k.w && v.h === k.h) {
                const P = c.pop();
                P && E < c.length && (c[E] = P);
              } else v.h === k.h ? (k.x += v.w, k.w -= v.w) : v.w === k.w ? (k.y += v.h, k.h -= v.h) : (c.push({ x: k.x + v.w, y: k.y, w: k.w - v.w, h: v.h }), k.y += v.h, k.h -= v.h);
              break;
            }
          }
          return { w: f, h: m, fill: e / (f * m) || 0 };
        }
        class Lm {
          constructor(e, { pixelRatio: r, version: c, stretchX: f, stretchY: m, content: v, textFitWidth: E, textFitHeight: k }) {
            this.paddedRect = e, this.pixelRatio = r, this.stretchX = f, this.stretchY = m, this.content = v, this.version = c, this.textFitWidth = E, this.textFitHeight = k;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class d0 {
          constructor(e, r) {
            const c = {}, f = {};
            this.haveRenderCallbacks = [];
            const m = [];
            this.addImages(e, c, m), this.addImages(r, f, m);
            const { w: v, h: E } = h0(m), k = new us({ width: v || 1, height: E || 1 });
            for (const P in e) {
              const L = e[P], N = c[P].paddedRect;
              us.copy(L.data, k, { x: 0, y: 0 }, { x: N.x + 1, y: N.y + 1 }, L.data);
            }
            for (const P in r) {
              const L = r[P], N = f[P].paddedRect, G = N.x + 1, j = N.y + 1, Z = L.data.width, Y = L.data.height;
              us.copy(L.data, k, { x: 0, y: 0 }, { x: G, y: j }, L.data), us.copy(L.data, k, { x: 0, y: Y - 1 }, { x: G, y: j - 1 }, { width: Z, height: 1 }), us.copy(L.data, k, { x: 0, y: 0 }, { x: G, y: j + Y }, { width: Z, height: 1 }), us.copy(L.data, k, { x: Z - 1, y: 0 }, { x: G - 1, y: j }, { width: 1, height: Y }), us.copy(L.data, k, { x: 0, y: 0 }, { x: G + Z, y: j }, { width: 1, height: Y });
            }
            this.image = k, this.iconPositions = c, this.patternPositions = f;
          }
          addImages(e, r, c) {
            for (const f in e) {
              const m = e[f], v = { x: 0, y: 0, w: m.data.width + 2, h: m.data.height + 2 };
              c.push(v), r[f] = new Lm(v, m), m.hasRenderCallback && this.haveRenderCallbacks.push(f);
            }
          }
          patchUpdatedImages(e, r) {
            e.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const c in e.updatedImages) this.patchUpdatedImage(this.iconPositions[c], e.getImage(c), r), this.patchUpdatedImage(this.patternPositions[c], e.getImage(c), r);
          }
          patchUpdatedImage(e, r, c) {
            if (!e || !r || e.version === r.version) return;
            e.version = r.version;
            const [f, m] = e.tl;
            c.update(r.data, void 0, { x: f, y: m });
          }
        }
        var Ol;
        function Cp(i, e, r, c, f, m, v, E, k, P, L, N, G, j, Z) {
          const Y = lh.fromFeature(i, f);
          let J;
          N === S.az.vertical && Y.verticalizePunctuation();
          let ie = Y.determineLineBreaks(P, m, e, c, j);
          const { processBidirectionalText: ye, processStyledBidirectionalText: ae } = co;
          if (ye && Y.sections.length === 1) {
            J = [], ie = ie.map(((Ke) => Y.toCodeUnitIndex(Ke)));
            const Le = ye(Y.toString(), ie);
            for (const Ke of Le) {
              const dt = [...Ke].map((() => 0));
              J.push(new lh(Ke, Y.sections, dt));
            }
          } else if (ae) {
            J = [], ie = ie.map(((ht) => Y.toCodeUnitIndex(ht)));
            let Le = 0;
            const Ke = [];
            for (const ht of Y.text) Ke.push(...Array(ht.length).fill(Y.sectionIndex[Le])), Le++;
            const dt = ae(Y.text, Ke, ie);
            for (const ht of dt) {
              const mt = [];
              let Pt = "";
              for (const bt of ht[0]) mt.push(ht[1][Pt.length]), Pt += bt;
              J.push(new lh(ht[0], Y.sections, mt));
            }
          } else J = (function(Le, Ke) {
            const dt = [];
            let ht = 0;
            for (const mt of Ke) dt.push(Le.substring(ht, mt)), ht = mt;
            return ht < Le.length() && dt.push(Le.substring(ht, Le.length())), dt;
          })(Y, ie);
          const ue = [], Ee = { positionedLines: ue, text: Y.toString(), top: L[1], bottom: L[1], left: L[0], right: L[0], writingMode: N, iconsInText: !1, verticalizable: !1 };
          return (function(Le, Ke, dt, ht, mt, Pt, bt, ct, ot, Nt, Rt, Ut) {
            let Ft = 0, Ht = 0, Tr = 0, yr = 0;
            const fn = ct === "right" ? 1 : ct === "left" ? 0 : 0.5, Ai = di / Ut;
            let Zn = 0;
            for (const Rr of mt) {
              Rr.trim();
              const Tn = Rr.getMaxScale(), Ln = { positionedGlyphs: [], lineOffset: 0 };
              Le.positionedLines[Zn] = Ln;
              const Kr = Ln.positionedGlyphs;
              let cs = 0;
              if (!Rr.length()) {
                Ht += Pt, ++Zn;
                continue;
              }
              const Li = OS(ht, Rr, Ai);
              let hs = 0;
              for (const gi of Rr.text) {
                const vn = Rr.getSection(hs), Hn = gi.codePointAt(0), kn = zS(ot, Rt, Hn), mi = { glyph: Hn, imageName: null, x: Ft, y: Ht + -17, vertical: kn, scale: 1, fontStack: "", sectionIndex: Rr.getSectionIndex(hs), metrics: null, rect: null };
                let el;
                if ("fontStack" in vn) {
                  if (el = BS(vn, Hn, kn, Li, Ke, dt), !el) continue;
                  mi.fontStack = vn.fontStack;
                } else {
                  if (Le.iconsInText = !0, vn.scale *= Ai, el = GS(vn, kn, Tn, Li, ht), !el) continue;
                  cs = Math.max(cs, el.imageOffset), mi.imageName = vn.imageName;
                }
                const { rect: Na, metrics: Zd, baselineOffset: Vl } = el;
                mi.y += Vl, mi.scale = vn.scale, mi.metrics = Zd, mi.rect = Na, Kr.push(mi), kn ? (Le.verticalizable = !0, Ft += ("imageName" in vn ? Zd.advance : di) * vn.scale + Nt) : Ft += Zd.advance * vn.scale + Nt, hs++;
              }
              Kr.length !== 0 && (Tr = Math.max(Ft - Nt, Tr), jS(Kr, 0, Kr.length - 1, fn)), Ft = 0, Ln.lineOffset = Math.max(cs, (Tn - 1) * di);
              const ua = Pt * Tn + cs;
              Ht += ua, yr = Math.max(ua, yr), ++Zn;
            }
            const { horizontalAlign: pn, verticalAlign: on } = Dm(bt);
            (function(Rr, Tn, Ln, Kr, cs, Li, hs, ua, gi) {
              const vn = (Tn - Ln) * cs;
              let Hn = 0;
              Hn = Li !== hs ? -ua * Kr - -17 : -Kr * gi * hs + 0.5 * hs;
              for (const kn of Rr) for (const mi of kn.positionedGlyphs) mi.x += vn, mi.y += Hn;
            })(Le.positionedLines, fn, pn, on, Tr, yr, Pt, Ht, mt.length), Le.top += -on * Ht, Le.bottom = Le.top + Ht, Le.left += -pn * Tr, Le.right = Le.left + Tr;
          })(Ee, e, r, c, J, v, E, k, N, P, G, Z), !(function(Le) {
            for (const Ke of Le) if (Ke.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(ue) && Ee;
        }
        function Dm(i) {
          let e = 0.5, r = 0.5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              e = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e = 0;
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0;
          }
          return { horizontalAlign: e, verticalAlign: r };
        }
        function OS(i, e, r) {
          const c = e.getMaxScale() * di, { maxImageWidth: f, maxImageHeight: m } = e.getMaxImageSize(i), v = Math.max(c, m * r);
          return { verticalLineContentWidth: Math.max(c, f * r), horizontalLineContentHeight: v };
        }
        function f0(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function zS(i, e, r) {
          return !(i === S.az.horizontal || !e && !pd(r) || e && (up(r) || (c = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(c)))));
          var c;
        }
        function BS(i, e, r, c, f, m) {
          const v = m[i.fontStack], E = (function(P, L, N, G) {
            if (P && P.rect) return P;
            const j = L[N.fontStack], Z = j && j[G];
            return Z ? { rect: null, metrics: Z.metrics } : null;
          })(v && v[e], f, i, e);
          if (E === null) return null;
          let k;
          if (r) k = c.verticalLineContentWidth - i.scale * di;
          else {
            const P = f0(i.verticalAlign);
            k = (c.horizontalLineContentHeight - i.scale * di) * P;
          }
          return { rect: E.rect, metrics: E.metrics, baselineOffset: k };
        }
        function GS(i, e, r, c, f) {
          const m = f[i.imageName];
          if (!m) return null;
          const v = m.paddedRect, E = m.displaySize, k = { width: E[0], height: E[1], left: 1, top: -3, advance: e ? E[1] : E[0] };
          let P;
          if (e) P = c.verticalLineContentWidth - E[1] * i.scale;
          else {
            const L = f0(i.verticalAlign);
            P = (c.horizontalLineContentHeight - E[1] * i.scale) * L;
          }
          return { rect: v, metrics: k, baselineOffset: P, imageOffset: (e ? E[0] : E[1]) * i.scale - di * r };
        }
        function jS(i, e, r, c) {
          if (c === 0) return;
          const f = i[r], m = (i[r].x + f.metrics.advance * f.scale) * c;
          for (let v = e; v <= r; v++) i[v].x -= m;
        }
        function VS(i, e, r) {
          const { horizontalAlign: c, verticalAlign: f } = Dm(r), m = e[0] - i.displaySize[0] * c, v = e[1] - i.displaySize[1] * f;
          return { image: i, top: v, bottom: v + i.displaySize[1], left: m, right: m + i.displaySize[0] };
        }
        function p0(i) {
          var e, r;
          let c = i.left, f = i.top, m = i.right - c, v = i.bottom - f;
          const E = (e = i.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", k = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink", P = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (k === "proportional") {
            if (E === "stretchOnly" && m / v < P || E === "proportional") {
              const L = Math.ceil(v * P);
              c *= L / m, m = L;
            }
          } else if (E === "proportional" && k === "stretchOnly" && P !== 0 && m / v > P) {
            const L = Math.ceil(m / P);
            f *= L / v, v = L;
          }
          return { x1: c, y1: f, x2: c + m, y2: f + v };
        }
        function g0(i, e, r, c, f, m) {
          const v = i.image;
          let E;
          if (v.content) {
            const J = v.content, ie = v.pixelRatio || 1;
            E = [J[0] / ie, J[1] / ie, v.displaySize[0] - J[2] / ie, v.displaySize[1] - J[3] / ie];
          }
          const k = e.left * m, P = e.right * m;
          let L, N, G, j;
          r === "width" || r === "both" ? (j = f[0] + k - c[3], N = f[0] + P + c[1]) : (j = f[0] + (k + P - v.displaySize[0]) / 2, N = j + v.displaySize[0]);
          const Z = e.top * m, Y = e.bottom * m;
          return r === "height" || r === "both" ? (L = f[1] + Z - c[0], G = f[1] + Y + c[2]) : (L = f[1] + (Z + Y - v.displaySize[1]) / 2, G = L + v.displaySize[1]), { image: v, top: L, right: N, bottom: G, left: j, collisionPadding: E };
        }
        Vt("ImagePosition", Lm), Vt("ImageAtlas", d0), S.az = void 0, (Ol = S.az || (S.az = {}))[Ol.none = 0] = "none", Ol[Ol.horizontal = 1] = "horizontal", Ol[Ol.vertical = 2] = "vertical", Ol[Ol.horizontalOnly = 3] = "horizontalOnly";
        const Ko = 128, zl = 32640;
        function m0(i, e) {
          const { expression: r } = e;
          if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new Vr(i + 1)) };
          if (r.kind === "source") return { kind: "source" };
          {
            const { zoomStops: c, interpolationType: f } = r;
            let m = 0;
            for (; m < c.length && c[m] <= i; ) m++;
            m = Math.max(0, m - 1);
            let v = m;
            for (; v < c.length && c[v] < i + 1; ) v++;
            v = Math.min(c.length - 1, v);
            const E = c[m], k = c[v];
            return r.kind === "composite" ? { kind: "composite", minZoom: E, maxZoom: k, interpolationType: f } : { kind: "camera", minZoom: E, maxZoom: k, minSize: r.evaluate(new Vr(E)), maxSize: r.evaluate(new Vr(k)), interpolationType: f };
          }
        }
        function Rm(i, e, r) {
          let c = "never";
          const f = i.get(e);
          return f ? c = f : i.get(r) && (c = "always"), c;
        }
        const US = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Pp(i, e, r, c, f, m, v, E, k, P, L, N, G) {
          const j = E ? Math.min(zl, Math.round(E[0])) : 0, Z = E ? Math.min(zl, Math.round(E[1])) : 0;
          i.emplaceBack(e, r, Math.round(32 * c), Math.round(32 * f), m, v, (j << 1) + (k ? 1 : 0), Z, 16 * P, 16 * L, 256 * N, 256 * G);
        }
        function Fm(i, e, r) {
          i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r);
        }
        function qS(i) {
          for (const e of i.sections) if (dp(e.text)) return !0;
          return !1;
        }
        class Nm {
          constructor(e) {
            this.layoutVertexArray = new ke(), this.indexArray = new it(), this.programConfigurations = e, this.segments = new Lt(), this.dynamicLayoutVertexArray = new je(), this.opacityVertexArray = new at(), this.hasVisibleVertices = !1, this.placedSymbolArray = new T();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(e, r, c, f) {
            this.isEmpty() || (c && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, _S.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, yS.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, US, !0), this.opacityVertexBuffer.itemSize = 1), (c || f) && this.programConfigurations.upload(e));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Vt("SymbolBuffers", Nm);
        class Om {
          constructor(e, r, c) {
            this.layoutVertexArray = new e(), this.layoutAttributes = r, this.indexArray = new c(), this.segments = new Lt(), this.collisionVertexArray = new nt();
          }
          upload(e) {
            this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, vS.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Vt("CollisionBuffers", Om);
        class ch {
          constructor(e) {
            this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((v) => v.id)), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = m0(this.zoom, r["text-size"]), this.iconSizeData = m0(this.zoom, r["icon-size"]);
            const c = this.layers[0].layout, f = c.get("symbol-sort-key"), m = c.get("symbol-z-order");
            this.canOverlap = Rm(c, "text-overlap", "text-allow-overlap") !== "never" || Rm(c, "icon-overlap", "icon-allow-overlap") !== "never" || c.get("text-ignore-placement") || c.get("icon-ignore-placement"), this.sortFeaturesByKey = m !== "viewport-y" && !f.isConstant(), this.sortFeaturesByY = (m === "viewport-y" || m === "auto" && !this.sortFeaturesByKey) && this.canOverlap, c.get("symbol-placement") === "point" && (this.writingModes = c.get("text-writing-mode").map(((v) => S.az[v]))), this.stateDependentLayerIds = this.layers.filter(((v) => v.isStateDependent())).map(((v) => v.id)), this.sourceID = e.sourceID;
          }
          createArrays() {
            this.text = new Nm(new Jo(this.layers, this.zoom, ((e) => /^text/.test(e)))), this.icon = new Nm(new Jo(this.layers, this.zoom, ((e) => /^icon/.test(e)))), this.glyphOffsetArray = new F(), this.lineVertexArray = new O(), this.symbolInstances = new A(), this.textAnchorOffsets = new V();
          }
          calculateGlyphDependencies(e, r, c, f, m) {
            for (const v of e) if (r[v.codePointAt(0)] = !0, (c || f) && m) {
              const E = Bd[v];
              E && (r[E.codePointAt(0)] = !0);
            }
          }
          populate(e, r, c) {
            const f = this.layers[0], m = f.layout, v = m.get("text-font"), E = m.get("text-field"), k = m.get("icon-image"), P = (E.value.kind !== "constant" || E.value.value instanceof Xn && !E.value.value.isEmpty() || E.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), L = k.value.kind !== "constant" || !!k.value.value || Object.keys(k.parameters).length > 0, N = m.get("symbol-sort-key");
            if (this.features = [], !P && !L) return;
            const G = r.iconDependencies, j = r.glyphDependencies, Z = r.availableImages, Y = new Vr(this.zoom);
            for (const { feature: J, id: ie, index: ye, sourceLayerIndex: ae } of e) {
              const ue = f._featureFilter.needGeometry, Ee = go(J, ue);
              if (!f._featureFilter.filter(Y, Ee, c)) continue;
              let Le, Ke;
              if (ue || (Ee.geometry = po(J)), P) {
                const ht = f.getValueAndResolveTokens("text-field", Ee, c, Z), mt = Xn.factory(ht), Pt = this.hasRTLText = this.hasRTLText || qS(mt);
                (!Pt || co.getRTLTextPluginStatus() === "unavailable" || Pt && co.isParsed()) && (Le = bS(mt, f, Ee));
              }
              if (L) {
                const ht = f.getValueAndResolveTokens("icon-image", Ee, c, Z);
                Ke = ht instanceof hr ? ht : hr.fromString(ht);
              }
              if (!Le && !Ke) continue;
              const dt = this.sortFeaturesByKey ? N.evaluate(Ee, {}, c) : void 0;
              if (this.features.push({ id: ie, text: Le, icon: Ke, index: ye, sourceLayerIndex: ae, geometry: Ee.geometry, properties: J.properties, type: Nd.types[J.type], sortKey: dt }), Ke && (G[Ke.name] = !0), Le) {
                const ht = v.evaluate(Ee, {}, c).join(","), mt = m.get("text-rotation-alignment") !== "viewport" && m.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(S.az.vertical) >= 0;
                for (const Pt of Le.sections) if (Pt.image) G[Pt.image.name] = !0;
                else {
                  const bt = Fl(Le.toString()), ct = Pt.fontStack || ht, ot = j[ct] = j[ct] || {};
                  this.calculateGlyphDependencies(Pt.text, ot, mt, this.allowVerticalPlacement, bt);
                }
              }
            }
            m.get("symbol-placement") === "line" && (this.features = (function(J) {
              const ie = {}, ye = {}, ae = [];
              let ue = 0;
              function Ee(ht) {
                ae.push(J[ht]), ue++;
              }
              function Le(ht, mt, Pt) {
                const bt = ye[ht];
                return delete ye[ht], ye[mt] = bt, ae[bt].geometry[0].pop(), ae[bt].geometry[0] = ae[bt].geometry[0].concat(Pt[0]), bt;
              }
              function Ke(ht, mt, Pt) {
                const bt = ie[mt];
                return delete ie[mt], ie[ht] = bt, ae[bt].geometry[0].shift(), ae[bt].geometry[0] = Pt[0].concat(ae[bt].geometry[0]), bt;
              }
              function dt(ht, mt, Pt) {
                const bt = Pt ? mt[0][mt[0].length - 1] : mt[0][0];
                return `${ht}:${bt.x}:${bt.y}`;
              }
              for (let ht = 0; ht < J.length; ht++) {
                const mt = J[ht], Pt = mt.geometry, bt = mt.text ? mt.text.toString() : null;
                if (!bt) {
                  Ee(ht);
                  continue;
                }
                const ct = dt(bt, Pt), ot = dt(bt, Pt, !0);
                if (ct in ye && ot in ie && ye[ct] !== ie[ot]) {
                  const Nt = Ke(ct, ot, Pt), Rt = Le(ct, ot, ae[Nt].geometry);
                  delete ie[ct], delete ye[ot], ye[dt(bt, ae[Rt].geometry, !0)] = Rt, ae[Nt].geometry = null;
                } else ct in ye ? Le(ct, ot, Pt) : ot in ie ? Ke(ct, ot, Pt) : (Ee(ht), ie[ct] = ue - 1, ye[ot] = ue - 1);
              }
              return ae.filter(((ht) => ht.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((J, ie) => J.sortKey - ie.sortKey));
          }
          update(e, r, c) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, r, this.layers, { imagePositions: c }), this.icon.programConfigurations.updatePaintArrays(e, r, this.layers, { imagePositions: c }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(e) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(e, r) {
            const c = this.lineVertexArray.length;
            if (e.segment !== void 0) {
              let f = e.dist(r[e.segment + 1]), m = e.dist(r[e.segment]);
              const v = {};
              for (let E = e.segment + 1; E < r.length; E++) v[E] = { x: r[E].x, y: r[E].y, tileUnitDistanceFromAnchor: f }, E < r.length - 1 && (f += r[E + 1].dist(r[E]));
              for (let E = e.segment || 0; E >= 0; E--) v[E] = { x: r[E].x, y: r[E].y, tileUnitDistanceFromAnchor: m }, E > 0 && (m += r[E - 1].dist(r[E]));
              for (let E = 0; E < r.length; E++) {
                const k = v[E];
                this.lineVertexArray.emplaceBack(k.x, k.y, k.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: c, lineLength: this.lineVertexArray.length - c };
          }
          addSymbols(e, r, c, f, m, v, E, k, P, L, N, G) {
            const j = e.indexArray, Z = e.layoutVertexArray, Y = e.segments.prepareSegment(4 * r.length, Z, j, this.canOverlap ? v.sortKey : void 0), J = this.glyphOffsetArray.length, ie = Y.vertexLength, ye = this.allowVerticalPlacement && E === S.az.vertical ? Math.PI / 2 : 0, ae = v.text && v.text.sections;
            for (let ue = 0; ue < r.length; ue++) {
              const { tl: Ee, tr: Le, bl: Ke, br: dt, tex: ht, pixelOffsetTL: mt, pixelOffsetBR: Pt, minFontScaleX: bt, minFontScaleY: ct, glyphOffset: ot, isSDF: Nt, sectionIndex: Rt } = r[ue], Ut = Y.vertexLength, Ft = ot[1];
              Pp(Z, k.x, k.y, Ee.x, Ft + Ee.y, ht.x, ht.y, c, Nt, mt.x, mt.y, bt, ct), Pp(Z, k.x, k.y, Le.x, Ft + Le.y, ht.x + ht.w, ht.y, c, Nt, Pt.x, mt.y, bt, ct), Pp(Z, k.x, k.y, Ke.x, Ft + Ke.y, ht.x, ht.y + ht.h, c, Nt, mt.x, Pt.y, bt, ct), Pp(Z, k.x, k.y, dt.x, Ft + dt.y, ht.x + ht.w, ht.y + ht.h, c, Nt, Pt.x, Pt.y, bt, ct), Fm(e.dynamicLayoutVertexArray, k, ye), j.emplaceBack(Ut, Ut + 2, Ut + 1), j.emplaceBack(Ut + 1, Ut + 2, Ut + 3), Y.vertexLength += 4, Y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ot[0]), ue !== r.length - 1 && Rt === r[ue + 1].sectionIndex || e.programConfigurations.populatePaintArrays(Z.length, v, v.index, { imagePositions: {}, canonical: G, formattedSection: ae && ae[Rt] });
            }
            e.placedSymbolArray.emplaceBack(k.x, k.y, J, this.glyphOffsetArray.length - J, ie, P, L, k.segment, c ? c[0] : 0, c ? c[1] : 0, f[0], f[1], E, 0, !1, 0, N);
          }
          _addCollisionDebugVertex(e, r, c, f, m, v) {
            return r.emplaceBack(0, 0), e.emplaceBack(c.x, c.y, f, m, Math.round(v.x), Math.round(v.y));
          }
          addCollisionDebugVertices(e, r, c, f, m, v, E) {
            const k = m.segments.prepareSegment(4, m.layoutVertexArray, m.indexArray), P = k.vertexLength, L = m.layoutVertexArray, N = m.collisionVertexArray, G = E.anchorX, j = E.anchorY;
            this._addCollisionDebugVertex(L, N, v, G, j, new R(e, r)), this._addCollisionDebugVertex(L, N, v, G, j, new R(c, r)), this._addCollisionDebugVertex(L, N, v, G, j, new R(c, f)), this._addCollisionDebugVertex(L, N, v, G, j, new R(e, f)), k.vertexLength += 4;
            const Z = m.indexArray;
            Z.emplaceBack(P, P + 1), Z.emplaceBack(P + 1, P + 2), Z.emplaceBack(P + 2, P + 3), Z.emplaceBack(P + 3, P), k.primitiveLength += 4;
          }
          addDebugCollisionBoxes(e, r, c, f) {
            for (let m = e; m < r; m++) {
              const v = this.collisionBoxArray.get(m);
              this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, f ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, c);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Om(tt, n0.members, St), this.iconCollisionBox = new Om(tt, n0.members, St);
            for (let e = 0; e < this.symbolInstances.length; e++) {
              const r = this.symbolInstances.get(e);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(e, r, c, f, m, v, E, k, P) {
            const L = {};
            for (let N = r; N < c; N++) {
              const G = e.get(N);
              L.textBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.textFeatureIndex = G.featureIndex;
              break;
            }
            for (let N = f; N < m; N++) {
              const G = e.get(N);
              L.verticalTextBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.verticalTextFeatureIndex = G.featureIndex;
              break;
            }
            for (let N = v; N < E; N++) {
              const G = e.get(N);
              L.iconBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.iconFeatureIndex = G.featureIndex;
              break;
            }
            for (let N = k; N < P; N++) {
              const G = e.get(N);
              L.verticalIconBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.verticalIconFeatureIndex = G.featureIndex;
              break;
            }
            return L;
          }
          deserializeCollisionBoxes(e) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const c = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, c.textBoxStartIndex, c.textBoxEndIndex, c.verticalTextBoxStartIndex, c.verticalTextBoxEndIndex, c.iconBoxStartIndex, c.iconBoxEndIndex, c.verticalIconBoxStartIndex, c.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(e, r) {
            const c = e.placedSymbolArray.get(r), f = c.vertexStartIndex + 4 * c.numGlyphs;
            for (let m = c.vertexStartIndex; m < f; m += 4) e.indexArray.emplaceBack(m, m + 2, m + 1), e.indexArray.emplaceBack(m + 1, m + 2, m + 3);
          }
          getSortedSymbolIndexes(e) {
            if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(e), c = Math.cos(e), f = [], m = [], v = [];
            for (let E = 0; E < this.symbolInstances.length; ++E) {
              v.push(E);
              const k = this.symbolInstances.get(E);
              f.push(0 | Math.round(r * k.anchorX + c * k.anchorY)), m.push(k.featureIndex);
            }
            return v.sort(((E, k) => f[E] - f[k] || m[k] - m[E])), v;
          }
          addToSortKeyRanges(e, r) {
            const c = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            c && c.sortKey === r ? c.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
          }
          sortFeatures(e) {
            if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const c = this.symbolInstances.get(r);
                this.featureSortOrder.push(c.featureIndex), [c.rightJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.leftJustifiedTextSymbolIndex].forEach(((f, m, v) => {
                  f >= 0 && v.indexOf(f) === m && this.addIndicesForPlacedSymbol(this.text, f);
                })), c.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, c.verticalPlacedTextSymbolIndex), c.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.placedIconSymbolIndex), c.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let _0, y0;
        Vt("SymbolBucket", ch, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ch.MAX_GLYPHS = 65535, ch.addDynamicAttributes = Fm;
        var zm = { get paint() {
          return y0 = y0 || new Ui({ "icon-opacity": new Xt(Be.paint_symbol["icon-opacity"]), "icon-color": new Xt(Be.paint_symbol["icon-color"]), "icon-halo-color": new Xt(Be.paint_symbol["icon-halo-color"]), "icon-halo-width": new Xt(Be.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Xt(Be.paint_symbol["icon-halo-blur"]), "icon-translate": new $t(Be.paint_symbol["icon-translate"]), "icon-translate-anchor": new $t(Be.paint_symbol["icon-translate-anchor"]), "text-opacity": new Xt(Be.paint_symbol["text-opacity"]), "text-color": new Xt(Be.paint_symbol["text-color"], { runtimeType: mn, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new Xt(Be.paint_symbol["text-halo-color"]), "text-halo-width": new Xt(Be.paint_symbol["text-halo-width"]), "text-halo-blur": new Xt(Be.paint_symbol["text-halo-blur"]), "text-translate": new $t(Be.paint_symbol["text-translate"]), "text-translate-anchor": new $t(Be.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return _0 = _0 || new Ui({ "symbol-placement": new $t(Be.layout_symbol["symbol-placement"]), "symbol-spacing": new $t(Be.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new $t(Be.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Xt(Be.layout_symbol["symbol-sort-key"]), "symbol-z-order": new $t(Be.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new $t(Be.layout_symbol["icon-allow-overlap"]), "icon-overlap": new $t(Be.layout_symbol["icon-overlap"]), "icon-ignore-placement": new $t(Be.layout_symbol["icon-ignore-placement"]), "icon-optional": new $t(Be.layout_symbol["icon-optional"]), "icon-rotation-alignment": new $t(Be.layout_symbol["icon-rotation-alignment"]), "icon-size": new Xt(Be.layout_symbol["icon-size"]), "icon-text-fit": new $t(Be.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new $t(Be.layout_symbol["icon-text-fit-padding"]), "icon-image": new Xt(Be.layout_symbol["icon-image"]), "icon-rotate": new Xt(Be.layout_symbol["icon-rotate"]), "icon-padding": new Xt(Be.layout_symbol["icon-padding"]), "icon-keep-upright": new $t(Be.layout_symbol["icon-keep-upright"]), "icon-offset": new Xt(Be.layout_symbol["icon-offset"]), "icon-anchor": new Xt(Be.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new $t(Be.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new $t(Be.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new $t(Be.layout_symbol["text-rotation-alignment"]), "text-field": new Xt(Be.layout_symbol["text-field"]), "text-font": new Xt(Be.layout_symbol["text-font"]), "text-size": new Xt(Be.layout_symbol["text-size"]), "text-max-width": new Xt(Be.layout_symbol["text-max-width"]), "text-line-height": new $t(Be.layout_symbol["text-line-height"]), "text-letter-spacing": new Xt(Be.layout_symbol["text-letter-spacing"]), "text-justify": new Xt(Be.layout_symbol["text-justify"]), "text-radial-offset": new Xt(Be.layout_symbol["text-radial-offset"]), "text-variable-anchor": new $t(Be.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Xt(Be.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Xt(Be.layout_symbol["text-anchor"]), "text-max-angle": new $t(Be.layout_symbol["text-max-angle"]), "text-writing-mode": new $t(Be.layout_symbol["text-writing-mode"]), "text-rotate": new Xt(Be.layout_symbol["text-rotate"]), "text-padding": new $t(Be.layout_symbol["text-padding"]), "text-keep-upright": new $t(Be.layout_symbol["text-keep-upright"]), "text-transform": new Xt(Be.layout_symbol["text-transform"]), "text-offset": new Xt(Be.layout_symbol["text-offset"]), "text-allow-overlap": new $t(Be.layout_symbol["text-allow-overlap"]), "text-overlap": new $t(Be.layout_symbol["text-overlap"]), "text-ignore-placement": new $t(Be.layout_symbol["text-ignore-placement"]), "text-optional": new $t(Be.layout_symbol["text-optional"]) });
        } };
        class v0 {
          constructor(e) {
            if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = e.property.overrides ? e.property.overrides.runtimeType : Wr, this.defaultValue = e;
          }
          evaluate(e) {
            if (e.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(e.formattedSection)) return r.getOverride(e.formattedSection);
            }
            return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(e) {
            this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        Vt("FormatSectionOverride", v0, { omit: ["defaultValue"] });
        class Ap extends Ts {
          constructor(e, r) {
            super(e, zm, r);
          }
          recalculate(e, r) {
            if (super.recalculate(e, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const c = this.layout.get("text-writing-mode");
              if (c) {
                const f = [];
                for (const m of c) f.indexOf(m) < 0 && f.push(m);
                this.layout._values["text-writing-mode"] = f;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(e, r, c, f) {
            const m = this.layout.get(e).evaluate(r, {}, c, f), v = this._unevaluatedLayout._values[e];
            return v.isDataDriven() || Pl(v.value) || !m ? m : (function(E, k) {
              return k.replace(/{([^{}]+)}/g, ((P, L) => E && L in E ? String(E[L]) : ""));
            })(r.properties, m);
          }
          createBucket(e) {
            return new ch(e);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const e of zm.paint.overridableProperties) {
              if (!Ap.hasPaintOverride(this.layout, e)) continue;
              const r = this.paint.get(e), c = new v0(r), f = new rd(c, r.property.specification);
              let m = null;
              m = r.value.kind === "constant" || r.value.kind === "source" ? new Fc("source", f) : new nd("composite", f, r.value.zoomStops), this.paint._values[e] = new Vs(r.property, m, r.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(e, r, c) {
            return !(!this.layout || r.isDataDriven() || c.isDataDriven()) && Ap.hasPaintOverride(this.layout, e);
          }
          static hasPaintOverride(e, r) {
            const c = e.get("text-field"), f = zm.paint.properties[r];
            let m = !1;
            const v = (E) => {
              for (const k of E) if (f.overrides && f.overrides.hasOverride(k)) return void (m = !0);
            };
            if (c.value.kind === "constant" && c.value.value instanceof Xn) v(c.value.value.sections);
            else if (c.value.kind === "source" || c.value.kind === "composite") {
              const E = (P) => {
                m || (P instanceof nn && qr(P.value) === wt ? v(P.value.sections) : P instanceof zs ? v(P.sections) : P.eachChild(E));
              }, k = c.value;
              k._styleExpression && E(k._styleExpression.expression);
            }
            return m;
          }
        }
        let x0;
        var $S = { get paint() {
          return x0 = x0 || new Ui({ "background-color": new $t(Be.paint_background["background-color"]), "background-pattern": new Hc(Be.paint_background["background-pattern"]), "background-opacity": new $t(Be.paint_background["background-opacity"]) });
        } };
        class ZS extends Ts {
          constructor(e, r) {
            super(e, $S, r);
          }
        }
        class HS extends Ts {
          constructor(e, r) {
            super(e, {}, r), this.onAdd = (c) => {
              this.implementation.onAdd && this.implementation.onAdd(c, c.painter.context.gl);
            }, this.onRemove = (c) => {
              this.implementation.onRemove && this.implementation.onRemove(c, c.painter.context.gl);
            }, this.implementation = e;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class YS {
          constructor(e) {
            this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const WS = { once: !0 }, Bm = 63710088e-1;
        class Bl {
          constructor(e, r) {
            if (isNaN(e) || isNaN(r)) throw new Error(`Invalid LngLat object: (${e}, ${r})`);
            if (this.lng = +e, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Bl(mr(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(e) {
            const r = Math.PI / 180, c = this.lat * r, f = e.lat * r, m = Math.sin(c) * Math.sin(f) + Math.cos(c) * Math.cos(f) * Math.cos((e.lng - this.lng) * r);
            return Bm * Math.acos(Math.min(m, 1));
          }
          static convert(e) {
            if (e instanceof Bl) return e;
            if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new Bl(Number(e[0]), Number(e[1]));
            if (!Array.isArray(e) && typeof e == "object" && e !== null) return new Bl(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const b0 = 2 * Math.PI * Bm;
        function w0(i) {
          return b0 * Math.cos(i * Math.PI / 180);
        }
        function E0(i) {
          return (180 + i) / 360;
        }
        function S0(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
        }
        function T0(i, e) {
          return i / w0(e);
        }
        function k0(i) {
          return 360 * i - 180;
        }
        function Lp(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
        }
        function I0(i, e) {
          return i * w0(Lp(e));
        }
        class Gd {
          constructor(e, r, c = 0) {
            this.x = +e, this.y = +r, this.z = +c;
          }
          static fromLngLat(e, r = 0) {
            const c = Bl.convert(e);
            return new Gd(E0(c.lng), S0(c.lat), T0(r, c.lat));
          }
          toLngLat() {
            return new Bl(k0(this.x), Lp(this.y));
          }
          toAltitude() {
            return I0(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / b0 * (e = Lp(this.y), 1 / Math.cos(e * Math.PI / 180));
            var e;
          }
        }
        function M0(i, e, r) {
          var c = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [i * c - 2 * Math.PI * 6378137 / 2, e * c - 2 * Math.PI * 6378137 / 2];
        }
        class Gm {
          constructor(e, r, c) {
            if (!(function(f, m, v) {
              return !(f < 0 || f > 25 || v < 0 || v >= Math.pow(2, f) || m < 0 || m >= Math.pow(2, f));
            })(e, r, c)) throw new Error(`x=${r}, y=${c}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
            this.z = e, this.x = r, this.y = c, this.key = hh(0, e, e, r, c);
          }
          equals(e) {
            return this.z === e.z && this.x === e.x && this.y === e.y;
          }
          url(e, r, c) {
            const f = (v = this.y, E = this.z, k = M0(256 * (m = this.x), 256 * (v = Math.pow(2, E) - v - 1), E), P = M0(256 * (m + 1), 256 * (v + 1), E), k[0] + "," + k[1] + "," + P[0] + "," + P[1]);
            var m, v, E, k, P;
            const L = (function(N, G, j) {
              let Z, Y = "";
              for (let J = N; J > 0; J--) Z = 1 << J - 1, Y += (G & Z ? 1 : 0) + (j & Z ? 2 : 0);
              return Y;
            })(this.z, this.x, this.y);
            return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(c === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, L).replace(/{bbox-epsg-3857}/g, f);
          }
          isChildOf(e) {
            const r = this.z - e.z;
            return r > 0 && e.x === this.x >> r && e.y === this.y >> r;
          }
          getTilePoint(e) {
            const r = Math.pow(2, this.z);
            return new R((e.x * r - this.x) * Je, (e.y * r - this.y) * Je);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class C0 {
          constructor(e, r) {
            this.wrap = e, this.canonical = r, this.key = hh(e, r.z, r.z, r.x, r.y);
          }
        }
        class $s {
          constructor(e, r, c, f, m) {
            if (this.terrainRttPosMatrix32f = null, e < c) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${c}`);
            this.overscaledZ = e, this.wrap = r, this.canonical = new Gm(c, +f, +m), this.key = hh(r, e, c, f, m);
          }
          clone() {
            return new $s(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(e) {
            return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
          }
          scaledTo(e) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - e;
            return e > this.canonical.z ? new $s(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new $s(e, this.wrap, e, this.canonical.x >> r, this.canonical.y >> r);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(e, r) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
            const c = this.canonical.z - e;
            return e > this.canonical.z ? hh(this.wrap * +r, e, this.canonical.z, this.canonical.x, this.canonical.y) : hh(this.wrap * +r, e, e, this.canonical.x >> c, this.canonical.y >> c);
          }
          isChildOf(e) {
            if (e.wrap !== this.wrap || this.overscaledZ - e.overscaledZ <= 0) return !1;
            if (e.overscaledZ === 0) return this.overscaledZ > 0;
            const r = this.canonical.z - e.canonical.z;
            return !(r < 0) && e.canonical.x === this.canonical.x >> r && e.canonical.y === this.canonical.y >> r;
          }
          children(e) {
            if (this.overscaledZ >= e) return [new $s(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1, c = 2 * this.canonical.x, f = 2 * this.canonical.y;
            return [new $s(r, this.wrap, r, c, f), new $s(r, this.wrap, r, c + 1, f), new $s(r, this.wrap, r, c, f + 1), new $s(r, this.wrap, r, c + 1, f + 1)];
          }
          isLessThan(e) {
            return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
          }
          wrapped() {
            return new $s(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(e) {
            return new $s(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new C0(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(e) {
            return this.canonical.getTilePoint(new Gd(e.x - this.wrap, e.y));
          }
        }
        function hh(i, e, r, c, f) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const m = 1 << r;
          return (m * m * i + m * f + c).toString(36) + r.toString(36) + e.toString(36);
        }
        function jm(i, e) {
          return e ? i.properties[e] : i.id;
        }
        function XS(i, e) {
          const r = { id: i.id };
          if (e.removeAllProperties && (delete i.removeProperties, delete i.addOrUpdateProperties, delete e.removeProperties), e.removeProperties) for (const c of e.removeProperties) {
            const f = i.addOrUpdateProperties.findIndex(((m) => m.key === c));
            f > -1 && i.addOrUpdateProperties.splice(f, 1);
          }
          return (i.removeAllProperties || e.removeAllProperties) && (r.removeAllProperties = !0), (i.removeProperties || e.removeProperties) && (r.removeProperties = [...i.removeProperties || [], ...e.removeProperties || []]), (i.addOrUpdateProperties || e.addOrUpdateProperties) && (r.addOrUpdateProperties = [...i.addOrUpdateProperties || [], ...e.addOrUpdateProperties || []]), (i.newGeometry || e.newGeometry) && (r.newGeometry = e.newGeometry || i.newGeometry), r;
        }
        function P0(i) {
          var e, r;
          if (!i) return {};
          const c = {};
          return c.removeAll = i.removeAll, c.remove = new Set(i.remove || []), c.add = new Map((e = i.add) === null || e === void 0 ? void 0 : e.map(((f) => [f.id, f]))), c.update = new Map((r = i.update) === null || r === void 0 ? void 0 : r.map(((f) => [f.id, f]))), c;
        }
        Vt("CanonicalTileID", Gm), Vt("OverscaledTileID", $s, { omit: ["terrainRttPosMatrix32f"] });
        class Ju {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(e) {
            return this.minX = Math.min(this.minX, e.x), this.minY = Math.min(this.minY, e.y), this.maxX = Math.max(this.maxX, e.x), this.maxY = Math.max(this.maxY, e.y), this;
          }
          expandBy(e) {
            return this.minX -= e, this.minY -= e, this.maxX += e, this.maxY += e, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(e) {
            return this.expandBy(-e);
          }
          map(e) {
            const r = new Ju();
            return r.extend(e(new R(this.minX, this.minY))), r.extend(e(new R(this.maxX, this.minY))), r.extend(e(new R(this.minX, this.maxY))), r.extend(e(new R(this.maxX, this.maxY))), r;
          }
          static fromPoints(e) {
            const r = new Ju();
            for (const c of e) r.extend(c);
            return r;
          }
          contains(e) {
            return e.x >= this.minX && e.x <= this.maxX && e.y >= this.minY && e.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(e) {
            return !this.empty() && !e.empty() && e.minX >= this.minX && e.maxX <= this.maxX && e.minY >= this.minY && e.maxY <= this.maxY;
          }
          intersects(e) {
            return !this.empty() && !e.empty() && e.minX <= this.maxX && e.maxX >= this.minX && e.minY <= this.maxY && e.maxY >= this.minY;
          }
        }
        class A0 {
          constructor(e) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < e.length; r++) {
              const c = e[r];
              this._stringToNumber[c] = r, this._numberToString[r] = c;
            }
          }
          encode(e) {
            return this._stringToNumber[e];
          }
          decode(e) {
            if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[e];
          }
        }
        class L0 {
          constructor(e, r, c, f, m) {
            this.type = "Feature", this._vectorTileFeature = e, this._x = c, this._y = f, this._z = r, this.properties = e.properties, this.id = m;
          }
          projectPoint(e, r, c, f) {
            return [360 * (e.x + r) / f - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e.y + c) / f) * Math.PI)) - 90];
          }
          projectLine(e, r, c, f) {
            return e.map(((m) => this.projectPoint(m, r, c, f)));
          }
          get geometry() {
            if (this._geometry) return this._geometry;
            const e = this._vectorTileFeature, r = e.extent * Math.pow(2, this._z), c = e.extent * this._x, f = e.extent * this._y, m = e.loadGeometry();
            switch (e.type) {
              case 1: {
                const v = [];
                for (const k of m) v.push(k[0]);
                const E = this.projectLine(v, c, f, r);
                this._geometry = v.length === 1 ? { type: "Point", coordinates: E[0] } : { type: "MultiPoint", coordinates: E };
                break;
              }
              case 2: {
                const v = m.map(((E) => this.projectLine(E, c, f, r)));
                this._geometry = v.length === 1 ? { type: "LineString", coordinates: v[0] } : { type: "MultiLineString", coordinates: v };
                break;
              }
              case 3: {
                const v = Hv(m), E = [];
                for (const k of v) E.push(k.map(((P) => this.projectLine(P, c, f, r))));
                this._geometry = E.length === 1 ? { type: "Polygon", coordinates: E[0] } : { type: "MultiPolygon", coordinates: E };
                break;
              }
              default:
                throw new Error(`unknown feature type: ${e.type}`);
            }
            return this._geometry;
          }
          set geometry(e) {
            this._geometry = e;
          }
          toJSON() {
            const e = { geometry: this.geometry };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && r !== "_x" && r !== "_y" && r !== "_z" && (e[r] = this[r]);
            return e;
          }
        }
        class dh {
          _name;
          dataBuffer;
          nullabilityBuffer;
          _size;
          constructor(e, r, c) {
            this._name = e, this.dataBuffer = r, typeof c == "number" ? this._size = c : (this.nullabilityBuffer = c, this._size = c.size());
          }
          getValue(e) {
            return this.nullabilityBuffer && !this.nullabilityBuffer.get(e) ? null : this.getValueFromBuffer(e);
          }
          has(e) {
            return this.nullabilityBuffer && this.nullabilityBuffer.get(e) || !this.nullabilityBuffer;
          }
          get name() {
            return this._name;
          }
          get size() {
            return this._size;
          }
        }
        class Dp extends dh {
        }
        class Vm extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class Um extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class D0 extends dh {
          delta;
          constructor(e, r, c, f) {
            super(e, r, f), this.delta = c;
          }
        }
        class qm extends D0 {
          constructor(e, r, c, f) {
            super(e, Int32Array.of(r), c, f);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0] + e * this.delta;
          }
        }
        class $m extends dh {
          constructor(e, r, c) {
            super(e, Int32Array.of(r), c);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0];
          }
        }
        class JS {
          _name;
          _geometryVector;
          _idVector;
          _propertyVectors;
          _extent;
          propertyVectorsMap;
          constructor(e, r, c, f, m = 4096) {
            this._name = e, this._geometryVector = r, this._idVector = c, this._propertyVectors = f, this._extent = m;
          }
          get name() {
            return this._name;
          }
          get idVector() {
            return this._idVector;
          }
          get geometryVector() {
            return this._geometryVector;
          }
          get propertyVectors() {
            return this._propertyVectors;
          }
          getPropertyVector(e) {
            return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((r) => [r.name, r])))), this.propertyVectorsMap.get(e);
          }
          *[Symbol.iterator]() {
            const e = this.geometryVector[Symbol.iterator]();
            let r = 0;
            for (; r < this.numFeatures; ) {
              let c;
              this.idVector && (c = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r)) : this.idVector.getValue(r));
              const f = e?.next().value, m = {};
              for (const v of this.propertyVectors) {
                if (!v) continue;
                const E = v.name, k = v.getValue(r);
                k !== null && (m[E] = k);
              }
              r++, yield { id: c, geometry: f, properties: m };
            }
          }
          get numFeatures() {
            return this.geometryVector.numGeometries;
          }
          get extent() {
            return this._extent;
          }
          getFeatures() {
            const e = [], r = this.geometryVector.getGeometries();
            for (let c = 0; c < this.numFeatures; c++) {
              let f;
              this.idVector && (f = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(c)) : this.idVector.getValue(c));
              const m = { coordinates: r[c], type: this.geometryVector.geometryType(c) }, v = {};
              for (const E of this.propertyVectors) {
                if (!E) continue;
                const k = E.name, P = E.getValue(c);
                P !== null && (v[k] = P);
              }
              e.push({ id: f, geometry: m, properties: v });
            }
            return e;
          }
          containsMaxSaveIntegerValues(e) {
            return e instanceof Vm || e instanceof $m && e instanceof qm || e instanceof Um;
          }
        }
        class KS {
          value;
          constructor(e) {
            this.value = e;
          }
          get() {
            return this.value;
          }
          set(e) {
            this.value = e;
          }
          increment() {
            return this.value++;
          }
          add(e) {
            this.value += e;
          }
        }
        var xr, Qo, Ci, Ra, Ku, Is, fi, pi, R0, Zs;
        function Si(i, e, r) {
          const c = new Int32Array(r);
          let f = 0, m = e.get();
          for (let v = 0; v < c.length; v++) {
            let E = i[m++], k = 127 & E;
            E < 128 || (E = i[m++], k |= (127 & E) << 7, E < 128 || (E = i[m++], k |= (127 & E) << 14, E < 128 || (E = i[m++], k |= (127 & E) << 21, E < 128 || (E = i[m++], k |= (15 & E) << 28)))), c[f++] = k;
          }
          return e.set(m), c;
        }
        function Rp(i, e, r) {
          const c = new BigInt64Array(r);
          for (let f = 0; f < c.length; f++) c[f] = eT(i, e);
          return c;
        }
        function QS(i, e) {
          let r, c;
          return c = i[e.get()], e.increment(), r = 127 & c, c < 128 ? r : (c = i[e.get()], e.increment(), r |= (127 & c) << 7, c < 128 ? r : (c = i[e.get()], e.increment(), r |= (127 & c) << 14, c < 128 ? r : (c = i[e.get()], e.increment(), r |= (127 & c) << 21, c < 128 ? r : (c = i[e.get()], r |= (15 & c) << 28, (function(f, m, v) {
            let E, k;
            if (k = m[v.get()], v.increment(), E = (112 & k) >> 4, k < 128 || (k = m[v.get()], v.increment(), E |= (127 & k) << 3, k < 128) || (k = m[v.get()], v.increment(), E |= (127 & k) << 10, k < 128) || (k = m[v.get()], v.increment(), E |= (127 & k) << 17, k < 128) || (k = m[v.get()], v.increment(), E |= (127 & k) << 24, k < 128) || (k = m[v.get()], v.increment(), E |= (1 & k) << 31, k < 128)) return 4294967296 * E + (f >>> 0);
            throw new Error("Expected varint not more than 10 bytes");
          })(r, i, e)))));
        }
        function F0(i, e, r, c) {
          throw new Error("FastPFor is not implemented yet.");
        }
        function Qu(i) {
          return i >>> 1 ^ -(1 & i);
        }
        function fh(i) {
          return i >> 1n ^ -(1n & i);
        }
        function eT(i, e) {
          let r = 0n, c = 0, f = e.get();
          for (; f < i.length; ) {
            const m = i[f++];
            if (r |= BigInt(127 & m) << BigInt(c), !(128 & m)) break;
            if (c += 7, c >= 64) throw new Error("Varint too long");
          }
          return e.set(f), r;
        }
        function N0(i, e, r) {
          const c = new Int32Array(r);
          let f = 0;
          for (let m = 0; m < e; m++) {
            const v = i[m];
            c.fill(i[m + e], f, f + v), f += v;
          }
          return c;
        }
        function O0(i, e, r) {
          const c = new BigInt64Array(r);
          let f = 0;
          for (let m = 0; m < e; m++) {
            const v = Number(i[m]);
            c.fill(i[m + e], f, f + v), f += v;
          }
          return c;
        }
        function z0(i, e, r) {
          const c = new Float64Array(r);
          let f = 0;
          for (let m = 0; m < e; m++) {
            const v = i[m];
            c.fill(i[m + e], f, f + v), f += v;
          }
          return c;
        }
        function Zm(i) {
          const e = i.length / 4 * 4;
          let r = 1;
          if (e >= 4) for (let c = i[0]; r < e - 4; r += 4) c = i[r] += c, c = i[r + 1] += c, c = i[r + 2] += c, c = i[r + 3] += c;
          for (; r != i.length; ) i[r] += i[r - 1], ++r;
        }
        function B0(i) {
          i[0] = i[0] >>> 1 ^ -(1 & i[0]), i[1] = i[1] >>> 1 ^ -(1 & i[1]);
          const e = i.length / 4 * 4;
          let r = 2;
          if (e >= 4) for (; r < e - 4; r += 4) {
            const c = i[r], f = i[r + 1], m = i[r + 2], v = i[r + 3];
            i[r] = (c >>> 1 ^ -(1 & c)) + i[r - 2], i[r + 1] = (f >>> 1 ^ -(1 & f)) + i[r - 1], i[r + 2] = (m >>> 1 ^ -(1 & m)) + i[r], i[r + 3] = (v >>> 1 ^ -(1 & v)) + i[r + 1];
          }
          for (; r != i.length; r += 2) i[r] = (i[r] >>> 1 ^ -(1 & i[r])) + i[r - 2], i[r + 1] = (i[r + 1] >>> 1 ^ -(1 & i[r + 1])) + i[r - 1];
        }
        (function(i) {
          i.NONE = "NONE", i.DELTA = "DELTA", i.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", i.RLE = "RLE", i.MORTON = "MORTON", i.PDE = "PDE";
        })(xr || (xr = {})), (function(i) {
          i.NONE = "NONE", i.FAST_PFOR = "FAST_PFOR", i.VARINT = "VARINT", i.ALP = "ALP";
        })(Qo || (Qo = {})), (function(i) {
          i.PRESENT = "PRESENT", i.DATA = "DATA", i.OFFSET = "OFFSET", i.LENGTH = "LENGTH";
        })(Ci || (Ci = {}));
        class Hm {
          _dictionaryType;
          _offsetType;
          _lengthType;
          constructor(e, r, c) {
            this._dictionaryType = e, this._offsetType = r, this._lengthType = c;
          }
          get dictionaryType() {
            return this._dictionaryType;
          }
          get offsetType() {
            return this._offsetType;
          }
          get lengthType() {
            return this._lengthType;
          }
        }
        function Qi(i, e) {
          const r = (function(c, f) {
            const m = c[f.get()], v = Object.values(Ci)[m >> 4];
            let E = null;
            switch (v) {
              case Ci.DATA:
                E = new Hm(Object.values(Ra)[15 & m]);
                break;
              case Ci.OFFSET:
                E = new Hm(null, Object.values(Ku)[15 & m]);
                break;
              case Ci.LENGTH:
                E = new Hm(null, null, Object.values(Is)[15 & m]);
            }
            f.increment();
            const k = c[f.get()], P = Object.values(xr)[k >> 5], L = Object.values(xr)[k >> 2 & 7], N = Object.values(Qo)[3 & k];
            f.increment();
            const G = Si(c, f, 2), j = G[0];
            return { physicalStreamType: v, logicalStreamType: E, logicalLevelTechnique1: P, logicalLevelTechnique2: L, physicalLevelTechnique: N, numValues: j, byteLength: G[1], decompressedCount: j };
          })(i, e);
          return r.logicalLevelTechnique1 === xr.MORTON ? (function(c, f, m) {
            const v = Si(f, m, 2);
            return { physicalStreamType: c.physicalStreamType, logicalStreamType: c.logicalStreamType, logicalLevelTechnique1: c.logicalLevelTechnique1, logicalLevelTechnique2: c.logicalLevelTechnique2, physicalLevelTechnique: c.physicalLevelTechnique, numValues: c.numValues, byteLength: c.byteLength, decompressedCount: c.decompressedCount, numBits: v[0], coordinateShift: v[1] };
          })(r, i, e) : xr.RLE !== r.logicalLevelTechnique1 && xr.RLE !== r.logicalLevelTechnique2 || Qo.NONE === r.physicalLevelTechnique ? r : (function(c, f, m) {
            const v = Si(f, m, 2);
            return { physicalStreamType: c.physicalStreamType, logicalStreamType: c.logicalStreamType, logicalLevelTechnique1: c.logicalLevelTechnique1, logicalLevelTechnique2: c.logicalLevelTechnique2, physicalLevelTechnique: c.physicalLevelTechnique, numValues: c.numValues, byteLength: c.byteLength, decompressedCount: v[1], runs: v[0], numRleValues: v[1] };
          })(r, i, e);
        }
        (function(i) {
          i.NONE = "NONE", i.SINGLE = "SINGLE", i.SHARED = "SHARED", i.VERTEX = "VERTEX", i.MORTON = "MORTON", i.FSST = "FSST";
        })(Ra || (Ra = {})), (function(i) {
          i.VERTEX = "VERTEX", i.INDEX = "INDEX", i.STRING = "STRING", i.KEY = "KEY";
        })(Ku || (Ku = {})), (function(i) {
          i.VAR_BINARY = "VAR_BINARY", i.GEOMETRIES = "GEOMETRIES", i.PARTS = "PARTS", i.RINGS = "RINGS", i.TRIANGLES = "TRIANGLES", i.SYMBOL = "SYMBOL", i.DICTIONARY = "DICTIONARY";
        })(Is || (Is = {})), (function(i) {
          i[i.FLAT = 0] = "FLAT", i[i.CONST = 1] = "CONST", i[i.SEQUENCE = 2] = "SEQUENCE", i[i.DICTIONARY = 3] = "DICTIONARY", i[i.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
        })(fi || (fi = {}));
        class Fa {
          values;
          _size;
          constructor(e, r) {
            this.values = e, this._size = r;
          }
          get(e) {
            const r = Math.floor(e / 8);
            return (this.values[r] >> e % 8 & 1) == 1;
          }
          set(e, r) {
            const c = Math.floor(e / 8);
            this.values[c] = this.values[c] | (r ? 1 : 0) << e % 8;
          }
          getInt(e) {
            const r = Math.floor(e / 8);
            return this.values[r] >> e % 8 & 1;
          }
          size() {
            return this._size;
          }
          getBuffer() {
            return this.values;
          }
        }
        function es(i, e, r, c, f) {
          return (function(m, v, E) {
            switch (v.logicalLevelTechnique1) {
              case xr.DELTA:
                return v.logicalLevelTechnique2 === xr.RLE ? (function(k, P, L) {
                  const N = new Int32Array(L);
                  let G = 0, j = 0;
                  for (let Z = 0; Z < P; Z++) {
                    const Y = k[Z], J = Qu(k[Z + P]);
                    for (let ie = 0; ie < Y; ie++) j += J, N[G++] = j;
                  }
                  return N;
                })(m, v.runs, v.numRleValues) : ((function(k) {
                  k[0] = k[0] >>> 1 ^ -(1 & k[0]);
                  const P = k.length / 4 * 4;
                  let L = 1;
                  if (P >= 4) for (; L < P - 4; L += 4) {
                    const N = k[L], G = k[L + 1], j = k[L + 2], Z = k[L + 3];
                    k[L] = (N >>> 1 ^ -(1 & N)) + k[L - 1], k[L + 1] = (G >>> 1 ^ -(1 & G)) + k[L], k[L + 2] = (j >>> 1 ^ -(1 & j)) + k[L + 1], k[L + 3] = (Z >>> 1 ^ -(1 & Z)) + k[L + 2];
                  }
                  for (; L != k.length; ++L) k[L] = (k[L] >>> 1 ^ -(1 & k[L])) + k[L - 1];
                })(m), m);
              case xr.RLE:
                return (function(k, P, L) {
                  return L ? (function(N, G, j) {
                    const Z = new Int32Array(j);
                    let Y = 0;
                    for (let J = 0; J < G; J++) {
                      const ie = N[J];
                      let ye = N[J + G];
                      ye = ye >>> 1 ^ -(1 & ye), Z.fill(ye, Y, Y + ie), Y += ie;
                    }
                    return Z;
                  })(k, P.runs, P.numRleValues) : N0(k, P.runs, P.numRleValues);
                })(m, v, E);
              case xr.MORTON:
                return Zm(m), m;
              case xr.COMPONENTWISE_DELTA:
                return B0(m), m;
              case xr.NONE:
                return E && (function(k) {
                  for (let P = 0; P < k.length; P++) {
                    const L = k[P];
                    k[P] = L >>> 1 ^ -(1 & L);
                  }
                })(m), m;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${v.logicalLevelTechnique1}`);
            }
          })(Fp(i, e, r), r, c);
        }
        function Gl(i, e, r) {
          return (function(c, f) {
            if (f.logicalLevelTechnique1 === xr.DELTA && f.logicalLevelTechnique2 === xr.NONE)
              return (function(v) {
                const E = new Int32Array(v.length + 1);
                E[0] = 0, E[1] = Qu(v[0]);
                let k = E[1], P = 2;
                for (; P != E.length; ++P) {
                  const L = v[P - 1];
                  k += L >>> 1 ^ -(1 & L), E[P] = E[P - 1] + k;
                }
                return E;
              })(c);
            if (f.logicalLevelTechnique1 === xr.RLE && f.logicalLevelTechnique2 === xr.NONE)
              return (function(v, E, k) {
                const P = new Int32Array(k + 1);
                P[0] = 0;
                let L = 1, N = P[0];
                for (let G = 0; G < E; G++) {
                  const j = v[G], Z = v[G + E];
                  for (let Y = L; Y < L + j; Y++) P[Y] = Z + N, N = P[Y];
                  L += j;
                }
                return P;
              })(c, f.runs, f.numRleValues);
            if (f.logicalLevelTechnique1 === xr.NONE && f.logicalLevelTechnique2 === xr.NONE) {
              (function(v) {
                let E = 0;
                for (let k = 0; k < v.length; k++) v[k] += E, E = v[k];
              })(c);
              const m = new Int32Array(f.numValues + 1);
              return m[0] = 0, m.set(c, 1), m;
            }
            if (f.logicalLevelTechnique1 === xr.DELTA && f.logicalLevelTechnique2 === xr.RLE) {
              const m = (function(v, E, k) {
                const P = new Int32Array(k + 1);
                P[0] = 0;
                let L = 1, N = P[0];
                for (let G = 0; G < E; G++) {
                  const j = v[G];
                  let Z = v[G + E];
                  Z = Z >>> 1 ^ -(1 & Z);
                  for (let Y = L; Y < L + j; Y++) P[Y] = Z + N, N = P[Y];
                  L += j;
                }
                return P;
              })(c, f.runs, f.numRleValues);
              return Zm(m), m;
            }
            throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
          })(Fp(i, e, r), r);
        }
        function Fp(i, e, r) {
          const c = r.physicalLevelTechnique;
          if (c === Qo.FAST_PFOR) return F0();
          if (c === Qo.VARINT) return Si(i, e, r.numValues);
          if (c === Qo.NONE) {
            const f = e.get();
            e.add(r.byteLength);
            const m = i.subarray(f, e.get());
            return new Int32Array(m);
          }
          throw new Error("Specified physicalLevelTechnique is not supported (yet).");
        }
        function Ym(i, e, r, c) {
          const f = Fp(i, e, r);
          if (f.length === 1) {
            const m = f[0];
            return c ? Qu(m) : m;
          }
          return c ? (function(m) {
            return Qu(m[1]);
          })(f) : (function(m) {
            return m[1];
          })(f);
        }
        function G0(i, e, r) {
          return (function(c) {
            if (c.length == 2) {
              const f = Qu(c[1]);
              return [f, f];
            }
            return [Qu(c[2]), Qu(c[3])];
          })(Fp(i, e, r));
        }
        function j0(i, e, r) {
          return (function(c) {
            if (c.length == 2) {
              const f = fh(c[1]);
              return [f, f];
            }
            return [fh(c[2]), fh(c[3])];
          })(Rp(i, e, r.numValues));
        }
        function V0(i, e, r, c) {
          return (function(f, m, v) {
            switch (m.logicalLevelTechnique1) {
              case xr.DELTA:
                return m.logicalLevelTechnique2 === xr.RLE ? (function(E, k, P) {
                  const L = new BigInt64Array(P);
                  let N = 0, G = 0n;
                  for (let j = 0; j < k; j++) {
                    const Z = Number(E[j]), Y = fh(E[j + k]);
                    for (let J = 0; J < Z; J++) G += Y, L[N++] = G;
                  }
                  return L;
                })(f, m.runs, m.numRleValues) : ((function(E) {
                  E[0] = E[0] >> 1n ^ -(1n & E[0]);
                  const k = E.length / 4 * 4;
                  let P = 1;
                  if (k >= 4) for (; P < k - 4; P += 4) {
                    const L = E[P], N = E[P + 1], G = E[P + 2], j = E[P + 3];
                    E[P] = (L >> 1n ^ -(1n & L)) + E[P - 1], E[P + 1] = (N >> 1n ^ -(1n & N)) + E[P], E[P + 2] = (G >> 1n ^ -(1n & G)) + E[P + 1], E[P + 3] = (j >> 1n ^ -(1n & j)) + E[P + 2];
                  }
                  for (; P != E.length; ++P) E[P] = (E[P] >> 1n ^ -(1n & E[P])) + E[P - 1];
                })(f), f);
              case xr.RLE:
                return (function(E, k, P) {
                  return P ? (function(L, N, G) {
                    const j = new BigInt64Array(G);
                    let Z = 0;
                    for (let Y = 0; Y < N; Y++) {
                      const J = Number(L[Y]);
                      let ie = L[Y + N];
                      ie = ie >> 1n ^ -(1n & ie), j.fill(ie, Z, Z + J), Z += J;
                    }
                    return j;
                  })(E, k.runs, k.numRleValues) : O0(E, k.runs, k.numRleValues);
                })(f, m, v);
              case xr.NONE:
                return v && (function(E) {
                  for (let k = 0; k < E.length; k++) {
                    const P = E[k];
                    E[k] = P >> 1n ^ -(1n & P);
                  }
                })(f), f;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${m.logicalLevelTechnique1}`);
            }
          })(Rp(i, e, r.numValues), r, c);
        }
        function U0(i, e, r, c) {
          const f = Rp(i, e, r.numValues);
          if (f.length === 1) {
            const m = f[0];
            return c ? fh(m) : m;
          }
          return c ? (function(m) {
            return fh(m[1]);
          })(f) : (function(m) {
            return m[1];
          })(f);
        }
        function Wm(i, e, r, c, f) {
          return (function(m, v, E, k) {
            switch (v.logicalLevelTechnique1) {
              case xr.DELTA:
                return v.logicalLevelTechnique2 === xr.RLE && (m = N0(m, v.runs, v.numRleValues)), (function(P, L) {
                  const N = new Int32Array(P.size());
                  let G = 0;
                  P.get(0) ? (N[0] = P.get(0) ? L[0] >>> 1 ^ -(1 & L[0]) : 0, G = 1) : N[0] = 0;
                  let j = 1;
                  for (; j != N.length; ++j) N[j] = P.get(j) ? N[j - 1] + (L[G] >>> 1 ^ -(1 & L[G++])) : N[j - 1];
                  return N;
                })(k, m);
              case xr.RLE:
                return (function(P, L, N, G) {
                  const j = L;
                  return N ? (function(Z, Y, J) {
                    const ie = new Int32Array(Z.size());
                    let ye = 0;
                    for (let ae = 0; ae < J; ae++) {
                      const ue = Y[ae];
                      let Ee = Y[ae + J];
                      Ee = Ee >>> 1 ^ -(1 & Ee);
                      for (let Le = ye; Le < ye + ue; Le++) Z.get(Le) ? ie[Le] = Ee : (ie[Le] = 0, ye++);
                      ye += ue;
                    }
                    return ie;
                  })(G, P, j.runs) : (function(Z, Y, J) {
                    const ie = new Int32Array(Z.size());
                    let ye = 0;
                    for (let ae = 0; ae < J; ae++) {
                      const ue = Y[ae], Ee = Y[ae + J];
                      for (let Le = ye; Le < ye + ue; Le++) Z.get(Le) ? ie[Le] = Ee : (ie[Le] = 0, ye++);
                      ye += ue;
                    }
                    return ie;
                  })(G, P, j.runs);
                })(m, v, E, k);
              case xr.MORTON:
                return Zm(m), m;
              case xr.COMPONENTWISE_DELTA:
                return B0(m), m;
              case xr.NONE:
                return m = E ? (function(P, L) {
                  const N = new Int32Array(P.size());
                  let G = 0, j = 0;
                  for (; j != N.length; ++j) if (P.get(j)) {
                    const Z = L[G++];
                    N[j] = Z >>> 1 ^ -(1 & Z);
                  } else N[j] = 0;
                  return N;
                })(k, m) : (function(P, L) {
                  const N = new Int32Array(P.size());
                  let G = 0, j = 0;
                  for (; j != N.length; ++j) N[j] = P.get(j) ? L[G++] : 0;
                  return N;
                })(k, m), m;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          })(r.physicalLevelTechnique === Qo.FAST_PFOR ? F0() : Si(i, e, r.numValues), r, c, f);
        }
        function Np(i, e, r, c) {
          const f = i.logicalLevelTechnique1;
          if (f === xr.RLE) return i.runs === 1 ? fi.CONST : fi.FLAT;
          const m = e instanceof Fa ? e.size() : e;
          if (f === xr.DELTA && i.logicalLevelTechnique2 === xr.RLE) {
            const v = i.runs, E = 2;
            if (i.numRleValues !== m) return fi.FLAT;
            if (v === 1) return fi.SEQUENCE;
            if (v === 2) {
              const k = c.get();
              let P;
              if (i.physicalLevelTechnique === Qo.VARINT) P = Si(r, c, 4);
              else {
                const L = c.get();
                P = new Int32Array(r.buffer, r.byteOffset + L, 4);
              }
              if (c.set(k), P[2] === E && P[3] === E) return fi.SEQUENCE;
            }
          }
          return i.numValues === 1 ? fi.CONST : fi.FLAT;
        }
        class q0 extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class $0 extends D0 {
          constructor(e, r, c, f) {
            super(e, BigInt64Array.of(r), c, f);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0] + BigInt(e) * this.delta;
          }
        }
        class ph {
          _geometryOffsets;
          _partOffsets;
          _ringOffsets;
          constructor(e, r, c) {
            this._geometryOffsets = e, this._partOffsets = r, this._ringOffsets = c;
          }
          get geometryOffsets() {
            return this._geometryOffsets;
          }
          get partOffsets() {
            return this._partOffsets;
          }
          get ringOffsets() {
            return this._ringOffsets;
          }
        }
        function Xm(i, e, r) {
          return { x: Z0(i, e) - r, y: Z0(i >> 1, e) - r };
        }
        function Z0(i, e) {
          let r = 0;
          for (let c = 0; c < e; c++) r |= (i & 1 << 2 * c) >> c;
          return r;
        }
        (function(i) {
          i[i.POINT = 0] = "POINT", i[i.LINESTRING = 1] = "LINESTRING", i[i.POLYGON = 2] = "POLYGON", i[i.MULTIPOINT = 3] = "MULTIPOINT", i[i.MULTILINESTRING = 4] = "MULTILINESTRING", i[i.MULTIPOLYGON = 5] = "MULTIPOLYGON";
        })(pi || (pi = {})), (function(i) {
          i[i.POINT = 0] = "POINT", i[i.LINESTRING = 1] = "LINESTRING", i[i.POLYGON = 2] = "POLYGON";
        })(R0 || (R0 = {})), (function(i) {
          i[i.MORTON = 0] = "MORTON", i[i.VEC_2 = 1] = "VEC_2", i[i.VEC_3 = 2] = "VEC_3";
        })(Zs || (Zs = {}));
        class tT {
          createPoint(e) {
            return [[e]];
          }
          createMultiPoint(e) {
            return e.map(((r) => [r]));
          }
          createLineString(e) {
            return [e];
          }
          createMultiLineString(e) {
            return e;
          }
          createPolygon(e, r) {
            return [e].concat(r);
          }
          createMultiPolygon(e) {
            return e.flat();
          }
        }
        function H0(i) {
          const e = new Array(i.numGeometries);
          let r = 1, c = 1, f = 1, m = 0;
          const v = new tT();
          let E = 0, k = 0;
          const P = i.mortonSettings, L = i.topologyVector, N = L.geometryOffsets, G = L.partOffsets, j = L.ringOffsets, Z = i.vertexOffsets, Y = i.containsPolygonGeometry(), J = i.vertexBuffer;
          for (let ie = 0; ie < i.numGeometries; ie++) {
            const ye = i.geometryType(ie);
            if (ye === pi.POINT) {
              if (Z && Z.length !== 0) if (i.vertexBufferType === Zs.VEC_2) {
                const ae = 2 * Z[k++], ue = new R(J[ae], J[ae + 1]);
                e[m++] = v.createPoint(ue);
              } else {
                const ae = Xm(J[Z[k++]], P.numBits, P.coordinateShift), ue = new R(ae.x, ae.y);
                e[m++] = v.createPoint(ue);
              }
              else {
                const ae = new R(J[E++], J[E++]);
                e[m++] = v.createPoint(ae);
              }
              N && f++, G && r++, j && c++;
            } else if (ye === pi.MULTIPOINT) {
              const ae = N[f] - N[f - 1];
              f++;
              const ue = new Array(ae);
              if (Z && Z.length !== 0) {
                for (let Ee = 0; Ee < ae; Ee++) {
                  const Le = 2 * Z[k++];
                  ue[Ee] = new R(J[Le], J[Le + 1]);
                }
                e[m++] = v.createMultiPoint(ue);
              } else {
                for (let Ee = 0; Ee < ae; Ee++) {
                  const Le = J[E++], Ke = J[E++];
                  ue[Ee] = new R(Le, Ke);
                }
                e[m++] = v.createMultiPoint(ue);
              }
            } else if (ye === pi.LINESTRING) {
              let ae, ue = 0;
              Y ? (ue = j[c] - j[c - 1], c++) : ue = G[r] - G[r - 1], r++, Z && Z.length !== 0 ? (ae = i.vertexBufferType === Zs.VEC_2 ? Km(J, Z, k, ue, !1) : Qm(J, Z, k, ue, !1, P), k += ue) : (ae = Jm(J, E, ue, !1), E += 2 * ue), e[m++] = v.createLineString(ae), N && f++;
            } else if (ye === pi.POLYGON) {
              const ae = G[r] - G[r - 1];
              r++;
              const ue = new Array(ae - 1);
              let Ee = j[c] - j[c - 1];
              if (c++, Z && Z.length !== 0) {
                const Le = i.vertexBufferType === Zs.VEC_2 ? zp(J, Z, k, Ee) : Bp(J, Z, k, Ee, 0, P);
                k += Ee;
                for (let Ke = 0; Ke < ue.length; Ke++) Ee = j[c] - j[c - 1], c++, ue[Ke] = i.vertexBufferType === Zs.VEC_2 ? zp(J, Z, k, Ee) : Bp(J, Z, k, Ee, 0, P), k += Ee;
                e[m++] = v.createPolygon(Le, ue);
              } else {
                const Le = Op(J, E, Ee);
                E += 2 * Ee;
                for (let Ke = 0; Ke < ue.length; Ke++) Ee = j[c] - j[c - 1], c++, ue[Ke] = Op(J, E, Ee), E += 2 * Ee;
                e[m++] = v.createPolygon(Le, ue);
              }
              N && f++;
            } else if (ye === pi.MULTILINESTRING) {
              const ae = N[f] - N[f - 1];
              f++;
              const ue = new Array(ae);
              if (Z && Z.length !== 0) {
                for (let Ee = 0; Ee < ae; Ee++) {
                  let Le = 0;
                  Y ? (Le = j[c] - j[c - 1], c++) : Le = G[r] - G[r - 1], r++;
                  const Ke = i.vertexBufferType === Zs.VEC_2 ? Km(J, Z, k, Le, !1) : Qm(J, Z, k, Le, !1, P);
                  ue[Ee] = Ke, k += Le;
                }
                e[m++] = v.createMultiLineString(ue);
              } else {
                for (let Ee = 0; Ee < ae; Ee++) {
                  let Le = 0;
                  Y ? (Le = j[c] - j[c - 1], c++) : Le = G[r] - G[r - 1], r++, ue[Ee] = Jm(J, E, Le, !1), E += 2 * Le;
                }
                e[m++] = v.createMultiLineString(ue);
              }
            } else {
              if (ye !== pi.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
              {
                const ae = N[f] - N[f - 1];
                f++;
                const ue = new Array(ae);
                let Ee = 0;
                if (Z && Z.length !== 0) {
                  for (let Le = 0; Le < ae; Le++) {
                    const Ke = G[r] - G[r - 1];
                    r++;
                    const dt = new Array(Ke - 1);
                    Ee = j[c] - j[c - 1], c++;
                    const ht = i.vertexBufferType === Zs.VEC_2 ? zp(J, Z, k, Ee) : Bp(J, Z, k, Ee, 0, P);
                    k += Ee;
                    for (let mt = 0; mt < dt.length; mt++) Ee = j[c] - j[c - 1], c++, dt[mt] = i.vertexBufferType === Zs.VEC_2 ? zp(J, Z, k, Ee) : Bp(J, Z, k, Ee, 0, P), k += Ee;
                    ue[Le] = v.createPolygon(ht, dt);
                  }
                  e[m++] = v.createMultiPolygon(ue);
                } else {
                  for (let Le = 0; Le < ae; Le++) {
                    const Ke = G[r] - G[r - 1];
                    r++;
                    const dt = new Array(Ke - 1);
                    Ee = j[c] - j[c - 1], c++;
                    const ht = Op(J, E, Ee);
                    E += 2 * Ee;
                    for (let mt = 0; mt < dt.length; mt++) {
                      const Pt = j[c] - j[c - 1];
                      c++, dt[mt] = Op(J, E, Pt), E += 2 * Pt;
                    }
                    ue[Le] = v.createPolygon(ht, dt);
                  }
                  e[m++] = v.createMultiPolygon(ue);
                }
              }
            }
          }
          return e;
        }
        function Op(i, e, r) {
          return Jm(i, e, r, !0);
        }
        function zp(i, e, r, c) {
          return Km(i, e, r, c, !0);
        }
        function Bp(i, e, r, c, f, m) {
          return Qm(i, e, r, c, !0, m);
        }
        function Jm(i, e, r, c) {
          const f = new Array(c ? r + 1 : r);
          for (let m = 0; m < 2 * r; m += 2) f[m / 2] = new R(i[e + m], i[e + m + 1]);
          return c && (f[f.length - 1] = f[0]), f;
        }
        function Km(i, e, r, c, f) {
          const m = new Array(f ? c + 1 : c);
          for (let v = 0; v < 2 * c; v += 2) {
            const E = 2 * e[r + v / 2];
            m[v / 2] = new R(i[E], i[E + 1]);
          }
          return f && (m[m.length - 1] = m[0]), m;
        }
        function Qm(i, e, r, c, f, m) {
          const v = new Array(f ? c + 1 : c);
          for (let E = 0; E < c; E++) {
            const k = Xm(i[e[r + E]], m.numBits, m.coordinateShift);
            v[E] = new R(k.x, k.y);
          }
          return f && (v[v.length - 1] = v[0]), v;
        }
        class Y0 {
          _vertexBufferType;
          _topologyVector;
          _vertexOffsets;
          _vertexBuffer;
          _mortonSettings;
          constructor(e, r, c, f, m) {
            this._vertexBufferType = e, this._topologyVector = r, this._vertexOffsets = c, this._vertexBuffer = f, this._mortonSettings = m;
          }
          get vertexBufferType() {
            return this._vertexBufferType;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          get vertexOffsets() {
            return this._vertexOffsets;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          *[Symbol.iterator]() {
            const e = H0(this);
            let r = 0;
            for (; r < this.numGeometries; ) yield { coordinates: e[r], type: this.geometryType(r) }, r++;
          }
          getSimpleEncodedVertex(e) {
            const r = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e;
            return [this.vertexBuffer[r], this.vertexBuffer[r + 1]];
          }
          getVertex(e) {
            if (this.vertexOffsets && this.mortonSettings) {
              const c = Xm(this.vertexBuffer[this.vertexOffsets[e]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
              return [c.x, c.y];
            }
            const r = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e;
            return [this.vertexBuffer[r], this.vertexBuffer[r + 1]];
          }
          getGeometries() {
            return H0(this);
          }
          get mortonSettings() {
            return this._mortonSettings;
          }
        }
        class W0 extends Y0 {
          _numGeometries;
          _geometryType;
          constructor(e, r, c, f, m, v, E) {
            super(c, f, m, v, E), this._numGeometries = e, this._geometryType = r;
          }
          geometryType(e) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsPolygonGeometry() {
            return this._geometryType === pi.POLYGON || this._geometryType === pi.MULTIPOLYGON;
          }
          containsSingleGeometryType() {
            return !0;
          }
        }
        class X0 extends Y0 {
          _geometryTypes;
          constructor(e, r, c, f, m, v) {
            super(e, c, f, m, v), this._geometryTypes = r;
          }
          geometryType(e) {
            return this._geometryTypes[e];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsPolygonGeometry() {
            for (let e = 0; e < this.numGeometries; e++) if (this.geometryType(e) === pi.POLYGON || this.geometryType(e) === pi.MULTIPOLYGON) return !0;
            return !1;
          }
          containsSingleGeometryType() {
            return !1;
          }
        }
        class J0 {
          _triangleOffsets;
          _indexBuffer;
          _vertexBuffer;
          _topologyVector;
          constructor(e, r, c, f) {
            this._triangleOffsets = e, this._indexBuffer = r, this._vertexBuffer = c, this._topologyVector = f;
          }
          get triangleOffsets() {
            return this._triangleOffsets;
          }
          get indexBuffer() {
            return this._indexBuffer;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          getGeometries() {
            if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
            const e = new Array(this.numGeometries), r = this._topologyVector, c = r.partOffsets, f = r.ringOffsets, m = r.geometryOffsets;
            let v = 0, E = 1, k = 1, P = 1;
            for (let L = 0; L < this.numGeometries; L++) switch (this.geometryType(L)) {
              case pi.POLYGON:
                {
                  const N = c[E] - c[E - 1];
                  E++;
                  const G = [];
                  for (let j = 0; j < N; j++) {
                    const Z = f[k] - f[k - 1];
                    k++;
                    const Y = [];
                    for (let J = 0; J < Z; J++) {
                      const ie = this._vertexBuffer[v++], ye = this._vertexBuffer[v++];
                      Y.push(new R(ie, ye));
                    }
                    Y.length > 0 && Y.push(Y[0]), G.push(Y);
                  }
                  e[L] = G, m && P++;
                }
                break;
              case pi.MULTIPOLYGON: {
                const N = m[P] - m[P - 1];
                P++;
                const G = [];
                for (let j = 0; j < N; j++) {
                  const Z = c[E] - c[E - 1];
                  E++;
                  for (let Y = 0; Y < Z; Y++) {
                    const J = f[k] - f[k - 1];
                    k++;
                    const ie = [];
                    for (let ye = 0; ye < J; ye++) {
                      const ae = this._vertexBuffer[v++], ue = this._vertexBuffer[v++];
                      ie.push(new R(ae, ue));
                    }
                    ie.length > 0 && ie.push(ie[0]), G.push(ie);
                  }
                }
                e[L] = G;
              }
            }
            return e;
          }
          [Symbol.iterator]() {
            return null;
          }
        }
        function K0(i, e, r, c, f, m) {
          return new rT(i, e, r, c, f, m);
        }
        class rT extends J0 {
          _numGeometries;
          _geometryType;
          constructor(e, r, c, f, m, v) {
            super(c, f, m, v), this._numGeometries = e, this._geometryType = r;
          }
          geometryType(e) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsSingleGeometryType() {
            return !0;
          }
        }
        function Q0(i, e, r, c, f) {
          return new nT(i, e, r, c, f);
        }
        class nT extends J0 {
          _geometryTypes;
          constructor(e, r, c, f, m) {
            super(r, c, f, m), this._geometryTypes = e;
          }
          geometryType(e) {
            return this._geometryTypes[e];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsSingleGeometryType() {
            return !1;
          }
        }
        function iT(i, e, r, c, f) {
          const m = Qi(i, r);
          let v = null, E = null, k = null, P = null, L = null, N = null, G = null, j = null;
          if (Np(m, c, i, r) === fi.CONST) {
            const Y = Ym(i, r, m, !1);
            for (let J = 0; J < e - 1; J++) {
              const ie = Qi(i, r);
              switch (ie.physicalStreamType) {
                case Ci.LENGTH:
                  switch (ie.logicalStreamType.lengthType) {
                    case Is.GEOMETRIES:
                      v = Gl(i, r, ie);
                      break;
                    case Is.PARTS:
                      E = Gl(i, r, ie);
                      break;
                    case Is.RINGS:
                      k = Gl(i, r, ie);
                      break;
                    case Is.TRIANGLES:
                      G = Gl(i, r, ie);
                  }
                  break;
                case Ci.OFFSET:
                  switch (ie.logicalStreamType.offsetType) {
                    case Ku.VERTEX:
                      P = es(i, r, ie, !1);
                      break;
                    case Ku.INDEX:
                      j = es(i, r, ie, !1);
                  }
                  break;
                case Ci.DATA:
                  Ra.VERTEX === ie.logicalStreamType.dictionaryType ? L = es(i, r, ie, !0) : (N = { numBits: ie.numBits, coordinateShift: ie.coordinateShift }, L = es(i, r, ie, !1));
              }
            }
            return j !== null ? v != null || E != null ? K0(c, Y, G, j, L, new ph(v, E, k)) : K0(c, Y, G, j, L) : N === null ? (function(J, ie, ye, ae, ue) {
              return new W0(J, ie, Zs.VEC_2, ye, ae, ue);
            })(c, Y, new ph(v, E, k), P, L) : (function(J, ie, ye, ae, ue, Ee) {
              return new W0(J, ie, Zs.MORTON, ye, ae, ue, Ee);
            })(c, Y, new ph(v, E, k), P, L, N);
          }
          const Z = es(i, r, m, !1);
          for (let Y = 0; Y < e - 1; Y++) {
            const J = Qi(i, r);
            switch (J.physicalStreamType) {
              case Ci.LENGTH:
                switch (J.logicalStreamType.lengthType) {
                  case Is.GEOMETRIES:
                    v = es(i, r, J, !1);
                    break;
                  case Is.PARTS:
                    E = es(i, r, J, !1);
                    break;
                  case Is.RINGS:
                    k = es(i, r, J, !1);
                    break;
                  case Is.TRIANGLES:
                    G = Gl(i, r, J);
                }
                break;
              case Ci.OFFSET:
                switch (J.logicalStreamType.offsetType) {
                  case Ku.VERTEX:
                    P = es(i, r, J, !1);
                    break;
                  case Ku.INDEX:
                    j = es(i, r, J, !1);
                }
                break;
              case Ci.DATA:
                Ra.VERTEX === J.logicalStreamType.dictionaryType ? L = es(i, r, J, !0) : (N = { numBits: J.numBits, coordinateShift: J.coordinateShift }, L = es(i, r, J, !1));
            }
          }
          return j !== null && E === null ? Q0(Z, G, j, L) : (v !== null ? (v = e_(Z, v, 2), E !== null && k !== null ? (E = ex(Z, v, E, !1), k = (function(Y, J, ie, ye) {
            const ae = new Int32Array(ie[ie.length - 1] + 1);
            let ue = 0;
            ae[0] = ue;
            let Ee = 1, Le = 1, Ke = 0;
            for (let dt = 0; dt < Y.length; dt++) {
              const ht = Y[dt], mt = J[dt + 1] - J[dt];
              if (ht !== 0 && ht !== 3) for (let Pt = 0; Pt < mt; Pt++) {
                const bt = ie[Ee] - ie[Ee - 1];
                Ee++;
                for (let ct = 0; ct < bt; ct++) ue = ae[Le++] = ue + ye[Ke++];
              }
              else for (let Pt = 0; Pt < mt; Pt++) ae[Le++] = ++ue, Ee++;
            }
            return ae;
          })(Z, v, E, k)) : E !== null && (E = (function(Y, J, ie) {
            const ye = new Int32Array(J[J.length - 1] + 1);
            let ae = 0;
            ye[0] = ae;
            let ue = 1, Ee = 0;
            for (let Le = 0; Le < Y.length; Le++) {
              const Ke = Y[Le], dt = J[Le + 1] - J[Le];
              if (Ke === 4 || Ke === 1) for (let ht = 0; ht < dt; ht++) ae = ye[ue++] = ae + ie[Ee++];
              else for (let ht = 0; ht < dt; ht++) ye[ue++] = ++ae;
            }
            return ye;
          })(Z, v, E))) : E !== null && k !== null ? (E = e_(Z, E, 1), k = ex(Z, E, k, !0)) : E !== null && (E = e_(Z, E, 0)), j !== null ? Q0(Z, G, j, L, new ph(v, E, k)) : N === null ? (function(Y, J, ie, ye) {
            return new X0(Zs.VEC_2, Y, J, ie, ye);
          })(Z, new ph(v, E, k), P, L) : (function(Y, J, ie, ye, ae) {
            return new X0(Zs.MORTON, Y, J, ie, ye, ae);
          })(Z, new ph(v, E, k), P, L, N));
        }
        function e_(i, e, r) {
          const c = new Int32Array(i.length + 1);
          let f = 0;
          c[0] = f;
          let m = 0;
          for (let v = 0; v < i.length; v++) f = c[v + 1] = f + (i[v] > r ? e[m++] : 1);
          return c;
        }
        function ex(i, e, r, c) {
          const f = new Int32Array(e[e.length - 1] + 1);
          let m = 0;
          f[0] = m;
          let v = 1, E = 0;
          for (let k = 0; k < i.length; k++) {
            const P = i[k], L = e[k + 1] - e[k];
            if (P === 5 || P === 2 || c && (P === 4 || P === 1)) for (let N = 0; N < L; N++) m = f[v++] = m + r[E++];
            else for (let N = 0; N < L; N++) f[v++] = ++m;
          }
          return f;
        }
        class sT extends dh {
          dataVector;
          constructor(e, r, c) {
            super(e, r.getBuffer(), c), this.dataVector = r;
          }
          getValueFromBuffer(e) {
            return this.dataVector.get(e);
          }
        }
        class aT extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class tx extends dh {
          constructor(e, r, c) {
            super(e, BigInt64Array.of(r), c);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0];
          }
        }
        function jd(i, e, r) {
          return rx(i, Math.ceil(e / 8), r);
        }
        function rx(i, e, r) {
          const c = new Uint8Array(e);
          let f = 0;
          for (; f < e; ) {
            const m = i[r.increment()];
            if (m <= 127) {
              const v = m + 3, E = i[r.increment()], k = f + v;
              c.fill(E, f, k), f = k;
            } else {
              const v = 256 - m;
              for (let E = 0; E < v; E++) c[f++] = i[r.increment()];
            }
          }
          return c;
        }
        const oT = new TextDecoder();
        function t_(i, e, r) {
          return r - e >= 12 ? oT.decode(i.subarray(e, r)) : (function(c, f, m) {
            let v = "", E = f;
            for (; E < m; ) {
              const k = c[E];
              let P, L, N, G = null, j = k > 239 ? 4 : k > 223 ? 3 : k > 191 ? 2 : 1;
              if (E + j > m) break;
              j === 1 ? k < 128 && (G = k) : j === 2 ? (P = c[E + 1], (192 & P) == 128 && (G = (31 & k) << 6 | 63 & P, G <= 127 && (G = null))) : j === 3 ? (P = c[E + 1], L = c[E + 2], (192 & P) == 128 && (192 & L) == 128 && (G = (15 & k) << 12 | (63 & P) << 6 | 63 & L, (G <= 2047 || G >= 55296 && G <= 57343) && (G = null))) : j === 4 && (P = c[E + 1], L = c[E + 2], N = c[E + 3], (192 & P) == 128 && (192 & L) == 128 && (192 & N) == 128 && (G = (15 & k) << 18 | (63 & P) << 12 | (63 & L) << 6 | 63 & N, (G <= 65535 || G >= 1114112) && (G = null))), G === null ? (G = 65533, j = 1) : G > 65535 && (G -= 65536, v += String.fromCharCode(G >>> 10 & 1023 | 55296), G = 56320 | 1023 & G), v += String.fromCharCode(G), E += j;
            }
            return v;
          })(i, e, r);
        }
        class r_ extends dh {
          offsetBuffer;
          constructor(e, r, c, f) {
            super(e, c, f), this.offsetBuffer = r;
          }
        }
        class nx extends r_ {
          textEncoder;
          constructor(e, r, c, f) {
            super(e, r, c, f ?? r.length - 1), this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            return t_(this.dataBuffer, this.offsetBuffer[e], this.offsetBuffer[e + 1]);
          }
        }
        class gh extends r_ {
          indexBuffer;
          textEncoder;
          constructor(e, r, c, f, m) {
            super(e, c, f, m ?? r.length), this.indexBuffer = r, this.indexBuffer = r, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            const r = this.indexBuffer[e];
            return t_(this.dataBuffer, this.offsetBuffer[r], this.offsetBuffer[r + 1]);
          }
        }
        class ix extends r_ {
          indexBuffer;
          symbolOffsetBuffer;
          symbolTableBuffer;
          textEncoder;
          symbolLengthBuffer;
          lengthBuffer;
          decodedDictionary;
          constructor(e, r, c, f, m, v, E) {
            super(e, c, f, E), this.indexBuffer = r, this.symbolOffsetBuffer = m, this.symbolTableBuffer = v, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            this.decodedDictionary == null && (this.symbolLengthBuffer == null && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = (function(c, f, m) {
              const v = [], E = new Array(f.length).fill(0);
              for (let k = 1; k < f.length; k++) E[k] = E[k - 1] + f[k - 1];
              for (let k = 0; k < m.length; k++) if (m[k] === 255) v.push(m[++k]);
              else {
                const P = f[m[k]], L = E[m[k]];
                for (let N = 0; N < P; N++) v.push(c[L + N]);
              }
              return new Uint8Array(v);
            })(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
            const r = this.indexBuffer[e];
            return t_(this.decodedDictionary, this.offsetBuffer[r], this.offsetBuffer[r + 1]);
          }
          offsetToLengthBuffer(e) {
            const r = new Uint32Array(e.length - 1);
            let c = e[0];
            for (let f = 1; f < e.length; f++) {
              const m = e[f];
              r[f - 1] = m - c, c = m;
            }
            return r;
          }
        }
        function lT(i, e, r, c, f, m) {
          return r.type === "scalarType" ? (function(v, E, k, P, L, N) {
            let G = null, j = 0;
            if (v === 0) return null;
            if (N.nullable) {
              const Y = Qi(E, k);
              j = Y.numValues;
              const J = k.get(), ie = jd(E, j, k);
              k.set(J + Y.byteLength), G = new Fa(ie, Y.numValues);
            }
            const Z = G ?? P;
            switch (L.physicalType) {
              case 4:
              case 3:
                return (function(Y, J, ie, ye, ae) {
                  const ue = Qi(Y, J), Ee = Np(ue, ae, Y, J), Le = ye.physicalType === 3;
                  if (Ee === fi.FLAT) {
                    const Ke = Vd(ae) ? Wm(Y, J, ue, Le, ae) : es(Y, J, ue, Le);
                    return new Vm(ie.name, Ke, ae);
                  }
                  if (Ee === fi.SEQUENCE) {
                    const Ke = G0(Y, J, ue);
                    return new qm(ie.name, Ke[0], Ke[1], ue.numRleValues);
                  }
                  {
                    const Ke = Ym(Y, J, ue, Le);
                    return new $m(ie.name, Ke, ae);
                  }
                })(E, k, N, L, Z);
              case 9:
                return (function(Y, J, ie, ye, ae) {
                  let ue = null, Ee = null, Le = null, Ke = null, dt = null, ht = null, mt = null, Pt = null;
                  for (let bt = 0; bt < ye; bt++) {
                    const ct = Qi(J, ie);
                    if (ct.byteLength !== 0) switch (ct.physicalStreamType) {
                      case Ci.PRESENT: {
                        const ot = jd(J, ct.numValues, ie);
                        ht = new Fa(ot, ct.numValues);
                        break;
                      }
                      case Ci.OFFSET:
                        Ee = ae != null || ht != null ? Wm(J, ie, ct, !1, ae ?? ht) : es(J, ie, ct, !1);
                        break;
                      case Ci.LENGTH: {
                        const ot = Gl(J, ie, ct);
                        Is.DICTIONARY === ct.logicalStreamType.lengthType ? ue = ot : Is.SYMBOL === ct.logicalStreamType.lengthType ? Ke = ot : mt = ot;
                        break;
                      }
                      case Ci.DATA: {
                        const ot = J.subarray(ie.get(), ie.get() + ct.byteLength);
                        ie.add(ct.byteLength);
                        const Nt = ct.logicalStreamType.dictionaryType;
                        Ra.FSST === Nt ? dt = ot : Ra.SINGLE === Nt || Ra.SHARED === Nt ? Le = ot : Ra.NONE === Nt && (Pt = ot);
                        break;
                      }
                    }
                  }
                  return (function(bt, ct, ot, Nt, Rt, Ut, Ft) {
                    return ct ? new ix(bt, ot, Nt, Rt, Ut, ct, Ft) : null;
                  })(Y, dt, Ee, ue, Le, Ke, ae ?? ht) ?? (function(bt, ct, ot, Nt, Rt) {
                    return ct ? Rt ? new gh(bt, ot, Nt, ct, Rt) : new gh(bt, ot, Nt, ct) : null;
                  })(Y, Le, Ee, ue, ae ?? ht) ?? (function(bt, ct, ot, Nt, Rt) {
                    if (!ct || !ot) return null;
                    if (Nt) return Rt ? new gh(bt, Nt, ct, ot, Rt) : new gh(bt, Nt, ct, ot);
                    if (Rt && Rt.size() !== ct.length - 1) {
                      const Ut = new Int32Array(Rt.size());
                      let Ft = 0;
                      for (let Ht = 0; Ht < Rt.size(); Ht++) Ut[Ht] = Rt.get(Ht) ? Ft++ : 0;
                      return new gh(bt, Ut, ct, ot, Rt);
                    }
                    return Rt ? new nx(bt, ct, ot, Rt) : new nx(bt, ct, ot);
                  })(Y, mt, Pt, Ee, ae ?? ht);
                })(N.name, E, k, N.nullable ? v - 1 : v, G);
              case 0:
                return (function(Y, J, ie, ye, ae) {
                  const ue = Qi(Y, J), Ee = ue.numValues, Le = J.get(), Ke = Vd(ae) ? (function(ht, mt, Pt, bt) {
                    const ct = rx(ht, Math.ceil(mt / 8), Pt), ot = new Fa(ct, mt), Nt = bt.size(), Rt = new Fa(new Uint8Array(Nt), Nt);
                    let Ut = 0;
                    for (let Ft = 0; Ft < bt.size(); Ft++) {
                      const Ht = !!bt.get(Ft) && ot.get(Ut++);
                      Rt.set(Ft, Ht);
                    }
                    return Rt.getBuffer();
                  })(Y, Ee, J, ae) : jd(Y, Ee, J);
                  J.set(Le + ue.byteLength);
                  const dt = new Fa(Ke, Ee);
                  return new sT(ie.name, dt, ae);
                })(E, k, N, 0, Z);
              case 6:
              case 5:
                return (function(Y, J, ie, ye, ae) {
                  const ue = Qi(Y, J), Ee = Np(ue, ye, Y, J), Le = ae.physicalType === 5;
                  if (Ee === fi.FLAT) {
                    const Ke = Vd(ye) ? (function(dt, ht, mt, Pt, bt) {
                      return (function(ct, ot, Nt, Rt) {
                        switch (ot.logicalLevelTechnique1) {
                          case xr.DELTA:
                            return ot.logicalLevelTechnique2 === xr.RLE && (ct = O0(ct, ot.runs, ot.numRleValues)), (function(Ut, Ft) {
                              const Ht = new BigInt64Array(Ut.size());
                              let Tr = 0;
                              Ut.get(0) ? (Ht[0] = Ut.get(0) ? Ft[0] >> 1n ^ -(1n & Ft[0]) : 0n, Tr = 1) : Ht[0] = 0n;
                              let yr = 1;
                              for (; yr != Ht.length; ++yr) Ht[yr] = Ut.get(yr) ? Ht[yr - 1] + (Ft[Tr] >> 1n ^ -(1n & Ft[Tr++])) : Ht[yr - 1];
                              return Ht;
                            })(Rt, ct);
                          case xr.RLE:
                            return (function(Ut, Ft, Ht, Tr) {
                              const yr = Ft;
                              return Ht ? (function(fn, Ai, Zn) {
                                const pn = new BigInt64Array(fn.size());
                                let on = 0;
                                for (let Rr = 0; Rr < Zn; Rr++) {
                                  const Tn = Number(Ai[Rr]);
                                  let Ln = Ai[Rr + Zn];
                                  Ln = Ln >> 1n ^ -(1n & Ln);
                                  for (let Kr = on; Kr < on + Tn; Kr++) fn.get(Kr) ? pn[Kr] = Ln : (pn[Kr] = 0n, on++);
                                  on += Tn;
                                }
                                return pn;
                              })(Tr, Ut, yr.runs) : (function(fn, Ai, Zn) {
                                const pn = new BigInt64Array(fn.size());
                                let on = 0;
                                for (let Rr = 0; Rr < Zn; Rr++) {
                                  const Tn = Number(Ai[Rr]), Ln = Ai[Rr + Zn];
                                  for (let Kr = on; Kr < on + Tn; Kr++) fn.get(Kr) ? pn[Kr] = Ln : (pn[Kr] = 0n, on++);
                                  on += Tn;
                                }
                                return pn;
                              })(Tr, Ut, yr.runs);
                            })(ct, ot, Nt, Rt);
                          case xr.NONE:
                            return ct = Nt ? (function(Ut, Ft) {
                              const Ht = new BigInt64Array(Ut.size());
                              let Tr = 0, yr = 0;
                              for (; yr != Ht.length; ++yr) if (Ut.get(yr)) {
                                const fn = Ft[Tr++];
                                Ht[yr] = fn >> 1n ^ -(1n & fn);
                              } else Ht[yr] = 0n;
                              return Ht;
                            })(Rt, ct) : (function(Ut, Ft) {
                              const Ht = new BigInt64Array(Ut.size());
                              let Tr = 0, yr = 0;
                              for (; yr != Ht.length; ++yr) Ht[yr] = Ut.get(yr) ? Ft[Tr++] : 0n;
                              return Ht;
                            })(Rt, ct), ct;
                          default:
                            throw new Error("The specified Logical level technique is not supported");
                        }
                      })(Rp(dt, ht, mt.numValues), mt, Pt, bt);
                    })(Y, J, ue, Le, ye) : V0(Y, J, ue, Le);
                    return new q0(ie.name, Ke, ye);
                  }
                  if (Ee === fi.SEQUENCE) {
                    const Ke = j0(Y, J, ue);
                    return new $0(ie.name, Ke[0], Ke[1], ue.numRleValues);
                  }
                  {
                    const Ke = U0(Y, J, ue, Le);
                    return new tx(ie.name, Ke, ye);
                  }
                })(E, k, N, Z, L);
              case 7:
                return (function(Y, J, ie, ye) {
                  const ae = Qi(Y, J), ue = Vd(ye) ? (function(Ee, Le, Ke, dt) {
                    const ht = Le.get(), mt = ht + dt * Float32Array.BYTES_PER_ELEMENT, Pt = new Uint8Array(Ee.subarray(ht, mt)).buffer, bt = new Float32Array(Pt);
                    Le.set(mt);
                    const ct = Ke.size(), ot = new Float32Array(ct);
                    let Nt = 0;
                    for (let Rt = 0; Rt < ct; Rt++) ot[Rt] = Ke.get(Rt) ? bt[Nt++] : 0;
                    return ot;
                  })(Y, J, ye, ae.numValues) : (function(Ee, Le, Ke) {
                    const dt = Le.get(), ht = dt + Ke * Float32Array.BYTES_PER_ELEMENT, mt = new Uint8Array(Ee.subarray(dt, ht)).buffer, Pt = new Float32Array(mt);
                    return Le.set(ht), Pt;
                  })(Y, J, ae.numValues);
                  return new aT(ie.name, ue, ye);
                })(E, k, N, Z);
              case 8:
                return (function(Y, J, ie, ye) {
                  const ae = Qi(Y, J), ue = Vd(ye) ? (function(Ee, Le, Ke, dt) {
                    const ht = Le.get(), mt = ht + dt * Float64Array.BYTES_PER_ELEMENT, Pt = new Uint8Array(Ee.subarray(ht, mt)).buffer, bt = new Float64Array(Pt);
                    Le.set(mt);
                    const ct = Ke.size(), ot = new Float64Array(ct);
                    let Nt = 0;
                    for (let Rt = 0; Rt < ct; Rt++) ot[Rt] = Ke.get(Rt) ? bt[Nt++] : 0;
                    return ot;
                  })(Y, J, ye, ae.numValues) : (function(Ee, Le, Ke) {
                    const dt = Le.get(), ht = dt + Ke * Float64Array.BYTES_PER_ELEMENT, mt = new Uint8Array(Ee.subarray(dt, ht)).buffer, Pt = new Float64Array(mt);
                    return Le.set(ht), Pt;
                  })(Y, J, ae.numValues);
                  return new Um(ie.name, ue, ye);
                })(E, k, N, Z);
              default:
                throw new Error(`The specified data type for the field is currently not supported: ${L}`);
            }
          })(c, i, e, f, r.scalarType, r) : c != 1 ? null : (function(v, E, k, P) {
            let L = null, N = null, G = null, j = null, Z = !1;
            for (; !Z; ) {
              const ye = Qi(v, E);
              switch (ye.physicalStreamType) {
                case Ci.LENGTH:
                  Is.DICTIONARY === ye.logicalStreamType.lengthType ? L = Gl(v, E, ye) : G = Gl(v, E, ye);
                  break;
                case Ci.DATA:
                  Ra.SINGLE === ye.logicalStreamType.dictionaryType || Ra.SHARED === ye.logicalStreamType.dictionaryType ? (N = v.subarray(E.get(), E.get() + ye.byteLength), Z = !0) : j = v.subarray(E.get(), E.get() + ye.byteLength), E.add(ye.byteLength);
              }
            }
            const Y = k.complexType.children, J = [];
            let ie = 0;
            for (const ye of Y) {
              const ae = Si(v, E, 1)[0];
              if (ae == 0) continue;
              const ue = `${k.name}${ye.name === "default" ? "" : ":" + ye.name}`;
              if (ae !== 2 || ye.type !== "scalarField" || ye.scalarField.physicalType !== 9) throw new Error("Currently only optional string fields are implemented for a struct.");
              const Ee = Qi(v, E), Le = jd(v, Ee.numValues, E), Ke = Qi(v, E), dt = Ke.decompressedCount !== P ? Wm(v, E, Ke, !1, new Fa(Le, Ee.numValues)) : es(v, E, Ke, !1);
              J[ie++] = j ? new ix(ue, dt, L, N, G, j, new Fa(Le, Ee.numValues)) : new gh(ue, dt, L, N, new Fa(Le, Ee.numValues));
            }
            return J;
          })(i, e, r, f);
        }
        function Vd(i) {
          return i instanceof Fa;
        }
        function uT(i) {
          if (i.name === "id") return !1;
          if (i.type === "scalarType") {
            const e = i.scalarType;
            if (e.type === "physicalType") switch (e.physicalType) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              default:
                return !1;
              case 9:
                return !0;
            }
            else if (e.type === "logicalType") return !1;
          } else if (i.type === "complexType") {
            const e = i.complexType;
            if (e.type === "physicalType") switch (e.physicalType) {
              case 0:
              case 1:
                return !0;
              default:
                return !1;
            }
          }
          return console.warn("Unexpected column type in hasStreamCount", i), !1;
        }
        const cT = new TextDecoder();
        function sx(i, e) {
          const r = Si(i, e, 1)[0];
          if (r === 0) return "";
          const c = e.get(), f = i.subarray(c, c + r);
          return e.add(r), cT.decode(f);
        }
        function ax(i, e) {
          const r = Si(i, e, 1)[0] >>> 0, c = !!(4 & r), f = !!(2 & r), m = Si(i, e, 1)[0] >>> 0, v = {};
          if (1 & r && (v.nullable = !0), f) {
            const E = {};
            if (c ? (E.type = "logicalType", E.logicalType = m) : (E.type = "physicalType", E.physicalType = m), 8 & r) {
              const k = Si(i, e, 1)[0] >>> 0;
              E.children = new Array(k);
              for (let P = 0; P < k; P++) E.children[P] = ax(i, e);
            }
            v.type = "complexField", v.complexField = E;
          } else {
            const E = {};
            c ? (E.type = "logicalType", E.logicalType = m) : (E.type = "physicalType", E.physicalType = m), v.type = "scalarField", v.scalarField = E;
          }
          return v;
        }
        function hT(i, e) {
          const r = Si(i, e, 1)[0] >>> 0, c = (function(f) {
            switch (f) {
              case 0:
              case 1:
              case 2:
              case 3: {
                const m = {};
                m.nullable = !!(1 & f), m.columnScope = 0;
                const v = {};
                return v.physicalType = f > 1 ? 6 : 4, v.type = "physicalType", m.scalarType = v, m.type = "scalarType", m;
              }
              case 4: {
                const m = { nullable: !1, columnScope: 0 }, v = { type: "physicalType", physicalType: 0 };
                return m.type = "complexType", m.complexType = v, m;
              }
              case 30: {
                const m = { nullable: !1, columnScope: 0 }, v = { type: "physicalType", physicalType: 1 };
                return m.type = "complexType", m.complexType = v, m;
              }
              default:
                return (function(m) {
                  let v = null;
                  switch (m) {
                    case 10:
                    case 11:
                      v = 0;
                      break;
                    case 12:
                    case 13:
                      v = 1;
                      break;
                    case 14:
                    case 15:
                      v = 2;
                      break;
                    case 16:
                    case 17:
                      v = 3;
                      break;
                    case 18:
                    case 19:
                      v = 4;
                      break;
                    case 20:
                    case 21:
                      v = 5;
                      break;
                    case 22:
                    case 23:
                      v = 6;
                      break;
                    case 24:
                    case 25:
                      v = 7;
                      break;
                    case 26:
                    case 27:
                      v = 8;
                      break;
                    case 28:
                    case 29:
                      v = 9;
                      break;
                    default:
                      return null;
                  }
                  const E = {};
                  E.nullable = !!(1 & m), E.columnScope = 0;
                  const k = { type: "physicalType" };
                  return k.physicalType = v, E.type = "scalarType", E.scalarType = k, E;
                })(f);
            }
          })(r);
          if (!c) throw new Error(`Unsupported column type code: ${r}`);
          if ((function(f) {
            return f >= 10;
          })(r) ? c.name = sx(i, e) : r >= 0 && r <= 3 ? c.name = "id" : r === 4 && (c.name = "geometry"), /* @__PURE__ */ (function(f) {
            return f === 30;
          })(r)) {
            const f = Si(i, e, 1)[0] >>> 0, m = c.complexType;
            m.children = new Array(f);
            for (let v = 0; v < f; v++) m.children[v] = ax(i, e);
          }
          return c;
        }
        function dT(i, e) {
          const r = { featureTables: [] }, c = {};
          c.name = sx(i, e);
          const f = Si(i, e, 1)[0] >>> 0, m = Si(i, e, 1)[0] >>> 0;
          c.columns = new Array(m);
          for (let v = 0; v < m; v++) c.columns[v] = hT(i, e);
          return r.featureTables.push(c), [r, f];
        }
        function fT(i, e, r, c, f, m, v = !1) {
          const E = e.scalarType.physicalType, k = Np(f, m, i, r);
          if (E === 4) switch (k) {
            case fi.FLAT: {
              const P = es(i, r, f, !1);
              return new Vm(c, P, m);
            }
            case fi.SEQUENCE: {
              const P = G0(i, r, f);
              return new qm(c, P[0], P[1], f.numRleValues);
            }
            case fi.CONST: {
              const P = Ym(i, r, f, !1);
              return new $m(c, P, m);
            }
          }
          else switch (k) {
            case fi.FLAT: {
              if (v) {
                const L = (function(N, G, j, Z) {
                  const Y = (function(J, ie, ye) {
                    const ae = new Float64Array(ie);
                    for (let ue = 0; ue < ie; ue++) ae[ue] = QS(J, ye);
                    return ae;
                  })(N, j.numValues, G);
                  return (function(J, ie, ye) {
                    switch (ie.logicalLevelTechnique1) {
                      case xr.DELTA:
                        return ie.logicalLevelTechnique2 === xr.RLE && (J = z0(J, ie.runs, ie.numRleValues)), (function(ae) {
                          ae[0] = ae[0] % 2 == 1 ? (ae[0] + 1) / -2 : ae[0] / 2;
                          const ue = ae.length / 4 * 4;
                          let Ee = 1;
                          if (ue >= 4) for (; Ee < ue - 4; Ee += 4) {
                            const Le = ae[Ee], Ke = ae[Ee + 1], dt = ae[Ee + 2], ht = ae[Ee + 3];
                            ae[Ee] = (Le % 2 == 1 ? (Le + 1) / -2 : Le / 2) + ae[Ee - 1], ae[Ee + 1] = (Ke % 2 == 1 ? (Ke + 1) / -2 : Ke / 2) + ae[Ee], ae[Ee + 2] = (dt % 2 == 1 ? (dt + 1) / -2 : dt / 2) + ae[Ee + 1], ae[Ee + 3] = (ht % 2 == 1 ? (ht + 1) / -2 : ht / 2) + ae[Ee + 2];
                          }
                          for (; Ee != ae.length; ++Ee) ae[Ee] = (ae[Ee] % 2 == 1 ? (ae[Ee] + 1) / -2 : ae[Ee] / 2) + ae[Ee - 1];
                        })(J), J;
                      case xr.RLE:
                        return (function(ae, ue, Ee) {
                          return z0(ae, ue.runs, ue.numRleValues);
                        })(J, ie);
                      case xr.NONE:
                        return J;
                      default:
                        throw new Error(`The specified Logical level technique is not supported: ${ie.logicalLevelTechnique1}`);
                    }
                  })(Y, j);
                })(i, r, f);
                return new Um(c, L, m);
              }
              const P = V0(i, r, f, !1);
              return new q0(c, P, m);
            }
            case fi.SEQUENCE: {
              const P = j0(i, r, f);
              return new $0(c, P[0], P[1], f.numRleValues);
            }
            case fi.CONST: {
              const P = U0(i, r, f, !1);
              return new tx(c, P, m);
            }
          }
          throw new Error("Vector type not supported for id column.");
        }
        class pT {
          constructor(e, r) {
            var c;
            switch (this._featureData = e, this.properties = this._featureData.properties || {}, (c = this._featureData.geometry) === null || c === void 0 ? void 0 : c.type) {
              case pi.POINT:
              case pi.MULTIPOINT:
                this.type = 1;
                break;
              case pi.LINESTRING:
              case pi.MULTILINESTRING:
                this.type = 2;
                break;
              case pi.POLYGON:
              case pi.MULTIPOLYGON:
                this.type = 3;
                break;
              default:
                this.type = 0;
            }
            this.extent = r, this.id = Number(this._featureData.id);
          }
          loadGeometry() {
            const e = [];
            for (const r of this._featureData.geometry.coordinates) {
              const c = [];
              for (const f of r) c.push(new R(f.x, f.y));
              e.push(c);
            }
            return e;
          }
        }
        class gT {
          constructor(e) {
            this.features = [], this.featureTable = e, this.name = e.name, this.extent = e.extent, this.version = 2, this.features = e.getFeatures(), this.length = this.features.length;
          }
          feature(e) {
            return new pT(this.features[e], this.extent);
          }
        }
        class ox {
          constructor(e) {
            this.layers = {};
            const r = (function(c, f, m = !0) {
              const v = new KS(0), E = [];
              for (; v.get() < c.length; ) {
                const k = Si(c, v, 1)[0] >>> 0, P = v.get() + k;
                if (P > c.length) throw new Error(`Block overruns tile: ${P} > ${c.length}`);
                if (Si(c, v, 1)[0] >>> 0 != 1) {
                  v.set(P);
                  continue;
                }
                const L = dT(c, v), N = L[1], G = L[0].featureTables[0];
                let j = null, Z = null;
                const Y = [];
                let J = 0;
                for (const ye of G.columns) {
                  const ae = ye.name;
                  if (ae === "id") {
                    let ue = null;
                    if (ye.nullable) {
                      const Le = Qi(c, v), Ke = v.get(), dt = jd(c, Le.numValues, v);
                      v.set(Ke + Le.byteLength), ue = new Fa(dt, Le.numValues);
                    }
                    const Ee = Qi(c, v);
                    J = Ee.decompressedCount, j = fT(c, ye, v, ae, Ee, ue ?? J, m);
                  } else if (ae === "geometry") {
                    const ue = Si(c, v, 1)[0];
                    if (J === 0) {
                      const Ee = v.get();
                      J = Qi(c, v).decompressedCount, v.set(Ee);
                    }
                    Z = iT(c, ue, v, J);
                  } else {
                    const ue = uT(ye) ? Si(c, v, 1)[0] : 1;
                    if (ue === 0 && ye.type === "scalarType") continue;
                    const Ee = lT(c, v, ye, ue, J);
                    if (Ee) if (Array.isArray(Ee)) for (const Le of Ee) Y.push(Le);
                    else Y.push(Ee);
                  }
                }
                const ie = new JS(G.name, Z, j, Y, N);
                E.push(ie), v.set(P);
              }
              return E;
            })(new Uint8Array(e));
            this.layers = r.reduce(((c, f) => Object.assign(Object.assign({}, c), { [f.name]: new gT(f) })), {});
          }
        }
        class mT {
          constructor(e, r) {
            this.feature = e, this.type = e.type, this.properties = e.tags ? e.tags : {}, this.extent = r, "id" in e && (typeof e.id == "string" ? this.id = parseInt(e.id, 10) : typeof e.id != "number" || isNaN(e.id) || (this.id = e.id));
          }
          loadGeometry() {
            const e = [], r = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const c of r) {
              const f = [];
              for (const m of c) f.push(new R(m[0], m[1]));
              e.push(f);
            }
            return e;
          }
        }
        const Ud = "_geojsonTileLayer";
        function _T(i, e) {
          e.writeVarintField(15, i.version || 1), e.writeStringField(1, i.name || ""), e.writeVarintField(5, i.extent || 4096);
          const r = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let m = 0; m < i.length; m++) r.feature = i.feature(m), e.writeMessage(2, yT, r);
          const c = r.keys;
          for (const m of c) e.writeStringField(3, m);
          const f = r.values;
          for (const m of f) e.writeMessage(4, bT, m);
        }
        function yT(i, e) {
          if (!i.feature) return;
          const r = i.feature;
          r.id !== void 0 && e.writeVarintField(1, r.id), e.writeMessage(2, vT, i), e.writeVarintField(3, r.type), e.writeMessage(4, xT, r);
        }
        function vT(i, e) {
          for (const r in i.feature?.properties) {
            let c = i.feature.properties[r], f = i.keycache[r];
            if (c == null) continue;
            f === void 0 && (i.keys.push(r), f = i.keys.length - 1, i.keycache[r] = f), e.writeVarint(f), typeof c != "string" && typeof c != "boolean" && typeof c != "number" && (c = JSON.stringify(c));
            const m = typeof c + ":" + c;
            let v = i.valuecache[m];
            v === void 0 && (i.values.push(c), v = i.values.length - 1, i.valuecache[m] = v), e.writeVarint(v);
          }
        }
        function n_(i, e) {
          return (e << 3) + (7 & i);
        }
        function lx(i) {
          return i << 1 ^ i >> 31;
        }
        function xT(i, e) {
          const r = i.loadGeometry(), c = i.type;
          let f = 0, m = 0;
          for (const v of r) {
            let E = 1;
            c === 1 && (E = v.length), e.writeVarint(n_(1, E));
            const k = c === 3 ? v.length - 1 : v.length;
            for (let P = 0; P < k; P++) {
              P === 1 && c !== 1 && e.writeVarint(n_(2, k - 1));
              const L = v[P].x - f, N = v[P].y - m;
              e.writeVarint(lx(L)), e.writeVarint(lx(N)), f += L, m += N;
            }
            i.type === 3 && e.writeVarint(n_(7, 1));
          }
        }
        function bT(i, e) {
          const r = typeof i;
          r === "string" ? e.writeStringField(1, i) : r === "boolean" ? e.writeBooleanField(7, i) : r === "number" && (i % 1 != 0 ? e.writeDoubleField(3, i) : i < 0 ? e.writeSVarintField(6, i) : e.writeVarintField(5, i));
        }
        class ux {
          constructor(e, r) {
            this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Dl(Je, 16, 0), this.grid3D = new Dl(Je, 16, 0), this.featureIndexArray = new te(), this.promoteId = r;
          }
          insert(e, r, c, f, m, v) {
            const E = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(c, f, m);
            const k = v ? this.grid3D : this.grid;
            for (let P = 0; P < r.length; P++) {
              const L = r[P], N = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let G = 0; G < L.length; G++) {
                const j = L[G];
                N[0] = Math.min(N[0], j.x), N[1] = Math.min(N[1], j.y), N[2] = Math.max(N[2], j.x), N[3] = Math.max(N[3], j.y);
              }
              N[0] < Je && N[1] < Je && N[2] >= 0 && N[3] >= 0 && k.insert(E, N[0], N[1], N[2], N[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = this.encoding !== "mlt" ? new Yv(new Mp(this.rawTileData)).layers : new ox(this.rawTileData).layers, this.sourceLayerCoder = new A0(this.vtLayers ? Object.keys(this.vtLayers).sort() : [Ud])), this.vtLayers;
          }
          query(e, r, c, f) {
            this.loadVTLayers();
            const m = e.params, v = Je / e.tileSize / e.scale, E = Iu(m.filter, m.globalState), k = e.queryGeometry, P = e.queryPadding * v, L = Ju.fromPoints(k), N = this.grid.query(L.minX - P, L.minY - P, L.maxX + P, L.maxY + P), G = Ju.fromPoints(e.cameraQueryGeometry).expandBy(P), j = this.grid3D.query(G.minX, G.minY, G.maxX, G.maxY, ((J, ie, ye, ae) => (function(ue, Ee, Le, Ke, dt) {
              for (const mt of ue) if (Ee <= mt.x && Le <= mt.y && Ke >= mt.x && dt >= mt.y) return !0;
              const ht = [new R(Ee, Le), new R(Ee, dt), new R(Ke, dt), new R(Ke, Le)];
              if (ue.length > 2) {
                for (const mt of ht) if (nh(ue, mt)) return !0;
              }
              for (let mt = 0; mt < ue.length - 1; mt++) if (EE(ue[mt], ue[mt + 1], ht)) return !0;
              return !1;
            })(e.cameraQueryGeometry, J - P, ie - P, ye + P, ae + P)));
            for (const J of j) N.push(J);
            N.sort(wT);
            const Z = {};
            let Y;
            for (let J = 0; J < N.length; J++) {
              const ie = N[J];
              if (ie === Y) continue;
              Y = ie;
              const ye = this.featureIndexArray.get(ie);
              let ae = null;
              this.loadMatchingFeature(Z, ye.bucketIndex, ye.sourceLayerIndex, ye.featureIndex, E, m.layers, m.availableImages, r, c, f, ((ue, Ee, Le) => (ae || (ae = po(ue)), Ee.queryIntersectsFeature({ queryGeometry: k, feature: ue, featureState: Le, geometry: ae, zoom: this.z, transform: e.transform, pixelsToTileUnits: v, pixelPosMatrix: e.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e.getElevation }))));
            }
            return Z;
          }
          loadMatchingFeature(e, r, c, f, m, v, E, k, P, L, N) {
            const G = this.bucketLayerIDs[r];
            if (v && !G.some(((J) => v.has(J)))) return;
            const j = this.sourceLayerCoder.decode(c), Z = this.vtLayers[j].feature(f);
            if (m.needGeometry) {
              const J = go(Z, !0);
              if (!m.filter(new Vr(this.tileID.overscaledZ), J, this.tileID.canonical)) return;
            } else if (!m.filter(new Vr(this.tileID.overscaledZ), Z)) return;
            const Y = this.getId(Z, j);
            for (let J = 0; J < G.length; J++) {
              const ie = G[J];
              if (v && !v.has(ie)) continue;
              const ye = k[ie];
              if (!ye) continue;
              let ae = {};
              Y && L && (ae = L.getState(ye.sourceLayer || Ud, Y));
              const ue = He({}, P[ie]);
              ue.paint = cx(ue.paint, ye.paint, Z, ae, E), ue.layout = cx(ue.layout, ye.layout, Z, ae, E);
              const Ee = !N || N(Z, ye, ae);
              if (!Ee) continue;
              const Le = new L0(Z, this.z, this.x, this.y, Y);
              Le.layer = ue;
              let Ke = e[ie];
              Ke === void 0 && (Ke = e[ie] = []), Ke.push({ featureIndex: f, feature: Le, intersectionZ: Ee });
            }
          }
          lookupSymbolFeatures(e, r, c, f, m, v, E, k) {
            const P = {};
            this.loadVTLayers();
            const L = Iu(m.filterSpec, m.globalState);
            for (const N of e) this.loadMatchingFeature(P, c, f, N, L, v, E, k, r);
            return P;
          }
          hasLayer(e) {
            for (const r of this.bucketLayerIDs) for (const c of r) if (e === c) return !0;
            return !1;
          }
          getId(e, r) {
            var c;
            let f = e.id;
            return this.promoteId && (f = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof f == "boolean" && (f = Number(f)), f === void 0 && (!((c = e.properties) === null || c === void 0) && c.cluster) && this.promoteId && (f = Number(e.properties.cluster_id))), f;
          }
        }
        function cx(i, e, r, c, f) {
          return fr(i, ((m, v) => {
            const E = e instanceof Gu ? e.get(v) : null;
            return E && E.evaluate ? E.evaluate(r, c, f) : E;
          }));
        }
        function wT(i, e) {
          return e - i;
        }
        function hx(i, e, r, c, f) {
          const m = [];
          for (let v = 0; v < i.length; v++) {
            const E = i[v];
            let k;
            for (let P = 0; P < E.length - 1; P++) {
              let L = E[P], N = E[P + 1];
              L.x < e && N.x < e || (L.x < e ? L = new R(e, L.y + (e - L.x) / (N.x - L.x) * (N.y - L.y))._round() : N.x < e && (N = new R(e, L.y + (e - L.x) / (N.x - L.x) * (N.y - L.y))._round()), L.y < r && N.y < r || (L.y < r ? L = new R(L.x + (r - L.y) / (N.y - L.y) * (N.x - L.x), r)._round() : N.y < r && (N = new R(L.x + (r - L.y) / (N.y - L.y) * (N.x - L.x), r)._round()), L.x >= c && N.x >= c || (L.x >= c ? L = new R(c, L.y + (c - L.x) / (N.x - L.x) * (N.y - L.y))._round() : N.x >= c && (N = new R(c, L.y + (c - L.x) / (N.x - L.x) * (N.y - L.y))._round()), L.y >= f && N.y >= f || (L.y >= f ? L = new R(L.x + (f - L.y) / (N.y - L.y) * (N.x - L.x), f)._round() : N.y >= f && (N = new R(L.x + (f - L.y) / (N.y - L.y) * (N.x - L.x), f)._round()), k && L.equals(k[k.length - 1]) || (k = [L], m.push(k)), k.push(N)))));
            }
          }
          return m;
        }
        function dx(i, e, r, c, f) {
          switch (e) {
            case 1:
              return (function(m, v, E, k) {
                const P = [];
                for (const L of m) for (const N of L) {
                  const G = k === 0 ? N.x : N.y;
                  G >= v && G <= E && P.push([N]);
                }
                return P;
              })(i, r, c, f);
            case 2:
              return fx(i, r, c, f, !1);
            case 3:
              return fx(i, r, c, f, !0);
          }
          return [];
        }
        function ET(i, e, r, c, f) {
          const m = c === 0 ? ST : TT;
          let v = [];
          const E = [];
          for (let L = 0; L < i.length - 1; L++) {
            const N = i[L], G = i[L + 1], j = c === 0 ? N.x : N.y, Z = c === 0 ? G.x : G.y;
            let Y = !1;
            j < e ? Z > e && v.push(m(N, G, e)) : j > r ? Z < r && v.push(m(N, G, r)) : v.push(N), Z < e && j >= e && (v.push(m(N, G, e)), Y = !0), Z > r && j <= r && (v.push(m(N, G, r)), Y = !0), !f && Y && (E.push(v), v = []);
          }
          const k = i.length - 1, P = c === 0 ? i[k].x : i[k].y;
          return P >= e && P <= r && v.push(i[k]), f && v.length > 0 && !v[0].equals(v[v.length - 1]) && v.push(new R(v[0].x, v[0].y)), v.length > 0 && E.push(v), E;
        }
        function fx(i, e, r, c, f) {
          const m = [];
          for (const v of i) {
            const E = ET(v, e, r, c, f);
            E.length > 0 && m.push(...E);
          }
          return m;
        }
        function ST(i, e, r) {
          return new R(r, i.y + (r - i.x) / (e.x - i.x) * (e.y - i.y));
        }
        function TT(i, e, r) {
          return new R(i.x + (r - i.y) / (e.y - i.y) * (e.x - i.x), r);
        }
        Vt("FeatureIndex", ux, { omit: ["rawTileData", "sourceLayerCoder"] });
        class jl extends R {
          constructor(e, r, c, f) {
            super(e, r), this.angle = c, f !== void 0 && (this.segment = f);
          }
          clone() {
            return new jl(this.x, this.y, this.angle, this.segment);
          }
        }
        function px(i, e, r, c, f) {
          if (e.segment === void 0 || r === 0) return !0;
          let m = e, v = e.segment + 1, E = 0;
          for (; E > -r / 2; ) {
            if (v--, v < 0) return !1;
            E -= i[v].dist(m), m = i[v];
          }
          E += i[v].dist(i[v + 1]), v++;
          const k = [];
          let P = 0;
          for (; E < r / 2; ) {
            const L = i[v], N = i[v + 1];
            if (!N) return !1;
            let G = i[v - 1].angleTo(L) - L.angleTo(N);
            for (G = Math.abs((G + 3 * Math.PI) % (2 * Math.PI) - Math.PI), k.push({ distance: E, angleDelta: G }), P += G; E - k[0].distance > c; ) P -= k.shift().angleDelta;
            if (P > f) return !1;
            v++, E += L.dist(N);
          }
          return !0;
        }
        function gx(i) {
          let e = 0;
          for (let r = 0; r < i.length - 1; r++) e += i[r].dist(i[r + 1]);
          return e;
        }
        function mx(i, e, r) {
          return i ? 0.6 * e * r : 0;
        }
        function _x(i, e) {
          return Math.max(i ? i.right - i.left : 0, e ? e.right - e.left : 0);
        }
        function kT(i, e, r, c, f, m) {
          const v = mx(r, f, m), E = _x(r, c) * m;
          let k = 0;
          const P = gx(i) / 2;
          for (let L = 0; L < i.length - 1; L++) {
            const N = i[L], G = i[L + 1], j = N.dist(G);
            if (k + j > P) {
              const Z = (P - k) / j, Y = Xr.number(N.x, G.x, Z), J = Xr.number(N.y, G.y, Z), ie = new jl(Y, J, G.angleTo(N), L);
              return ie._round(), !v || px(i, ie, E, v, e) ? ie : void 0;
            }
            k += j;
          }
        }
        function IT(i, e, r, c, f, m, v, E, k) {
          const P = mx(c, m, v), L = _x(c, f), N = L * v, G = i[0].x === 0 || i[0].x === k || i[0].y === 0 || i[0].y === k;
          return e - N < e / 4 && (e = N + e / 4), yx(i, G ? e / 2 * E % e : (L / 2 + 2 * m) * v * E % e, e, P, r, N, G, !1, k);
        }
        function yx(i, e, r, c, f, m, v, E, k) {
          const P = m / 2, L = gx(i);
          let N = 0, G = e - r, j = [];
          for (let Z = 0; Z < i.length - 1; Z++) {
            const Y = i[Z], J = i[Z + 1], ie = Y.dist(J), ye = J.angleTo(Y);
            for (; G + r < N + ie; ) {
              G += r;
              const ae = (G - N) / ie, ue = Xr.number(Y.x, J.x, ae), Ee = Xr.number(Y.y, J.y, ae);
              if (ue >= 0 && ue < k && Ee >= 0 && Ee < k && G - P >= 0 && G + P <= L) {
                const Le = new jl(ue, Ee, ye, Z);
                Le._round(), c && !px(i, Le, m, c, f) || j.push(Le);
              }
            }
            N += ie;
          }
          return E || j.length || v || (j = yx(i, N / 2, r, c, f, m, v, !0, k)), j;
        }
        function vx(i, e, r, c) {
          const f = [], m = i.image, v = m.pixelRatio, E = m.paddedRect.w - 2, k = m.paddedRect.h - 2;
          let P = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
          const L = m.stretchX || [[0, E]], N = m.stretchY || [[0, k]], G = (ot, Nt) => ot + Nt[1] - Nt[0], j = L.reduce(G, 0), Z = N.reduce(G, 0), Y = E - j, J = k - Z;
          let ie = 0, ye = j, ae = 0, ue = Z, Ee = 0, Le = Y, Ke = 0, dt = J;
          if (m.content && c) {
            const ot = m.content, Nt = ot[2] - ot[0], Rt = ot[3] - ot[1];
            (m.textFitWidth || m.textFitHeight) && (P = p0(i)), ie = Gp(L, 0, ot[0]), ae = Gp(N, 0, ot[1]), ye = Gp(L, ot[0], ot[2]), ue = Gp(N, ot[1], ot[3]), Ee = ot[0] - ie, Ke = ot[1] - ae, Le = Nt - ye, dt = Rt - ue;
          }
          const ht = P.x1, mt = P.y1, Pt = P.x2 - ht, bt = P.y2 - mt, ct = (ot, Nt, Rt, Ut) => {
            const Ft = jp(ot.stretch - ie, ye, Pt, ht), Ht = Vp(ot.fixed - Ee, Le, ot.stretch, j), Tr = jp(Nt.stretch - ae, ue, bt, mt), yr = Vp(Nt.fixed - Ke, dt, Nt.stretch, Z), fn = jp(Rt.stretch - ie, ye, Pt, ht), Ai = Vp(Rt.fixed - Ee, Le, Rt.stretch, j), Zn = jp(Ut.stretch - ae, ue, bt, mt), pn = Vp(Ut.fixed - Ke, dt, Ut.stretch, Z), on = new R(Ft, Tr), Rr = new R(fn, Tr), Tn = new R(fn, Zn), Ln = new R(Ft, Zn), Kr = new R(Ht / v, yr / v), cs = new R(Ai / v, pn / v), Li = e * Math.PI / 180;
            if (Li) {
              const gi = Math.sin(Li), vn = Math.cos(Li), Hn = [vn, -gi, gi, vn];
              on._matMult(Hn), Rr._matMult(Hn), Ln._matMult(Hn), Tn._matMult(Hn);
            }
            const hs = ot.stretch + ot.fixed, ua = Nt.stretch + Nt.fixed;
            return { tl: on, tr: Rr, bl: Ln, br: Tn, tex: { x: m.paddedRect.x + 1 + hs, y: m.paddedRect.y + 1 + ua, w: Rt.stretch + Rt.fixed - hs, h: Ut.stretch + Ut.fixed - ua }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Kr, pixelOffsetBR: cs, minFontScaleX: Le / v / Pt, minFontScaleY: dt / v / bt, isSDF: r };
          };
          if (c && (m.stretchX || m.stretchY)) {
            const ot = xx(L, Y, j), Nt = xx(N, J, Z);
            for (let Rt = 0; Rt < ot.length - 1; Rt++) {
              const Ut = ot[Rt], Ft = ot[Rt + 1];
              for (let Ht = 0; Ht < Nt.length - 1; Ht++) f.push(ct(Ut, Nt[Ht], Ft, Nt[Ht + 1]));
            }
          } else f.push(ct({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: E + 1 }, { fixed: 0, stretch: k + 1 }));
          return f;
        }
        function Gp(i, e, r) {
          let c = 0;
          for (const f of i) c += Math.max(e, Math.min(r, f[1])) - Math.max(e, Math.min(r, f[0]));
          return c;
        }
        function xx(i, e, r) {
          const c = [{ fixed: -1, stretch: 0 }];
          for (const [f, m] of i) {
            const v = c[c.length - 1];
            c.push({ fixed: f - v.stretch, stretch: v.stretch }), c.push({ fixed: f - v.stretch, stretch: v.stretch + (m - f) });
          }
          return c.push({ fixed: e + 1, stretch: r }), c;
        }
        function jp(i, e, r, c) {
          return i / e * r + c;
        }
        function Vp(i, e, r, c) {
          return i - e * r / c;
        }
        Vt("Anchor", jl);
        class Up {
          constructor(e, r, c, f, m, v, E, k, P, L) {
            var N;
            if (this.boxStartIndex = e.length, P) {
              let G = v.top, j = v.bottom;
              const Z = v.collisionPadding;
              Z && (G -= Z[1], j += Z[3]);
              let Y = j - G;
              Y > 0 && (Y = Math.max(10, Y), this.circleDiameter = Y);
            } else {
              const G = !((N = v.image) === null || N === void 0) && N.content && (v.image.textFitWidth || v.image.textFitHeight) ? p0(v) : { x1: v.left, y1: v.top, x2: v.right, y2: v.bottom };
              G.y1 = G.y1 * E - k[0], G.y2 = G.y2 * E + k[2], G.x1 = G.x1 * E - k[3], G.x2 = G.x2 * E + k[1];
              const j = v.collisionPadding;
              if (j && (G.x1 -= j[0] * E, G.y1 -= j[1] * E, G.x2 += j[2] * E, G.y2 += j[3] * E), L) {
                const Z = new R(G.x1, G.y1), Y = new R(G.x2, G.y1), J = new R(G.x1, G.y2), ie = new R(G.x2, G.y2), ye = L * Math.PI / 180;
                Z._rotate(ye), Y._rotate(ye), J._rotate(ye), ie._rotate(ye), G.x1 = Math.min(Z.x, Y.x, J.x, ie.x), G.x2 = Math.max(Z.x, Y.x, J.x, ie.x), G.y1 = Math.min(Z.y, Y.y, J.y, ie.y), G.y2 = Math.max(Z.y, Y.y, J.y, ie.y);
              }
              e.emplaceBack(r.x, r.y, G.x1, G.y1, G.x2, G.y2, c, f, m);
            }
            this.boxEndIndex = e.length;
          }
        }
        class MT {
          constructor(e = [], r = (c, f) => c < f ? -1 : c > f ? 1 : 0) {
            if (this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (let c = (this.length >> 1) - 1; c >= 0; c--) this._down(c);
          }
          push(e) {
            this.data.push(e), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const e = this.data[0], r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), e;
          }
          peek() {
            return this.data[0];
          }
          _up(e) {
            const { data: r, compare: c } = this, f = r[e];
            for (; e > 0; ) {
              const m = e - 1 >> 1, v = r[m];
              if (c(f, v) >= 0) break;
              r[e] = v, e = m;
            }
            r[e] = f;
          }
          _down(e) {
            const { data: r, compare: c } = this, f = this.length >> 1, m = r[e];
            for (; e < f; ) {
              let v = 1 + (e << 1);
              const E = v + 1;
              if (E < this.length && c(r[E], r[v]) < 0 && (v = E), c(r[v], m) >= 0) break;
              r[e] = r[v], e = v;
            }
            r[e] = m;
          }
        }
        function CT(i, e = 1, r = !1) {
          const c = Ju.fromPoints(i[0]), f = Math.min(c.width(), c.height());
          let m = f / 2;
          const v = new MT([], PT), { minX: E, minY: k, maxX: P, maxY: L } = c;
          if (f === 0) return new R(E, k);
          for (let j = E; j < P; j += f) for (let Z = k; Z < L; Z += f) v.push(new mh(j + m, Z + m, m, i));
          let N = (function(j) {
            let Z = 0, Y = 0, J = 0;
            const ie = j[0];
            for (let ye = 0, ae = ie.length, ue = ae - 1; ye < ae; ue = ye++) {
              const Ee = ie[ye], Le = ie[ue], Ke = Ee.x * Le.y - Le.x * Ee.y;
              Y += (Ee.x + Le.x) * Ke, J += (Ee.y + Le.y) * Ke, Z += 3 * Ke;
            }
            return new mh(Y / Z, J / Z, 0, j);
          })(i), G = v.length;
          for (; v.length; ) {
            const j = v.pop();
            (j.d > N.d || !N.d) && (N = j, r && console.log("found best %d after %d probes", Math.round(1e4 * j.d) / 1e4, G)), j.max - N.d <= e || (m = j.h / 2, v.push(new mh(j.p.x - m, j.p.y - m, m, i)), v.push(new mh(j.p.x + m, j.p.y - m, m, i)), v.push(new mh(j.p.x - m, j.p.y + m, m, i)), v.push(new mh(j.p.x + m, j.p.y + m, m, i)), G += 4);
          }
          return r && (console.log(`num probes: ${G}`), console.log(`best distance: ${N.d}`)), N.p;
        }
        function PT(i, e) {
          return e.max - i.max;
        }
        function mh(i, e, r, c) {
          this.p = new R(i, e), this.h = r, this.d = (function(f, m) {
            let v = !1, E = 1 / 0;
            for (let k = 0; k < m.length; k++) {
              const P = m[k];
              for (let L = 0, N = P.length, G = N - 1; L < N; G = L++) {
                const j = P[L], Z = P[G];
                j.y > f.y != Z.y > f.y && f.x < (Z.x - j.x) * (f.y - j.y) / (Z.y - j.y) + j.x && (v = !v), E = Math.min(E, Tv(f, j, Z));
              }
            }
            return (v ? 1 : -1) * Math.sqrt(E);
          })(this.p, c), this.max = this.d + this.h * Math.SQRT2;
        }
        var Pi;
        S.aP = void 0, (Pi = S.aP || (S.aP = {}))[Pi.center = 1] = "center", Pi[Pi.left = 2] = "left", Pi[Pi.right = 3] = "right", Pi[Pi.top = 4] = "top", Pi[Pi.bottom = 5] = "bottom", Pi[Pi["top-left"] = 6] = "top-left", Pi[Pi["top-right"] = 7] = "top-right", Pi[Pi["bottom-left"] = 8] = "bottom-left", Pi[Pi["bottom-right"] = 9] = "bottom-right";
        const i_ = Number.POSITIVE_INFINITY;
        function bx(i, e) {
          return e[1] !== i_ ? (function(r, c, f) {
            let m = 0, v = 0;
            switch (c = Math.abs(c), f = Math.abs(f), r) {
              case "top-right":
              case "top-left":
              case "top":
                v = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                v = 7 - f;
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                m = -c;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                m = c;
            }
            return [m, v];
          })(i, e[0], e[1]) : (function(r, c) {
            let f = 0, m = 0;
            c < 0 && (c = 0);
            const v = c / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                m = v - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                m = 7 - v;
                break;
              case "bottom":
                m = 7 - c;
                break;
              case "top":
                m = c - 7;
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                f = -v;
                break;
              case "top-left":
              case "bottom-left":
                f = v;
                break;
              case "left":
                f = c;
                break;
              case "right":
                f = -c;
            }
            return [f, m];
          })(i, e[0]);
        }
        function wx(i, e, r) {
          var c;
          const f = i.layout, m = (c = f.get("text-variable-anchor-offset")) === null || c === void 0 ? void 0 : c.evaluate(e, {}, r);
          if (m) {
            const E = m.values, k = [];
            for (let P = 0; P < E.length; P += 2) {
              const L = k[P] = E[P], N = E[P + 1].map(((G) => G * di));
              L.startsWith("top") ? N[1] -= 7 : L.startsWith("bottom") && (N[1] += 7), k[P + 1] = N;
            }
            return new oi(k);
          }
          const v = f.get("text-variable-anchor");
          if (v) {
            let E;
            E = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [f.get("text-radial-offset").evaluate(e, {}, r) * di, i_] : f.get("text-offset").evaluate(e, {}, r).map(((P) => P * di));
            const k = [];
            for (const P of v) k.push(P, bx(P, E));
            return new oi(k);
          }
          return null;
        }
        function s_(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function AT(i, e, r, c, f, m, v, E, k, P, L, N) {
          let G = m.textMaxSize.evaluate(e, {});
          G === void 0 && (G = v);
          const j = i.layers[0].layout, Z = j.get("icon-offset").evaluate(e, {}, L), Y = Sx(r.horizontal), J = v / 24, ie = i.tilePixelRatio * J, ye = i.tilePixelRatio * G / 24, ae = i.tilePixelRatio * E, ue = i.tilePixelRatio * j.get("symbol-spacing"), Ee = j.get("text-padding") * i.tilePixelRatio, Le = (function(Rt, Ut, Ft, Ht = 1) {
            const Tr = Rt.get("icon-padding").evaluate(Ut, {}, Ft), yr = Tr && Tr.values;
            return [yr[0] * Ht, yr[1] * Ht, yr[2] * Ht, yr[3] * Ht];
          })(j, e, L, i.tilePixelRatio), Ke = j.get("text-max-angle") / 180 * Math.PI, dt = j.get("text-rotation-alignment") !== "viewport" && j.get("symbol-placement") !== "point", ht = j.get("icon-rotation-alignment") === "map" && j.get("symbol-placement") !== "point", mt = j.get("symbol-placement"), Pt = ue / 2, bt = j.get("icon-text-fit");
          let ct;
          c && bt !== "none" && (i.allowVerticalPlacement && r.vertical && (ct = g0(c, r.vertical, bt, j.get("icon-text-fit-padding"), Z, J)), Y && (c = g0(c, Y, bt, j.get("icon-text-fit-padding"), Z, J)));
          const ot = L ? N.line.getGranularityForZoomLevel(L.z) : 1, Nt = (Rt, Ut) => {
            Ut.x < 0 || Ut.x >= Je || Ut.y < 0 || Ut.y >= Je || (function(Ft, Ht, Tr, yr, fn, Ai, Zn, pn, on, Rr, Tn, Ln, Kr, cs, Li, hs, ua, gi, vn, Hn, kn, mi, el, Na, Zd) {
              const Vl = Ft.addToLineVertexArray(Ht, Tr);
              let ec, _h, yh, vh, Mx = 0, Cx = 0, Px = 0, Ax = 0, f_ = -1, p_ = -1;
              const tl = {};
              let Lx = An("");
              if (Ft.allowVerticalPlacement && yr.vertical) {
                const qi = pn.layout.get("text-rotate").evaluate(kn, {}, Na) + 90;
                yh = new Up(on, Ht, Rr, Tn, Ln, yr.vertical, Kr, cs, Li, qi), Zn && (vh = new Up(on, Ht, Rr, Tn, Ln, Zn, ua, gi, Li, qi));
              }
              if (fn) {
                const qi = pn.layout.get("icon-rotate").evaluate(kn, {}), Hs = pn.layout.get("icon-text-fit") !== "none", tc = vx(fn, qi, el, Hs), za = Zn ? vx(Zn, qi, el, Hs) : void 0;
                _h = new Up(on, Ht, Rr, Tn, Ln, fn, ua, gi, !1, qi), Mx = 4 * tc.length;
                const rc = Ft.iconSizeData;
                let mo = null;
                rc.kind === "source" ? (mo = [Ko * pn.layout.get("icon-size").evaluate(kn, {})], mo[0] > zl && ur(`${Ft.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : rc.kind === "composite" && (mo = [Ko * mi.compositeIconSizes[0].evaluate(kn, {}, Na), Ko * mi.compositeIconSizes[1].evaluate(kn, {}, Na)], (mo[0] > zl || mo[1] > zl) && ur(`${Ft.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Ft.addSymbols(Ft.icon, tc, mo, Hn, vn, kn, S.az.none, Ht, Vl.lineStartIndex, Vl.lineLength, -1, Na), f_ = Ft.icon.placedSymbolArray.length - 1, za && (Cx = 4 * za.length, Ft.addSymbols(Ft.icon, za, mo, Hn, vn, kn, S.az.vertical, Ht, Vl.lineStartIndex, Vl.lineLength, -1, Na), p_ = Ft.icon.placedSymbolArray.length - 1);
              }
              const Dx = Object.keys(yr.horizontal);
              for (const qi of Dx) {
                const Hs = yr.horizontal[qi];
                if (!ec) {
                  Lx = An(Hs.text);
                  const za = pn.layout.get("text-rotate").evaluate(kn, {}, Na);
                  ec = new Up(on, Ht, Rr, Tn, Ln, Hs, Kr, cs, Li, za);
                }
                const tc = Hs.positionedLines.length === 1;
                if (Px += Ex(Ft, Ht, Hs, Ai, pn, Li, kn, hs, Vl, yr.vertical ? S.az.horizontal : S.az.horizontalOnly, tc ? Dx : [qi], tl, f_, mi, Na), tc) break;
              }
              yr.vertical && (Ax += Ex(Ft, Ht, yr.vertical, Ai, pn, Li, kn, hs, Vl, S.az.vertical, ["vertical"], tl, p_, mi, Na));
              const RT = ec ? ec.boxStartIndex : Ft.collisionBoxArray.length, FT = ec ? ec.boxEndIndex : Ft.collisionBoxArray.length, NT = yh ? yh.boxStartIndex : Ft.collisionBoxArray.length, OT = yh ? yh.boxEndIndex : Ft.collisionBoxArray.length, zT = _h ? _h.boxStartIndex : Ft.collisionBoxArray.length, BT = _h ? _h.boxEndIndex : Ft.collisionBoxArray.length, GT = vh ? vh.boxStartIndex : Ft.collisionBoxArray.length, jT = vh ? vh.boxEndIndex : Ft.collisionBoxArray.length;
              let Oa = -1;
              const $p = (qi, Hs) => qi && qi.circleDiameter ? Math.max(qi.circleDiameter, Hs) : Hs;
              Oa = $p(ec, Oa), Oa = $p(yh, Oa), Oa = $p(_h, Oa), Oa = $p(vh, Oa);
              const Rx = Oa > -1 ? 1 : 0;
              Rx && (Oa *= Zd / di), Ft.glyphOffsetArray.length >= ch.MAX_GLYPHS && ur("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), kn.sortKey !== void 0 && Ft.addToSortKeyRanges(Ft.symbolInstances.length, kn.sortKey);
              const VT = wx(pn, kn, Na), [UT, qT] = (function(qi, Hs) {
                const tc = qi.length, za = Hs?.values;
                if (za?.length > 0) for (let rc = 0; rc < za.length; rc += 2) {
                  const mo = za[rc + 1];
                  qi.emplaceBack(S.aP[za[rc]], mo[0], mo[1]);
                }
                return [tc, qi.length];
              })(Ft.textAnchorOffsets, VT);
              Ft.symbolInstances.emplaceBack(Ht.x, Ht.y, tl.right >= 0 ? tl.right : -1, tl.center >= 0 ? tl.center : -1, tl.left >= 0 ? tl.left : -1, tl.vertical || -1, f_, p_, Lx, RT, FT, NT, OT, zT, BT, GT, jT, Rr, Px, Ax, Mx, Cx, Rx, 0, Kr, Oa, UT, qT);
            })(i, Ut, Rt, r, c, f, ct, i.layers[0], i.collisionBoxArray, e.index, e.sourceLayerIndex, i.index, ie, [Ee, Ee, Ee, Ee], dt, k, ae, Le, ht, Z, e, m, P, L, v);
          };
          if (mt === "line") for (const Rt of hx(e.geometry, 0, 0, Je, Je)) {
            const Ut = Xu(Rt, ot), Ft = IT(Ut, ue, Ke, r.vertical || Y, c, 24, ye, i.overscaling, Je);
            for (const Ht of Ft) Y && LT(i, Y.text, Pt, Ht) || Nt(Ut, Ht);
          }
          else if (mt === "line-center") {
            for (const Rt of e.geometry) if (Rt.length > 1) {
              const Ut = Xu(Rt, ot), Ft = kT(Ut, Ke, r.vertical || Y, c, 24, ye);
              Ft && Nt(Ut, Ft);
            }
          } else if (e.type === "Polygon") for (const Rt of zo(e.geometry, 0)) {
            const Ut = CT(Rt, 16);
            Nt(Xu(Rt[0], ot, !0), new jl(Ut.x, Ut.y, 0));
          }
          else if (e.type === "LineString") for (const Rt of e.geometry) {
            const Ut = Xu(Rt, ot);
            Nt(Ut, new jl(Ut[0].x, Ut[0].y, 0));
          }
          else if (e.type === "Point") for (const Rt of e.geometry) for (const Ut of Rt) Nt([Ut], new jl(Ut.x, Ut.y, 0));
        }
        function Ex(i, e, r, c, f, m, v, E, k, P, L, N, G, j, Z) {
          const Y = (function(ye, ae, ue, Ee, Le, Ke, dt, ht) {
            const mt = Ee.layout.get("text-rotate").evaluate(Ke, {}) * Math.PI / 180, Pt = [];
            for (const bt of ae.positionedLines) for (const ct of bt.positionedGlyphs) {
              if (!ct.rect) continue;
              const ot = ct.rect || {};
              let Nt = 4, Rt = !0, Ut = 1, Ft = 0;
              const Ht = (Le || ht) && ct.vertical, Tr = ct.metrics.advance * ct.scale / 2;
              if (ht && ae.verticalizable && (Ft = bt.lineOffset / 2 - (ct.imageName ? -(di - ct.metrics.width * ct.scale) / 2 : (ct.scale - 1) * di)), ct.imageName) {
                const gi = dt[ct.imageName];
                Rt = gi.sdf, Ut = gi.pixelRatio, Nt = 1 / Ut;
              }
              const yr = Le ? [ct.x + Tr, ct.y] : [0, 0];
              let fn = Le ? [0, 0] : [ct.x + Tr + ue[0], ct.y + ue[1] - Ft], Ai = [0, 0];
              Ht && (Ai = fn, fn = [0, 0]);
              const Zn = ct.metrics.isDoubleResolution ? 2 : 1, pn = (ct.metrics.left - Nt) * ct.scale - Tr + fn[0], on = (-ct.metrics.top - Nt) * ct.scale + fn[1], Rr = pn + ot.w / Zn * ct.scale / Ut, Tn = on + ot.h / Zn * ct.scale / Ut, Ln = new R(pn, on), Kr = new R(Rr, on), cs = new R(pn, Tn), Li = new R(Rr, Tn);
              if (Ht) {
                const gi = new R(-Tr, Tr - -17), vn = -Math.PI / 2, Hn = 12 - Tr, kn = new R(22 - Hn, -(ct.imageName ? Hn : 0)), mi = new R(...Ai);
                Ln._rotateAround(vn, gi)._add(kn)._add(mi), Kr._rotateAround(vn, gi)._add(kn)._add(mi), cs._rotateAround(vn, gi)._add(kn)._add(mi), Li._rotateAround(vn, gi)._add(kn)._add(mi);
              }
              if (mt) {
                const gi = Math.sin(mt), vn = Math.cos(mt), Hn = [vn, -gi, gi, vn];
                Ln._matMult(Hn), Kr._matMult(Hn), cs._matMult(Hn), Li._matMult(Hn);
              }
              const hs = new R(0, 0), ua = new R(0, 0);
              Pt.push({ tl: Ln, tr: Kr, bl: cs, br: Li, tex: ot, writingMode: ae.writingMode, glyphOffset: yr, sectionIndex: ct.sectionIndex, isSDF: Rt, pixelOffsetTL: hs, pixelOffsetBR: ua, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Pt;
          })(0, r, E, f, m, v, c, i.allowVerticalPlacement), J = i.textSizeData;
          let ie = null;
          J.kind === "source" ? (ie = [Ko * f.layout.get("text-size").evaluate(v, {})], ie[0] > zl && ur(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : J.kind === "composite" && (ie = [Ko * j.compositeTextSizes[0].evaluate(v, {}, Z), Ko * j.compositeTextSizes[1].evaluate(v, {}, Z)], (ie[0] > zl || ie[1] > zl) && ur(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, Y, ie, E, m, v, P, e, k.lineStartIndex, k.lineLength, G, Z);
          for (const ye of L) N[ye] = i.text.placedSymbolArray.length - 1;
          return 4 * Y.length;
        }
        function Sx(i) {
          for (const e in i) return i[e];
          return null;
        }
        function LT(i, e, r, c) {
          const f = i.compareText;
          if (e in f) {
            const m = f[e];
            for (let v = m.length - 1; v >= 0; v--) if (c.dist(m[v]) < r) return !0;
          } else f[e] = [];
          return f[e].push(c), !1;
        }
        const Tx = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class a_ {
          static from(e) {
            if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, c] = new Uint8Array(e, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const f = c >> 4;
            if (f !== 1) throw new Error(`Got v${f} data when expected v1.`);
            const m = Tx[15 & c];
            if (!m) throw new Error("Unrecognized array type.");
            const [v] = new Uint16Array(e, 2, 1), [E] = new Uint32Array(e, 4, 1);
            return new a_(E, v, m, e);
          }
          constructor(e, r = 64, c = Float64Array, f) {
            if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
            this.numItems = +e, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = c, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
            const m = Tx.indexOf(this.ArrayType), v = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, E = e * this.IndexArrayType.BYTES_PER_ELEMENT, k = (8 - E % 8) % 8;
            if (m < 0) throw new Error(`Unexpected typed array class: ${c}.`);
            f && f instanceof ArrayBuffer ? (this.data = f, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + E + k, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + v + E + k), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + E + k, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + m]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = e);
          }
          add(e, r) {
            const c = this._pos >> 1;
            return this.ids[c] = c, this.coords[this._pos++] = e, this.coords[this._pos++] = r, c;
          }
          finish() {
            const e = this._pos >> 1;
            if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
            return o_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(e, r, c, f) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: m, coords: v, nodeSize: E } = this, k = [0, m.length - 1, 0], P = [];
            for (; k.length; ) {
              const L = k.pop() || 0, N = k.pop() || 0, G = k.pop() || 0;
              if (N - G <= E) {
                for (let J = G; J <= N; J++) {
                  const ie = v[2 * J], ye = v[2 * J + 1];
                  ie >= e && ie <= c && ye >= r && ye <= f && P.push(m[J]);
                }
                continue;
              }
              const j = G + N >> 1, Z = v[2 * j], Y = v[2 * j + 1];
              Z >= e && Z <= c && Y >= r && Y <= f && P.push(m[j]), (L === 0 ? e <= Z : r <= Y) && (k.push(G), k.push(j - 1), k.push(1 - L)), (L === 0 ? c >= Z : f >= Y) && (k.push(j + 1), k.push(N), k.push(1 - L));
            }
            return P;
          }
          within(e, r, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: f, coords: m, nodeSize: v } = this, E = [0, f.length - 1, 0], k = [], P = c * c;
            for (; E.length; ) {
              const L = E.pop() || 0, N = E.pop() || 0, G = E.pop() || 0;
              if (N - G <= v) {
                for (let J = G; J <= N; J++) Ix(m[2 * J], m[2 * J + 1], e, r) <= P && k.push(f[J]);
                continue;
              }
              const j = G + N >> 1, Z = m[2 * j], Y = m[2 * j + 1];
              Ix(Z, Y, e, r) <= P && k.push(f[j]), (L === 0 ? e - c <= Z : r - c <= Y) && (E.push(G), E.push(j - 1), E.push(1 - L)), (L === 0 ? e + c >= Z : r + c >= Y) && (E.push(j + 1), E.push(N), E.push(1 - L));
            }
            return k;
          }
        }
        function o_(i, e, r, c, f, m) {
          if (f - c <= r) return;
          const v = c + f >> 1;
          kx(i, e, v, c, f, m), o_(i, e, r, c, v - 1, 1 - m), o_(i, e, r, v + 1, f, 1 - m);
        }
        function kx(i, e, r, c, f, m) {
          for (; f > c; ) {
            if (f - c > 600) {
              const P = f - c + 1, L = r - c + 1, N = Math.log(P), G = 0.5 * Math.exp(2 * N / 3), j = 0.5 * Math.sqrt(N * G * (P - G) / P) * (L - P / 2 < 0 ? -1 : 1);
              kx(i, e, r, Math.max(c, Math.floor(r - L * G / P + j)), Math.min(f, Math.floor(r + (P - L) * G / P + j)), m);
            }
            const v = e[2 * r + m];
            let E = c, k = f;
            for (qd(i, e, c, r), e[2 * f + m] > v && qd(i, e, c, f); E < k; ) {
              for (qd(i, e, E, k), E++, k--; e[2 * E + m] < v; ) E++;
              for (; e[2 * k + m] > v; ) k--;
            }
            e[2 * c + m] === v ? qd(i, e, c, k) : (k++, qd(i, e, k, f)), k <= r && (c = k + 1), r <= k && (f = k - 1);
          }
        }
        function qd(i, e, r, c) {
          l_(i, r, c), l_(e, 2 * r, 2 * c), l_(e, 2 * r + 1, 2 * c + 1);
        }
        function l_(i, e, r) {
          const c = i[e];
          i[e] = i[r], i[r] = c;
        }
        function Ix(i, e, r, c) {
          const f = i - r, m = e - c;
          return f * f + m * m;
        }
        var u_;
        S.cI = void 0, (u_ = S.cI || (S.cI = {})).create = "create", u_.load = "load", u_.fullLoad = "fullLoad";
        let qp = null, $d = [];
        const c_ = 1e3 / 60, h_ = "loadTime", d_ = "fullLoadTime", DT = { mark(i) {
          performance.mark(i);
        }, frame(i) {
          const e = i;
          qp != null && $d.push(e - qp), qp = e;
        }, clearMetrics() {
          qp = null, $d = [], performance.clearMeasures(h_), performance.clearMeasures(d_);
          for (const i in S.cI) performance.clearMarks(S.cI[i]);
        }, getPerformanceMetrics() {
          performance.measure(h_, S.cI.create, S.cI.load), performance.measure(d_, S.cI.create, S.cI.fullLoad);
          const i = performance.getEntriesByName(h_)[0].duration, e = performance.getEntriesByName(d_)[0].duration, r = $d.length, c = 1 / ($d.reduce(((m, v) => m + v), 0) / r / 1e3), f = $d.filter(((m) => m > c_)).reduce(((m, v) => m + (v - c_) / c_), 0);
          return { loadTime: i, fullLoadTime: e, fps: c, percentDroppedFrames: f / (r + f) * 100, totalFrames: r };
        } };
        S.$ = ne, S.A = Ue, S.B = Ll, S.C = ci, S.D = $t, S.E = vt, S.F = function([i, e, r]) {
          return e += 90, e *= Math.PI / 180, r *= Math.PI / 180, { x: i * Math.cos(e) * Math.sin(r), y: i * Math.sin(e) * Math.sin(r), z: i * Math.cos(r) };
        }, S.G = Xr, S.H = Vr, S.I = Lm, S.J = lp, S.K = function(i) {
          if (Dr == null) {
            const e = i.navigator ? i.navigator.userAgent : null;
            Dr = !!i.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
          }
          return Dr;
        }, S.L = class {
          constructor(i, e) {
            this.target = i, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new YS((() => this.process())), this.subscription = Ls(this.target, "message", ((r) => this.receive(r)), !1), this.globalScope = ni(self) ? i : window;
          }
          registerMessageHandler(i, e) {
            this.messageHandlers[i] = e;
          }
          unregisterMessageHandler(i) {
            delete this.messageHandlers[i];
          }
          sendAsync(i, e) {
            return new Promise(((r, c) => {
              const f = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), m = e ? Ls(e.signal, "abort", (() => {
                m?.unsubscribe(), delete this.resolveRejects[f];
                const k = { id: f, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(k);
              }), WS) : null;
              this.resolveRejects[f] = { resolve: (k) => {
                m?.unsubscribe(), r(k);
              }, reject: (k) => {
                m?.unsubscribe(), c(k);
              } };
              const v = [], E = Object.assign(Object.assign({}, i), { id: f, sourceMapId: this.mapId, origin: location.origin, data: Nu(i.data, v) });
              this.target.postMessage(E, { transfer: v });
            }));
          }
          receive(i) {
            const e = i.data, r = e.id;
            if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== "resource://android" && location.origin !== "resource://android" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) {
              if (e.type === "<cancel>") {
                delete this.tasks[r];
                const c = this.abortControllers[r];
                return delete this.abortControllers[r], void (c && c.abort());
              }
              if (ni(self) || e.mustQueue) return this.tasks[r] = e, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, e);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(), e = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(i, e);
          }
          processTask(i, e) {
            return u(this, void 0, void 0, (function* () {
              if (e.type === "<response>") {
                const f = this.resolveRejects[i];
                return delete this.resolveRejects[i], f ? void (e.error ? f.reject(Ou(e.error)) : f.resolve(Ou(e.data))) : void 0;
              }
              if (!this.messageHandlers[e.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = Ou(e.data), c = new AbortController();
              this.abortControllers[i] = c;
              try {
                const f = yield this.messageHandlers[e.type](e.sourceMapId, r, c);
                this.completeTask(i, null, f);
              } catch (f) {
                this.completeTask(i, f);
              }
            }));
          }
          completeTask(i, e, r) {
            const c = [];
            delete this.abortControllers[i];
            const f = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? Nu(e) : null, data: Nu(r, c) };
            this.target.postMessage(f, { transfer: c });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, S.M = re, S.N = function() {
          var i = new Ue(16);
          return Ue != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
        }, S.O = function(i, e, r) {
          var c, f, m, v, E, k, P, L, N, G, j, Z, Y = r[0], J = r[1], ie = r[2];
          return e === i ? (i[12] = e[0] * Y + e[4] * J + e[8] * ie + e[12], i[13] = e[1] * Y + e[5] * J + e[9] * ie + e[13], i[14] = e[2] * Y + e[6] * J + e[10] * ie + e[14], i[15] = e[3] * Y + e[7] * J + e[11] * ie + e[15]) : (f = e[1], m = e[2], v = e[3], E = e[4], k = e[5], P = e[6], L = e[7], N = e[8], G = e[9], j = e[10], Z = e[11], i[0] = c = e[0], i[1] = f, i[2] = m, i[3] = v, i[4] = E, i[5] = k, i[6] = P, i[7] = L, i[8] = N, i[9] = G, i[10] = j, i[11] = Z, i[12] = c * Y + E * J + N * ie + e[12], i[13] = f * Y + k * J + G * ie + e[13], i[14] = m * Y + P * J + j * ie + e[14], i[15] = v * Y + L * J + Z * ie + e[15]), i;
        }, S.P = R, S.Q = function(i, e, r) {
          var c = r[0], f = r[1], m = r[2];
          return i[0] = e[0] * c, i[1] = e[1] * c, i[2] = e[2] * c, i[3] = e[3] * c, i[4] = e[4] * f, i[5] = e[5] * f, i[6] = e[6] * f, i[7] = e[7] * f, i[8] = e[8] * m, i[9] = e[9] * m, i[10] = e[10] * m, i[11] = e[11] * m, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
        }, S.R = us, S.S = function(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = e[3], E = e[4], k = e[5], P = e[6], L = e[7], N = e[8], G = e[9], j = e[10], Z = e[11], Y = e[12], J = e[13], ie = e[14], ye = e[15], ae = r[0], ue = r[1], Ee = r[2], Le = r[3];
          return i[0] = ae * c + ue * E + Ee * N + Le * Y, i[1] = ae * f + ue * k + Ee * G + Le * J, i[2] = ae * m + ue * P + Ee * j + Le * ie, i[3] = ae * v + ue * L + Ee * Z + Le * ye, i[4] = (ae = r[4]) * c + (ue = r[5]) * E + (Ee = r[6]) * N + (Le = r[7]) * Y, i[5] = ae * f + ue * k + Ee * G + Le * J, i[6] = ae * m + ue * P + Ee * j + Le * ie, i[7] = ae * v + ue * L + Ee * Z + Le * ye, i[8] = (ae = r[8]) * c + (ue = r[9]) * E + (Ee = r[10]) * N + (Le = r[11]) * Y, i[9] = ae * f + ue * k + Ee * G + Le * J, i[10] = ae * m + ue * P + Ee * j + Le * ie, i[11] = ae * v + ue * L + Ee * Z + Le * ye, i[12] = (ae = r[12]) * c + (ue = r[13]) * E + (Ee = r[14]) * N + (Le = r[15]) * Y, i[13] = ae * f + ue * k + Ee * G + Le * J, i[14] = ae * m + ue * P + Ee * j + Le * ie, i[15] = ae * v + ue * L + Ee * Z + Le * ye, i;
        }, S.T = Em, S.U = function(i, e) {
          const r = {};
          for (let c = 0; c < e.length; c++) {
            const f = e[c];
            f in i && (r[f] = i[f]);
          }
          return r;
        }, S.V = Bl, S.W = mr, S.X = S0, S.Y = E0, S.Z = Fe, S._ = u, S.a = os, S.a$ = ge, S.a0 = Pe, S.a1 = Zi, S.a2 = $s, S.a3 = k0, S.a4 = Lp, S.a5 = Je, S.a6 = function(i, e, r) {
          if (!i) return e || {};
          if (!e) return i || {};
          const c = P0(i), f = P0(e);
          (function(v, E) {
            E.removeAll && (v.add.clear(), v.update.clear(), v.remove.clear(), E.remove.clear());
            for (const k of E.remove) v.add.delete(k), v.update.delete(k);
            for (const [k, P] of E.update) {
              const L = v.update.get(k);
              L && (E.update.set(k, XS(L, P)), v.update.delete(k));
            }
          })(c, f);
          const m = {};
          if ((c.removeAll || f.removeAll) && (m.removeAll = !0), m.remove = /* @__PURE__ */ new Set([...c.remove, ...f.remove]), m.add = new Map([...c.add, ...f.add]), m.update = new Map([...c.update, ...f.update]), m.remove.size && m.add.size) for (const v of m.add.keys()) m.remove.delete(v);
          return (function(v) {
            const E = {};
            return v.removeAll && (E.removeAll = v.removeAll), v.remove && (E.remove = Array.from(v.remove)), v.add && (E.add = Array.from(v.add.values())), v.update && (E.update = Array.from(v.update.values())), E;
          })(m);
        }, S.a7 = function(i, e) {
          const r = /* @__PURE__ */ new Map();
          if (i == null || i.type == null) return r;
          if (i.type === "Feature") {
            const c = jm(i, e);
            return c == null ? void 0 : (r.set(c, i), r);
          }
          if (i.type === "FeatureCollection") {
            const c = /* @__PURE__ */ new Set();
            for (const f of i.features) {
              const m = jm(f, e);
              if (m == null || c.has(m)) return;
              c.add(m), r.set(m, f);
            }
            return r;
          }
        }, S.a8 = function(i, e, r) {
          var c, f;
          const m = [];
          if (e.removeAll) i.clear();
          else if (e.remove) for (const v of e.remove) {
            const E = i.get(v);
            E && (m.push(E.geometry), i.delete(v));
          }
          if (e.add) for (const v of e.add) {
            const E = jm(v, r);
            if (E == null) continue;
            const k = i.get(E);
            k && m.push(k.geometry), m.push(v.geometry), i.set(E, v);
          }
          if (e.update) for (const v of e.update) {
            const E = i.get(v.id);
            if (!E) continue;
            const k = !!v.newGeometry, P = v.removeAllProperties || ((c = v.removeProperties) === null || c === void 0 ? void 0 : c.length) > 0 || ((f = v.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0;
            if (!k && !P) continue;
            m.push(E.geometry);
            const L = Object.assign({}, E);
            if (i.set(v.id, L), k && (m.push(v.newGeometry), L.geometry = v.newGeometry), P) {
              if (L.properties = v.removeAllProperties ? {} : Object.assign({}, L.properties || {}), v.removeProperties) for (const N of v.removeProperties) delete L.properties[N];
              if (v.addOrUpdateProperties) for (const { key: N, value: G } of v.addOrUpdateProperties) L.properties[N] = G;
            }
          }
          return m;
        }, S.a9 = Gd, S.aA = function(i, { uSize: e, uSizeT: r }, { lowerSize: c, upperSize: f }) {
          return i.kind === "source" ? c / Ko : i.kind === "composite" ? Xr.number(c / Ko, f / Ko, r) : e;
        }, S.aB = function(i, e) {
          var r = e[0], c = e[1], f = e[2], m = e[3], v = e[4], E = e[5], k = e[6], P = e[7], L = e[8], N = e[9], G = e[10], j = e[11], Z = e[12], Y = e[13], J = e[14], ie = e[15], ye = r * E - c * v, ae = r * k - f * v, ue = r * P - m * v, Ee = c * k - f * E, Le = c * P - m * E, Ke = f * P - m * k, dt = L * Y - N * Z, ht = L * J - G * Z, mt = L * ie - j * Z, Pt = N * J - G * Y, bt = N * ie - j * Y, ct = G * ie - j * J, ot = ye * ct - ae * bt + ue * Pt + Ee * mt - Le * ht + Ke * dt;
          return ot ? (i[0] = (E * ct - k * bt + P * Pt) * (ot = 1 / ot), i[1] = (f * bt - c * ct - m * Pt) * ot, i[2] = (Y * Ke - J * Le + ie * Ee) * ot, i[3] = (G * Le - N * Ke - j * Ee) * ot, i[4] = (k * mt - v * ct - P * ht) * ot, i[5] = (r * ct - f * mt + m * ht) * ot, i[6] = (J * ue - Z * Ke - ie * ae) * ot, i[7] = (L * Ke - G * ue + j * ae) * ot, i[8] = (v * bt - E * mt + P * dt) * ot, i[9] = (c * mt - r * bt - m * dt) * ot, i[10] = (Z * Le - Y * ue + ie * ye) * ot, i[11] = (N * ue - L * Le - j * ye) * ot, i[12] = (E * ht - v * Pt - k * dt) * ot, i[13] = (r * Pt - c * ht + f * dt) * ot, i[14] = (Y * ae - Z * Ee - J * ye) * ot, i[15] = (L * Ee - N * ae + G * ye) * ot, i) : null;
        }, S.aC = Ge, S.aD = function(i) {
          var e = i[0], r = i[1];
          return Math.sqrt(e * e + r * r);
        }, S.aE = function(i) {
          return i[0] = 0, i[1] = 0, i;
        }, S.aF = function(i, e, r) {
          return i[0] = e[0] * r, i[1] = e[1] * r, i;
        }, S.aG = Fm, S.aH = Re, S.aI = function(i, e, r, c) {
          const f = e.y - i.y, m = e.x - i.x, v = c.y - r.y, E = c.x - r.x, k = v * m - E * f;
          if (k === 0) return null;
          const P = (E * (i.y - r.y) - v * (i.x - r.x)) / k;
          return new R(i.x + P * m, i.y + P * f);
        }, S.aJ = hx, S.aK = rh, S.aL = function(i) {
          let e = 1 / 0, r = 1 / 0, c = -1 / 0, f = -1 / 0;
          for (const m of i) e = Math.min(e, m.x), r = Math.min(r, m.y), c = Math.max(c, m.x), f = Math.max(f, m.y);
          return [e, r, c, f];
        }, S.aM = di, S.aN = ft, S.aO = function(i, e, r, c, f = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const m = f ? c === "map" ? -i.bearingInRadians : 0 : c === "viewport" ? i.bearingInRadians : 0;
          if (m) {
            const v = Math.sin(m), E = Math.cos(m);
            r = [r[0] * E - r[1] * v, r[0] * v + r[1] * E];
          }
          return [f ? r[0] : ft(e, r[0], i.zoom), f ? r[1] : ft(e, r[1], i.zoom)];
        }, S.aQ = Rm, S.aR = s_, S.aS = Dm, S.aT = a_, S.aU = Pn, S.aV = kp, S.aW = he, S.aX = Lt, S.aY = it, S.aZ = ln, S.a_ = I0, S.aa = Ju, S.ab = 25, S.ac = Gm, S.ad = (i) => {
          const e = window.document.createElement("video");
          return e.muted = !0, new Promise(((r) => {
            e.onloadstart = () => {
              r(e);
            };
            for (const c of i) {
              const f = window.document.createElement("source");
              We(c) || (e.crossOrigin = "Anonymous"), f.src = c, e.appendChild(f);
            }
          }));
        }, S.ae = pt, S.af = function() {
          return yi++;
        }, S.ag = g, S.ah = ch, S.ai = Ud, S.aj = Iu, S.ak = go, S.al = L0, S.am = function(i) {
          const e = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, c, f, m) => {
            const v = f || m;
            return e[c] = !v || v.toLowerCase(), "";
          })), e["max-age"]) {
            const r = parseInt(e["max-age"], 10);
            isNaN(r) ? delete e["max-age"] : e["max-age"] = r;
          }
          return e;
        }, S.an = Yt, S.ao = 85.051129, S.ap = tr, S.aq = function(i) {
          return Math.pow(2, i);
        }, S.ar = et, S.as = T0, S.at = function(i) {
          return Math.log(i) / Math.LN2;
        }, S.au = function(i) {
          var e = i[0], r = i[1];
          return e * e + r * r;
        }, S.av = function(i) {
          if (!i.length) return /* @__PURE__ */ new Set();
          const e = Math.max(...i.map(((k) => k.canonical.z)));
          let r = 1 / 0, c = -1 / 0, f = 1 / 0, m = -1 / 0;
          const v = [];
          for (const k of i) {
            const { x: P, y: L, z: N } = k.canonical, G = Math.pow(2, e - N), j = P * G, Z = L * G;
            v.push({ id: k, x: j, y: Z }), j < r && (r = j), j > c && (c = j), Z < f && (f = Z), Z > m && (m = Z);
          }
          const E = /* @__PURE__ */ new Set();
          for (const k of v) k.x !== r && k.x !== c && k.y !== f && k.y !== m || E.add(k.id);
          return E;
        }, S.aw = function(i, e) {
          const r = Math.abs(2 * i.wrap) - +(i.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return i.overscaledZ - e.overscaledZ || c - r || e.canonical.y - i.canonical.y || e.canonical.x - i.canonical.x;
        }, S.ax = class {
          constructor(i, e) {
            this.max = i, this.onRemove = e, this.reset();
          }
          reset() {
            for (const i in this.data) for (const e of this.data[i]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
            return this.data = {}, this.order = [], this;
          }
          add(i, e, r) {
            const c = i.wrapped().key;
            this.data[c] === void 0 && (this.data[c] = []);
            const f = { value: e, timeout: void 0 };
            if (r !== void 0 && (f.timeout = setTimeout((() => {
              this.remove(i, f);
            }), r)), this.data[c].push(f), this.order.push(c), this.order.length > this.max) {
              const m = this._getAndRemoveByKey(this.order[0]);
              m && this.onRemove(m);
            }
            return this;
          }
          has(i) {
            return i.wrapped().key in this.data;
          }
          getAndRemove(i) {
            return this.has(i) ? this._getAndRemoveByKey(i.wrapped().key) : null;
          }
          _getAndRemoveByKey(i) {
            const e = this.data[i].shift();
            return e.timeout && clearTimeout(e.timeout), this.data[i].length === 0 && delete this.data[i], this.order.splice(this.order.indexOf(i), 1), e.value;
          }
          getByKey(i) {
            const e = this.data[i];
            return e ? e[0].value : null;
          }
          get(i) {
            return this.has(i) ? this.data[i.wrapped().key][0].value : null;
          }
          remove(i, e) {
            if (!this.has(i)) return this;
            const r = i.wrapped().key, c = e === void 0 ? 0 : this.data[r].indexOf(e), f = this.data[r][c];
            return this.data[r].splice(c, 1), f.timeout && clearTimeout(f.timeout), this.data[r].length === 0 && delete this.data[r], this.onRemove(f.value), this.order.splice(this.order.indexOf(r), 1), this;
          }
          setMaxSize(i) {
            for (this.max = i; this.order.length > this.max; ) {
              const e = this._getAndRemoveByKey(this.order[0]);
              e && this.onRemove(e);
            }
            return this;
          }
          filter(i) {
            const e = [];
            for (const r in this.data) for (const c of this.data[r]) i(c.value) || e.push(c);
            for (const r of e) this.remove(r.value.tileID, r);
          }
        }, S.ay = function(i, e) {
          let r = 0, c = 0;
          if (i.kind === "constant") c = i.layoutSize;
          else if (i.kind !== "source") {
            const { interpolationType: f, minZoom: m, maxZoom: v } = i, E = f ? Yt(xi.interpolationFactor(f, e, m, v), 0, 1) : 0;
            i.kind === "camera" ? c = Xr.number(i.minSize, i.maxSize, E) : r = E;
          }
          return { uSizeT: r, uSize: c };
        }, S.b = ii, S.b$ = Xo, S.b0 = se, S.b1 = function(i) {
          var e = new Ue(3);
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e;
        }, S.b2 = function(i, e, r) {
          return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], i;
        }, S.b3 = function(i, e) {
          var r = e[0], c = e[1], f = e[2], m = r * r + c * c + f * f;
          return m > 0 && (m = 1 / Math.sqrt(m)), i[0] = e[0] * m, i[1] = e[1] * m, i[2] = e[2] * m, i;
        }, S.b4 = Se, S.b5 = function(i, e) {
          return i[0] * e[0] + i[1] * e[1] + i[2] * e[2];
        }, S.b6 = function(i, e, r) {
          return i[0] = e[0] * r[0], i[1] = e[1] * r[1], i[2] = e[2] * r[2], i[3] = e[3] * r[3], i;
        }, S.b7 = ut, S.b8 = function(i, e, r) {
          const c = e[0] * r[0] + e[1] * r[1] + e[2] * r[2];
          return c === 0 ? null : (-(i[0] * r[0] + i[1] * r[1] + i[2] * r[2]) - r[3]) / c;
        }, S.b9 = ze, S.bA = function() {
          return new Float64Array(3);
        }, S.bB = Ne, S.bC = function(i, e, r) {
          var c = r[0], f = r[1], m = r[2], v = r[3], E = e[0], k = e[1], P = e[2], L = f * P - m * k, N = m * E - c * P, G = c * k - f * E;
          return i[0] = E + v * (L += L) + f * (G += G) - m * (N += N), i[1] = k + v * N + m * L - c * G, i[2] = P + v * G + c * N - f * L, i;
        }, S.bD = function(i, e, r) {
          const c = (f = [i[0], i[1], i[2], e[0], e[1], e[2], r[0], r[1], r[2]])[0] * ((L = f[8]) * (v = f[4]) - (E = f[5]) * (P = f[7])) + f[1] * (-L * (m = f[3]) + E * (k = f[6])) + f[2] * (P * m - v * k);
          var f, m, v, E, k, P, L;
          if (c === 0) return null;
          const N = Se([], [e[0], e[1], e[2]], [r[0], r[1], r[2]]), G = Se([], [r[0], r[1], r[2]], [i[0], i[1], i[2]]), j = Se([], [i[0], i[1], i[2]], [e[0], e[1], e[2]]), Z = ge([], N, -i[3]);
          return se(Z, Z, ge([], G, -e[3])), se(Z, Z, ge([], j, -r[3])), ge(Z, Z, 1 / c), Z;
        }, S.bE = Bm, S.bF = function() {
          return new Float64Array(4);
        }, S.bG = function(i, e, r, c) {
          var f = [], m = [];
          return f[0] = e[0] - r[0], f[1] = e[1] - r[1], f[2] = e[2] - r[2], m[0] = f[0] * Math.cos(c) - f[1] * Math.sin(c), m[1] = f[0] * Math.sin(c) + f[1] * Math.cos(c), m[2] = f[2], i[0] = m[0] + r[0], i[1] = m[1] + r[1], i[2] = m[2] + r[2], i;
        }, S.bH = function(i, e, r, c) {
          var f = [], m = [];
          return f[0] = e[0] - r[0], f[1] = e[1] - r[1], f[2] = e[2] - r[2], m[0] = f[0], m[1] = f[1] * Math.cos(c) - f[2] * Math.sin(c), m[2] = f[1] * Math.sin(c) + f[2] * Math.cos(c), i[0] = m[0] + r[0], i[1] = m[1] + r[1], i[2] = m[2] + r[2], i;
        }, S.bI = function(i, e, r, c) {
          var f = [], m = [];
          return f[0] = e[0] - r[0], f[1] = e[1] - r[1], f[2] = e[2] - r[2], m[0] = f[2] * Math.sin(c) + f[0] * Math.cos(c), m[1] = f[1], m[2] = f[2] * Math.cos(c) - f[0] * Math.sin(c), i[0] = m[0] + r[0], i[1] = m[1] + r[1], i[2] = m[2] + r[2], i;
        }, S.bJ = function(i, e, r) {
          var c = Math.sin(r), f = Math.cos(r), m = e[0], v = e[1], E = e[2], k = e[3], P = e[8], L = e[9], N = e[10], G = e[11];
          return e !== i && (i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = m * f - P * c, i[1] = v * f - L * c, i[2] = E * f - N * c, i[3] = k * f - G * c, i[8] = m * c + P * f, i[9] = v * c + L * f, i[10] = E * c + N * f, i[11] = k * c + G * f, i;
        }, S.bK = function(i, e) {
          const r = Tt(i, 360), c = Tt(e, 360), f = c - r, m = c > r ? f - 360 : f + 360;
          return Math.abs(f) < Math.abs(m) ? f : m;
        }, S.bL = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i;
        }, S.bM = function(i, e, r, c) {
          const f = Math.sqrt(i * i + e * e), m = Math.sqrt(r * r + c * c);
          i /= f, e /= f, r /= m, c /= m;
          const v = Math.acos(i * r + e * c);
          return -e * r + i * c > 0 ? v : -v;
        }, S.bN = function(i, e) {
          const r = Tt(i, 2 * Math.PI), c = Tt(e, 2 * Math.PI);
          return Math.min(Math.abs(r - c), Math.abs(r - c + 2 * Math.PI), Math.abs(r - c - 2 * Math.PI));
        }, S.bO = function() {
          const i = {}, e = Be.$version;
          for (const r in Be.$root) {
            const c = Be.$root[r];
            if (c.required) {
              let f = null;
              f = r === "version" ? e : c.type === "array" ? [] : {}, f != null && (i[r] = f);
            }
          }
          return i;
        }, S.bP = me, S.bQ = fd, S.bR = function i(e, r) {
          if (Array.isArray(e)) {
            if (!Array.isArray(r) || e.length !== r.length) return !1;
            for (let c = 0; c < e.length; c++) if (!i(e[c], r[c])) return !1;
            return !0;
          }
          if (typeof e == "object" && e !== null && r !== null) {
            if (typeof r != "object" || Object.keys(e).length !== Object.keys(r).length) return !1;
            for (const c in e) if (!i(e[c], r[c])) return !1;
            return !0;
          }
          return e === r;
        }, S.bS = function(i) {
          i = i.slice();
          const e = /* @__PURE__ */ Object.create(null);
          for (let r = 0; r < i.length; r++) e[i[r].id] = i[r];
          for (let r = 0; r < i.length; r++) "ref" in i[r] && (i[r] = Cr(i[r], e[i[r].ref]));
          return i;
        }, S.bT = function(i, e) {
          if (i.type === "custom") return new HS(i, e);
          switch (i.type) {
            case "background":
              return new ZS(i, e);
            case "circle":
              return new PE(i, e);
            case "color-relief":
              return new NE(i, e);
            case "fill":
              return new JE(i, e);
            case "fill-extrusion":
              return new uS(i, e);
            case "heatmap":
              return new LE(i, e);
            case "hillshade":
              return new RE(i, e);
            case "line":
              return new mS(i, e);
            case "raster":
              return new pm(i, e);
            case "symbol":
              return new Ap(i, e);
          }
        }, S.bU = (i) => i.type === "raster", S.bV = Me, S.bW = function(i, e) {
          if (!i) return [{ command: "setStyle", args: [e] }];
          let r = [];
          try {
            if (!kt(i.version, e.version)) return [{ command: "setStyle", args: [e] }];
            kt(i.center, e.center) || r.push({ command: "setCenter", args: [e.center] }), kt(i.state, e.state) || r.push({ command: "setGlobalState", args: [e.state] }), kt(i.centerAltitude, e.centerAltitude) || r.push({ command: "setCenterAltitude", args: [e.centerAltitude] }), kt(i.zoom, e.zoom) || r.push({ command: "setZoom", args: [e.zoom] }), kt(i.bearing, e.bearing) || r.push({ command: "setBearing", args: [e.bearing] }), kt(i.pitch, e.pitch) || r.push({ command: "setPitch", args: [e.pitch] }), kt(i.roll, e.roll) || r.push({ command: "setRoll", args: [e.roll] }), kt(i.sprite, e.sprite) || r.push({ command: "setSprite", args: [e.sprite] }), kt(i.glyphs, e.glyphs) || r.push({ command: "setGlyphs", args: [e.glyphs] }), kt(i.transition, e.transition) || r.push({ command: "setTransition", args: [e.transition] }), kt(i.light, e.light) || r.push({ command: "setLight", args: [e.light] }), kt(i.terrain, e.terrain) || r.push({ command: "setTerrain", args: [e.terrain] }), kt(i.sky, e.sky) || r.push({ command: "setSky", args: [e.sky] }), kt(i.projection, e.projection) || r.push({ command: "setProjection", args: [e.projection] });
            const c = {}, f = [];
            (function(v, E, k, P) {
              let L;
              for (L in E = E || {}, v = v || {}) Object.prototype.hasOwnProperty.call(v, L) && (Object.prototype.hasOwnProperty.call(E, L) || Fr(L, k, P));
              for (L in E) Object.prototype.hasOwnProperty.call(E, L) && (Object.prototype.hasOwnProperty.call(v, L) ? kt(v[L], E[L]) || (v[L].type === "geojson" && E[L].type === "geojson" && un(v, E, L) ? lt(k, { command: "setGeoJSONSourceData", args: [L, E[L].data] }) : wr(L, E, k, P)) : nr(L, E, k));
            })(i.sources, e.sources, f, c);
            const m = [];
            i.layers && i.layers.forEach(((v) => {
              "source" in v && c[v.source] ? r.push({ command: "removeLayer", args: [v.id] }) : m.push(v);
            })), r = r.concat(f), (function(v, E, k) {
              E = E || [];
              const P = (v = v || []).map(Ur), L = E.map(Ur), N = v.reduce(Ir, {}), G = E.reduce(Ir, {}), j = P.slice(), Z = /* @__PURE__ */ Object.create(null);
              let Y, J, ie, ye, ae;
              for (let ue = 0, Ee = 0; ue < P.length; ue++) Y = P[ue], Object.prototype.hasOwnProperty.call(G, Y) ? Ee++ : (lt(k, { command: "removeLayer", args: [Y] }), j.splice(j.indexOf(Y, Ee), 1));
              for (let ue = 0, Ee = 0; ue < L.length; ue++) Y = L[L.length - 1 - ue], j[j.length - 1 - ue] !== Y && (Object.prototype.hasOwnProperty.call(N, Y) ? (lt(k, { command: "removeLayer", args: [Y] }), j.splice(j.lastIndexOf(Y, j.length - Ee), 1)) : Ee++, ye = j[j.length - ue], lt(k, { command: "addLayer", args: [G[Y], ye] }), j.splice(j.length - ue, 0, Y), Z[Y] = !0);
              for (let ue = 0; ue < L.length; ue++) if (Y = L[ue], J = N[Y], ie = G[Y], !Z[Y] && !kt(J, ie)) if (kt(J.source, ie.source) && kt(J["source-layer"], ie["source-layer"]) && kt(J.type, ie.type)) {
                for (ae in Qr(J.layout, ie.layout, k, Y, null, "setLayoutProperty"), Qr(J.paint, ie.paint, k, Y, null, "setPaintProperty"), kt(J.filter, ie.filter) || lt(k, { command: "setFilter", args: [Y, ie.filter] }), kt(J.minzoom, ie.minzoom) && kt(J.maxzoom, ie.maxzoom) || lt(k, { command: "setLayerZoomRange", args: [Y, ie.minzoom, ie.maxzoom] }), J) Object.prototype.hasOwnProperty.call(J, ae) && ae !== "layout" && ae !== "paint" && ae !== "filter" && ae !== "metadata" && ae !== "minzoom" && ae !== "maxzoom" && (ae.indexOf("paint.") === 0 ? Qr(J[ae], ie[ae], k, Y, ae.slice(6), "setPaintProperty") : kt(J[ae], ie[ae]) || lt(k, { command: "setLayerProperty", args: [Y, ae, ie[ae]] }));
                for (ae in ie) Object.prototype.hasOwnProperty.call(ie, ae) && !Object.prototype.hasOwnProperty.call(J, ae) && ae !== "layout" && ae !== "paint" && ae !== "filter" && ae !== "metadata" && ae !== "minzoom" && ae !== "maxzoom" && (ae.indexOf("paint.") === 0 ? Qr(J[ae], ie[ae], k, Y, ae.slice(6), "setPaintProperty") : kt(J[ae], ie[ae]) || lt(k, { command: "setLayerProperty", args: [Y, ae, ie[ae]] }));
              } else lt(k, { command: "removeLayer", args: [Y] }), ye = j[j.lastIndexOf(Y) + 1], lt(k, { command: "addLayer", args: [ie, ye] });
            })(m, e.layers, r);
          } catch (c) {
            console.warn("Unable to compute style diff:", c), r = [{ command: "setStyle", args: [e] }];
          }
          return r;
        }, S.bX = function(i) {
          const e = [], r = i.id;
          return r === void 0 && e.push({ message: `layers.${r}: missing required property "id"` }), i.render === void 0 && e.push({ message: `layers.${r}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e;
        }, S.bY = fr, S.bZ = Bt, S.b_ = class extends Ki {
          constructor(i, e) {
            super(i, e), this.current = 0;
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
          }
        }, S.ba = function(i, e, r) {
          return i[0] = e[0] * r, i[1] = e[1] * r, i[2] = e[2] * r, i[3] = e[3] * r, i;
        }, S.bb = function(i, e) {
          return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3];
        }, S.bc = C0, S.bd = hh, S.be = function(i, e, r, c, f) {
          var m = 1 / Math.tan(e / 2);
          if (i[0] = m / r, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = m, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, f != null && f !== 1 / 0) {
            var v = 1 / (c - f);
            i[10] = (f + c) * v, i[14] = 2 * f * c * v;
          } else i[10] = -1, i[14] = -2 * c;
          return i;
        }, S.bf = function(i) {
          var e = new Ue(16);
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], e;
        }, S.bg = function(i, e, r) {
          var c = Math.sin(r), f = Math.cos(r), m = e[0], v = e[1], E = e[2], k = e[3], P = e[4], L = e[5], N = e[6], G = e[7];
          return e !== i && (i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = m * f + P * c, i[1] = v * f + L * c, i[2] = E * f + N * c, i[3] = k * f + G * c, i[4] = P * f - m * c, i[5] = L * f - v * c, i[6] = N * f - E * c, i[7] = G * f - k * c, i;
        }, S.bh = function(i, e, r) {
          var c = Math.sin(r), f = Math.cos(r), m = e[4], v = e[5], E = e[6], k = e[7], P = e[8], L = e[9], N = e[10], G = e[11];
          return e !== i && (i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[4] = m * f + P * c, i[5] = v * f + L * c, i[6] = E * f + N * c, i[7] = k * f + G * c, i[8] = P * f - m * c, i[9] = L * f - v * c, i[10] = N * f - E * c, i[11] = G * f - k * c, i;
        }, S.bi = function() {
          const i = new Float32Array(16);
          return et(i), i;
        }, S.bj = function() {
          const i = new Float64Array(16);
          return et(i), i;
        }, S.bk = function() {
          return new Float64Array(16);
        }, S.bl = function(i, e, r) {
          const c = new Float64Array(4);
          return Ne(c, i, e - 90, r), c;
        }, S.bm = function(i, e, r, c) {
          var f, m, v, E, k, P = e[0], L = e[1], N = e[2], G = e[3], j = r[0], Z = r[1], Y = r[2], J = r[3];
          return (m = P * j + L * Z + N * Y + G * J) < 0 && (m = -m, j = -j, Z = -Z, Y = -Y, J = -J), 1 - m > ve ? (f = Math.acos(m), v = Math.sin(f), E = Math.sin((1 - c) * f) / v, k = Math.sin(c * f) / v) : (E = 1 - c, k = c), i[0] = E * P + k * j, i[1] = E * L + k * Z, i[2] = E * N + k * Y, i[3] = E * G + k * J, i;
        }, S.bn = function(i) {
          const e = new Float64Array(9);
          var r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, J, ie, ye, ae;
          N = (f = (c = i)[0]) * (k = f + f), G = (m = c[1]) * k, Z = (v = c[2]) * k, Y = v * (P = m + m), ie = (E = c[3]) * k, ye = E * P, ae = E * (L = v + v), (r = e)[0] = 1 - (j = m * P) - (J = v * L), r[3] = G - ae, r[6] = Z + ye, r[1] = G + ae, r[4] = 1 - N - J, r[7] = Y - ie, r[2] = Z - ye, r[5] = Y + ie, r[8] = 1 - N - j;
          const ue = ln(-Math.asin(Yt(e[2], -1, 1)));
          let Ee, Le;
          return Math.hypot(e[5], e[8]) < 1e-3 ? (Ee = 0, Le = -ln(Math.atan2(e[3], e[4]))) : (Ee = ln(e[5] === 0 && e[8] === 0 ? 0 : Math.atan2(e[5], e[8])), Le = ln(e[1] === 0 && e[0] === 0 ? 0 : Math.atan2(e[1], e[0]))), { roll: Ee, pitch: ue + 90, bearing: Le };
        }, S.bo = function(i, e) {
          return i.roll == e.roll && i.pitch == e.pitch && i.bearing == e.bearing;
        }, S.bp = cr, S.bq = Wo, S.br = oh, S.bs = Rd, S.bt = ah, S.bu = Zt, S.bv = zt, S.bw = rn, S.bx = function(i, e, r, c, f) {
          return Zt(c, f, Yt((i - e) / (r - e), 0, 1));
        }, S.by = function(i, e, r, c) {
          return i[0] = e[0] + r[0] * c, i[1] = e[1] + r[1] * c, i[2] = e[2] + r[2] * c, i;
        }, S.bz = Tt, S.c = H, S.c$ = class {
          constructor(i) {
            this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
          }
        }, S.c0 = class extends Ki {
          constructor(i, e) {
            super(i, e), this.current = ks;
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let e = 1; e < 16; e++) if (i[e] !== this.current[e]) {
              this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
              break;
            }
          }
        }, S.c1 = Yu, S.c2 = class extends Ki {
          constructor(i, e) {
            super(i, e), this.current = [0, 0, 0];
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
          }
        }, S.c3 = class extends Ki {
          constructor(i, e) {
            super(i, e), this.current = [0, 0];
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
          }
        }, S.c4 = Qe, S.c5 = function(i, e) {
          var r = Math.sin(e), c = Math.cos(e);
          return i[0] = c, i[1] = r, i[2] = 0, i[3] = -r, i[4] = c, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i;
        }, S.c6 = function(i, e, r) {
          var c = e[0], f = e[1], m = e[2];
          return i[0] = c * r[0] + f * r[3] + m * r[6], i[1] = c * r[1] + f * r[4] + m * r[7], i[2] = c * r[2] + f * r[5] + m * r[8], i;
        }, S.c7 = function(i, e, r, c, f, m, v) {
          var E = 1 / (e - r), k = 1 / (c - f), P = 1 / (m - v);
          return i[0] = -2 * E, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * k, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * P, i[11] = 0, i[12] = (e + r) * E, i[13] = (f + c) * k, i[14] = (v + m) * P, i[15] = 1, i;
        }, S.c8 = class extends Ki {
          constructor(i, e) {
            super(i, e), this.current = new Array();
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const e = new Float32Array(4 * i.length);
              for (let r = 0; r < i.length; r++) e[4 * r] = i[r].r, e[4 * r + 1] = i[r].g, e[4 * r + 2] = i[r].b, e[4 * r + 3] = i[r].a;
              this.gl.uniform4fv(this.location, e);
            }
          }
        }, S.c9 = class extends Ki {
          constructor(i, e) {
            super(i, e), this.current = new Array();
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const e = new Float32Array(i);
              this.gl.uniform1fv(this.location, e);
            }
          }
        }, S.cA = function(i, e) {
          var r;
          if (!Un[e]) return !1;
          const c = i?.target, f = ((r = c?.ownerDocument) === null || r === void 0 ? void 0 : r.defaultView) || window;
          return i instanceof f.MouseEvent || i instanceof f.WheelEvent;
        }, S.cB = function(i, e) {
          return Vn[e] && "touches" in i;
        }, S.cC = function(i) {
          return Vn[i] || Un[i];
        }, S.cD = function(i, e, r) {
          var c = e[0], f = e[1];
          return i[0] = r[0] * c + r[4] * f + r[12], i[1] = r[1] * c + r[5] * f + r[13], i;
        }, S.cE = function(i, e) {
          const { x: r, y: c } = Gd.fromLngLat(e);
          return !(i < 0 || i > 25 || c < 0 || c >= 1 || r < 0 || r >= 1);
        }, S.cF = function(i, e) {
          return i[0] = e[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = e[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = e[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
        }, S.cG = class extends Wc {
        }, S.cH = DT, S.cJ = Te, S.cK = function(i, e) {
          H.REGISTERED_PROTOCOLS[i] = e;
        }, S.cL = function(i) {
          delete H.REGISTERED_PROTOCOLS[i];
        }, S.cM = function(i, e) {
          const r = {};
          for (let f = 0; f < i.length; f++) {
            const m = e && e[i[f].id] || Jf(i[f]);
            e && (e[i[f].id] = m);
            let v = r[m];
            v || (v = r[m] = []), v.push(i[f]);
          }
          const c = [];
          for (const f in r) c.push(r[f]);
          return c;
        }, S.cN = Vt, S.cO = A0, S.cP = ux, S.cQ = d0, S.cR = function(i) {
          var e;
          i.bucket.createArrays(), i.bucket.tilePixelRatio = Je / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const r = i.bucket.layers[0], c = r.layout, f = r._unevaluatedLayout._values, m = { layoutIconSize: f["icon-size"].possiblyEvaluate(new Vr(i.bucket.zoom + 1), i.canonical), layoutTextSize: f["text-size"].possiblyEvaluate(new Vr(i.bucket.zoom + 1), i.canonical), textMaxSize: f["text-size"].possiblyEvaluate(new Vr(18)) };
          if (i.bucket.textSizeData.kind === "composite") {
            const { minZoom: L, maxZoom: N } = i.bucket.textSizeData;
            m.compositeTextSizes = [f["text-size"].possiblyEvaluate(new Vr(L), i.canonical), f["text-size"].possiblyEvaluate(new Vr(N), i.canonical)];
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const { minZoom: L, maxZoom: N } = i.bucket.iconSizeData;
            m.compositeIconSizes = [f["icon-size"].possiblyEvaluate(new Vr(L), i.canonical), f["icon-size"].possiblyEvaluate(new Vr(N), i.canonical)];
          }
          const v = c.get("text-line-height") * di, E = c.get("text-rotation-alignment") !== "viewport" && c.get("symbol-placement") !== "point", k = c.get("text-keep-upright"), P = c.get("text-size");
          for (const L of i.bucket.features) {
            const N = c.get("text-font").evaluate(L, {}, i.canonical).join(","), G = P.evaluate(L, {}, i.canonical), j = m.layoutTextSize.evaluate(L, {}, i.canonical), Z = m.layoutIconSize.evaluate(L, {}, i.canonical), Y = { horizontal: {}, vertical: void 0 }, J = L.text;
            let ie, ye = [0, 0];
            if (J) {
              const Ee = J.toString(), Le = c.get("text-letter-spacing").evaluate(L, {}, i.canonical) * di, Ke = dm(Ee) ? Le : 0, dt = c.get("text-anchor").evaluate(L, {}, i.canonical), ht = wx(r, L, i.canonical);
              if (!ht) {
                const ct = c.get("text-radial-offset").evaluate(L, {}, i.canonical);
                ye = ct ? bx(dt, [ct * di, i_]) : c.get("text-offset").evaluate(L, {}, i.canonical).map(((ot) => ot * di));
              }
              let mt = E ? "center" : c.get("text-justify").evaluate(L, {}, i.canonical);
              const Pt = c.get("symbol-placement") === "point" ? c.get("text-max-width").evaluate(L, {}, i.canonical) * di : 1 / 0, bt = () => {
                i.bucket.allowVerticalPlacement && Fl(Ee) && (Y.vertical = Cp(J, i.glyphMap, i.glyphPositions, i.imagePositions, N, Pt, v, dt, "left", Ke, ye, S.az.vertical, !0, j, G));
              };
              if (!E && ht) {
                const ct = /* @__PURE__ */ new Set();
                if (mt === "auto") for (let Nt = 0; Nt < ht.values.length; Nt += 2) ct.add(s_(ht.values[Nt]));
                else ct.add(mt);
                let ot = !1;
                for (const Nt of ct) if (!Y.horizontal[Nt]) if (ot) Y.horizontal[Nt] = Y.horizontal[0];
                else {
                  const Rt = Cp(J, i.glyphMap, i.glyphPositions, i.imagePositions, N, Pt, v, "center", Nt, Ke, ye, S.az.horizontal, !1, j, G);
                  Rt && (Y.horizontal[Nt] = Rt, ot = Rt.positionedLines.length === 1);
                }
                bt();
              } else {
                mt === "auto" && (mt = s_(dt));
                const ct = Cp(J, i.glyphMap, i.glyphPositions, i.imagePositions, N, Pt, v, dt, mt, Ke, ye, S.az.horizontal, !1, j, G);
                ct && (Y.horizontal[mt] = ct), bt(), Fl(Ee) && E && k && (Y.vertical = Cp(J, i.glyphMap, i.glyphPositions, i.imagePositions, N, Pt, v, dt, mt, Ke, ye, S.az.vertical, !1, j, G));
              }
            }
            let ae = !1;
            if (L.icon && L.icon.name) {
              const Ee = i.imageMap[L.icon.name];
              Ee && (ie = VS(i.imagePositions[L.icon.name], c.get("icon-offset").evaluate(L, {}, i.canonical), c.get("icon-anchor").evaluate(L, {}, i.canonical)), ae = !!Ee.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = ae : i.bucket.sdfIcons !== ae && ur("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ee.pixelRatio !== i.bucket.pixelRatio || c.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
            }
            const ue = Sx(Y.horizontal) || Y.vertical;
            (e = i.bucket).iconsInText || (e.iconsInText = !!ue && ue.iconsInText), (ue || ie) && AT(i.bucket, L, Y, ie, i.imageMap, m, j, Z, ye, ae, i.canonical, i.subdivisionGranularity);
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
        }, S.cS = Im, S.cT = Cm, S.cU = Pm, S.cV = function(i) {
          const e = new Mp();
          return (function(r, c) {
            for (const f in r.layers) c.writeMessage(3, _T, r.layers[f]);
          })(i, e), e.finish();
        }, S.cW = function(i, e, r, c, f, m) {
          let v = dx(i, e, r, f, 0);
          return v = dx(v, e, c, m, 1), v;
        }, S.cX = class {
          constructor(i) {
            this.maxEntries = i, this.map = /* @__PURE__ */ new Map();
          }
          get(i) {
            const e = this.map.get(i);
            return e !== void 0 && (this.map.delete(i), this.map.set(i, e)), e;
          }
          set(i, e) {
            if (this.map.has(i)) this.map.delete(i);
            else if (this.map.size >= this.maxEntries) {
              const r = this.map.keys().next().value;
              this.map.delete(r);
            }
            this.map.set(i, e);
          }
          clear() {
            this.map.clear();
          }
        }, S.cY = Yv, S.cZ = Mp, S.c_ = ox, S.ca = class extends Ho {
        }, S.cb = xS, S.cc = class extends Hu {
        }, S.cd = wm, S.ce = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
        }, S.cf = Dv, S.cg = function(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = r[3] * c + r[7] * f + r[11] * m + r[15];
          return i[0] = (r[0] * c + r[4] * f + r[8] * m + r[12]) / (v = v || 1), i[1] = (r[1] * c + r[5] * f + r[9] * m + r[13]) / v, i[2] = (r[2] * c + r[6] * f + r[10] * m + r[14]) / v, i;
        }, S.ch = class extends xd {
        }, S.ci = class extends t {
        }, S.cj = function(i, e) {
          return i[0] === e[0] && i[1] === e[1] && i[2] === e[2] && i[3] === e[3] && i[4] === e[4] && i[5] === e[5] && i[6] === e[6] && i[7] === e[7] && i[8] === e[8] && i[9] === e[9] && i[10] === e[10] && i[11] === e[11] && i[12] === e[12] && i[13] === e[13] && i[14] === e[14] && i[15] === e[15];
        }, S.ck = function(i, e) {
          var r = i[0], c = i[1], f = i[2], m = i[3], v = i[4], E = i[5], k = i[6], P = i[7], L = i[8], N = i[9], G = i[10], j = i[11], Z = i[12], Y = i[13], J = i[14], ie = i[15], ye = e[0], ae = e[1], ue = e[2], Ee = e[3], Le = e[4], Ke = e[5], dt = e[6], ht = e[7], mt = e[8], Pt = e[9], bt = e[10], ct = e[11], ot = e[12], Nt = e[13], Rt = e[14], Ut = e[15];
          return Math.abs(r - ye) <= ve * Math.max(1, Math.abs(r), Math.abs(ye)) && Math.abs(c - ae) <= ve * Math.max(1, Math.abs(c), Math.abs(ae)) && Math.abs(f - ue) <= ve * Math.max(1, Math.abs(f), Math.abs(ue)) && Math.abs(m - Ee) <= ve * Math.max(1, Math.abs(m), Math.abs(Ee)) && Math.abs(v - Le) <= ve * Math.max(1, Math.abs(v), Math.abs(Le)) && Math.abs(E - Ke) <= ve * Math.max(1, Math.abs(E), Math.abs(Ke)) && Math.abs(k - dt) <= ve * Math.max(1, Math.abs(k), Math.abs(dt)) && Math.abs(P - ht) <= ve * Math.max(1, Math.abs(P), Math.abs(ht)) && Math.abs(L - mt) <= ve * Math.max(1, Math.abs(L), Math.abs(mt)) && Math.abs(N - Pt) <= ve * Math.max(1, Math.abs(N), Math.abs(Pt)) && Math.abs(G - bt) <= ve * Math.max(1, Math.abs(G), Math.abs(bt)) && Math.abs(j - ct) <= ve * Math.max(1, Math.abs(j), Math.abs(ct)) && Math.abs(Z - ot) <= ve * Math.max(1, Math.abs(Z), Math.abs(ot)) && Math.abs(Y - Nt) <= ve * Math.max(1, Math.abs(Y), Math.abs(Nt)) && Math.abs(J - Rt) <= ve * Math.max(1, Math.abs(J), Math.abs(Rt)) && Math.abs(ie - Ut) <= ve * Math.max(1, Math.abs(ie), Math.abs(Ut));
        }, S.cl = function(i, e) {
          return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
        }, S.cm = (i) => i.type === "symbol", S.cn = (i) => i.type === "circle", S.co = (i) => i.type === "heatmap", S.cp = (i) => i.type === "line", S.cq = (i) => i.type === "fill", S.cr = (i) => i.type === "fill-extrusion", S.cs = (i) => i.type === "hillshade", S.ct = (i) => i.type === "color-relief", S.cu = (i) => i.type === "background", S.cv = (i) => i.type === "custom", S.cw = At, S.cx = function(i, e, r) {
          if (e <= 0) return i;
          const c = 1 / e;
          return r === void 0 || Math.abs(r) < 1e-10 ? Math.round(i * c) / c : (r > 0 ? Math.ceil(i * c - 1e-9) : Math.floor(i * c + 1e-10)) / c;
        }, S.cy = function(i, e, r) {
          const c = qe(e.x - r.x, e.y - r.y), f = qe(i.x - r.x, i.y - r.y);
          var m, v;
          return ln(Math.atan2(c[0] * f[1] - c[1] * f[0], (m = c)[0] * (v = f)[0] + m[1] * v[1]));
        }, S.cz = Dt, S.d = We, S.d0 = function(i, e, r, c, f) {
          return u(this, void 0, void 0, (function* () {
            if (Pe()) try {
              return yield Zi(i, e, r, c, f);
            } catch {
            }
            return (function(m, v, E, k, P) {
              const L = m.width, N = m.height;
              Ti && jn || (Ti = new OffscreenCanvas(L, N), jn = Ti.getContext("2d", { willReadFrequently: !0 })), Ti.width = L, Ti.height = N, jn.drawImage(m, 0, 0, L, N);
              const G = jn.getImageData(v, E, k, P);
              return jn.clearRect(0, 0, L, N), G.data;
            })(i, e, r, c, f);
          }));
        }, S.d1 = Nv, S.d2 = z, S.d3 = class {
          constructor(i, e) {
            this.layers = { [Ud]: this }, this.name = Ud, this.version = e ? e.version : 1, this.extent = e ? e.extent : 4096, this.length = i.length, this.features = i;
          }
          feature(i) {
            return new mT(this.features[i], this.extent);
          }
        }, S.d4 = ku, S.d5 = co, S.e = He, S.f = (i) => u(void 0, void 0, void 0, (function* () {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const e = new Blob([new Uint8Array(i)], { type: "image/png" });
          try {
            return createImageBitmap(e);
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), S.g = K, S.h = (i) => new Promise(((e, r) => {
          const c = new Image();
          c.onload = () => {
            e(c), URL.revokeObjectURL(c.src), c.onload = null, window.requestAnimationFrame((() => {
              c.src = Mt;
            }));
          }, c.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const f = new Blob([new Uint8Array(i)], { type: "image/png" });
          c.src = i.byteLength ? URL.createObjectURL(f) : Mt;
        })), S.i = ni, S.j = (i, e) => Ye(He(i, { type: "json" }), e), S.k = st, S.l = gt, S.m = Ye, S.n = (i, e) => Ye(He(i, { type: "arrayBuffer" }), e), S.o = function(i) {
          return new Mp(i).readFields(RS, []);
        }, S.p = h0, S.q = function(i) {
          return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }, S.r = Cd, S.s = Ls, S.t = Ui, S.u = Be, S.v = Ru, S.w = ur, S.x = yd, S.y = Fu, S.z = Bu;
      })), x("worker", ["./shared"], (function(S) {
        class u {
          constructor(H, K) {
            this.keyCache = {}, H && this.replace(H, K);
          }
          replace(H, K) {
            this._layerConfigs = {}, this._layers = {}, this.update(H, [], K);
          }
          update(H, K, re) {
            for (const me of H) {
              this._layerConfigs[me.id] = me;
              const Ye = this._layers[me.id] = S.bT(me, re);
              Ye._featureFilter = S.aj(Ye.filter, re), this.keyCache[me.id] && delete this.keyCache[me.id];
            }
            for (const me of K) delete this.keyCache[me], delete this._layerConfigs[me], delete this._layers[me];
            this.familiesBySource = {};
            const Te = S.cM(Object.values(this._layerConfigs), this.keyCache);
            for (const me of Te) {
              const Ye = me.map(((vt) => this._layers[vt.id])), We = Ye[0];
              if (We.isHidden()) continue;
              const Ve = We.source || "";
              let $e = this.familiesBySource[Ve];
              $e || ($e = this.familiesBySource[Ve] = {});
              const gt = We.sourceLayer || S.ai;
              let st = $e[gt];
              st || (st = $e[gt] = []), st.push(Ye);
            }
          }
        }
        class R {
          constructor(H) {
            const K = {}, re = [];
            for (const We in H) {
              const Ve = H[We], $e = K[We] = {};
              for (const gt in Ve) {
                const st = Ve[+gt];
                if (!st || st.bitmap.width === 0 || st.bitmap.height === 0) continue;
                const vt = { x: 0, y: 0, w: st.bitmap.width + 2, h: st.bitmap.height + 2 };
                re.push(vt), $e[gt] = { rect: vt, metrics: st.metrics };
              }
            }
            const { w: Te, h: me } = S.p(re), Ye = new S.r({ width: Te || 1, height: me || 1 });
            for (const We in H) {
              const Ve = H[We];
              for (const $e in Ve) {
                const gt = Ve[+$e];
                if (!gt || gt.bitmap.width === 0 || gt.bitmap.height === 0) continue;
                const st = K[We][$e].rect;
                S.r.copy(gt.bitmap, Ye, { x: 0, y: 0 }, { x: st.x + 1, y: st.y + 1 }, gt.bitmap);
              }
            }
            this.image = Ye, this.positions = K;
          }
        }
        S.cN("GlyphAtlas", R);
        class z {
          constructor(H) {
            this.tileID = new S.a2(H.tileID.overscaledZ, H.tileID.wrap, H.tileID.canonical.z, H.tileID.canonical.x, H.tileID.canonical.y), this.uid = H.uid, this.zoom = H.zoom, this.pixelRatio = H.pixelRatio, this.tileSize = H.tileSize, this.source = H.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = H.showCollisionBoxes, this.collectResourceTiming = !!H.collectResourceTiming, this.returnDependencies = !!H.returnDependencies, this.promoteId = H.promoteId, this.inFlightDependencies = [];
          }
          parse(H, K, re, Te, me) {
            return S._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = H, this.collisionBoxArray = new S.ag();
              const Ye = new S.cO(Object.keys(H.layers).sort()), We = new S.cP(this.tileID, this.promoteId);
              We.bucketLayerIDs = [];
              const Ve = {}, $e = { featureIndex: We, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: re, subdivisionGranularity: me }, gt = K.familiesBySource[this.source];
              for (const pt in gt) {
                const jr = H.layers[pt];
                if (!jr) continue;
                jr.version === 1 && S.w(`Vector tile source "${this.source}" layer "${pt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Wn = Ye.encode(pt), Hi = [];
                for (let Wr = 0; Wr < jr.length; Wr++) {
                  const yt = jr.feature(Wr), er = We.getId(yt, pt);
                  Hi.push({ feature: yt, id: er, index: Wr, sourceLayerIndex: Wn });
                }
                for (const Wr of gt[pt]) {
                  const yt = Wr[0];
                  yt.source !== this.source && S.w(`layer.source = ${yt.source} does not equal this.source = ${this.source}`), yt.isHidden(this.zoom, !0) || (U(Wr, this.zoom, re), (Ve[yt.id] = yt.createBucket({ index: We.bucketLayerIDs.length, layers: Wr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Wn, sourceID: this.source })).populate(Hi, $e, this.tileID.canonical), We.bucketLayerIDs.push(Wr.map(((er) => er.id))));
                }
              }
              const st = S.bY($e.glyphDependencies, ((pt) => Object.keys(pt).map(Number)));
              this.inFlightDependencies.forEach(((pt) => pt?.abort())), this.inFlightDependencies = [];
              let vt = Promise.resolve({});
              if (Object.keys(st).length) {
                const pt = new AbortController();
                this.inFlightDependencies.push(pt), vt = Te.sendAsync({ type: "GG", data: { stacks: st, source: this.source, tileID: this.tileID, type: "glyphs" } }, pt);
              }
              const Be = Object.keys($e.iconDependencies);
              let Qt = Promise.resolve({});
              if (Be.length) {
                const pt = new AbortController();
                this.inFlightDependencies.push(pt), Qt = Te.sendAsync({ type: "GI", data: { icons: Be, source: this.source, tileID: this.tileID, type: "icons" } }, pt);
              }
              const Cr = Object.keys($e.patternDependencies);
              let kt = Promise.resolve({});
              if (Cr.length) {
                const pt = new AbortController();
                this.inFlightDependencies.push(pt), kt = Te.sendAsync({ type: "GI", data: { icons: Cr, source: this.source, tileID: this.tileID, type: "patterns" } }, pt);
              }
              const lt = $e.dashDependencies;
              let nr = Promise.resolve({});
              if (Object.keys(lt).length) {
                const pt = new AbortController();
                this.inFlightDependencies.push(pt), nr = Te.sendAsync({ type: "GDA", data: { dashes: lt } }, pt);
              }
              const [Fr, wr, un, Qr] = yield Promise.all([vt, Qt, kt, nr]), Ur = new R(Fr), Ir = new S.cQ(wr, un);
              for (const pt in Ve) {
                const jr = Ve[pt];
                jr instanceof S.ah ? (U(jr.layers, this.zoom, re), S.cR({ bucket: jr, glyphMap: Fr, glyphPositions: Ur.positions, imageMap: wr, imagePositions: Ir.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: $e.subdivisionGranularity })) : jr.hasDependencies && (jr instanceof S.cS || jr instanceof S.cT || jr instanceof S.cU) && (U(jr.layers, this.zoom, re), jr.addFeatures($e, this.tileID.canonical, Ir.patternPositions, Qr));
              }
              return this.status = "done", { buckets: Object.values(Ve).filter(((pt) => !pt.isEmpty())), featureIndex: We, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ur.image, imageAtlas: Ir, dashPositions: Qr, glyphMap: this.returnDependencies ? Fr : null, iconMap: this.returnDependencies ? wr : null, glyphPositions: this.returnDependencies ? Ur.positions : null };
            }));
          }
        }
        function U(Fe, H, K) {
          const re = new S.H(H);
          for (const Te of Fe) Te.recalculate(re, K);
        }
        class $ {
          constructor(H, K, re, Te, me) {
            this.type = H, this.properties = re || {}, this.extent = me, this.pointsArray = K, this.id = Te;
          }
          loadGeometry() {
            return this.pointsArray.map(((H) => H.map(((K) => new S.P(K.x, K.y)))));
          }
        }
        class ee {
          constructor(H, K, re) {
            this.version = 2, this._myFeatures = H, this.name = K, this.length = H.length, this.extent = re;
          }
          feature(H) {
            return this._myFeatures[H];
          }
        }
        class le {
          constructor() {
            this.layers = {};
          }
          addLayer(H) {
            this.layers[H.name] = H;
          }
        }
        function ce(Fe) {
          let H = S.cV(Fe);
          return H.byteOffset === 0 && H.byteLength === H.buffer.byteLength || (H = new Uint8Array(H)), { vectorTile: Fe, rawData: H.buffer };
        }
        function _e(Fe, H, K) {
          const { extent: re } = Fe, Te = Math.pow(2, K.z - H.z), me = (K.x - H.x * Te) * re, Ye = (K.y - H.y * Te) * re, We = [];
          for (let Ve = 0; Ve < Fe.length; Ve++) {
            const $e = Fe.feature(Ve);
            let gt = $e.loadGeometry();
            for (const vt of gt) for (const Be of vt) Be.x = Be.x * Te - me, Be.y = Be.y * Te - Ye;
            const st = 128;
            gt = S.cW(gt, $e.type, -st, -st, re + st, re + st), gt.length !== 0 && We.push(new $($e.type, gt, $e.properties, $e.id, re));
          }
          return new ee(We, Fe.name, re);
        }
        class ne {
          constructor(H, K, re) {
            this.actor = H, this.layerIndex = K, this.availableImages = re, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new S.cX(1e3);
          }
          loadVectorTile(H, K) {
            return S._(this, void 0, void 0, (function* () {
              const re = yield S.n(H.request, K);
              try {
                return { vectorTile: H.encoding !== "mlt" ? new S.cY(new S.cZ(re.data)) : new S.c_(re.data), rawData: re.data, cacheControl: re.cacheControl, expires: re.expires };
              } catch (Te) {
                const me = new Uint8Array(re.data);
                let Ye = `Unable to parse the tile at ${H.request.url}, `;
                throw Ye += me[0] === 31 && me[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Te.message}`, new Error(Ye);
              }
            }));
          }
          loadTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const { uid: K, overzoomParameters: re } = H;
              re && (H.request = re.overzoomRequest);
              const Te = !!(H && H.request && H.request.collectResourceTiming) && new S.c$(H.request), me = new z(H);
              this.loading[K] = me;
              const Ye = new AbortController();
              me.abort = Ye;
              try {
                const We = yield this.loadVectorTile(H, Ye);
                if (delete this.loading[K], !We) return null;
                if (re) {
                  const vt = this._getOverzoomTile(H, We.vectorTile);
                  We.rawData = vt.rawData, We.vectorTile = vt.vectorTile;
                }
                const Ve = We.rawData, $e = {};
                We.expires && ($e.expires = We.expires), We.cacheControl && ($e.cacheControl = We.cacheControl);
                const gt = {};
                if (Te) {
                  const vt = Te.finish();
                  vt && (gt.resourceTiming = JSON.parse(JSON.stringify(vt)));
                }
                me.vectorTile = We.vectorTile;
                const st = me.parse(We.vectorTile, this.layerIndex, this.availableImages, this.actor, H.subdivisionGranularity);
                this.loaded[K] = me, this.fetching[K] = { rawTileData: Ve, cacheControl: $e, resourceTiming: gt };
                try {
                  const vt = yield st;
                  return S.e({ rawTileData: Ve.slice(0), encoding: H.encoding }, vt, $e, gt);
                } finally {
                  delete this.fetching[K];
                }
              } catch (We) {
                throw delete this.loading[K], me.status = "done", this.loaded[K] = me, We;
              }
            }));
          }
          _getOverzoomTile(H, K) {
            const { tileID: re, source: Te, overzoomParameters: me } = H, { maxZoomTileID: Ye } = me, We = `${Ye.key}_${re.key}`, Ve = this.overzoomedTileResultCache.get(We);
            if (Ve) return Ve;
            const $e = new le(), gt = this.layerIndex.familiesBySource[Te];
            for (const vt in gt) {
              const Be = K.layers[vt];
              if (!Be) continue;
              const Qt = _e(Be, Ye, re.canonical);
              Qt.length > 0 && $e.addLayer(Qt);
            }
            const st = ce($e);
            return this.overzoomedTileResultCache.set(We, st), st;
          }
          reloadTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const K = H.uid;
              if (!this.loaded || !this.loaded[K]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const re = this.loaded[K];
              if (re.showCollisionBoxes = H.showCollisionBoxes, re.status === "parsing") {
                const Te = yield re.parse(re.vectorTile, this.layerIndex, this.availableImages, this.actor, H.subdivisionGranularity);
                let me;
                if (this.fetching[K]) {
                  const { rawTileData: Ye, cacheControl: We, resourceTiming: Ve } = this.fetching[K];
                  delete this.fetching[K], me = S.e({ rawTileData: Ye.slice(0), encoding: H.encoding }, Te, We, Ve);
                } else me = Te;
                return me;
              }
              if (re.status === "done" && re.vectorTile) return re.parse(re.vectorTile, this.layerIndex, this.availableImages, this.actor, H.subdivisionGranularity);
            }));
          }
          abortTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const K = this.loading, re = H.uid;
              K && K[re] && K[re].abort && (K[re].abort.abort(), delete K[re]);
            }));
          }
          removeTile(H) {
            return S._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[H.uid] && delete this.loaded[H.uid];
            }));
          }
        }
        class Pe {
          constructor() {
            this.loaded = {};
          }
          loadTile(H) {
            return S._(this, void 0, void 0, (function* () {
              const { uid: K, encoding: re, rawImageData: Te, redFactor: me, greenFactor: Ye, blueFactor: We, baseShift: Ve } = H, $e = Te.width + 2, gt = Te.height + 2, st = S.b(Te) ? new S.R({ width: $e, height: gt }, yield S.d0(Te, -1, -1, $e, gt)) : Te, vt = new S.d1(K, st, re, me, Ye, We, Ve);
              return this.loaded = this.loaded || {}, this.loaded[K] = vt, vt;
            }));
          }
          removeTile(H) {
            const K = this.loaded, re = H.uid;
            K && K[re] && delete K[re];
          }
        }
        var ve, Ue, Qe = (function() {
          if (Ue) return ve;
          function Fe(K, re) {
            if (K.length !== 0) {
              H(K[0], re);
              for (var Te = 1; Te < K.length; Te++) H(K[Te], !re);
            }
          }
          function H(K, re) {
            for (var Te = 0, me = 0, Ye = 0, We = K.length, Ve = We - 1; Ye < We; Ve = Ye++) {
              var $e = (K[Ye][0] - K[Ve][0]) * (K[Ve][1] + K[Ye][1]), gt = Te + $e;
              me += Math.abs(Te) >= Math.abs($e) ? Te - gt + $e : $e - gt + Te, Te = gt;
            }
            Te + me >= 0 != !!re && K.reverse();
          }
          return Ue = 1, ve = function K(re, Te) {
            var me, Ye = re && re.type;
            if (Ye === "FeatureCollection") for (me = 0; me < re.features.length; me++) K(re.features[me], Te);
            else if (Ye === "GeometryCollection") for (me = 0; me < re.geometries.length; me++) K(re.geometries[me], Te);
            else if (Ye === "Feature") K(re.geometry, Te);
            else if (Ye === "Polygon") Fe(re.coordinates, Te);
            else if (Ye === "MultiPolygon") for (me = 0; me < re.coordinates.length; me++) Fe(re.coordinates[me], Te);
            return re;
          };
        })(), et = S.d2(Qe);
        const Xe = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Fe) => Fe }, ut = Math.fround || (Q = new Float32Array(1), (Fe) => (Q[0] = +Fe, Q[0]));
        var Q;
        class se {
          constructor(H) {
            this.options = Object.assign(Object.create(Xe), H), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(H) {
            const { log: K, minZoom: re, maxZoom: Te } = this.options;
            K && console.time("total time");
            const me = `prepare ${H.length} points`;
            K && console.time(me), this.points = H;
            const Ye = [];
            for (let Ve = 0; Ve < H.length; Ve++) {
              const $e = H[Ve];
              if (!$e.geometry) continue;
              const [gt, st] = $e.geometry.coordinates, vt = ut(Ie(gt)), Be = ut(ze(st));
              Ye.push(vt, Be, 1 / 0, Ve, -1, 1), this.options.reduce && Ye.push(0);
            }
            let We = this.trees[Te + 1] = this._createTree(Ye);
            K && console.timeEnd(me);
            for (let Ve = Te; Ve >= re; Ve--) {
              const $e = +Date.now();
              We = this.trees[Ve] = this._createTree(this._cluster(We, Ve)), K && console.log("z%d: %d clusters in %dms", Ve, We.numItems, +Date.now() - $e);
            }
            return K && console.timeEnd("total time"), this;
          }
          getClusters(H, K) {
            let re = ((H[0] + 180) % 360 + 360) % 360 - 180;
            const Te = Math.max(-90, Math.min(90, H[1]));
            let me = H[2] === 180 ? 180 : ((H[2] + 180) % 360 + 360) % 360 - 180;
            const Ye = Math.max(-90, Math.min(90, H[3]));
            if (H[2] - H[0] >= 360) re = -180, me = 180;
            else if (re > me) {
              const st = this.getClusters([re, Te, 180, Ye], K), vt = this.getClusters([-180, Te, me, Ye], K);
              return st.concat(vt);
            }
            const We = this.trees[this._limitZoom(K)], Ve = We.range(Ie(re), ze(Ye), Ie(me), ze(Te)), $e = We.data, gt = [];
            for (const st of Ve) {
              const vt = this.stride * st;
              gt.push($e[vt + 5] > 1 ? ge($e, vt, this.clusterProps) : this.points[$e[vt + 3]]);
            }
            return gt;
          }
          getChildren(H) {
            const K = this._getOriginId(H), re = this._getOriginZoom(H), Te = "No cluster with the specified id.", me = this.trees[re];
            if (!me) throw new Error(Te);
            const Ye = me.data;
            if (K * this.stride >= Ye.length) throw new Error(Te);
            const We = this.options.radius / (this.options.extent * Math.pow(2, re - 1)), Ve = me.within(Ye[K * this.stride], Ye[K * this.stride + 1], We), $e = [];
            for (const gt of Ve) {
              const st = gt * this.stride;
              Ye[st + 4] === H && $e.push(Ye[st + 5] > 1 ? ge(Ye, st, this.clusterProps) : this.points[Ye[st + 3]]);
            }
            if ($e.length === 0) throw new Error(Te);
            return $e;
          }
          getLeaves(H, K, re) {
            const Te = [];
            return this._appendLeaves(Te, H, K = K || 10, re = re || 0, 0), Te;
          }
          getTile(H, K, re) {
            const Te = this.trees[this._limitZoom(H)], me = Math.pow(2, H), { extent: Ye, radius: We } = this.options, Ve = We / Ye, $e = (re - Ve) / me, gt = (re + 1 + Ve) / me, st = { features: [] };
            return this._addTileFeatures(Te.range((K - Ve) / me, $e, (K + 1 + Ve) / me, gt), Te.data, K, re, me, st), K === 0 && this._addTileFeatures(Te.range(1 - Ve / me, $e, 1, gt), Te.data, me, re, me, st), K === me - 1 && this._addTileFeatures(Te.range(0, $e, Ve / me, gt), Te.data, -1, re, me, st), st.features.length ? st : null;
          }
          getClusterExpansionZoom(H) {
            let K = this._getOriginZoom(H) - 1;
            for (; K <= this.options.maxZoom; ) {
              const re = this.getChildren(H);
              if (K++, re.length !== 1) break;
              H = re[0].properties.cluster_id;
            }
            return K;
          }
          _appendLeaves(H, K, re, Te, me) {
            const Ye = this.getChildren(K);
            for (const We of Ye) {
              const Ve = We.properties;
              if (Ve && Ve.cluster ? me + Ve.point_count <= Te ? me += Ve.point_count : me = this._appendLeaves(H, Ve.cluster_id, re, Te, me) : me < Te ? me++ : H.push(We), H.length === re) break;
            }
            return me;
          }
          _createTree(H) {
            const K = new S.aT(H.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let re = 0; re < H.length; re += this.stride) K.add(H[re], H[re + 1]);
            return K.finish(), K.data = H, K;
          }
          _addTileFeatures(H, K, re, Te, me, Ye) {
            for (const We of H) {
              const Ve = We * this.stride, $e = K[Ve + 5] > 1;
              let gt, st, vt;
              if ($e) gt = Se(K, Ve, this.clusterProps), st = K[Ve], vt = K[Ve + 1];
              else {
                const Cr = this.points[K[Ve + 3]];
                gt = Cr.properties;
                const [kt, lt] = Cr.geometry.coordinates;
                st = Ie(kt), vt = ze(lt);
              }
              const Be = { type: 1, geometry: [[Math.round(this.options.extent * (st * me - re)), Math.round(this.options.extent * (vt * me - Te))]], tags: gt };
              let Qt;
              Qt = $e || this.options.generateId ? K[Ve + 3] : this.points[K[Ve + 3]].id, Qt !== void 0 && (Be.id = Qt), Ye.features.push(Be);
            }
          }
          _limitZoom(H) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+H), this.options.maxZoom + 1));
          }
          _cluster(H, K) {
            const { radius: re, extent: Te, reduce: me, minPoints: Ye } = this.options, We = re / (Te * Math.pow(2, K)), Ve = H.data, $e = [], gt = this.stride;
            for (let st = 0; st < Ve.length; st += gt) {
              if (Ve[st + 2] <= K) continue;
              Ve[st + 2] = K;
              const vt = Ve[st], Be = Ve[st + 1], Qt = H.within(Ve[st], Ve[st + 1], We), Cr = Ve[st + 5];
              let kt = Cr;
              for (const lt of Qt) {
                const nr = lt * gt;
                Ve[nr + 2] > K && (kt += Ve[nr + 5]);
              }
              if (kt > Cr && kt >= Ye) {
                let lt, nr = vt * Cr, Fr = Be * Cr, wr = -1;
                const un = (st / gt << 5) + (K + 1) + this.points.length;
                for (const Qr of Qt) {
                  const Ur = Qr * gt;
                  if (Ve[Ur + 2] <= K) continue;
                  Ve[Ur + 2] = K;
                  const Ir = Ve[Ur + 5];
                  nr += Ve[Ur] * Ir, Fr += Ve[Ur + 1] * Ir, Ve[Ur + 4] = un, me && (lt || (lt = this._map(Ve, st, !0), wr = this.clusterProps.length, this.clusterProps.push(lt)), me(lt, this._map(Ve, Ur)));
                }
                Ve[st + 4] = un, $e.push(nr / kt, Fr / kt, 1 / 0, un, -1, kt), me && $e.push(wr);
              } else {
                for (let lt = 0; lt < gt; lt++) $e.push(Ve[st + lt]);
                if (kt > 1) for (const lt of Qt) {
                  const nr = lt * gt;
                  if (!(Ve[nr + 2] <= K)) {
                    Ve[nr + 2] = K;
                    for (let Fr = 0; Fr < gt; Fr++) $e.push(Ve[nr + Fr]);
                  }
                }
              }
            }
            return $e;
          }
          _getOriginId(H) {
            return H - this.points.length >> 5;
          }
          _getOriginZoom(H) {
            return (H - this.points.length) % 32;
          }
          _map(H, K, re) {
            if (H[K + 5] > 1) {
              const Ye = this.clusterProps[H[K + 6]];
              return re ? Object.assign({}, Ye) : Ye;
            }
            const Te = this.points[H[K + 3]].properties, me = this.options.map(Te);
            return re && me === Te ? Object.assign({}, me) : me;
          }
        }
        function ge(Fe, H, K) {
          return { type: "Feature", id: Fe[H + 3], properties: Se(Fe, H, K), geometry: { type: "Point", coordinates: [(re = Fe[H], 360 * (re - 0.5)), Re(Fe[H + 1])] } };
          var re;
        }
        function Se(Fe, H, K) {
          const re = Fe[H + 5], Te = re >= 1e4 ? `${Math.round(re / 1e3)}k` : re >= 1e3 ? Math.round(re / 100) / 10 + "k" : re, me = Fe[H + 6], Ye = me === -1 ? {} : Object.assign({}, K[me]);
          return Object.assign(Ye, { cluster: !0, cluster_id: Fe[H + 3], point_count: re, point_count_abbreviated: Te });
        }
        function Ie(Fe) {
          return Fe / 360 + 0.5;
        }
        function ze(Fe) {
          const H = Math.sin(Fe * Math.PI / 180), K = 0.5 - 0.25 * Math.log((1 + H) / (1 - H)) / Math.PI;
          return K < 0 ? 0 : K > 1 ? 1 : K;
        }
        function Re(Fe) {
          const H = (180 - 360 * Fe) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(H)) / Math.PI - 90;
        }
        function De(Fe, H, K, re) {
          let Te = re;
          const me = H + (K - H >> 1);
          let Ye, We = K - H;
          const Ve = Fe[H], $e = Fe[H + 1], gt = Fe[K], st = Fe[K + 1];
          for (let vt = H + 3; vt < K; vt += 3) {
            const Be = Ne(Fe[vt], Fe[vt + 1], Ve, $e, gt, st);
            if (Be > Te) Ye = vt, Te = Be;
            else if (Be === Te) {
              const Qt = Math.abs(vt - me);
              Qt < We && (Ye = vt, We = Qt);
            }
          }
          Te > re && (Ye - H > 3 && De(Fe, H, Ye, re), Fe[Ye + 2] = Te, K - Ye > 3 && De(Fe, Ye, K, re));
        }
        function Ne(Fe, H, K, re, Te, me) {
          let Ye = Te - K, We = me - re;
          if (Ye !== 0 || We !== 0) {
            const Ve = ((Fe - K) * Ye + (H - re) * We) / (Ye * Ye + We * We);
            Ve > 1 ? (K = Te, re = me) : Ve > 0 && (K += Ye * Ve, re += We * Ve);
          }
          return Ye = Fe - K, We = H - re, Ye * Ye + We * We;
        }
        function Ge(Fe, H, K, re) {
          const Te = { type: H, geom: K }, me = { id: Fe ?? null, type: Te.type, geometry: Te.geom, tags: re, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          switch (Te.type) {
            case "Point":
            case "MultiPoint":
            case "LineString":
              qe(me, Te.geom);
              break;
            case "Polygon":
              qe(me, Te.geom[0]);
              break;
            case "MultiLineString":
              for (const Ye of Te.geom) qe(me, Ye);
              break;
            case "MultiPolygon":
              for (const Ye of Te.geom) qe(me, Ye[0]);
          }
          return me;
        }
        function qe(Fe, H) {
          for (let K = 0; K < H.length; K += 3) Fe.minX = Math.min(Fe.minX, H[K]), Fe.minY = Math.min(Fe.minY, H[K + 1]), Fe.maxX = Math.max(Fe.maxX, H[K]), Fe.maxY = Math.max(Fe.maxY, H[K + 1]);
        }
        function Je(Fe, H) {
          const K = [];
          switch (Fe.type) {
            case "FeatureCollection":
              for (let re = 0; re < Fe.features.length; re++) ft(K, Fe.features[re], H, re);
              break;
            case "Feature":
              ft(K, Fe, H);
              break;
            default:
              ft(K, { geometry: Fe, properties: void 0 }, H);
          }
          return K;
        }
        function ft(Fe, H, K, re) {
          if (!H.geometry) return;
          if (H.geometry.type === "GeometryCollection") {
            for (const We of H.geometry.geometries) ft(Fe, { id: H.id, geometry: We, properties: H.properties }, K, re);
            return;
          }
          if (!H.geometry.coordinates?.length) return;
          const me = Math.pow(K.tolerance / ((1 << K.maxZoom) * K.extent), 2);
          let Ye = H.id;
          switch (K.promoteId ? Ye = H.properties?.[K.promoteId] : K.generateId && (Ye = re || 0), H.geometry.type) {
            case "Point": {
              const We = [];
              return Tt(H.geometry.coordinates, We), void Fe.push(Ge(Ye, H.geometry.type, We, H.properties));
            }
            case "MultiPoint": {
              const We = [];
              for (const Ve of H.geometry.coordinates) Tt(Ve, We);
              return void Fe.push(Ge(Ye, H.geometry.type, We, H.properties));
            }
            case "LineString": {
              const We = [];
              return Zt(H.geometry.coordinates, We, me, !1), void Fe.push(Ge(Ye, H.geometry.type, We, H.properties));
            }
            case "MultiLineString": {
              if (K.lineMetrics) {
                for (const Ve of H.geometry.coordinates) {
                  const $e = [];
                  Zt(Ve, $e, me, !1), Fe.push(Ge(Ye, "LineString", $e, H.properties));
                }
                return;
              }
              const We = [];
              return zt(H.geometry.coordinates, We, me, !1), void Fe.push(Ge(Ye, H.geometry.type, We, H.properties));
            }
            case "Polygon": {
              const We = [];
              return zt(H.geometry.coordinates, We, me, !0), void Fe.push(Ge(Ye, H.geometry.type, We, H.properties));
            }
            case "MultiPolygon": {
              const We = [];
              for (const Ve of H.geometry.coordinates) {
                const $e = [];
                zt(Ve, $e, me, !0), We.push($e);
              }
              return void Fe.push(Ge(Ye, H.geometry.type, We, H.properties));
            }
            default:
              throw new Error("Input data is not a valid GeoJSON object.");
          }
        }
        function Tt(Fe, H) {
          H.push(At(Fe[0]), Dt(Fe[1]), 0);
        }
        function Zt(Fe, H, K, re) {
          let Te, me, Ye = 0;
          for (let Ve = 0; Ve < Fe.length; Ve++) {
            const $e = At(Fe[Ve][0]), gt = Dt(Fe[Ve][1]);
            H.push($e, gt, 0), Ve > 0 && (Ye += re ? (Te * gt - $e * me) / 2 : Math.sqrt(Math.pow($e - Te, 2) + Math.pow(gt - me, 2))), Te = $e, me = gt;
          }
          const We = H.length - 3;
          H[2] = 1, K > 0 && De(H, 0, We, K), H[We + 2] = 1, H.size = Math.abs(Ye), H.start = 0, H.end = H.size;
        }
        function zt(Fe, H, K, re) {
          for (let Te = 0; Te < Fe.length; Te++) {
            const me = [];
            Zt(Fe[Te], me, K, re), H.push(me);
          }
        }
        function At(Fe) {
          return Fe / 360 + 0.5;
        }
        function Dt(Fe) {
          const H = Math.sin(Fe * Math.PI / 180), K = 0.5 - 0.25 * Math.log((1 + H) / (1 - H)) / Math.PI;
          return K < 0 ? 0 : K > 1 ? 1 : K;
        }
        function Yt(Fe, H, K, re, Te, me, Ye, We) {
          if (re /= H, me >= (K /= H) && Ye < re) return Fe;
          if (Ye < K || me >= re) return null;
          const Ve = [];
          for (const $e of Fe) {
            const gt = Te === 0 ? $e.minX : $e.minY, st = Te === 0 ? $e.maxX : $e.maxY;
            if (gt >= K && st < re) Ve.push($e);
            else if (!(st < K || gt >= re)) switch ($e.type) {
              case "Point":
              case "MultiPoint": {
                const vt = [];
                if (mr($e.geometry, vt, K, re, Te), !vt.length) continue;
                Ve.push(Ge($e.id, vt.length === 3 ? "Point" : "MultiPoint", vt, $e.tags));
                continue;
              }
              case "LineString": {
                const vt = [];
                if (He($e.geometry, vt, K, re, Te, !1, We.lineMetrics), !vt.length) continue;
                if (We.lineMetrics) {
                  for (const Be of vt) Ve.push(Ge($e.id, $e.type, Be, $e.tags));
                  continue;
                }
                if (vt.length > 1) {
                  Ve.push(Ge($e.id, "MultiLineString", vt, $e.tags));
                  continue;
                }
                Ve.push(Ge($e.id, $e.type, vt[0], $e.tags));
                continue;
              }
              case "MultiLineString": {
                const vt = [];
                if (fr($e.geometry, vt, K, re, Te, !1), !vt.length) continue;
                if (vt.length === 1) {
                  Ve.push(Ge($e.id, "LineString", vt[0], $e.tags));
                  continue;
                }
                Ve.push(Ge($e.id, $e.type, vt, $e.tags));
                continue;
              }
              case "Polygon": {
                const vt = [];
                if (fr($e.geometry, vt, K, re, Te, !0), !vt.length) continue;
                Ve.push(Ge($e.id, $e.type, vt, $e.tags));
                continue;
              }
              case "MultiPolygon": {
                const vt = [];
                for (const Be of $e.geometry) {
                  const Qt = [];
                  fr(Be, Qt, K, re, Te, !0), Qt.length && vt.push(Qt);
                }
                if (!vt.length) continue;
                Ve.push(Ge($e.id, $e.type, vt, $e.tags));
                continue;
              }
            }
          }
          return Ve.length ? Ve : null;
        }
        function mr(Fe, H, K, re, Te) {
          for (let me = 0; me < Fe.length; me += 3) {
            const Ye = Fe[me + Te];
            Ye >= K && Ye <= re && Bt(H, Fe[me], Fe[me + 1], Fe[me + 2]);
          }
        }
        function He(Fe, H, K, re, Te, me, Ye) {
          let We = yi(Fe);
          const Ve = Te === 0 ? Me : br;
          let $e, gt, st = Fe.start;
          for (let kt = 0; kt < Fe.length - 3; kt += 3) {
            const lt = Fe[kt], nr = Fe[kt + 1], Fr = Fe[kt + 2], wr = Fe[kt + 3], un = Fe[kt + 4], Qr = Te === 0 ? lt : nr, Ur = Te === 0 ? wr : un;
            let Ir = !1;
            Ye && ($e = Math.sqrt(Math.pow(lt - wr, 2) + Math.pow(nr - un, 2))), Qr < K ? Ur > K && (gt = Ve(We, lt, nr, wr, un, K), Ye && (We.start = st + $e * gt)) : Qr > re ? Ur < re && (gt = Ve(We, lt, nr, wr, un, re), Ye && (We.start = st + $e * gt)) : Bt(We, lt, nr, Fr), Ur < K && Qr >= K && (gt = Ve(We, lt, nr, wr, un, K), Ir = !0), Ur > re && Qr <= re && (gt = Ve(We, lt, nr, wr, un, re), Ir = !0), !me && Ir && (Ye && (We.end = st + $e * gt), H.push(We), We = yi(Fe)), Ye && (st += $e);
          }
          let vt = Fe.length - 3;
          const Be = Fe[vt], Qt = Fe[vt + 1], Cr = Te === 0 ? Be : Qt;
          Cr >= K && Cr <= re && Bt(We, Be, Qt, Fe[vt + 2]), vt = We.length - 3, me && vt >= 3 && (We[vt] !== We[0] || We[vt + 1] !== We[1]) && Bt(We, We[0], We[1], We[2]), We.length && H.push(We);
        }
        function yi(Fe) {
          const H = [];
          return H.size = Fe.size, H.start = Fe.start, H.end = Fe.end, H;
        }
        function fr(Fe, H, K, re, Te, me) {
          for (const Ye of Fe) He(Ye, H, K, re, Te, me, !1);
        }
        function Bt(Fe, H, K, re) {
          Fe.push(H, K, re);
        }
        function Me(Fe, H, K, re, Te, me) {
          const Ye = (me - H) / (re - H);
          return Bt(Fe, me, K + (Te - K) * Ye, 1), Ye;
        }
        function br(Fe, H, K, re, Te, me) {
          const Ye = (me - K) / (Te - K);
          return Bt(Fe, H + (re - H) * Ye, me, 1), Ye;
        }
        function ur(Fe, H) {
          const K = H.buffer / H.extent;
          let re = Fe;
          const Te = Yt(Fe, 1, -1 - K, K, 0, -1, 2, H), me = Yt(Fe, 1, 1 - K, 2 + K, 0, -1, 2, H);
          return (Te || me) && (re = Yt(Fe, 1, -K, 1 + K, 0, -1, 2, H) || [], Te && (re = rr(Te, 1).concat(re)), me && (re = re.concat(rr(me, -1)))), re;
        }
        function rr(Fe, H) {
          const K = [];
          for (const re of Fe) switch (re.type) {
            case "Point":
            case "MultiPoint":
            case "LineString": {
              const Te = ni(re.geometry, H);
              K.push(Ge(re.id, re.type, Te, re.tags));
              continue;
            }
            case "MultiLineString":
            case "Polygon": {
              const Te = [];
              for (const me of re.geometry) Te.push(ni(me, H));
              K.push(Ge(re.id, re.type, Te, re.tags));
              continue;
            }
            case "MultiPolygon": {
              const Te = [];
              for (const me of re.geometry) {
                const Ye = [];
                for (const We of me) Ye.push(ni(We, H));
                Te.push(Ye);
              }
              K.push(Ge(re.id, re.type, Te, re.tags));
              continue;
            }
          }
          return K;
        }
        function ni(Fe, H) {
          const K = [];
          K.size = Fe.size, Fe.start !== void 0 && (K.start = Fe.start, K.end = Fe.end);
          for (let re = 0; re < Fe.length; re += 3) K.push(Fe[re] + H, Fe[re + 1], Fe[re + 2]);
          return K;
        }
        function Dr(Fe, H) {
          if (Fe.transformed) return Fe;
          const K = 1 << Fe.z, re = Fe.x, Te = Fe.y;
          for (const me of Fe.features) {
            if (me.type === 1) {
              const We = [];
              for (let Ve = 0; Ve < me.geometry.length; Ve += 2) We.push(ii(me.geometry[Ve], me.geometry[Ve + 1], H, K, re, Te));
              me.geometry = We;
              continue;
            }
            const Ye = [];
            for (const We of me.geometry) {
              const Ve = [];
              for (let $e = 0; $e < We.length; $e += 2) Ve.push(ii(We[$e], We[$e + 1], H, K, re, Te));
              Ye.push(Ve);
            }
            me.geometry = Ye;
          }
          return Fe.transformed = !0, Fe;
        }
        function ii(Fe, H, K, re, Te, me) {
          return [Math.round(K * (Fe * re - Te)), Math.round(K * (H * re - me))];
        }
        function Mt(Fe, H, K, re, Te) {
          const me = H === Te.maxZoom ? 0 : Te.tolerance / ((1 << H) * Te.extent), Ye = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Fe.length, source: null, x: K, y: re, z: H, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const We of Fe) Zi(Ye, We, me, Te);
          return Ye;
        }
        function Zi(Fe, H, K, re) {
          Fe.minX = Math.min(Fe.minX, H.minX), Fe.minY = Math.min(Fe.minY, H.minY), Fe.maxX = Math.max(Fe.maxX, H.maxX), Fe.maxY = Math.max(Fe.maxY, H.maxY);
          let Te, me = H.tags || null;
          switch (H.type) {
            case "Point":
            case "MultiPoint": {
              const Ye = [];
              for (let We = 0; We < H.geometry.length; We += 3) Ye.push(H.geometry[We], H.geometry[We + 1]), Fe.numPoints++, Fe.numSimplified++;
              if (!Ye.length) return;
              Te = { type: 1, tags: me, geometry: Ye };
              break;
            }
            case "LineString": {
              const Ye = [];
              if (Ti(Ye, H.geometry, Fe, K, !1, !1), !Ye.length) return;
              if (re.lineMetrics) {
                me = {};
                for (const We in H.tags) me[We] = H.tags[We];
                me.mapbox_clip_start = H.geometry.start / H.geometry.size, me.mapbox_clip_end = H.geometry.end / H.geometry.size;
              }
              Te = { type: 2, tags: me, geometry: Ye };
              break;
            }
            case "MultiLineString":
            case "Polygon": {
              const Ye = [];
              for (let We = 0; We < H.geometry.length; We++) Ti(Ye, H.geometry[We], Fe, K, H.type === "Polygon", We === 0);
              if (!Ye.length) return;
              Te = { type: H.type === "Polygon" ? 3 : 2, tags: me, geometry: Ye };
              break;
            }
            case "MultiPolygon": {
              const Ye = [];
              for (let We = 0; We < H.geometry.length; We++) {
                const Ve = H.geometry[We];
                for (let $e = 0; $e < Ve.length; $e++) Ti(Ye, Ve[$e], Fe, K, !0, $e === 0);
              }
              if (!Ye.length) return;
              Te = { type: 3, tags: me, geometry: Ye };
              break;
            }
          }
          H.id !== null && (Te.id = H.id), Fe.features.push(Te);
        }
        function Ti(Fe, H, K, re, Te, me) {
          const Ye = re * re;
          if (re > 0 && H.size < (Te ? Ye : re)) return void (K.numPoints += H.length / 3);
          const We = [];
          for (let Ve = 0; Ve < H.length; Ve += 3) (re === 0 || H[Ve + 2] > Ye) && (K.numSimplified++, We.push(H[Ve], H[Ve + 1])), K.numPoints++;
          Te && (function(Ve, $e) {
            let gt = 0;
            for (let st = 0, vt = Ve.length, Be = vt - 2; st < vt; Be = st, st += 2) gt += (Ve[st] - Ve[Be]) * (Ve[st + 1] + Ve[Be + 1]);
            if (gt > 0 === $e) for (let st = 0, vt = Ve.length; st < vt / 2; st += 2) {
              const Be = Ve[st], Qt = Ve[st + 1];
              Ve[st] = Ve[vt - 2 - st], Ve[st + 1] = Ve[vt - 1 - st], Ve[vt - 2 - st] = Be, Ve[vt - 1 - st] = Qt;
            }
          })(We, me), Fe.push(We);
        }
        function jn(Fe, H, K) {
          const re = !!H.newGeometry, Te = H.removeAllProperties || H.removeProperties?.length > 0 || H.addOrUpdateProperties?.length > 0;
          if (re) {
            let me = Je({ type: "FeatureCollection", features: [{ type: "Feature", id: Fe.id, geometry: H.newGeometry, properties: Te ? Ls(Fe.tags, H) : Fe.tags }] }, K);
            return me = ur(me, K), me[0];
          }
          if (Te) {
            const me = { ...Fe };
            return me.tags = Ls(me.tags, H), me;
          }
          return null;
        }
        function Ls(Fe, H) {
          if (H.removeAllProperties) return {};
          const K = { ...Fe || {} };
          if (H.removeProperties) for (const re of H.removeProperties) delete K[re];
          if (H.addOrUpdateProperties) for (const { key: re, value: Te } of H.addOrUpdateProperties) K[re] = Te;
          return K;
        }
        const tr = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, updateable: !1, debug: 0 };
        class ln {
          options;
          tiles;
          tileCoords;
          stats = {};
          total = 0;
          source;
          constructor(H, K) {
            const re = (K = this.options = Object.assign({}, tr, K)).debug;
            if (re && console.time("preprocess data"), K.maxZoom < 0 || K.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (K.promoteId && K.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let Te = Je(H, K);
            this.tiles = {}, this.tileCoords = [], re && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", K.indexMaxZoom, K.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Te = ur(Te, K), Te.length && this.splitTile(Te, 0, 0, 0), K.updateable && (this.source = Te), re && (Te.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(H, K, re, Te, me, Ye, We) {
            const Ve = [H, K, re, Te], $e = this.options, gt = $e.debug;
            for (; Ve.length; ) {
              Te = Ve.pop(), re = Ve.pop(), K = Ve.pop(), H = Ve.pop();
              const st = 1 << K, vt = Vn(K, re, Te);
              let Be = this.tiles[vt];
              if (!Be && (gt > 1 && console.time("creation"), Be = this.tiles[vt] = Mt(H, K, re, Te, $e), this.tileCoords.push({ z: K, x: re, y: Te, id: vt }), gt)) {
                gt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", K, re, Te, Be.numFeatures, Be.numPoints, Be.numSimplified), console.timeEnd("creation"));
                const Ir = `z${K}`;
                this.stats[Ir] = (this.stats[Ir] || 0) + 1, this.total++;
              }
              if (Be.source = H, me == null) {
                if (K === $e.indexMaxZoom || Be.numPoints <= $e.indexMaxPoints) continue;
              } else {
                if (K === $e.maxZoom || K === me) continue;
                if (me != null) {
                  const Ir = me - K;
                  if (re !== Ye >> Ir || Te !== We >> Ir) continue;
                }
              }
              if (Be.source = null, !H.length) continue;
              gt > 1 && console.time("clipping");
              const Qt = 0.5 * $e.buffer / $e.extent, Cr = 0.5 - Qt, kt = 0.5 + Qt, lt = 1 + Qt;
              let nr = null, Fr = null, wr = null, un = null;
              const Qr = Yt(H, st, re - Qt, re + kt, 0, Be.minX, Be.maxX, $e), Ur = Yt(H, st, re + Cr, re + lt, 0, Be.minX, Be.maxX, $e);
              Qr && (nr = Yt(Qr, st, Te - Qt, Te + kt, 1, Be.minY, Be.maxY, $e), Fr = Yt(Qr, st, Te + Cr, Te + lt, 1, Be.minY, Be.maxY, $e)), Ur && (wr = Yt(Ur, st, Te - Qt, Te + kt, 1, Be.minY, Be.maxY, $e), un = Yt(Ur, st, Te + Cr, Te + lt, 1, Be.minY, Be.maxY, $e)), gt > 1 && console.timeEnd("clipping"), Ve.push(nr || [], K + 1, 2 * re, 2 * Te), Ve.push(Fr || [], K + 1, 2 * re, 2 * Te + 1), Ve.push(wr || [], K + 1, 2 * re + 1, 2 * Te), Ve.push(un || [], K + 1, 2 * re + 1, 2 * Te + 1);
            }
          }
          getTile(H, K, re) {
            H = +H, K = +K, re = +re;
            const Te = this.options, { extent: me, debug: Ye } = Te;
            if (H < 0 || H > 24) return null;
            const We = 1 << H, Ve = Vn(H, K = K + We & We - 1, re);
            if (this.tiles[Ve]) return Dr(this.tiles[Ve], me);
            Ye > 1 && console.log("drilling down to z%d-%d-%d", H, K, re);
            let $e, gt = H, st = K, vt = re;
            for (; !$e && gt > 0; ) gt--, st >>= 1, vt >>= 1, $e = this.tiles[Vn(gt, st, vt)];
            return $e?.source ? (Ye > 1 && (console.log("found parent tile z%d-%d-%d", gt, st, vt), console.time("drilling down")), this.splitTile($e.source, gt, st, vt, H, K, re), Ye > 1 && console.timeEnd("drilling down"), this.tiles[Ve] ? Dr(this.tiles[Ve], me) : null) : null;
          }
          invalidateTiles(H) {
            const K = this.options, { debug: re } = K;
            let Te = 1 / 0, me = -1 / 0, Ye = 1 / 0, We = -1 / 0;
            for (const gt of H) Te = Math.min(Te, gt.minX), me = Math.max(me, gt.maxX), Ye = Math.min(Ye, gt.minY), We = Math.max(We, gt.maxY);
            const Ve = K.buffer / K.extent, $e = /* @__PURE__ */ new Set();
            for (const gt in this.tiles) {
              const st = this.tiles[gt], vt = 1 << st.z, Be = (st.x - Ve) / vt, Qt = (st.x + 1 + Ve) / vt, Cr = (st.y - Ve) / vt, kt = (st.y + 1 + Ve) / vt;
              if (me < Be || Te >= Qt || We < Cr || Ye >= kt) continue;
              let lt = !1;
              for (const nr of H) if (nr.maxX >= Be && nr.minX < Qt && nr.maxY >= Cr && nr.minY < kt) {
                lt = !0;
                break;
              }
              if (lt) {
                if (re) {
                  re > 1 && console.log("invalidate tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", st.z, st.x, st.y, st.numFeatures, st.numPoints, st.numSimplified);
                  const nr = `z${st.z}`;
                  this.stats[nr] = (this.stats[nr] || 0) - 1, this.total--;
                }
                delete this.tiles[gt], $e.add(gt);
              }
            }
            $e.size && (this.tileCoords = this.tileCoords.filter(((gt) => !$e.has(gt.id))));
          }
          updateData(H) {
            const K = this.options, re = K.debug;
            if (!K.updateable) throw new Error("to update tile geojson `updateable` option must be set to true");
            const { affected: Te, source: me } = (function(st, vt, Be) {
              const Qt = (function(kt) {
                return kt ? { removeAll: kt.removeAll, remove: new Set(kt.remove || []), add: new Map(kt.add?.map(((lt) => [lt.id, lt]))), update: new Map(kt.update?.map(((lt) => [lt.id, lt]))) } : { remove: /* @__PURE__ */ new Set(), add: /* @__PURE__ */ new Map(), update: /* @__PURE__ */ new Map() };
              })(vt);
              let Cr = [];
              if (Qt.removeAll && (Cr = st, st = []), Qt.remove.size || Qt.add.size) {
                const kt = [];
                for (const lt of st) {
                  const { id: nr } = lt;
                  (Qt.remove.has(nr) || Qt.add.has(nr)) && kt.push(lt);
                }
                if (kt.length) {
                  Cr.push(...kt);
                  const lt = new Set(kt.map(((nr) => nr.id)));
                  st = st.filter(((nr) => !lt.has(nr.id)));
                }
                if (Qt.add.size) {
                  let lt = Je({ type: "FeatureCollection", features: Array.from(Qt.add.values()) }, Be);
                  lt = ur(lt, Be), Cr.push(...lt), st.push(...lt);
                }
              }
              if (Qt.update.size) for (const [kt, lt] of Qt.update) {
                const nr = st.findIndex(((un) => un.id === kt));
                if (nr === -1) continue;
                const Fr = st[nr], wr = jn(Fr, lt, Be);
                wr && (Cr.push(Fr, wr), st[nr] = wr);
              }
              return { affected: Cr, source: st };
            })(this.source, H, K);
            if (!Te.length) return;
            this.source = me, re > 1 && (console.log("invalidating tiles"), console.time("invalidating")), this.invalidateTiles(Te), re > 1 && console.timeEnd("invalidating");
            const [Ye, We, Ve] = [0, 0, 0], $e = Mt(this.source, Ye, We, Ve, this.options);
            $e.source = this.source;
            const gt = Vn(Ye, We, Ve);
            if (this.tiles[gt] = $e, this.tileCoords.push({ z: Ye, x: We, y: Ve, id: gt }), re) {
              const st = `z${Ye}`;
              this.stats[st] = (this.stats[st] || 0) + 1, this.total++;
            }
          }
        }
        function Vn(Fe, H, K) {
          return 32 * ((1 << Fe) * K + H) + Fe;
        }
        class Un extends ne {
          constructor(H, K, re, Te = Jt) {
            super(H, K, re), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = Te;
          }
          loadVectorTile(H, K) {
            return S._(this, void 0, void 0, (function* () {
              const re = H.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const Te = this._geoJSONIndex.getTile(re.z, re.x, re.y);
              return Te ? ce(new S.d3(Te.features, { version: 2, extent: S.a5 })) : null;
            }));
          }
          loadData(H) {
            return S._(this, void 0, void 0, (function* () {
              var K;
              (K = this._pendingRequest) === null || K === void 0 || K.abort();
              const re = this._startPerformance(H);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || H.request || H.data || H.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(H, this._pendingRequest));
                const Te = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(Te, H), this.loaded = {};
                const me = {};
                return H.request && (me.data = Te), this._finishPerformance(re, H, me), me;
              } catch (Te) {
                if (delete this._pendingRequest, S.Z(Te)) return { abandoned: !0 };
                throw Te;
              }
            }));
          }
          _startPerformance(H) {
            var K;
            if (!((K = H?.request) === null || K === void 0) && K.collectResourceTiming) return new S.c$(H.request);
          }
          _finishPerformance(H, K, re) {
            if (!H) return;
            const Te = H.finish();
            Te && (re.resourceTiming = {}, re.resourceTiming[K.source] = JSON.parse(JSON.stringify(Te)));
          }
          getData() {
            return S._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(H) {
            const K = this.loaded;
            return K && K[H.uid] ? super.reloadTile(H) : this.loadTile(H);
          }
          loadAndProcessGeoJSON(H, K) {
            return S._(this, void 0, void 0, (function* () {
              let re;
              if (H.request ? re = yield this.loadGeoJSONFromUrl(H.request, H.promoteId, K) : H.data ? re = this._loadGeoJSONFromObject(H.data, H.promoteId) : H.dataDiff && (re = this._loadGeoJSONFromDiff(H.dataDiff, H.promoteId, H.source)), delete this._pendingRequest, typeof re != "object") throw new Error(`Input data given to '${H.source}' is not a valid GeoJSON object.`);
              return et(re, !0), H.filter && (re = this._filterGeoJSON(re, H.filter)), re;
            }));
          }
          loadGeoJSONFromUrl(H, K, re) {
            return S._(this, void 0, void 0, (function* () {
              const Te = yield S.j(H, re);
              return this._dataUpdateable = S.a7(Te.data, K), Te.data;
            }));
          }
          _loadGeoJSONFromObject(H, K) {
            return this._dataUpdateable = S.a7(H, K), H;
          }
          _loadGeoJSONFromDiff(H, K, re) {
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${re}`);
            S.a8(this._dataUpdateable, H, K);
            const Te = Array.from(this._dataUpdateable.values());
            return this._toFeatureCollection(Te);
          }
          _filterGeoJSON(H, K) {
            const re = S.d4(K, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
            if (re.result === "error") throw new Error(re.value.map(((me) => `${me.key}: ${me.message}`)).join(", "));
            const Te = H.features.filter(((me) => re.value.evaluate({ zoom: 0 }, me)));
            return this._toFeatureCollection(Te);
          }
          _toFeatureCollection(H) {
            return { type: "FeatureCollection", features: H };
          }
          removeSource(H) {
            return S._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(H) {
            return this._geoJSONIndex.getClusterExpansionZoom(H.clusterId);
          }
          getClusterChildren(H) {
            return this._geoJSONIndex.getChildren(H.clusterId);
          }
          getClusterLeaves(H) {
            return this._geoJSONIndex.getLeaves(H.clusterId, H.limit, H.offset);
          }
        }
        function Jt(Fe, H) {
          return H.cluster ? new se((function({ superclusterOptions: K, clusterProperties: re }) {
            if (!re || !K) return K;
            const Te = {}, me = {}, Ye = { accumulated: null, zoom: 0 }, We = { properties: null }, Ve = Object.keys(re);
            for (const $e of Ve) {
              const [gt, st] = re[$e], vt = S.d4(st), Be = S.d4(typeof gt == "string" ? [gt, ["accumulated"], ["get", $e]] : gt);
              Te[$e] = vt.value, me[$e] = Be.value;
            }
            return K.map = ($e) => {
              We.properties = $e;
              const gt = {};
              for (const st of Ve) gt[st] = Te[st].evaluate(Ye, We);
              return gt;
            }, K.reduce = ($e, gt) => {
              We.properties = gt;
              for (const st of Ve) Ye.accumulated = $e[st], $e[st] = me[st].evaluate(Ye, We);
            }, K;
          })(H)).load(Fe.features) : (function(K, re) {
            return new ln(K, re);
          })(Fe, H.geojsonVtOptions);
        }
        class os {
          constructor(H) {
            this.self = H, this.actor = new S.L(H), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (K, re) => {
              if (this.externalWorkerSourceTypes[K]) throw new Error(`Worker source with name "${K}" already registered.`);
              this.externalWorkerSourceTypes[K] = re;
            }, this.self.addProtocol = S.cK, this.self.removeProtocol = S.cL, this.self.registerRTLTextPlugin = (K) => {
              S.d5.setMethods(K);
            }, this.actor.registerMessageHandler("LDT", ((K, re) => this._getDEMWorkerSource(K, re.source).loadTile(re))), this.actor.registerMessageHandler("RDT", ((K, re) => S._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(K, re.source).removeTile(re);
            })))), this.actor.registerMessageHandler("GCEZ", ((K, re) => S._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(K, re.type, re.source).getClusterExpansionZoom(re);
            })))), this.actor.registerMessageHandler("GCC", ((K, re) => S._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(K, re.type, re.source).getClusterChildren(re);
            })))), this.actor.registerMessageHandler("GCL", ((K, re) => S._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(K, re.type, re.source).getClusterLeaves(re);
            })))), this.actor.registerMessageHandler("LD", ((K, re) => this._getWorkerSource(K, re.type, re.source).loadData(re))), this.actor.registerMessageHandler("GD", ((K, re) => this._getWorkerSource(K, re.type, re.source).getData())), this.actor.registerMessageHandler("LT", ((K, re) => this._getWorkerSource(K, re.type, re.source).loadTile(re))), this.actor.registerMessageHandler("RT", ((K, re) => this._getWorkerSource(K, re.type, re.source).reloadTile(re))), this.actor.registerMessageHandler("AT", ((K, re) => this._getWorkerSource(K, re.type, re.source).abortTile(re))), this.actor.registerMessageHandler("RMT", ((K, re) => this._getWorkerSource(K, re.type, re.source).removeTile(re))), this.actor.registerMessageHandler("RS", ((K, re) => S._(this, void 0, void 0, (function* () {
              if (!this.workerSources[K] || !this.workerSources[K][re.type] || !this.workerSources[K][re.type][re.source]) return;
              const Te = this.workerSources[K][re.type][re.source];
              delete this.workerSources[K][re.type][re.source], Te.removeSource !== void 0 && Te.removeSource(re);
            })))), this.actor.registerMessageHandler("RM", ((K) => S._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[K], delete this.availableImages[K], delete this.workerSources[K], delete this.demWorkerSources[K], this.globalStates.delete(K);
            })))), this.actor.registerMessageHandler("SR", ((K, re) => S._(this, void 0, void 0, (function* () {
              this.referrer = re;
            })))), this.actor.registerMessageHandler("SRPS", ((K, re) => this._syncRTLPluginState(K, re))), this.actor.registerMessageHandler("IS", ((K, re) => S._(this, void 0, void 0, (function* () {
              this.self.importScripts(re);
            })))), this.actor.registerMessageHandler("SI", ((K, re) => this._setImages(K, re))), this.actor.registerMessageHandler("UL", ((K, re) => S._(this, void 0, void 0, (function* () {
              this._getLayerIndex(K).update(re.layers, re.removedIds, this._getGlobalState(K));
            })))), this.actor.registerMessageHandler("UGS", ((K, re) => S._(this, void 0, void 0, (function* () {
              const Te = this._getGlobalState(K);
              for (const me in re) Te[me] = re[me];
            })))), this.actor.registerMessageHandler("SL", ((K, re) => S._(this, void 0, void 0, (function* () {
              this._getLayerIndex(K).replace(re, this._getGlobalState(K));
            }))));
          }
          _getGlobalState(H) {
            let K = this.globalStates.get(H);
            return K || (K = {}, this.globalStates.set(H, K)), K;
          }
          _setImages(H, K) {
            return S._(this, void 0, void 0, (function* () {
              this.availableImages[H] = K;
              for (const re in this.workerSources[H]) {
                const Te = this.workerSources[H][re];
                for (const me in Te) Te[me].availableImages = K;
              }
            }));
          }
          _syncRTLPluginState(H, K) {
            return S._(this, void 0, void 0, (function* () {
              return yield S.d5.syncState(K, this.self.importScripts);
            }));
          }
          _getAvailableImages(H) {
            let K = this.availableImages[H];
            return K || (K = []), K;
          }
          _getLayerIndex(H) {
            let K = this.layerIndexes[H];
            return K || (K = this.layerIndexes[H] = new u()), K;
          }
          _getWorkerSource(H, K, re) {
            if (this.workerSources[H] || (this.workerSources[H] = {}), this.workerSources[H][K] || (this.workerSources[H][K] = {}), !this.workerSources[H][K][re]) {
              const Te = { sendAsync: (me, Ye) => (me.targetMapId = H, this.actor.sendAsync(me, Ye)) };
              switch (K) {
                case "vector":
                  this.workerSources[H][K][re] = new ne(Te, this._getLayerIndex(H), this._getAvailableImages(H));
                  break;
                case "geojson":
                  this.workerSources[H][K][re] = new Un(Te, this._getLayerIndex(H), this._getAvailableImages(H));
                  break;
                default:
                  this.workerSources[H][K][re] = new this.externalWorkerSourceTypes[K](Te, this._getLayerIndex(H), this._getAvailableImages(H));
              }
            }
            return this.workerSources[H][K][re];
          }
          _getDEMWorkerSource(H, K) {
            return this.demWorkerSources[H] || (this.demWorkerSources[H] = {}), this.demWorkerSources[H][K] || (this.demWorkerSources[H][K] = new Pe()), this.demWorkerSources[H][K];
          }
        }
        return S.i(self) && (self.worker = new os(self)), os;
      })), x("index", ["exports", "./shared"], (function(S, u) {
        var R = "5.17.0";
        function z() {
          var b = new u.A(4);
          return u.A != Float32Array && (b[1] = 0, b[2] = 0), b[0] = 1, b[3] = 1, b;
        }
        let U, $, ee;
        const le = { frame(b, t, s, d) {
          const g = d || window, w = g.requestAnimationFrame(((C) => {
            T(), t(C);
          })), { unsubscribe: T } = u.s(b.signal, "abort", (() => {
            T(), g.cancelAnimationFrame(w), s(new u.a(b.signal.reason));
          }), !1);
        }, frameAsync(b, t) {
          return new Promise(((s, d) => {
            this.frame(b, s, d, t);
          }));
        }, getImageData(b, t = 0) {
          return this.getImageCanvasContext(b).getImageData(-t, -t, b.width + 2 * t, b.height + 2 * t);
        }, getImageCanvasContext(b) {
          const t = window.document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: !0 });
          if (!s) throw new Error("failed to create canvas 2d context");
          return t.width = b.width, t.height = b.height, s.drawImage(b, 0, 0, b.width, b.height), s;
        }, resolveURL: (b) => (U || (U = document.createElement("a")), U.href = b, U.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return ee !== void 0 ? ee : !!matchMedia && ($ == null && ($ = matchMedia("(prefers-reduced-motion: reduce)")), $.matches);
        }, set prefersReducedMotion(b) {
          ee = b;
        } }, ce = new class {
          constructor() {
            this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return this._frozenAt !== null ? this._frozenAt : this._realTime();
          }
          setNow(b) {
            this._frozenAt = b;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return this._frozenAt !== null;
          }
        }();
        function _e() {
          return ce.getCurrentTime();
        }
        class ne {
          static testProp(t) {
            if (!ne.docStyle) return t[0];
            for (let s = 0; s < t.length; s++) if (t[s] in ne.docStyle) return t[s];
            return t[0];
          }
          static create(t, s, d) {
            const g = window.document.createElement(t);
            return s !== void 0 && (g.className = s), d && d.appendChild(g), g;
          }
          static createNS(t, s) {
            return window.document.createElementNS(t, s);
          }
          static disableDrag() {
            ne.docStyle && ne.selectProp && (ne.userSelect = ne.docStyle[ne.selectProp], ne.docStyle[ne.selectProp] = "none");
          }
          static enableDrag() {
            ne.docStyle && ne.selectProp && (ne.docStyle[ne.selectProp] = ne.userSelect);
          }
          static setTransform(t, s) {
            t.style[ne.transformProp] = s;
          }
          static addEventListener(t, s, d, g = {}) {
            t.addEventListener(s, d, "passive" in g ? g : g.capture);
          }
          static removeEventListener(t, s, d, g = {}) {
            t.removeEventListener(s, d, "passive" in g ? g : g.capture);
          }
          static suppressClickInternal(t) {
            t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", ne.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", ne.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", ne.suppressClickInternal, !0);
            }), 0);
          }
          static getScale(t) {
            const s = t.getBoundingClientRect();
            return { x: s.width / t.offsetWidth || 1, y: s.height / t.offsetHeight || 1, boundingClientRect: s };
          }
          static getPoint(t, s, d) {
            const g = s.boundingClientRect;
            return new u.P((d.clientX - g.left) / s.x - t.clientLeft, (d.clientY - g.top) / s.y - t.clientTop);
          }
          static mousePos(t, s) {
            const d = ne.getScale(t);
            return ne.getPoint(t, d, s);
          }
          static touchPos(t, s) {
            const d = [], g = ne.getScale(t);
            for (let w = 0; w < s.length; w++) d.push(ne.getPoint(t, g, s[w]));
            return d;
          }
          static mouseButton(t) {
            return t.button;
          }
          static remove(t) {
            t.parentNode && t.parentNode.removeChild(t);
          }
          static sanitize(t) {
            const s = new DOMParser().parseFromString(t, "text/html").body || document.createElement("body"), d = s.querySelectorAll("script");
            for (const g of d) g.remove();
            return ne.clean(s), s.innerHTML;
          }
          static isPossiblyDangerous(t, s) {
            const d = s.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(t) || !d.includes("javascript:") && !d.includes("data:")) || !!t.startsWith("on") || void 0;
          }
          static clean(t) {
            const s = t.children;
            for (const d of s) ne.removeAttributes(d), ne.clean(d);
          }
          static removeAttributes(t) {
            for (const { name: s, value: d } of t.attributes) ne.isPossiblyDangerous(s, d) && t.removeAttribute(s);
          }
        }
        ne.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, ne.selectProp = ne.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), ne.transformProp = ne.testProp(["transform", "WebkitTransform"]);
        const Pe = { supported: !1, testSupport: function(b) {
          !Qe && Ue && (et ? Xe(b) : ve = b);
        } };
        let ve, Ue, Qe = !1, et = !1;
        function Xe(b) {
          const t = b.createTexture();
          b.bindTexture(b.TEXTURE_2D, t);
          try {
            if (b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, Ue), b.isContextLost()) return;
            Pe.supported = !0;
          } catch {
          }
          b.deleteTexture(t), Qe = !0;
        }
        var ut;
        typeof document < "u" && (Ue = document.createElement("img"), Ue.onload = () => {
          ve && Xe(ve), ve = null, et = !0;
        }, Ue.onerror = () => {
          Qe = !0, ve = null;
        }, Ue.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(b) {
          let t, s, d, g;
          b.resetRequestQueue = () => {
            t = [], s = 0, d = 0, g = {};
          }, b.addThrottleControl = (A) => {
            const F = d++;
            return g[F] = A, F;
          }, b.removeThrottleControl = (A) => {
            delete g[A], T();
          }, b.getImage = (A, F, O = !0) => new Promise(((q, V) => {
            Pe.supported && (A.headers || (A.headers = {}), A.headers.accept = "image/webp,*/*"), u.e(A, { type: "image" }), t.push({ abortController: F, requestParameters: A, supportImageRefresh: O, state: "queued", onError: (X) => {
              V(X);
            }, onSuccess: (X) => {
              q(X);
            } }), T();
          }));
          const w = (A) => u._(this, void 0, void 0, (function* () {
            A.state = "running";
            const { requestParameters: F, supportImageRefresh: O, onError: q, onSuccess: V, abortController: X } = A, te = O === !1 && !u.i(self) && !u.g(F.url) && (!F.headers || Object.keys(F.headers).reduce(((fe, be) => fe && be === "accept"), !0));
            s++;
            const he = te ? C(F, X) : u.m(F, X);
            try {
              const fe = yield he;
              delete A.abortController, A.state = "completed", fe.data instanceof HTMLImageElement || u.b(fe.data) ? V(fe) : fe.data && V({ data: yield (pe = fe.data, typeof createImageBitmap == "function" ? u.f(pe) : u.h(pe)), cacheControl: fe.cacheControl, expires: fe.expires });
            } catch (fe) {
              delete A.abortController, q(fe);
            } finally {
              s--, T();
            }
            var pe;
          })), T = () => {
            const A = (() => {
              for (const F of Object.keys(g)) if (g[F]()) return !0;
              return !1;
            })() ? u.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : u.c.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let F = s; F < A && t.length > 0; F++) {
              const O = t.shift();
              O.abortController.signal.aborted ? F-- : w(O);
            }
          }, C = (A, F) => new Promise(((O, q) => {
            const V = new Image(), X = A.url, te = A.credentials;
            te && te === "include" ? V.crossOrigin = "use-credentials" : (te && te === "same-origin" || !u.d(X)) && (V.crossOrigin = "anonymous"), F.signal.addEventListener("abort", (() => {
              V.src = "", q(new u.a(F.signal.reason));
            })), V.fetchPriority = "high", V.onload = () => {
              V.onerror = V.onload = null, O({ data: V });
            }, V.onerror = () => {
              V.onerror = V.onload = null, F.signal.aborted || q(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, V.src = X;
          }));
        })(ut || (ut = {})), ut.resetRequestQueue();
        class Q {
          constructor(t) {
            this._transformRequestFn = t ?? null;
          }
          transformRequest(t, s) {
            return this._transformRequestFn && this._transformRequestFn(t, s) || { url: t };
          }
          setTransformRequest(t) {
            this._transformRequestFn = t;
          }
        }
        function se(b) {
          const t = [];
          if (typeof b == "string") t.push({ id: "default", url: b });
          else if (b && b.length > 0) {
            const s = [];
            for (const { id: d, url: g } of b) {
              const w = `${d}${g}`;
              s.indexOf(w) === -1 && (s.push(w), t.push({ id: d, url: g }));
            }
          }
          return t;
        }
        function ge(b, t, s) {
          try {
            const d = new URL(b);
            return d.pathname += `${t}${s}`, d.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${b}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function Se(b) {
          const { userImage: t } = b;
          return !!(t && t.render && t.render()) && (b.data.replace(new Uint8Array(t.data.buffer)), !0);
        }
        class Ie extends u.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          destroy() {
            this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
            for (const t of Object.keys(this.images)) this.removeImage(t);
            this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t) {
            if (this.loaded !== t && (this.loaded = t, t)) {
              for (const { ids: s, promiseResolve: d } of this.requestors) d(this._getImagesForIds(s));
              this.requestors = [];
            }
          }
          getImage(t) {
            const s = this.images[t];
            if (s && !s.data && s.spriteData) {
              const d = s.spriteData;
              s.data = new u.R({ width: d.width, height: d.height }, d.context.getImageData(d.x, d.y, d.width, d.height).data), s.spriteData = null;
            }
            return s;
          }
          addImage(t, s) {
            if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`);
            this._validate(t, s) && (this.images[t] = s);
          }
          _validate(t, s) {
            let d = !0;
            const g = s.data || s.spriteData;
            return this._validateStretch(s.stretchX, g && g.width) || (this.fire(new u.k(new Error(`Image "${t}" has invalid "stretchX" value`))), d = !1), this._validateStretch(s.stretchY, g && g.height) || (this.fire(new u.k(new Error(`Image "${t}" has invalid "stretchY" value`))), d = !1), this._validateContent(s.content, s) || (this.fire(new u.k(new Error(`Image "${t}" has invalid "content" value`))), d = !1), d;
          }
          _validateStretch(t, s) {
            if (!t) return !0;
            let d = 0;
            for (const g of t) {
              if (g[0] < d || g[1] < g[0] || s < g[1]) return !1;
              d = g[1];
            }
            return !0;
          }
          _validateContent(t, s) {
            if (!t) return !0;
            if (t.length !== 4) return !1;
            const d = s.spriteData, g = d && d.width || s.data.width, w = d && d.height || s.data.height;
            return !(t[0] < 0 || g < t[0] || t[1] < 0 || w < t[1] || t[2] < 0 || g < t[2] || t[3] < 0 || w < t[3] || t[2] < t[0] || t[3] < t[1]);
          }
          updateImage(t, s, d = !0) {
            const g = this.getImage(t);
            if (d && (g.data.width !== s.data.width || g.data.height !== s.data.height)) throw new Error(`size mismatch between old image (${g.data.width}x${g.data.height}) and new image (${s.data.width}x${s.data.height}).`);
            s.version = g.version + 1, this.images[t] = s, this.updatedImages[t] = !0;
          }
          removeImage(t) {
            const s = this.images[t];
            delete this.images[t], delete this.patterns[t], s.userImage && s.userImage.onRemove && s.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t) {
            return new Promise(((s, d) => {
              let g = !0;
              if (!this.isLoaded()) for (const w of t) this.images[w] || (g = !1);
              this.isLoaded() || g ? s(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: s });
            }));
          }
          _getImagesForIds(t) {
            const s = {};
            for (const d of t) {
              let g = this.getImage(d);
              g || (this.fire(new u.l("styleimagemissing", { id: d })), g = this.getImage(d)), g ? s[d] = { data: g.data.clone(), pixelRatio: g.pixelRatio, sdf: g.sdf, version: g.version, stretchX: g.stretchX, stretchY: g.stretchY, content: g.content, textFitWidth: g.textFitWidth, textFitHeight: g.textFitHeight, hasRenderCallback: !!(g.userImage && g.userImage.render) } : u.w(`Image "${d}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return s;
          }
          getPixelSize() {
            const { width: t, height: s } = this.atlasImage;
            return { width: t, height: s };
          }
          getPattern(t) {
            const s = this.patterns[t], d = this.getImage(t);
            if (!d) return null;
            if (s && s.position.version === d.version) return s.position;
            if (s) s.position.version = d.version;
            else {
              const g = { w: d.data.width + 2, h: d.data.height + 2, x: 0, y: 0 }, w = new u.I(g, d);
              this.patterns[t] = { bin: g, position: w };
            }
            return this._updatePatternAtlas(), this.patterns[t].position;
          }
          bind(t) {
            const s = t.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new u.T(t, this.atlasImage, s.RGBA), this.atlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t = [];
            for (const w in this.patterns) t.push(this.patterns[w].bin);
            const { w: s, h: d } = u.p(t), g = this.atlasImage;
            g.resize({ width: s || 1, height: d || 1 });
            for (const w in this.patterns) {
              const { bin: T } = this.patterns[w], C = T.x + 1, A = T.y + 1, F = this.getImage(w).data, O = F.width, q = F.height;
              u.R.copy(F, g, { x: 0, y: 0 }, { x: C, y: A }, { width: O, height: q }), u.R.copy(F, g, { x: 0, y: q - 1 }, { x: C, y: A - 1 }, { width: O, height: 1 }), u.R.copy(F, g, { x: 0, y: 0 }, { x: C, y: A + q }, { width: O, height: 1 }), u.R.copy(F, g, { x: O - 1, y: 0 }, { x: C - 1, y: A }, { width: 1, height: q }), u.R.copy(F, g, { x: 0, y: 0 }, { x: C + O, y: A }, { width: 1, height: q });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t) {
            for (const s of t) {
              if (this.callbackDispatchedThisFrame[s]) continue;
              this.callbackDispatchedThisFrame[s] = !0;
              const d = this.getImage(s);
              d || u.w(`Image with ID: "${s}" was not found`), Se(d) && this.updateImage(s, d);
            }
          }
          cloneImages() {
            const t = {};
            for (const s in this.images) {
              const d = this.images[s];
              t[s] = Object.assign(Object.assign({}, d), { data: d.data ? d.data.clone() : null });
            }
            return t;
          }
        }
        const ze = 1e20;
        function Re(b, t, s, d, g, w, T, C, A) {
          for (let F = t; F < t + d; F++) De(b, s * w + F, w, g, T, C, A);
          for (let F = s; F < s + g; F++) De(b, F * w + t, 1, d, T, C, A);
        }
        function De(b, t, s, d, g, w, T) {
          w[0] = 0, T[0] = -ze, T[1] = ze, g[0] = b[t];
          for (let C = 1, A = 0, F = 0; C < d; C++) {
            g[C] = b[t + C * s];
            const O = C * C;
            do {
              const q = w[A];
              F = (g[C] - g[q] + O - q * q) / (C - q) / 2;
            } while (F <= T[A] && --A > -1);
            A++, w[A] = C, T[A] = F, T[A + 1] = ze;
          }
          for (let C = 0, A = 0; C < d; C++) {
            for (; T[A + 1] < C; ) A++;
            const F = w[A], O = C - F;
            b[t + C * s] = g[F] + O * O;
          }
        }
        const Ne = u.v.layout_symbol["text-font"].default.join(",");
        class Ge {
          constructor(t, s, d) {
            this.requestManager = t, this.localIdeographFontFamily = s, this.entries = {}, this.lang = d;
          }
          setURL(t) {
            this.url = t;
          }
          getGlyphs(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = [];
              for (const w in t) for (const T of t[w]) s.push(this._getAndCacheGlyphsPromise(w, T));
              const d = yield Promise.all(s), g = {};
              for (const { stack: w, id: T, glyph: C } of d) g[w] || (g[w] = {}), g[w][T] = C && { id: C.id, bitmap: C.bitmap.clone(), metrics: C.metrics };
              return g;
            }));
          }
          _getAndCacheGlyphsPromise(t, s) {
            return u._(this, void 0, void 0, (function* () {
              let d = this.entries[t];
              d || (d = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
              let g = d.glyphs[s];
              return g !== void 0 ? { stack: t, id: s, glyph: g } : !this.url || this._charUsesLocalIdeographFontFamily(s) ? (g = d.glyphs[s] = this._drawGlyph(d, t, s), { stack: t, id: s, glyph: g }) : yield this._downloadAndCacheRangePromise(t, s);
            }));
          }
          _downloadAndCacheRangePromise(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = this.entries[t], g = Math.floor(s / 256);
              if (d.ranges[g]) return { stack: t, id: s, glyph: null };
              if (!d.requests[g]) {
                const w = Ge.loadGlyphRange(t, g, this.url, this.requestManager);
                d.requests[g] = w;
              }
              try {
                const w = yield d.requests[g];
                for (const T in w) d.glyphs[+T] = w[+T];
                return d.ranges[g] = !0, { stack: t, id: s, glyph: w[s] || null };
              } catch (w) {
                const T = d.glyphs[s] = this._drawGlyph(d, t, s);
                return this._warnOnMissingGlyphRange(T, g, s, w), { stack: t, id: s, glyph: T };
              }
            }));
          }
          _warnOnMissingGlyphRange(t, s, d, g) {
            const w = 256 * s, T = w + 255, C = d.toString(16).padStart(4, "0").toUpperCase();
            u.w(`Unable to load glyph range ${s}, ${w}-${T}. Rendering codepoint U+${C} locally instead. ${g}`);
          }
          _charUsesLocalIdeographFontFamily(t) {
            return !!this.localIdeographFontFamily && u.q(t);
          }
          _drawGlyph(t, s, d) {
            const g = s === Ne && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(d), w = g ? "ideographTinySDF" : "tinySDF";
            t[w] || (t[w] = this._createTinySDF(g ? this.localIdeographFontFamily : s));
            const T = t[w].draw(String.fromCodePoint(d)), C = new RegExp("^\\p{gc=Cf}+$", "u").test(String.fromCodePoint(d));
            return { id: d, bitmap: new u.r({ width: T.width || 60, height: T.height || 60 }, T.data), metrics: { width: C ? 0 : T.glyphWidth / 2 || 24, height: T.glyphHeight / 2 || 24, left: T.glyphLeft / 2 + 0.5 || 0, top: T.glyphTop / 2 - 27.5 || -8, advance: C ? 0 : T.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
          _createTinySDF(t) {
            const s = t ? t.split(",") : [];
            s.push("sans-serif");
            const d = s.map(((g) => /[-\w]+/.test(g) ? g : `'${CSS.escape(g)}'`)).join(",");
            return new Ge.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: d, fontWeight: this._fontWeight(s[0]), fontStyle: this._fontStyle(s[0]), lang: this.lang });
          }
          _fontStyle(t) {
            return /italic/i.test(t) ? "italic" : /oblique/i.test(t) ? "oblique" : "normal";
          }
          _fontWeight(t) {
            const s = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
            let d;
            for (const [g, w] of Object.entries(s)) new RegExp(`\\b${g}\\b`, "i").test(t) && (d = `${w}`);
            return d;
          }
          destroy() {
            for (const t in this.entries) {
              const s = this.entries[t];
              s.tinySDF && (s.tinySDF = null), s.ideographTinySDF && (s.ideographTinySDF = null), s.glyphs = {}, s.requests = {}, s.ranges = {};
            }
            this.entries = {};
          }
        }
        Ge.loadGlyphRange = function(b, t, s, d) {
          return u._(this, void 0, void 0, (function* () {
            const g = 256 * t, w = g + 255, T = d.transformRequest(s.replace("{fontstack}", b).replace("{range}", `${g}-${w}`), "Glyphs"), C = yield u.n(T, new AbortController());
            if (!C || !C.data) throw new Error(`Could not load glyph range. range: ${t}, ${g}-${w}`);
            const A = {};
            for (const F of u.o(C.data)) A[F.id] = F;
            return A;
          }));
        }, Ge.TinySDF = class {
          constructor({ fontSize: b = 24, buffer: t = 3, radius: s = 8, cutoff: d = 0.25, fontFamily: g = "sans-serif", fontWeight: w = "normal", fontStyle: T = "normal", lang: C = null } = {}) {
            this.buffer = t, this.cutoff = d, this.radius = s, this.lang = C;
            const A = this.size = b + 4 * t, F = this._createCanvas(A), O = this.ctx = F.getContext("2d", { willReadFrequently: !0 });
            O.font = `${T} ${w} ${b}px ${g}`, O.textBaseline = "alphabetic", O.textAlign = "left", O.fillStyle = "black", this.gridOuter = new Float64Array(A * A), this.gridInner = new Float64Array(A * A), this.f = new Float64Array(A), this.z = new Float64Array(A + 1), this.v = new Uint16Array(A);
          }
          _createCanvas(b) {
            const t = document.createElement("canvas");
            return t.width = t.height = b, t;
          }
          draw(b) {
            const { width: t, actualBoundingBoxAscent: s, actualBoundingBoxDescent: d, actualBoundingBoxLeft: g, actualBoundingBoxRight: w } = this.ctx.measureText(b), T = Math.ceil(s), C = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(w - g))), A = Math.min(this.size - this.buffer, T + Math.ceil(d)), F = C + 2 * this.buffer, O = A + 2 * this.buffer, q = Math.max(F * O, 0), V = new Uint8ClampedArray(q), X = { data: V, width: F, height: O, glyphWidth: C, glyphHeight: A, glyphTop: T, glyphLeft: 0, glyphAdvance: t };
            if (C === 0 || A === 0) return X;
            const { ctx: te, buffer: he, gridInner: pe, gridOuter: fe } = this;
            this.lang && (te.lang = this.lang), te.clearRect(he, he, C, A), te.fillText(b, he, he + T);
            const be = te.getImageData(he, he, C, A);
            fe.fill(ze, 0, q), pe.fill(0, 0, q);
            for (let Ae = 0; Ae < A; Ae++) for (let xe = 0; xe < C; xe++) {
              const Ce = be.data[4 * (Ae * C + xe) + 3] / 255;
              if (Ce === 0) continue;
              const Oe = (Ae + he) * F + xe + he;
              if (Ce === 1) fe[Oe] = 0, pe[Oe] = ze;
              else {
                const ke = 0.5 - Ce;
                fe[Oe] = ke > 0 ? ke * ke : 0, pe[Oe] = ke < 0 ? ke * ke : 0;
              }
            }
            Re(fe, 0, 0, F, O, F, this.f, this.v, this.z), Re(pe, he, he, C, A, F, this.f, this.v, this.z);
            for (let Ae = 0; Ae < q; Ae++) {
              const xe = Math.sqrt(fe[Ae]) - Math.sqrt(pe[Ae]);
              V[Ae] = Math.round(255 - 255 * (xe / this.radius + this.cutoff));
            }
            return X;
          }
        };
        class qe {
          constructor() {
            this.specification = u.u.light.position;
          }
          possiblyEvaluate(t, s) {
            return u.F(t.expression.evaluate(s));
          }
          interpolate(t, s, d) {
            return { x: u.G.number(t.x, s.x, d), y: u.G.number(t.y, s.y, d), z: u.G.number(t.z, s.z, d) };
          }
        }
        let Je;
        class ft extends u.E {
          constructor(t) {
            super(), Je = Je || new u.t({ anchor: new u.D(u.u.light.anchor), position: new qe(), color: new u.D(u.u.light.color), intensity: new u.D(u.u.light.intensity) }), this._transitionable = new u.x(Je, void 0), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t, s = {}) {
            if (!this._validate(u.y, t, s)) for (const d in t) {
              const g = t[d];
              d.endsWith(u.z) ? this._transitionable.setTransition(d.slice(0, -u.z.length), g) : this._transitionable.setValue(d, g);
            }
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, s, d) {
            return (!d || d.validate !== !1) && u.B(this, t.call(u.C, { value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: u.u }));
          }
        }
        const Tt = new u.t({ "sky-color": new u.D(u.u.sky["sky-color"]), "horizon-color": new u.D(u.u.sky["horizon-color"]), "fog-color": new u.D(u.u.sky["fog-color"]), "fog-ground-blend": new u.D(u.u.sky["fog-ground-blend"]), "horizon-fog-blend": new u.D(u.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new u.D(u.u.sky["sky-horizon-blend"]), "atmosphere-blend": new u.D(u.u.sky["atmosphere-blend"]) });
        class Zt extends u.E {
          constructor(t) {
            super(), this._transitionable = new u.x(Tt, void 0), this.setSky(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.H(0));
          }
          setSky(t, s = {}) {
            if (!this._validate(u.J, t, s)) {
              t || (t = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const d in t) {
                const g = t[d];
                d.endsWith(u.z) ? this._transitionable.setTransition(d.slice(0, -u.z.length), g) : this._transitionable.setValue(d, g);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, s, d = {}) {
            return d?.validate !== !1 && u.B(this, t.call(u.C, u.e({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: u.u })));
          }
          calculateFogBlendOpacity(t) {
            return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
          }
        }
        class zt {
          constructor(t, s) {
            this.width = t, this.height = s, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t, s) {
            const d = t.join(",") + String(s);
            return this.dashEntry[d] || (this.dashEntry[d] = this.addDash(t, s)), this.dashEntry[d];
          }
          getDashRanges(t, s, d) {
            const g = [];
            let w = t.length % 2 == 1 ? -t[t.length - 1] * d : 0, T = t[0] * d, C = !0;
            g.push({ left: w, right: T, isDash: C, zeroLength: t[0] === 0 });
            let A = t[0];
            for (let F = 1; F < t.length; F++) {
              C = !C;
              const O = t[F];
              w = A * d, A += O, T = A * d, g.push({ left: w, right: T, isDash: C, zeroLength: O === 0 });
            }
            return g;
          }
          addRoundDash(t, s, d) {
            const g = s / 2;
            for (let w = -d; w <= d; w++) {
              const T = this.width * (this.nextRow + d + w);
              let C = 0, A = t[C];
              for (let F = 0; F < this.width; F++) {
                F / A.right > 1 && (A = t[++C]);
                const O = Math.abs(F - A.left), q = Math.abs(F - A.right), V = Math.min(O, q);
                let X;
                const te = w / d * (g + 1);
                if (A.isDash) {
                  const he = g - Math.abs(te);
                  X = Math.sqrt(V * V + he * he);
                } else X = g - Math.sqrt(V * V + te * te);
                this.data[T + F] = Math.max(0, Math.min(255, X + 128));
              }
            }
          }
          addRegularDash(t) {
            for (let C = t.length - 1; C >= 0; --C) {
              const A = t[C], F = t[C + 1];
              A.zeroLength ? t.splice(C, 1) : F && F.isDash === A.isDash && (F.left = A.left, t.splice(C, 1));
            }
            const s = t[0], d = t[t.length - 1];
            s.isDash === d.isDash && (s.left = d.left - this.width, d.right = s.right + this.width);
            const g = this.width * this.nextRow;
            let w = 0, T = t[w];
            for (let C = 0; C < this.width; C++) {
              C / T.right > 1 && (T = t[++w]);
              const A = Math.abs(C - T.left), F = Math.abs(C - T.right), O = Math.min(A, F);
              this.data[g + C] = Math.max(0, Math.min(255, (T.isDash ? O : -O) + 128));
            }
          }
          addDash(t, s) {
            const d = s ? 7 : 0, g = 2 * d + 1;
            if (this.nextRow + g > this.height) return u.w("LineAtlas out of space"), null;
            let w = 0;
            for (let C = 0; C < t.length; C++) w += t[C];
            if (w !== 0) {
              const C = this.width / w, A = this.getDashRanges(t, this.width, C);
              s ? this.addRoundDash(A, C, d) : this.addRegularDash(A);
            }
            const T = { y: this.nextRow + d, height: 2 * d, width: w };
            return this.nextRow += g, this.dirty = !0, T;
          }
          bind(t) {
            const s = t.gl;
            this.texture ? (s.bindTexture(s.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, this.width, this.height, s.ALPHA, s.UNSIGNED_BYTE, this.data))) : (this.texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this.texture), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texImage2D(s.TEXTURE_2D, 0, s.ALPHA, this.width, this.height, 0, s.ALPHA, s.UNSIGNED_BYTE, this.data));
          }
        }
        const At = "maplibre_preloaded_worker_pool";
        class Dt {
          constructor() {
            this.active = {};
          }
          acquire(t) {
            if (!this.workers) for (this.workers = []; this.workers.length < Dt.workerCount; ) this.workers.push(new Worker(u.c.WORKER_URL));
            return this.active[t] = !0, this.workers.slice();
          }
          release(t) {
            delete this.active[t], this.numActive() === 0 && (this.workers.forEach(((s) => {
              s.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[At];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Yt = Math.floor(le.hardwareConcurrency / 2);
        let mr, He;
        function yi() {
          return mr || (mr = new Dt()), mr;
        }
        Dt.workerCount = u.K(globalThis) ? Math.max(Math.min(Yt, 3), 1) : 1;
        class fr {
          constructor(t, s) {
            this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = s;
            const d = this.workerPool.acquire(s);
            for (let g = 0; g < d.length; g++) {
              const w = new u.L(d[g], s);
              w.name = `Worker ${g}`, this.actors.push(w);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(t, s) {
            const d = [];
            for (const g of this.actors) d.push(g.sendAsync({ type: t, data: s }));
            return Promise.all(d);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t = !0) {
            this.actors.forEach(((s) => {
              s.remove();
            })), this.actors = [], t && this.workerPool.release(this.id);
          }
          registerMessageHandler(t, s) {
            for (const d of this.actors) d.registerMessageHandler(t, s);
          }
          unregisterMessageHandler(t) {
            for (const s of this.actors) s.unregisterMessageHandler(t);
          }
        }
        function Bt() {
          return He || (He = new fr(yi(), u.M), He.registerMessageHandler("GR", ((b, t, s) => u.m(t, s)))), He;
        }
        function Me(b, t) {
          const s = u.N();
          return u.O(s, s, [1, 1, 0]), u.Q(s, s, [0.5 * b.width, 0.5 * b.height, 1]), b.calculatePosMatrix ? u.S(s, s, b.calculatePosMatrix(t.toUnwrapped())) : s;
        }
        function br(b, t, s, d, g, w, T) {
          var C;
          const A = (function(V, X, te) {
            if (V) for (const he of V) {
              const pe = X[he];
              if (pe && pe.source === te && pe.type === "fill-extrusion") return !0;
            }
            else for (const he in X) {
              const pe = X[he];
              if (pe.source === te && pe.type === "fill-extrusion") return !0;
            }
            return !1;
          })((C = g?.layers) !== null && C !== void 0 ? C : null, t, b.id), F = w.maxPitchScaleFactor(), O = b.tilesIn(d, F, A);
          O.sort(ur);
          const q = [];
          for (const V of O) q.push({ wrappedTileID: V.tileID.wrapped().key, queryResults: V.tile.queryRenderedFeatures(t, s, b.getState(), V.queryGeometry, V.cameraQueryGeometry, V.scale, g, w, F, Me(w, V.tileID), T ? (X, te) => T(V.tileID, X, te) : void 0) });
          return (function(V, X) {
            for (const te in V) for (const he of V[te]) rr(he, X);
            return V;
          })((function(V) {
            const X = {}, te = {};
            for (const he of V) {
              const pe = he.queryResults, fe = he.wrappedTileID, be = te[fe] = te[fe] || {};
              for (const Ae in pe) {
                const xe = pe[Ae], Ce = be[Ae] = be[Ae] || {}, Oe = X[Ae] = X[Ae] || [];
                for (const ke of xe) Ce[ke.featureIndex] || (Ce[ke.featureIndex] = !0, Oe.push(ke));
              }
            }
            return X;
          })(q), b);
        }
        function ur(b, t) {
          const s = b.tileID, d = t.tileID;
          return s.overscaledZ - d.overscaledZ || s.canonical.y - d.canonical.y || s.wrap - d.wrap || s.canonical.x - d.canonical.x;
        }
        function rr(b, t) {
          const s = b.feature, d = t.getFeatureState(s.layer["source-layer"], s.id);
          s.source = s.layer.source, s.layer["source-layer"] && (s.sourceLayer = s.layer["source-layer"]), s.state = d;
        }
        function ni(b, t, s, d) {
          return u._(this, void 0, void 0, (function* () {
            let g = b;
            if (b.url ? g = (yield u.j(t.transformRequest(b.url, "Source"), s)).data : yield le.frameAsync(s, d), !g) return null;
            const w = u.U(u.e(g, b), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in g && g.vector_layers && (w.vectorLayerIds = g.vector_layers.map(((T) => T.id))), w;
          }));
        }
        class Dr {
          constructor(t, s) {
            t && (s ? this.setSouthWest(t).setNorthEast(s) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])));
          }
          setNorthEast(t) {
            return this._ne = t instanceof u.V ? new u.V(t.lng, t.lat) : u.V.convert(t), this;
          }
          setSouthWest(t) {
            return this._sw = t instanceof u.V ? new u.V(t.lng, t.lat) : u.V.convert(t), this;
          }
          extend(t) {
            const s = this._sw, d = this._ne;
            let g, w;
            if (t instanceof u.V) g = t, w = t;
            else {
              if (!(t instanceof Dr)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(Dr.convert(t)) : this.extend(u.V.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(u.V.convert(t)) : this;
              if (g = t._sw, w = t._ne, !g || !w) return this;
            }
            return s || d ? (s.lng = Math.min(g.lng, s.lng), s.lat = Math.min(g.lat, s.lat), d.lng = Math.max(w.lng, d.lng), d.lat = Math.max(w.lat, d.lat)) : (this._sw = new u.V(g.lng, g.lat), this._ne = new u.V(w.lng, w.lat)), this;
          }
          getCenter() {
            return new u.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new u.V(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new u.V(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t) {
            const { lng: s, lat: d } = u.V.convert(t);
            let g = this._sw.lng <= s && s <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (g = this._sw.lng >= s && s >= this._ne.lng), this._sw.lat <= d && d <= this._ne.lat && g;
          }
          intersects(t) {
            if (!((t = Dr.convert(t)).getNorth() >= this.getSouth() && t.getSouth() <= this.getNorth())) return !1;
            const s = Math.abs(this.getEast() - this.getWest()), d = Math.abs(t.getEast() - t.getWest());
            if (s >= 360 || d >= 360) return !0;
            const g = u.W(this.getWest(), -180, 180), w = u.W(this.getEast(), -180, 180), T = u.W(t.getWest(), -180, 180), C = u.W(t.getEast(), -180, 180), A = g >= w, F = T >= C;
            return !(!A || !F) || (A ? C >= g || T <= w : F ? w >= T || g <= C : T <= w && C >= g);
          }
          static convert(t) {
            return t instanceof Dr ? t : t && new Dr(t);
          }
          static fromLngLat(t, s = 0) {
            const d = 360 * s / 40075017, g = d / Math.cos(Math.PI / 180 * t.lat);
            return new Dr(new u.V(t.lng - g, t.lat - d), new u.V(t.lng + g, t.lat + d));
          }
          adjustAntiMeridian() {
            const t = new u.V(this._sw.lng, this._sw.lat), s = new u.V(this._ne.lng, this._ne.lat);
            return new Dr(t, t.lng > s.lng ? new u.V(s.lng + 360, s.lat) : s);
          }
        }
        class ii {
          constructor(t, s, d) {
            this.bounds = Dr.convert(this.validateBounds(t)), this.minzoom = s || 0, this.maxzoom = d || 24;
          }
          validateBounds(t) {
            return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
          }
          contains(t) {
            const s = Math.pow(2, t.z), d = Math.floor(u.Y(this.bounds.getWest()) * s), g = Math.floor(u.X(this.bounds.getNorth()) * s), w = Math.ceil(u.Y(this.bounds.getEast()) * s), T = Math.ceil(u.X(this.bounds.getSouth()) * s);
            return t.x >= d && t.x < w && t.y >= g && t.y < T;
          }
        }
        class Mt extends u.E {
          constructor(t, s, d, g) {
            if (super(), this.id = t, this.dispatcher = d, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, u.e(this, u.U(s, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = u.e({ type: "vector" }, s), this._collectResourceTiming = s.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(g);
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t = yield ni(this._options, this.map._requestManager, this._tileJSONRequest, this.map._ownerWindow);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), t && (u.e(this, t), t.bounds && (this.tileBounds = new ii(t.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t) {
                this._tileJSONRequest = null, this._loaded = !0, u.Z(t) || this.fire(new u.k(t));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          setSourceProperty(t) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load();
          }
          setTiles(t) {
            return this.setSourceProperty((() => {
              this._options.tiles = t;
            })), this;
          }
          setUrl(t) {
            return this.setSourceProperty((() => {
              this.url = t, this._options.url = t;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return u.e({}, this._options);
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), d = { request: this.map._requestManager.transformRequest(s, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(t) };
              d.request.collectResourceTiming = this._collectResourceTiming;
              let g = "RT";
              if (t.actor && t.state !== "expired") {
                if (t.state === "loading") return new Promise(((w, T) => {
                  t.reloadPromise = { resolve: w, reject: T };
                }));
              } else t.actor = this.dispatcher.getActor(), g = "LT";
              t.abortController = new AbortController();
              try {
                const w = yield t.actor.sendAsync({ type: g, data: d }, t.abortController);
                if (delete t.abortController, t.aborted) return;
                this._afterTileLoadWorkerResponse(t, w);
              } catch (w) {
                if (delete t.abortController, t.aborted) return;
                if (w && w.status !== 404) throw w;
                this._afterTileLoadWorkerResponse(t, null);
              }
            }));
          }
          _getOverzoomParameters(t) {
            if (t.tileID.canonical.z <= this.maxzoom || this.map._zoomLevelsToOverscale === void 0) return;
            const s = t.tileID.scaledTo(this.maxzoom).canonical, d = s.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            return { maxZoomTileID: s, overzoomRequest: this.map._requestManager.transformRequest(d, "Tile") };
          }
          _afterTileLoadWorkerResponse(t, s) {
            if (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming), s && this.map._refreshExpiredTiles && t.setExpiryData(s), t.loadVectorData(s, this.map.painter), t.reloadPromise) {
              const d = t.reloadPromise;
              t.reloadPromise = null, this.loadTile(t).then(d.resolve).catch(d.reject);
            }
          }
          abortTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Zi extends u.E {
          constructor(t, s, d, g) {
            super(), this.id = t, this.dispatcher = d, this.setEventedParent(g), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = u.e({ type: "raster" }, s), u.e(this, u.U(s, ["url", "scheme", "tileSize"]));
          }
          load() {
            return u._(this, arguments, void 0, (function* (t = !1) {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const s = yield ni(this._options, this.map._requestManager, this._tileJSONRequest, this.map._ownerWindow);
                this._tileJSONRequest = null, this._loaded = !0, s && (u.e(this, s), s.bounds && (this.tileBounds = new ii(s.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: t })));
              } catch (s) {
                this._tileJSONRequest = null, this._loaded = !0, u.Z(s) || this.fire(new u.k(s));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(t) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load(!0);
          }
          setTiles(t) {
            return this.setSourceProperty((() => {
              this._options.tiles = t;
            })), this;
          }
          setUrl(t) {
            return this.setSourceProperty((() => {
              this.url = t, this._options.url = t;
            })), this;
          }
          serialize() {
            return u.e({}, this._options);
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t.abortController = new AbortController();
              try {
                const d = yield ut.getImage(this.map._requestManager.transformRequest(s, "Tile"), t.abortController, this.map._refreshExpiredTiles);
                if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
                if (d && d.data) {
                  this.map._refreshExpiredTiles && (d.cacheControl || d.expires) && t.setExpiryData({ cacheControl: d.cacheControl, expires: d.expires });
                  const g = this.map.painter.context, w = g.gl, T = d.data;
                  t.texture = this.map.painter.getTileTexture(T.width), t.texture ? t.texture.update(T, { useMipmap: !0 }) : (t.texture = new u.T(g, T, w.RGBA, { useMipmap: !0 }), t.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST)), t.state = "loaded";
                }
              } catch (d) {
                if (delete t.abortController, t.aborted) t.state = "unloaded";
                else if (d) throw t.state = "errored", d;
              }
            }));
          }
          abortTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController);
            }));
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.texture && this.map.painter.saveTileTexture(t.texture);
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Ti extends Zi {
          constructor(t, s, d, g) {
            super(t, s, d, g), this.type = "raster-dem", this.maxzoom = 22, this._options = u.e({ type: "raster-dem" }, s), this.encoding = s.encoding || "mapbox", this.redFactor = s.redFactor, this.greenFactor = s.greenFactor, this.blueFactor = s.blueFactor, this.baseShift = s.baseShift;
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), d = this.map._requestManager.transformRequest(s, "Tile");
              t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController();
              try {
                const g = yield ut.getImage(d, t.abortController, this.map._refreshExpiredTiles);
                if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
                if (g && g.data) {
                  const w = g.data;
                  this.map._refreshExpiredTiles && (g.cacheControl || g.expires) && t.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const T = u.b(w) && u.$() ? w : yield this.readImageNow(w), C = { type: this.type, uid: t.uid, source: this.id, rawImageData: T, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!t.actor || t.state === "expired") {
                    t.actor = this.dispatcher.getActor();
                    const A = yield t.actor.sendAsync({ type: "LDT", data: C });
                    t.dem = A, t.needsHillshadePrepare = !0, t.needsTerrainPrepare = !0, t.state = "loaded";
                  }
                }
              } catch (g) {
                if (delete t.abortController, t.aborted) t.state = "unloaded";
                else if (g) throw t.state = "errored", g;
              }
            }));
          }
          readImageNow(t) {
            return u._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && u.a0()) {
                const s = t.width + 2, d = t.height + 2;
                try {
                  return new u.R({ width: s, height: d }, yield u.a1(t, -1, -1, s, d));
                } catch {
                }
              }
              return le.getImageData(t, 1);
            }));
          }
          _getNeighboringTiles(t) {
            const s = t.canonical, d = Math.pow(2, s.z), g = (s.x - 1 + d) % d, w = s.x === 0 ? t.wrap - 1 : t.wrap, T = (s.x + 1 + d) % d, C = s.x + 1 === d ? t.wrap + 1 : t.wrap, A = {};
            return A[new u.a2(t.overscaledZ, w, s.z, g, s.y).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, C, s.z, T, s.y).key] = { backfilled: !1 }, s.y > 0 && (A[new u.a2(t.overscaledZ, w, s.z, g, s.y - 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, t.wrap, s.z, s.x, s.y - 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, C, s.z, T, s.y - 1).key] = { backfilled: !1 }), s.y + 1 < d && (A[new u.a2(t.overscaledZ, w, s.z, g, s.y + 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, t.wrap, s.z, s.x, s.y + 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, C, s.z, T, s.y + 1).key] = { backfilled: !1 }), A;
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } }));
            }));
          }
        }
        function jn(b) {
          return b.type === "GeometryCollection" ? b.geometries.map(((t) => t.coordinates)).flat(1 / 0) : b.coordinates.flat(1 / 0);
        }
        function Ls(b) {
          const t = new Dr();
          let s;
          switch (b.type) {
            case "FeatureCollection":
              s = b.features.map(((d) => jn(d.geometry))).flat(1 / 0);
              break;
            case "Feature":
              s = jn(b.geometry);
              break;
            default:
              s = jn(b);
          }
          if (s.length == 0) return t;
          for (let d = 0; d < s.length - 1; d += 2) t.extend([s[d], s[d + 1]]);
          return t;
        }
        class tr extends u.E {
          constructor(t, s, d, g) {
            super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: s.data }, this.actor = d.getActor(), this.setEventedParent(g), this._data = typeof s.data == "string" ? { url: s.data } : { geojson: s.data }, this._options = u.e({}, s), this._collectResourceTiming = s.collectResourceTiming, s.maxzoom !== void 0 && (this.maxzoom = s.maxzoom), s.type && (this.type = s.type), s.attribution && (this.attribution = s.attribution), this.promoteId = s.promoteId, s.clusterMaxZoom !== void 0 && this.maxzoom <= s.clusterMaxZoom && u.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${s.clusterMaxZoom}".`), this.workerOptions = u.e({ source: this.id, cluster: s.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(s.buffer !== void 0 ? s.buffer : 128), tolerance: this._pixelsToTileUnits(s.tolerance !== void 0 ? s.tolerance : 0.375), extent: u.a5, maxZoom: this.maxzoom, lineMetrics: s.lineMetrics || !1, generateId: s.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(s.clusterMaxZoom), minPoints: Math.max(2, s.clusterMinPoints || 2), extent: u.a5, radius: this._pixelsToTileUnits(s.clusterRadius || 50), log: !1, generateId: s.generateId || !1 }, clusterProperties: s.clusterProperties, filter: s.filter }, s.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(t) {
            return t * (u.a5 / this.tileSize);
          }
          _getClusterMaxZoom(t) {
            const s = t ? Math.round(t) : this.maxzoom - 1;
            return Number.isInteger(t) || t === void 0 || u.w(`Integer expected for option 'clusterMaxZoom': provided value "${t}" rounded to "${s}"`), s;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          setData(t, s) {
            this._data = typeof t == "string" ? { url: t } : { geojson: t }, this._pendingWorkerUpdate = { data: t };
            const d = this._updateWorkerData();
            return s ? d : this;
          }
          updateData(t, s) {
            this._pendingWorkerUpdate.diff = u.a6(this._pendingWorkerUpdate.diff, t);
            const d = this._updateWorkerData();
            return s ? d : this;
          }
          getData() {
            return u._(this, void 0, void 0, (function* () {
              const t = u.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: t });
            }));
          }
          getBounds() {
            return u._(this, void 0, void 0, (function* () {
              return Ls(yield this.getData());
            }));
          }
          setClusterOptions(t) {
            return this.workerOptions.cluster = t.cluster, t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(t.clusterRadius)), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(t.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } });
          }
          getClusterChildren(t) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } });
          }
          getClusterLeaves(t, s, d) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: s, offset: d } });
          }
          _updateWorkerData() {
            return u._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void u.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: t, diff: s } = this._pendingWorkerUpdate, d = this._getLoadGeoJSONParameters(t, s);
              t !== void 0 ? this._pendingWorkerUpdate.data = void 0 : s && (this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, yield this._dispatchWorkerUpdate(d);
            }));
          }
          _getLoadGeoJSONParameters(t, s) {
            const d = u.e({ type: this.type }, this.workerOptions);
            return typeof t == "string" ? (d.request = this.map._requestManager.transformRequest(le.resolveURL(t), "Source"), d.request.collectResourceTiming = this._collectResourceTiming, d) : t !== void 0 ? (d.data = t, d) : (s && (d.dataDiff = s), d);
          }
          _dispatchWorkerUpdate(t) {
            return u._(this, void 0, void 0, (function* () {
              this._isUpdatingWorker = !0, this.fire(new u.l("dataloading", { dataType: "source" }));
              try {
                const s = yield this.actor.sendAsync({ type: "LD", data: t });
                if (this._isUpdatingWorker = !1, this._removed || s.abandoned) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                s.data && (this._data = { geojson: s.data });
                const d = this._applyDiffToSource(t.dataDiff), g = this._getShouldReloadTileOptions(d), w = { dataType: "source" };
                this._applyResourceTiming(w, s), this.fire(new u.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "metadata" }))), this.fire(new u.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "content", shouldReloadTileOptions: g })));
              } catch (s) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                this.fire(new u.k(s));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            }));
          }
          _applyResourceTiming(t, s) {
            var d;
            if (!this._collectResourceTiming) return;
            const g = (d = s.resourceTiming) === null || d === void 0 ? void 0 : d[this.id];
            if (!g) return;
            const w = g.slice(0);
            w?.length && u.e(t, { resourceTiming: w });
          }
          _applyDiffToSource(t) {
            if (!t) return;
            const s = typeof this.promoteId == "string" ? this.promoteId : void 0;
            if (!this._data.url && !this._data.updateable) {
              const g = u.a7(this._data.geojson, s);
              if (!g) throw new Error(`GeoJSONSource "${this.id}": GeoJSON data is not compatible with updateData`);
              this._data = { updateable: g };
            }
            if (!this._data.updateable) return;
            const d = u.a8(this._data.updateable, t, s);
            return t.removeAll || this._options.cluster ? void 0 : d;
          }
          _getShouldReloadTileOptions(t) {
            if (t) return { affectedBounds: t.filter(Boolean).map(((s) => Ls(s))) };
          }
          shouldReloadTile(t, { affectedBounds: s }) {
            if (t.state === "loading") return !0;
            if (t.state === "unloaded") return !1;
            const { buffer: d, extent: g } = this.workerOptions.geojsonVtOptions, w = (function({ x: T, y: C, z: A }, F = 0) {
              const O = u.a3((T - F) / Math.pow(2, A)), q = u.a4((C + 1 + F) / Math.pow(2, A)), V = u.a3((T + 1 + F) / Math.pow(2, A)), X = u.a4((C - F) / Math.pow(2, A));
              return new Dr([O, q], [V, X]);
            })(t.tileID.canonical, d / g);
            for (const T of s) if (w.intersects(T)) return !0;
            return !1;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.actor ? "RT" : "LT";
              t.actor = this.actor;
              const d = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              t.abortController = new AbortController();
              const g = yield this.actor.sendAsync({ type: s, data: d }, t.abortController);
              delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(g, this.map.painter, s === "RT");
            }));
          }
          abortTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = !0;
            }));
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return u.e({}, this._options, { type: this.type, data: this._data.updateable ? { type: "FeatureCollection", features: Array.from(this._data.updateable.values()) } : this._data.url || this._data.geojson });
          }
          hasTransition() {
            return !1;
          }
        }
        class ln extends u.E {
          constructor(t, s, d, g) {
            super(), this.flippedWindingOrder = !1, this.id = t, this.dispatcher = d, this.coordinates = s.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(g), this.options = s;
          }
          load(t) {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const s = yield ut.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, s && s.data && (this.image = s.data, t && (this.coordinates = t), this._finishLoading());
              } catch (s) {
                this._request = null, this._loaded = !0, u.Z(s) || this.fire(new u.k(s));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t) {
            return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(t) {
            this.coordinates = t;
            const s = t.map(u.a9.fromLngLat);
            var d;
            return this.tileID = (function(g) {
              const w = u.aa.fromPoints(g), T = w.width(), C = w.height(), A = Math.max(T, C), F = Math.max(0, Math.floor(-Math.log(A) / Math.LN2)), O = Math.pow(2, F);
              return new u.ac(F, Math.floor((w.minX + w.maxX) / 2 * O), Math.floor((w.minY + w.maxY) / 2 * O));
            })(s), this.terrainTileRanges = this._getOverlappingTileRanges(s), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = s.map(((g) => this.tileID.getTilePoint(g)._round())), this.flippedWindingOrder = ((d = this.tileCoords)[1].x - d[0].x) * (d[2].y - d[0].y) - (d[1].y - d[0].y) * (d[2].x - d[0].x) < 0, this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const t = this.map.painter.context, s = t.gl;
            this.texture || (this.texture = new u.T(t, this.image, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            let d = !1;
            for (const g in this.tiles) {
              const w = this.tiles[g];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, d = !0);
            }
            d && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(t) {
            const { minX: s, minY: d, maxX: g, maxY: w } = u.aa.fromPoints(t), T = {};
            for (let C = 0; C <= u.ab; C++) {
              const A = Math.pow(2, C), F = Math.floor(s * A), O = Math.floor(d * A), q = Math.floor(g * A), V = Math.floor(w * A), X = (F % A + A) % A, te = q % A, he = Math.floor(F / A), pe = Math.floor(q / A);
              T[C] = { minWrap: he, maxWrap: pe, minTileXWrapped: X, maxTileXWrapped: te, minTileY: O, maxTileY: V };
            }
            return T;
          }
        }
        class Vn extends ln {
          constructor(t, s, d, g) {
            super(t, s, d, g), this.roundZoom = !0, this.type = "video", this.options = s;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1;
              const t = this.options;
              this.urls = [];
              for (const s of t.urls) this.urls.push(this.map._requestManager.transformRequest(s, "Source").url);
              try {
                const s = yield u.ad(this.urls);
                if (this._loaded = !0, !s) return;
                this.video = s, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (s) {
                this.fire(new u.k(s));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t) {
            if (this.video) {
              const s = this.video.seekable;
              t < s.start(0) || t > s.end(0) ? this.fire(new u.k(new u.ae(`sources.${this.id}`, null, `Playback for this video can be set only between the ${s.start(0)} and ${s.end(0)}-second mark.`))) : this.video.currentTime = t;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t) {
            this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const t = this.map.painter.context, s = t.gl;
            this.texture ? this.video.paused || (this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, s.RGBA, s.UNSIGNED_BYTE, this.video)) : (this.texture = new u.T(t, this.video, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            let d = !1;
            for (const g in this.tiles) {
              const w = this.tiles[g];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, d = !0);
            }
            d && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Un extends ln {
          constructor(t, s, d, g) {
            super(t, s, d, g), s.coordinates ? Array.isArray(s.coordinates) && s.coordinates.length === 4 && !s.coordinates.some(((w) => !Array.isArray(w) || w.length !== 2 || w.some(((T) => typeof T != "number")))) || this.fire(new u.k(new u.ae(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new u.k(new u.ae(`sources.${t}`, null, 'missing required property "coordinates"'))), s.animate && typeof s.animate != "boolean" && this.fire(new u.k(new u.ae(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), s.canvas ? typeof s.canvas == "string" || s.canvas instanceof HTMLCanvasElement || this.fire(new u.k(new u.ae(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new u.k(new u.ae(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = s, this.animate = s.animate === void 0 || s.animate;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new u.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t) {
            this.map = t, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const s = this.map.painter.context, d = s.gl;
            this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : (this.texture = new u.T(s, this.canvas, d.RGBA, { premultiply: !0 }), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE));
            let g = !1;
            for (const w in this.tiles) {
              const T = this.tiles[w];
              T.state !== "loaded" && (T.state = "loaded", T.texture = this.texture, g = !0);
            }
            g && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0;
            return !1;
          }
        }
        const Jt = {}, os = (b) => {
          switch (b) {
            case "geojson":
              return tr;
            case "image":
              return ln;
            case "raster":
              return Zi;
            case "raster-dem":
              return Ti;
            case "vector":
              return Mt;
            case "video":
              return Vn;
            case "canvas":
              return Un;
          }
          return Jt[b];
        }, Fe = "RTLPluginLoaded";
        class H extends u.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Bt();
          }
          _syncState(t) {
            return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch(((s) => {
              throw this.status = "error", s;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(t) {
            return u._(this, arguments, void 0, (function* (s, d = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = le.resolveURL(s), !this.url) throw new Error(`requested url ${s} is invalid`);
              if (this.status === "unavailable") {
                if (!d) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return u._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new u.l(Fe));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let K = null;
        function re() {
          return K || (K = new H()), K;
        }
        var Te, me;
        (function(b) {
          b[b.Base = 0] = "Base", b[b.Parent = 1] = "Parent";
        })(Te || (Te = {})), (function(b) {
          b[b.Departing = 0] = "Departing", b[b.Incoming = 1] = "Incoming";
        })(me || (me = {}));
        class Ye {
          constructor(t, s) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = t, this.uid = u.af(), this.uses = 0, this.tileSize = s, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(t) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (t || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: t, fadingDirection: s, fadingParentID: d, fadeEndTime: g }) {
            this.resetFadeLogic(), this.fadingRole = t, this.fadingDirection = s, this.fadingParentID = d, this.fadeEndTime = g;
          }
          setSelfFadeLogic(t) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = t;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = _e(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(t) {
            this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(t, s, d) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {
              t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData, this.latestFeatureIndex.encoding = t.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = (function(g, w) {
                const T = {};
                if (!w) return T;
                for (const C of g) {
                  const A = C.layerIds.map(((F) => w.getLayer(F))).filter(Boolean);
                  if (A.length !== 0) {
                    C.layers = A, C.stateDependentLayerIds && (C.stateDependentLayers = C.stateDependentLayerIds.map(((F) => A.filter(((O) => O.id === F))[0])));
                    for (const F of A) T[F.id] = C;
                  }
                }
                return T;
              })(t.buckets, s?.style), this.hasSymbolBuckets = !1;
              for (const g in this.buckets) {
                const w = this.buckets[g];
                if (w instanceof u.ah) {
                  if (this.hasSymbolBuckets = !0, !d) break;
                  w.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const g in this.buckets) {
                const w = this.buckets[g];
                if (w instanceof u.ah && w.hasRTLText) {
                  this.hasRTLText = !0, re().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const g in this.buckets) {
                const w = this.buckets[g];
                this.queryPadding = Math.max(this.queryPadding, s.style.getLayer(g).queryRadius(w));
              }
              t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), this.dashPositions = t.dashPositions;
            } else this.collisionBoxArray = new u.ag();
          }
          unloadVectorData() {
            for (const t in this.buckets) this.buckets[t].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t) {
            return this.buckets[t.id];
          }
          upload(t) {
            for (const d in this.buckets) {
              const g = this.buckets[d];
              g.uploadPending() && g.upload(t);
            }
            const s = t.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new u.T(t, this.imageAtlas.image, s.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new u.T(t, this.glyphAtlasImage, s.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t, s, d, g, w, T, C, A, F, O, q) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: g, cameraQueryGeometry: w, scale: T, tileSize: this.tileSize, pixelPosMatrix: O, transform: A, params: C, queryPadding: this.queryPadding * F, getElevation: q }, t, s, d) : {};
          }
          querySourceFeatures(t, s) {
            const d = this.latestFeatureIndex;
            if (!d || !d.rawTileData) return;
            const g = d.loadVTLayers(), w = s && s.sourceLayer ? s.sourceLayer : "", T = g[u.ai] || g[w];
            if (!T) return;
            const C = u.aj(s?.filter, s?.globalState), { z: A, x: F, y: O } = this.tileID.canonical, q = { z: A, x: F, y: O };
            for (let V = 0; V < T.length; V++) {
              const X = T.feature(V);
              if (C.needGeometry) {
                const pe = u.ak(X, !0);
                if (!C.filter(new u.H(this.tileID.overscaledZ), pe, this.tileID.canonical)) continue;
              } else if (!C.filter(new u.H(this.tileID.overscaledZ), X)) continue;
              const te = d.getId(X, w), he = new u.al(X, A, F, O, te);
              he.tile = q, t.push(he);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t) {
            const s = this.expirationTime;
            if (t.cacheControl) {
              const d = u.am(t.cacheControl);
              d["max-age"] && (this.expirationTime = Date.now() + 1e3 * d["max-age"]);
            } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
            if (this.expirationTime) {
              const d = Date.now();
              let g = !1;
              if (this.expirationTime > d) g = !1;
              else if (s) if (this.expirationTime < s) g = !0;
              else {
                const w = this.expirationTime - s;
                w ? this.expirationTime = d + Math.max(w, 3e4) : g = !0;
              }
              else g = !0;
              g ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t, s) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return;
            const d = this.latestFeatureIndex.loadVTLayers();
            for (const g in this.buckets) {
              if (!s.style.hasLayer(g)) continue;
              const w = this.buckets[g], T = w.layers[0].sourceLayer || u.ai, C = d[T], A = t[T];
              if (!C || !A || Object.keys(A).length === 0) continue;
              w.update(A, C, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const F = s && s.style && s.style.getLayer(g);
              F && (this.queryPadding = Math.max(this.queryPadding, F.queryRadius(w)));
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < _e();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(t) {
            this.symbolFadeHoldUntil = _e() + t;
          }
          setDependencies(t, s) {
            const d = {};
            for (const g of s) d[g] = !0;
            this.dependencies[t] = d;
          }
          hasDependency(t, s) {
            for (const d of t) {
              const g = this.dependencies[d];
              if (g) {
                for (const w of s) if (g[w]) return !0;
              }
            }
            return !1;
          }
        }
        class We {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t, s, d) {
            const g = String(s);
            if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][g] = this.stateChanges[t][g] || {}, u.e(this.stateChanges[t][g], d), this.deletedStates[t] === null) {
              this.deletedStates[t] = {};
              for (const w in this.state[t]) w !== g && (this.deletedStates[t][w] = null);
            } else if (this.deletedStates[t] && this.deletedStates[t][g] === null) {
              this.deletedStates[t][g] = {};
              for (const w in this.state[t][g]) d[w] || (this.deletedStates[t][g][w] = null);
            } else for (const w in d) this.deletedStates[t] && this.deletedStates[t][g] && this.deletedStates[t][g][w] === null && delete this.deletedStates[t][g][w];
          }
          removeFeatureState(t, s, d) {
            if (this.deletedStates[t] === null) return;
            const g = String(s);
            if (this.deletedStates[t] = this.deletedStates[t] || {}, d && s !== void 0) this.deletedStates[t][g] !== null && (this.deletedStates[t][g] = this.deletedStates[t][g] || {}, this.deletedStates[t][g][d] = null);
            else if (s !== void 0) if (this.stateChanges[t] && this.stateChanges[t][g]) for (d in this.deletedStates[t][g] = {}, this.stateChanges[t][g]) this.deletedStates[t][g][d] = null;
            else this.deletedStates[t][g] = null;
            else this.deletedStates[t] = null;
          }
          getState(t, s) {
            const d = String(s), g = u.e({}, (this.state[t] || {})[d], (this.stateChanges[t] || {})[d]);
            if (this.deletedStates[t] === null) return {};
            if (this.deletedStates[t]) {
              const w = this.deletedStates[t][s];
              if (w === null) return {};
              for (const T in w) delete g[T];
            }
            return g;
          }
          initializeTileState(t, s) {
            t.setFeatureState(this.state, s);
          }
          coalesceChanges(t, s) {
            const d = {};
            for (const g in this.stateChanges) {
              this.state[g] = this.state[g] || {};
              const w = {};
              for (const T in this.stateChanges[g]) this.state[g][T] || (this.state[g][T] = {}), u.e(this.state[g][T], this.stateChanges[g][T]), w[T] = this.state[g][T];
              d[g] = w;
            }
            for (const g in this.deletedStates) {
              this.state[g] = this.state[g] || {};
              const w = {};
              if (this.deletedStates[g] === null) for (const T in this.state[g]) w[T] = {}, this.state[g][T] = {};
              else for (const T in this.deletedStates[g]) {
                if (this.deletedStates[g][T] === null) this.state[g][T] = {};
                else for (const C of Object.keys(this.deletedStates[g][T])) delete this.state[g][T][C];
                w[T] = this.state[g][T];
              }
              d[g] = d[g] || {}, u.e(d[g], w);
            }
            this.stateChanges = {}, this.deletedStates = {}, Object.keys(d).length !== 0 && t.setFeatureState(d, s);
          }
        }
        const Ve = 89.25;
        function $e(b, t) {
          const s = u.an(t.lat, -u.ao, u.ao);
          return new u.P(u.Y(t.lng) * b, u.X(s) * b);
        }
        function gt(b, t) {
          return new u.a9(t.x / b, t.y / b).toLngLat();
        }
        function st(b) {
          return b.cameraToCenterDistance * Math.min(0.85 * Math.tan(u.ap(90 - b.pitch)), Math.tan(u.ap(Ve - b.pitch)));
        }
        function vt(b, t) {
          const s = b.canonical, d = t / u.aq(s.z), g = s.x + Math.pow(2, s.z) * b.wrap, w = u.ar(new Float64Array(16));
          return u.O(w, w, [g * d, s.y * d, 0]), u.Q(w, w, [d / u.a5, d / u.a5, 1]), w;
        }
        function Be(b, t, s, d, g) {
          const w = u.a9.fromLngLat(b, t), T = g * u.as(1, b.lat), { x: C, y: A, z: F } = Qt(s, d);
          return new u.a9(w.x + T * -C, w.y + T * -A, w.z + T * -F);
        }
        function Qt(b, t) {
          const s = u.ap(b), d = u.ap(t), g = Math.cos(-s), w = Math.sin(s);
          return { x: w * Math.sin(d), y: -w * Math.cos(d), z: g };
        }
        function Cr(b, t, s) {
          const d = t.intersectsFrustum(b);
          if (!s || d === 0) return d;
          const g = t.intersectsPlane(s);
          return g === 0 ? 0 : d === 2 && g === 2 ? 2 : 1;
        }
        function kt(b, t, s) {
          let d = 0;
          const g = (s - t) / 10;
          for (let w = 0; w < 10; w++) d += g * Math.pow(Math.cos(t + (w + 0.5) / 10 * (s - t)), b);
          return d;
        }
        function lt(b, t) {
          return function(s, d, g, w, T) {
            const C = 2 * ((b - 1) / u.at(Math.cos(u.ap(Ve - T)) / Math.cos(u.ap(Ve))) - 1), A = Math.acos(g / w), F = 2 * kt(C - 1, 0, u.ap(T / 2)), O = Math.min(u.ap(Ve), A + u.ap(T / 2)), q = kt(C - 1, Math.min(O, A - u.ap(T / 2)), O), V = Math.atan(d / g), X = Math.hypot(d, g);
            let te = s;
            return te += u.at(w / X / Math.max(0.5, Math.cos(u.ap(T / 2)))), te += C * u.at(Math.cos(V)) / 2, te -= u.at(Math.max(1, q / F / t)) / 2, te;
          };
        }
        const nr = lt(9.314, 3);
        function Fr(b, t) {
          const s = (t.roundZoom ? Math.round : Math.floor)(b.zoom + u.at(b.tileSize / t.tileSize));
          return Math.max(0, s);
        }
        function wr(b, t) {
          const s = b.getCameraFrustum(), d = b.getClippingPlane(), g = b.screenPointToMercatorCoordinate(b.getCameraPoint()), w = u.a9.fromLngLat(b.center, b.elevation);
          g.z = w.z + Math.cos(b.pitchInRadians) * b.cameraToCenterDistance / b.worldSize;
          const T = b.getCoveringTilesDetailsProvider(), C = T.allowVariableZoom(b, t), A = Fr(b, t), F = t.minzoom || 0, O = t.maxzoom !== void 0 ? t.maxzoom : b.maxZoom, q = Math.min(Math.max(0, A), O), V = Math.pow(2, q), X = [V * g.x, V * g.y, 0], te = [V * w.x, V * w.y, 0], he = Math.hypot(w.x - g.x, w.y - g.y), pe = Math.abs(w.z - g.z), fe = Math.hypot(he, pe), be = (Ce) => ({ zoom: 0, x: 0, y: 0, wrap: Ce, fullyVisible: !1 }), Ae = [], xe = [];
          if (b.renderWorldCopies && T.allowWorldCopies()) for (let Ce = 1; Ce <= 3; Ce++) Ae.push(be(-Ce)), Ae.push(be(Ce));
          for (Ae.push(be(0)); Ae.length > 0; ) {
            const Ce = Ae.pop(), Oe = Ce.x, ke = Ce.y;
            let je = Ce.fullyVisible;
            const at = { x: Oe, y: ke, z: Ce.zoom }, tt = T.getTileBoundingVolume(at, Ce.wrap, b.elevation, t);
            if (!je) {
              const It = Cr(s, tt, d);
              if (It === 0) continue;
              je = It === 2;
            }
            const nt = T.distanceToTile2d(g.x, g.y, at, tt);
            let it = A;
            C && (it = (t.calculateTileZoom || nr)(b.zoom + u.at(b.tileSize / t.tileSize), nt, pe, fe, b.fov)), it = (t.roundZoom ? Math.round : Math.floor)(it), it = Math.max(0, it);
            const St = Math.min(it, O);
            if (Ce.wrap = T.getWrap(w, at, Ce.wrap), Ce.zoom >= St) {
              if (Ce.zoom < F) continue;
              const It = q - Ce.zoom, _t = X[0] - 0.5 - (Oe << It), Lt = X[1] - 0.5 - (ke << It), or = t.reparseOverscaled ? Math.max(Ce.zoom, it) : Ce.zoom;
              xe.push({ tileID: new u.a2(Ce.zoom === O ? or : Ce.zoom, Ce.wrap, Ce.zoom, Oe, ke), distanceSq: u.au([te[0] - 0.5 - Oe, te[1] - 0.5 - ke]), tileDistanceToCamera: Math.sqrt(_t * _t + Lt * Lt) });
            } else for (let It = 0; It < 4; It++) Ae.push({ zoom: Ce.zoom + 1, x: (Oe << 1) + It % 2, y: (ke << 1) + (It >> 1), wrap: Ce.wrap, fullyVisible: je });
          }
          return xe.sort(((Ce, Oe) => Ce.distanceSq - Oe.distanceSq)).map(((Ce) => Ce.tileID));
        }
        const un = u.aa.fromPoints([new u.P(0, 0), new u.P(u.a5, u.a5)]);
        function Qr(b) {
          return b === "raster" || b === "image" || b === "video";
        }
        function Ur(b, t, s, d, g, w, T) {
          if (!t.hasData()) return !1;
          const { tileID: C, fadingRole: A, fadingDirection: F, fadingParentID: O } = t;
          if (A === Te.Base && F === me.Incoming && O) return s[O.key] = O, !0;
          const q = Math.max(C.overscaledZ - g, w);
          for (let V = C.overscaledZ - 1; V >= q; V--) {
            const X = C.scaledTo(V), te = b.getLoadedTile(X);
            if (te) return t.setCrossFadeLogic({ fadingRole: Te.Base, fadingDirection: me.Incoming, fadingParentID: te.tileID, fadeEndTime: d + T }), te.setCrossFadeLogic({ fadingRole: Te.Parent, fadingDirection: me.Departing, fadeEndTime: d + T }), s[X.key] = X, !0;
          }
          return !1;
        }
        function Ir(b, t, s, d, g, w) {
          if (!t.hasData()) return !1;
          const T = t.tileID.children(g);
          let C = pt(b, t, T, s, d, g, w);
          if (C) return !0;
          for (const A of T) pt(b, t, A.children(g), s, d, g, w) && (C = !0);
          return C;
        }
        function pt(b, t, s, d, g, w, T) {
          if (s[0].overscaledZ >= w) return !1;
          let C = !1;
          for (const A of s) {
            const F = b.getLoadedTile(A);
            if (!F) continue;
            const { fadingRole: O, fadingDirection: q, fadingParentID: V } = F;
            O === Te.Base && q === me.Departing && V || (F.setCrossFadeLogic({ fadingRole: Te.Base, fadingDirection: me.Departing, fadingParentID: t.tileID, fadeEndTime: g + T }), t.setCrossFadeLogic({ fadingRole: Te.Parent, fadingDirection: me.Incoming, fadeEndTime: g + T })), d[A.key] = A, C = !0;
          }
          return C;
        }
        function jr(b, t, s, d) {
          const g = b.tileID;
          return !!b.selfFading || !b.hasData() && !!t.has(g) && (b.setSelfFadeLogic(s + d), !0);
        }
        function Wn(b, t) {
          var s;
          b.needsHillshadePrepare = !0, b.needsTerrainPrepare = !0;
          let d = t.tileID.canonical.x - b.tileID.canonical.x;
          const g = t.tileID.canonical.y - b.tileID.canonical.y, w = Math.pow(2, b.tileID.canonical.z), T = t.tileID.key;
          d === 0 && g === 0 || Math.abs(g) > 1 || (Math.abs(d) > 1 && (Math.abs(d + w) === 1 ? d += w : Math.abs(d - w) === 1 && (d -= w)), t.dem && b.dem && (b.dem.backfillBorder(t.dem, d, g), !((s = b.neighboringTiles) === null || s === void 0) && s[T] && (b.neighboringTiles[T].backfilled = !0)));
        }
        class Hi {
          constructor() {
            this._tiles = {};
          }
          handleWrapJump(t) {
            const s = {};
            for (const d in this._tiles) {
              const g = this._tiles[d];
              g.tileID = g.tileID.unwrapTo(g.tileID.wrap + t), s[g.tileID.key] = g;
            }
            this._tiles = s;
          }
          setFeatureState(t, s) {
            for (const d in this._tiles) this._tiles[d].setFeatureState(t, s);
          }
          getAllTiles() {
            return Object.values(this._tiles);
          }
          getAllIds(t = !1) {
            return t ? Object.values(this._tiles).map(((s) => s.tileID)).sort(u.aw).map(((s) => s.key)) : Object.keys(this._tiles);
          }
          getTileById(t) {
            return this._tiles[t];
          }
          setTile(t, s) {
            this._tiles[t] = s;
          }
          deleteTileById(t) {
            delete this._tiles[t];
          }
          getLoadedTile(t) {
            const s = this.getTileById(t.key);
            return s?.hasData() ? s : null;
          }
          isIdRenderable(t, s = !1) {
            var d;
            return (d = this.getTileById(t)) === null || d === void 0 ? void 0 : d.isRenderable(s);
          }
          getRenderableIds(t = 0, s) {
            const d = [];
            for (const g of this.getAllIds()) this.isIdRenderable(g, s) && d.push(this.getTileById(g));
            return s ? d.sort(((g, w) => {
              const T = g.tileID, C = w.tileID, A = new u.P(T.canonical.x, T.canonical.y)._rotate(-t), F = new u.P(C.canonical.x, C.canonical.y)._rotate(-t);
              return T.overscaledZ - C.overscaledZ || F.y - A.y || F.x - A.x;
            })).map(((g) => g.tileID.key)) : d.map(((g) => g.tileID)).sort(u.aw).map(((g) => g.key));
          }
        }
        class Wr extends u.E {
          constructor(t, s, d) {
            super(), this.id = t, this.dispatcher = d, this.on("data", ((g) => this._dataHandler(g))), this.on("dataloading", (() => {
              this._sourceErrored = !1;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((g, w, T, C) => {
              const A = new (os(w.type))(g, w, T, C);
              if (A.id !== g) throw new Error(`Expected Source id to be ${g} instead of ${A.id}`);
              return A;
            })(t, s, d, this), this._inViewTiles = new Hi(), this._outOfViewCache = new u.ax(0, ((g) => this._unloadTile(g))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new We(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(t) {
            this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t);
          }
          onRemove(t) {
            for (const s of this._inViewTiles.getAllTiles()) s.unloadVectorData();
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t), this._inViewTiles = new Hi();
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const t of this._inViewTiles.getAllTiles()) if (t.state !== "loaded" && t.state !== "errored") return !1;
            return !0;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const t = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t, s, d) {
            return u._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(t), this._tileLoaded(t, s, d);
              } catch (g) {
                t.state = "errored", g.status !== 404 ? this._source.fire(new u.k(g, { tile: t })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(t) {
            this._source.unloadTile && this._source.unloadTile(t);
          }
          _abortTile(t) {
            this._source.abortTile && this._source.abortTile(t), this._source.fire(new u.l("dataabort", { tile: t, coord: t.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._inViewTiles, this.map ? this.map.painter : null);
            for (const s of this._inViewTiles.getAllTiles()) s.upload(t), s.prepare(this.map.style.imageManager);
          }
          getIds() {
            return this._inViewTiles.getAllIds(!0);
          }
          getRenderableIds(t) {
            var s;
            return this._inViewTiles.getRenderableIds((s = this.transform) === null || s === void 0 ? void 0 : s.bearingInRadians, t);
          }
          hasRenderableParent(t) {
            const s = t.overscaledZ - 1;
            if (s >= this._source.minzoom) {
              const d = this.getLoadedTile(t.scaledTo(s));
              if (d) return this._inViewTiles.isIdRenderable(d.tileID.key);
            }
            return !1;
          }
          reload(t, s = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._outOfViewCache.reset();
              for (const d of this._inViewTiles.getAllIds()) {
                const g = this._inViewTiles.getTileById(d);
                s && !this._source.shouldReloadTile(g, s) || (t ? this._reloadTile(d, "expired") : g.state !== "errored" && this._reloadTile(d, "reloading"));
              }
            }
          }
          _reloadTile(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = this._inViewTiles.getTileById(t);
              d && (d.state !== "loading" && (d.state = s), yield this._loadTile(d, t, s));
            }));
          }
          _tileLoaded(t, s, d) {
            t.timeAdded = _e(), t.selfFading && (t.fadeEndTime = t.timeAdded + this._rasterFadeDuration), d === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this.getSource().type === "raster-dem" && t.dem && (function(g, w) {
              var T, C;
              const A = w.getRenderableIds();
              for (const F of A) {
                if (!g.neighboringTiles || !g.neighboringTiles[F]) continue;
                const O = w.getTileById(F);
                g.neighboringTiles[F].backfilled || Wn(g, O), !((C = (T = O.neighboringTiles) === null || T === void 0 ? void 0 : T[g.tileID.key]) === null || C === void 0) && C.backfilled || Wn(O, g);
              }
            })(t, this._inViewTiles), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new u.l("data", { dataType: "source", tile: t, coord: t.tileID }));
          }
          getTile(t) {
            return this.getTileByID(t.key);
          }
          getTileByID(t) {
            return this._inViewTiles.getTileById(t);
          }
          _retainLoadedChildren(t, s) {
            const d = this._getLoadedDescendents(s), g = /* @__PURE__ */ new Set();
            for (const w of s) {
              const T = d[w.key];
              if (!T?.length) {
                g.add(w);
                continue;
              }
              const C = w.overscaledZ + Wr.maxOverzooming, A = T.filter(((q) => q.tileID.overscaledZ <= C));
              if (!A.length) {
                g.add(w);
                continue;
              }
              const F = Math.min(...A.map(((q) => q.tileID.overscaledZ))), O = A.filter(((q) => q.tileID.overscaledZ === F)).map(((q) => q.tileID));
              for (const q of O) t[q.key] = q;
              this._areDescendentsComplete(O, F, w.overscaledZ) || g.add(w);
            }
            return g;
          }
          _getLoadedDescendents(t) {
            var s;
            const d = {};
            for (const g of this._inViewTiles.getAllTiles().filter(((w) => w.hasData()))) for (const w of t) g.tileID.isChildOf(w) && (d[s = w.key] || (d[s] = [])).push(g);
            return d;
          }
          _areDescendentsComplete(t, s, d) {
            return t.length === 1 && t[0].isOverscaled() ? t[0].overscaledZ === s : Math.pow(4, s - d) === t.length;
          }
          getLoadedTile(t) {
            return this._inViewTiles.getLoadedTile(t);
          }
          updateCacheSize(t) {
            const s = Math.ceil(t.width / this._source.tileSize) + 1, d = Math.ceil(t.height / this._source.tileSize) + 1, g = Math.floor(s * d * (this._maxTileCacheZoomLevels === null ? u.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), w = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, g) : g;
            this._outOfViewCache.setMaxSize(w);
          }
          handleWrapJump(t) {
            const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
            this._prevLng = t, s && (this._inViewTiles.handleWrapJump(s), this._resetTileReloadTimers());
          }
          update(t, s) {
            if (!this._sourceLoaded || this._paused) return;
            let d;
            this.transform = t, this.terrain = s, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? d = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(((A) => new u.a2(A.canonical.z, A.wrap, A.canonical.z, A.canonical.x, A.canonical.y))) : (d = wr(t, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.type === "vector" && this.map._zoomLevelsToOverscale !== void 0 ? t.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: s, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (d = d.filter(((A) => this._source.hasTile(A))))) : d = [], this.usedForTerrain && (d = this._addTerrainIdealTiles(d));
            const g = d.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, g && this.fire(new u.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const w = Fr(t, this._source), T = this._updateRetainedTiles(d, w), C = Qr(this._source.type);
            C && this._rasterFadeDuration > 0 && !s && (function(A, F, O, q, V, X, te) {
              const he = _e(), pe = u.av(F);
              for (const fe of F) {
                const be = A.getTileById(fe.key);
                be.fadingDirection !== me.Departing && be.fadeOpacity !== 0 || be.resetFadeLogic(), Ur(A, be, O, he, q, V, te) || Ir(A, be, O, he, X, te) || jr(be, pe, he, te) || be.resetFadeLogic();
              }
            })(this._inViewTiles, d, T, this._maxFadingAncestorLevels, this._source.minzoom, this._source.maxzoom, this._rasterFadeDuration), C ? this._cleanUpRasterTiles(T) : this._cleanUpVectorTiles(T);
          }
          _cleanUpRasterTiles(t) {
            for (const s of this._inViewTiles.getAllIds()) t[s] || this._removeTile(s);
          }
          _cleanUpVectorTiles(t) {
            for (const s of this._inViewTiles.getAllIds()) {
              const d = this._inViewTiles.getTileById(s);
              t[s] ? d.clearSymbolFadeHold() : d.hasSymbolBuckets ? d.holdingForSymbolFade() ? d.symbolFadeFinished() && this._removeTile(s) : d.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(s);
            }
          }
          _addTerrainIdealTiles(t) {
            const s = [];
            for (const d of t) if (d.canonical.z > this._source.minzoom) {
              const g = d.scaledTo(d.canonical.z - 1);
              s.push(g);
              const w = d.scaledTo(Math.max(this._source.minzoom, Math.min(d.canonical.z, 5)));
              s.push(w);
            }
            return t.concat(s);
          }
          releaseSymbolFadeTiles() {
            for (const t of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(t).holdingForSymbolFade() && this._removeTile(t);
          }
          _updateRetainedTiles(t, s) {
            var d;
            const g = /* @__PURE__ */ new Set();
            for (const F of t) this._addTile(F).hasData() || g.add(F);
            const w = t.reduce(((F, O) => (F[O.key] = O, F)), {}), T = this._retainLoadedChildren(w, g), C = {}, A = Math.max(s - Wr.maxUnderzooming, this._source.minzoom);
            for (const F of T) {
              let O = this._inViewTiles.getTileById(F.key), q = O?.wasRequested();
              for (let V = F.overscaledZ - 1; V >= A; --V) {
                const X = F.scaledTo(V);
                if (C[X.key]) break;
                if (C[X.key] = !0, O = this.getTile(X), !O && q && (O = this._addTile(X)), O) {
                  const te = O.hasData();
                  if ((te || !(!((d = this.map) === null || d === void 0) && d.cancelPendingTileRequestsWhileZooming) || q) && (w[X.key] = X), q = O.wasRequested(), te) break;
                }
              }
            }
            return w;
          }
          _addTile(t) {
            let s = this._inViewTiles.getTileById(t.key);
            if (s) return s;
            s = this._outOfViewCache.getAndRemove(t), s && (s.resetFadeLogic(), this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null));
            const d = s;
            return s || (s = new Ye(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(s, t.key, s.state)), s.uses++, this._inViewTiles.setTile(t.key, s), d || this._source.fire(new u.l("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s;
          }
          _setTileReloadTimer(t, s) {
            this._clearTileReloadTimer(t);
            const d = s.getExpiryTimeout();
            d && (this._timers[t] = setTimeout((() => {
              this._reloadTile(t, "expired"), delete this._timers[t];
            }), d));
          }
          _clearTileReloadTimer(t) {
            const s = this._timers[t];
            s && (clearTimeout(s), delete this._timers[t]);
          }
          _resetTileReloadTimers() {
            for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];
            for (const t of this._inViewTiles.getAllIds()) {
              const s = this._inViewTiles.getTileById(t);
              this._setTileReloadTimer(t, s);
            }
          }
          refreshTiles(t) {
            for (const s of this._inViewTiles.getAllIds()) {
              const d = this._inViewTiles.getTileById(s);
              (this._inViewTiles.isIdRenderable(s) || d.state == "errored") && t.some(((g) => g.equals(d.tileID.canonical))) && this._reloadTile(s, "expired");
            }
          }
          _removeTile(t) {
            const s = this._inViewTiles.getTileById(t);
            s && (s.uses--, this._inViewTiles.deleteTileById(t), this._clearTileReloadTimer(t), s.uses > 0 || (s.hasData() && s.state !== "reloading" ? this._outOfViewCache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s))));
          }
          _dataHandler(t) {
            t.dataType === "source" && (t.sourceDataType !== "metadata" ? t.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(t.sourceDataChanged, t.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const t of this._inViewTiles.getAllIds()) this._removeTile(t);
            this._outOfViewCache.reset();
          }
          tilesIn(t, s, d) {
            const g = [], w = this.transform;
            if (!w) return g;
            const T = w.getCoveringTilesDetailsProvider().allowWorldCopies(), C = d ? w.getCameraQueryGeometry(t) : t, A = (X) => w.screenPointToMercatorCoordinate(X, this.terrain), F = this.transformBbox(t, A, !T), O = this.transformBbox(C, A, !T), q = this.getIds(), V = u.aa.fromPoints(O);
            for (let X = 0; X < q.length; X++) {
              const te = this._inViewTiles.getTileById(q[X]);
              if (te.holdingForSymbolFade()) continue;
              const he = T ? [te.tileID] : [te.tileID.unwrapTo(-1), te.tileID.unwrapTo(0)], pe = Math.pow(2, w.zoom - te.tileID.overscaledZ), fe = s * te.queryPadding * u.a5 / te.tileSize / pe;
              for (const be of he) {
                const Ae = V.map(((xe) => be.getTilePoint(new u.a9(xe.x, xe.y))));
                if (Ae.expandBy(fe), Ae.intersects(un)) {
                  const xe = F.map(((Oe) => be.getTilePoint(Oe))), Ce = O.map(((Oe) => be.getTilePoint(Oe)));
                  g.push({ tile: te, tileID: T ? be : be.unwrapTo(0), queryGeometry: xe, cameraQueryGeometry: Ce, scale: pe });
                }
              }
            }
            return g;
          }
          transformBbox(t, s, d) {
            let g = t.map(s);
            if (d) {
              const w = u.aa.fromPoints(t);
              w.shrinkBy(1e-3 * Math.min(w.width(), w.height()));
              const T = w.map(s);
              u.aa.fromPoints(g).covers(T) || (g = g.map(((C) => C.x > 0.5 ? new u.a9(C.x - 1, C.y, C.z) : C)));
            }
            return g;
          }
          getVisibleCoordinates(t) {
            const s = this.getRenderableIds(t).map(((d) => this._inViewTiles.getTileById(d).tileID));
            return this.transform && this.transform.populateCache(s), s;
          }
          hasTransition() {
            return !!this._source.hasTransition() || !(!Qr(this._source.type) || !(function(t, s) {
              if (s <= 0) return !1;
              const d = _e();
              for (const g of t.getAllTiles()) if (g.fadeEndTime >= d) return !0;
              return !1;
            })(this._inViewTiles, this._rasterFadeDuration));
          }
          setRasterFadeDuration(t) {
            this._rasterFadeDuration = t;
          }
          setFeatureState(t, s, d) {
            this._state.updateState(t = t || u.ai, s, d);
          }
          removeFeatureState(t, s, d) {
            this._state.removeFeatureState(t = t || u.ai, s, d);
          }
          getFeatureState(t, s) {
            return this._state.getState(t = t || u.ai, s);
          }
          setDependencies(t, s, d) {
            const g = this._inViewTiles.getTileById(t);
            g && g.setDependencies(s, d);
          }
          reloadTilesForDependencies(t, s) {
            for (const d of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(d).hasDependency(t, s) && this._reloadTile(d, "reloading");
            this._outOfViewCache.filter(((d) => !d.hasDependency(t, s)));
          }
          areTilesLoaded() {
            for (const t of this._inViewTiles.getAllTiles()) if (t.state !== "loaded" && t.state !== "errored") return !1;
            return !0;
          }
        }
        Wr.maxUnderzooming = 10, Wr.maxOverzooming = 3;
        class yt {
          constructor(t, s) {
            this.reset(t, s);
          }
          reset(t, s) {
            this.points = t || [], this._distances = [0];
            for (let d = 1; d < this.points.length; d++) this._distances[d] = this._distances[d - 1] + this.points[d].dist(this.points[d - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t) {
            if (this.points.length === 1) return this.points[0];
            t = u.an(t, 0, 1);
            let s = 1, d = this._distances[s];
            const g = t * this.paddedLength + this.padding;
            for (; d < g && s < this._distances.length; ) d = this._distances[++s];
            const w = s - 1, T = this._distances[w], C = d - T, A = C > 0 ? (g - T) / C : 0;
            return this.points[w].mult(1 - A).add(this.points[s].mult(A));
          }
        }
        function er(b, t) {
          let s = !0;
          return b === "always" || b !== "never" && t !== "never" || (s = !1), s;
        }
        class ir {
          constructor(t, s, d) {
            const g = this.boxCells = [], w = this.circleCells = [];
            this.xCellCount = Math.ceil(t / d), this.yCellCount = Math.ceil(s / d);
            for (let T = 0; T < this.xCellCount * this.yCellCount; T++) g.push([]), w.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t, s, d, g, w) {
            this._forEachCell(s, d, g, w, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(d), this.bboxes.push(g), this.bboxes.push(w);
          }
          insertCircle(t, s, d, g) {
            this._forEachCell(s - g, d - g, s + g, d + g, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(d), this.circles.push(g);
          }
          _insertBoxCell(t, s, d, g, w, T) {
            this.boxCells[w].push(T);
          }
          _insertCircleCell(t, s, d, g, w, T) {
            this.circleCells[w].push(T);
          }
          _query(t, s, d, g, w, T, C) {
            if (d < 0 || t > this.width || g < 0 || s > this.height) return [];
            const A = [];
            if (t <= 0 && s <= 0 && this.width <= d && this.height <= g) {
              if (w) return [{ key: null, x1: t, y1: s, x2: d, y2: g }];
              for (let F = 0; F < this.boxKeys.length; F++) A.push({ key: this.boxKeys[F], x1: this.bboxes[4 * F], y1: this.bboxes[4 * F + 1], x2: this.bboxes[4 * F + 2], y2: this.bboxes[4 * F + 3] });
              for (let F = 0; F < this.circleKeys.length; F++) {
                const O = this.circles[3 * F], q = this.circles[3 * F + 1], V = this.circles[3 * F + 2];
                A.push({ key: this.circleKeys[F], x1: O - V, y1: q - V, x2: O + V, y2: q + V });
              }
            } else this._forEachCell(t, s, d, g, this._queryCell, A, { hitTest: w, overlapMode: T, seenUids: { box: {}, circle: {} } }, C);
            return A;
          }
          query(t, s, d, g) {
            return this._query(t, s, d, g, !1, null);
          }
          hitTest(t, s, d, g, w, T) {
            return this._query(t, s, d, g, !0, w, T).length > 0;
          }
          hitTestCircle(t, s, d, g, w) {
            const T = t - d, C = t + d, A = s - d, F = s + d;
            if (C < 0 || T > this.width || F < 0 || A > this.height) return !1;
            const O = [];
            return this._forEachCell(T, A, C, F, this._queryCellCircle, O, { hitTest: !0, overlapMode: g, circle: { x: t, y: s, radius: d }, seenUids: { box: {}, circle: {} } }, w), O.length > 0;
          }
          _queryCell(t, s, d, g, w, T, C, A) {
            const { seenUids: F, hitTest: O, overlapMode: q } = C, V = this.boxCells[w];
            if (V !== null) {
              const te = this.bboxes;
              for (const he of V) if (!F.box[he]) {
                F.box[he] = !0;
                const pe = 4 * he, fe = this.boxKeys[he];
                if (t <= te[pe + 2] && s <= te[pe + 3] && d >= te[pe + 0] && g >= te[pe + 1] && (!A || A(fe)) && (!O || !er(q, fe.overlapMode)) && (T.push({ key: fe, x1: te[pe], y1: te[pe + 1], x2: te[pe + 2], y2: te[pe + 3] }), O)) return !0;
              }
            }
            const X = this.circleCells[w];
            if (X !== null) {
              const te = this.circles;
              for (const he of X) if (!F.circle[he]) {
                F.circle[he] = !0;
                const pe = 3 * he, fe = this.circleKeys[he];
                if (this._circleAndRectCollide(te[pe], te[pe + 1], te[pe + 2], t, s, d, g) && (!A || A(fe)) && (!O || !er(q, fe.overlapMode))) {
                  const be = te[pe], Ae = te[pe + 1], xe = te[pe + 2];
                  if (T.push({ key: fe, x1: be - xe, y1: Ae - xe, x2: be + xe, y2: Ae + xe }), O) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(t, s, d, g, w, T, C, A) {
            const { circle: F, seenUids: O, overlapMode: q } = C, V = this.boxCells[w];
            if (V !== null) {
              const te = this.bboxes;
              for (const he of V) if (!O.box[he]) {
                O.box[he] = !0;
                const pe = 4 * he, fe = this.boxKeys[he];
                if (this._circleAndRectCollide(F.x, F.y, F.radius, te[pe + 0], te[pe + 1], te[pe + 2], te[pe + 3]) && (!A || A(fe)) && !er(q, fe.overlapMode)) return T.push(!0), !0;
              }
            }
            const X = this.circleCells[w];
            if (X !== null) {
              const te = this.circles;
              for (const he of X) if (!O.circle[he]) {
                O.circle[he] = !0;
                const pe = 3 * he, fe = this.circleKeys[he];
                if (this._circlesCollide(te[pe], te[pe + 1], te[pe + 2], F.x, F.y, F.radius) && (!A || A(fe)) && !er(q, fe.overlapMode)) return T.push(!0), !0;
              }
            }
          }
          _forEachCell(t, s, d, g, w, T, C, A) {
            const F = this._convertToXCellCoord(t), O = this._convertToYCellCoord(s), q = this._convertToXCellCoord(d), V = this._convertToYCellCoord(g);
            for (let X = F; X <= q; X++) for (let te = O; te <= V; te++) if (w.call(this, t, s, d, g, this.xCellCount * te + X, T, C, A)) return;
          }
          _convertToXCellCoord(t) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
          }
          _convertToYCellCoord(t) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
          }
          _circlesCollide(t, s, d, g, w, T) {
            const C = g - t, A = w - s, F = d + T;
            return F * F > C * C + A * A;
          }
          _circleAndRectCollide(t, s, d, g, w, T, C) {
            const A = (T - g) / 2, F = Math.abs(t - (g + A));
            if (F > A + d) return !1;
            const O = (C - w) / 2, q = Math.abs(s - (w + O));
            if (q > O + d) return !1;
            if (F <= A || q <= O) return !0;
            const V = F - A, X = q - O;
            return V * V + X * X <= d * d;
          }
        }
        function mn(b, t, s) {
          const d = u.N();
          if (!b) {
            const { vecSouth: q, vecEast: V } = Gi(t), X = z();
            X[0] = V[0], X[1] = V[1], X[2] = q[0], X[3] = q[1], g = X, (O = (T = (w = X)[0]) * (F = w[3]) - (A = w[2]) * (C = w[1])) && (g[0] = F * (O = 1 / O), g[1] = -C * O, g[2] = -A * O, g[3] = T * O), d[0] = X[0], d[1] = X[1], d[4] = X[2], d[5] = X[3];
          }
          var g, w, T, C, A, F, O;
          return u.Q(d, d, [1 / s, 1 / s, 1]), d;
        }
        function Bi(b, t, s, d) {
          if (b) {
            const g = u.N();
            if (!t) {
              const { vecSouth: w, vecEast: T } = Gi(s);
              g[0] = T[0], g[1] = T[1], g[4] = w[0], g[5] = w[1];
            }
            return u.Q(g, g, [d, d, 1]), g;
          }
          return s.pixelsToClipSpaceMatrix;
        }
        function Gi(b) {
          const t = Math.cos(b.rollInRadians), s = Math.sin(b.rollInRadians), d = Math.cos(b.pitchInRadians), g = Math.cos(b.bearingInRadians), w = Math.sin(b.bearingInRadians), T = u.aC();
          T[0] = -g * d * s - w * t, T[1] = -w * d * s + g * t;
          const C = u.aD(T);
          C < 1e-9 ? u.aE(T) : u.aF(T, T, 1 / C);
          const A = u.aC();
          A[0] = g * d * t - w * s, A[1] = w * d * t + g * s;
          const F = u.aD(A);
          return F < 1e-9 ? u.aE(A) : u.aF(A, A, 1 / F), { vecEast: A, vecSouth: T };
        }
        function we(b, t, s, d) {
          let g;
          d ? (g = [b, t, d(b, t), 1], u.aH(g, g, s)) : (g = [b, t, 0, 1], vl(g, g, s));
          const w = g[3];
          return { point: new u.P(g[0] / w, g[1] / w), signedDistanceFromCamera: w, isOccluded: !1 };
        }
        function Gt(b, t) {
          return 0.5 + b / t * 0.5;
        }
        function wt(b, t) {
          return b.x >= -t[0] && b.x <= t[0] && b.y >= -t[1] && b.y <= t[1];
        }
        function Sr(b, t, s, d, g, w, T, C, A, F, O, q, V) {
          const X = s ? b.textSizeData : b.iconSizeData, te = u.ay(X, t.transform.zoom), he = [256 / t.width * 2 + 1, 256 / t.height * 2 + 1], pe = s ? b.text.dynamicLayoutVertexArray : b.icon.dynamicLayoutVertexArray;
          pe.clear();
          const fe = b.lineVertexArray, be = s ? b.text.placedSymbolArray : b.icon.placedSymbolArray, Ae = t.transform.width / t.transform.height;
          let xe = !1;
          for (let Ce = 0; Ce < be.length; Ce++) {
            const Oe = be.get(Ce);
            if (Oe.hidden || Oe.writingMode === u.az.vertical && !xe) {
              ba(Oe.numGlyphs, pe);
              continue;
            }
            xe = !1;
            const ke = new u.P(Oe.anchorX, Oe.anchorY), je = { getElevation: V, pitchedLabelPlaneMatrix: d, lineVertexArray: fe, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: t.transform, tileAnchorPoint: ke, unwrappedTileID: A, width: F, height: O, translation: q }, at = Rn(Oe.anchorX, Oe.anchorY, je);
            if (!wt(at.point, he)) {
              ba(Oe.numGlyphs, pe);
              continue;
            }
            const tt = Gt(t.transform.cameraToCenterDistance, at.signedDistanceFromCamera), nt = u.aA(X, te, Oe), it = w ? nt * t.transform.getPitchedTextCorrection(Oe.anchorX, Oe.anchorY, A) / tt : nt * tt, St = Mn({ projectionContext: je, pitchedLabelPlaneMatrixInverse: g, symbol: Oe, fontSize: it, flip: !1, keepUpright: T, glyphOffsetArray: b.glyphOffsetArray, dynamicLayoutVertexArray: pe, aspectRatio: Ae, rotateToLine: C });
            xe = St.useVertical, (St.notEnoughRoom || xe || St.needsFlipping && Mn({ projectionContext: je, pitchedLabelPlaneMatrixInverse: g, symbol: Oe, fontSize: it, flip: !0, keepUpright: T, glyphOffsetArray: b.glyphOffsetArray, dynamicLayoutVertexArray: pe, aspectRatio: Ae, rotateToLine: C }).notEnoughRoom) && ba(Oe.numGlyphs, pe);
          }
          s ? b.text.dynamicLayoutVertexBuffer.updateData(pe) : b.icon.dynamicLayoutVertexBuffer.updateData(pe);
        }
        function en(b, t, s, d, g, w, T, C) {
          const A = w.glyphStartIndex + w.numGlyphs, F = w.lineStartIndex, O = w.lineStartIndex + w.lineLength, q = t.getoffsetX(w.glyphStartIndex), V = t.getoffsetX(A - 1), X = si(b * q, s, d, g, w.segment, F, O, C, T);
          if (!X) return null;
          const te = si(b * V, s, d, g, w.segment, F, O, C, T);
          return te ? C.projectionCache.anyProjectionOccluded ? null : { first: X, last: te } : null;
        }
        function Mr(b, t, s, d) {
          return b === u.az.horizontal && Math.abs(s.y - t.y) > Math.abs(s.x - t.x) * d ? { useVertical: !0 } : (b === u.az.vertical ? t.y < s.y : t.x > s.x) ? { needsFlipping: !0 } : null;
        }
        function Mn(b) {
          const { projectionContext: t, pitchedLabelPlaneMatrixInverse: s, symbol: d, fontSize: g, flip: w, keepUpright: T, glyphOffsetArray: C, dynamicLayoutVertexArray: A, aspectRatio: F, rotateToLine: O } = b, q = g / 24, V = d.lineOffsetX * q, X = d.lineOffsetY * q;
          let te;
          if (d.numGlyphs > 1) {
            const he = d.glyphStartIndex + d.numGlyphs, pe = d.lineStartIndex, fe = d.lineStartIndex + d.lineLength, be = en(q, C, V, X, w, d, O, t);
            if (!be) return { notEnoughRoom: !0 };
            const Ae = _n(be.first.point.x, be.first.point.y, t, s), xe = _n(be.last.point.x, be.last.point.y, t, s);
            if (T && !w) {
              const Ce = Mr(d.writingMode, Ae, xe, F);
              if (Ce) return Ce;
            }
            te = [be.first];
            for (let Ce = d.glyphStartIndex + 1; Ce < he - 1; Ce++) {
              const Oe = si(q * C.getoffsetX(Ce), V, X, w, d.segment, pe, fe, t, O);
              if (!Oe) return { notEnoughRoom: !0 };
              te.push(Oe);
            }
            te.push(be.last);
          } else {
            if (T && !w) {
              const pe = Er(t.tileAnchorPoint.x, t.tileAnchorPoint.y, t).point, fe = d.lineStartIndex + d.segment + 1, be = new u.P(t.lineVertexArray.getx(fe), t.lineVertexArray.gety(fe)), Ae = Er(be.x, be.y, t), xe = Ae.signedDistanceFromCamera > 0 ? Ae.point : Dn(t.tileAnchorPoint, be, pe, 1, t), Ce = _n(pe.x, pe.y, t, s), Oe = _n(xe.x, xe.y, t, s), ke = Mr(d.writingMode, Ce, Oe, F);
              if (ke) return ke;
            }
            const he = si(q * C.getoffsetX(d.glyphStartIndex), V, X, w, d.segment, d.lineStartIndex, d.lineStartIndex + d.lineLength, t, O);
            if (!he || t.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            te = [he];
          }
          for (const he of te) u.aG(A, he.point, he.angle);
          return {};
        }
        function Dn(b, t, s, d, g) {
          const w = b.add(b.sub(t)._unit()), T = Er(w.x, w.y, g).point, C = s.sub(T);
          return s.add(C._mult(d / C.mag()));
        }
        function Nr(b, t, s) {
          const d = t.projectionCache;
          if (d.projections[b]) return d.projections[b];
          const g = new u.P(t.lineVertexArray.getx(b), t.lineVertexArray.gety(b)), w = Er(g.x, g.y, t);
          if (w.signedDistanceFromCamera > 0) return d.projections[b] = w.point, d.anyProjectionOccluded = d.anyProjectionOccluded || w.isOccluded, w.point;
          const T = b - s.direction;
          return Dn(s.distanceFromAnchor === 0 ? t.tileAnchorPoint : new u.P(t.lineVertexArray.getx(T), t.lineVertexArray.gety(T)), g, s.previousVertex, s.absOffsetX - s.distanceFromAnchor + 1, t);
        }
        function Er(b, t, s) {
          const d = b + s.translation[0], g = t + s.translation[1];
          let w;
          return s.pitchWithMap ? (w = we(d, g, s.pitchedLabelPlaneMatrix, s.getElevation), w.isOccluded = !1) : (w = s.transform.projectTileCoordinates(d, g, s.unwrappedTileID, s.getElevation), w.point.x = (0.5 * w.point.x + 0.5) * s.width, w.point.y = (0.5 * -w.point.y + 0.5) * s.height), w;
        }
        function _n(b, t, s, d) {
          if (s.pitchWithMap) {
            const g = [b, t, 0, 1];
            return u.aH(g, g, d), s.transform.projectTileCoordinates(g[0] / g[3], g[1] / g[3], s.unwrappedTileID, s.getElevation).point;
          }
          return { x: b / s.width * 2 - 1, y: 1 - t / s.height * 2 };
        }
        function Rn(b, t, s) {
          return s.transform.projectTileCoordinates(b, t, s.unwrappedTileID, s.getElevation);
        }
        function Yi(b, t, s) {
          return b._unit()._perp()._mult(t * s);
        }
        function Ds(b, t, s, d, g, w, T, C, A) {
          if (C.projectionCache.offsets[b]) return C.projectionCache.offsets[b];
          const F = s.add(t);
          if (b + A.direction < d || b + A.direction >= g) return C.projectionCache.offsets[b] = F, F;
          const O = Nr(b + A.direction, C, A), q = Yi(O.sub(s), T, A.direction), V = s.add(q), X = O.add(q);
          return C.projectionCache.offsets[b] = u.aI(w, F, V, X) || F, C.projectionCache.offsets[b];
        }
        function si(b, t, s, d, g, w, T, C, A) {
          const F = d ? b - t : b + t;
          let O = F > 0 ? 1 : -1, q = 0;
          d && (O *= -1, q = Math.PI), O < 0 && (q += Math.PI);
          let V, X = O > 0 ? w + g : w + g + 1;
          C.projectionCache.cachedAnchorPoint ? V = C.projectionCache.cachedAnchorPoint : (V = Er(C.tileAnchorPoint.x, C.tileAnchorPoint.y, C).point, C.projectionCache.cachedAnchorPoint = V);
          let te, he, pe = V, fe = V, be = 0, Ae = 0;
          const xe = Math.abs(F), Ce = [];
          let Oe;
          for (; be + Ae <= xe; ) {
            if (X += O, X < w || X >= T) return null;
            be += Ae, fe = pe, he = te;
            const at = { absOffsetX: xe, direction: O, distanceFromAnchor: be, previousVertex: fe };
            if (pe = Nr(X, C, at), s === 0) Ce.push(fe), Oe = pe.sub(fe);
            else {
              let tt;
              const nt = pe.sub(fe);
              tt = nt.mag() === 0 ? Yi(Nr(X + O, C, at).sub(pe), s, O) : Yi(nt, s, O), he || (he = fe.add(tt)), te = Ds(X, tt, pe, w, T, he, s, C, at), Ce.push(he), Oe = te.sub(he);
            }
            Ae = Oe.mag();
          }
          const ke = Oe._mult((xe - be) / Ae)._add(he || fe), je = q + Math.atan2(pe.y - fe.y, pe.x - fe.x);
          return Ce.push(ke), { point: ke, angle: A ? je : 0, path: Ce };
        }
        const yl = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function ba(b, t) {
          for (let s = 0; s < b; s++) {
            const d = t.length;
            t.resize(d + 4), t.float32.set(yl, 3 * d);
          }
        }
        function vl(b, t, s) {
          const d = t[0], g = t[1];
          return b[0] = s[0] * d + s[4] * g + s[12], b[1] = s[1] * d + s[5] * g + s[13], b[3] = s[3] * d + s[7] * g + s[15], b;
        }
        const cn = 100;
        class su {
          constructor(t, s = new ir(t.width + 200, t.height + 200, 25), d = new ir(t.width + 200, t.height + 200, 25)) {
            this.transform = t, this.grid = s, this.ignoredGrid = d, this.pitchFactor = Math.cos(t.pitch * Math.PI / 180) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + cn, this.screenBottomBoundary = t.height + cn, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t, s, d, g, w, T, C, A, F, O, q, V) {
            const X = this.projectAndGetPerspectiveRatio(t.anchorPointX + A[0], t.anchorPointY + A[1], w, O, V), te = d * X.perspectiveRatio;
            let he;
            if (T || C) he = this._projectCollisionBox(t, te, g, w, T, C, A, X, O, q, V);
            else {
              const Oe = X.x + (q ? q.x * te : 0), ke = X.y + (q ? q.y * te : 0);
              he = { allPointsOccluded: !1, box: [Oe + t.x1 * te, ke + t.y1 * te, Oe + t.x2 * te, ke + t.y2 * te] };
            }
            const [pe, fe, be, Ae] = he.box, xe = T ? he.allPointsOccluded : X.isOccluded;
            let Ce = xe;
            return Ce || (Ce = X.perspectiveRatio < this.perspectiveRatioCutoff), Ce || (Ce = !this.isInsideGrid(pe, fe, be, Ae)), Ce || s !== "always" && this.grid.hitTest(pe, fe, be, Ae, s, F) ? { box: [pe, fe, be, Ae], placeable: !1, offscreen: !1, occluded: xe } : { box: [pe, fe, be, Ae], placeable: !0, offscreen: this.isOffscreen(pe, fe, be, Ae), occluded: xe };
          }
          placeCollisionCircles(t, s, d, g, w, T, C, A, F, O, q, V, X, te) {
            const he = [], pe = new u.P(s.anchorX, s.anchorY), fe = this.getPerspectiveRatio(pe.x, pe.y, T, te), be = (F ? w * this.transform.getPitchedTextCorrection(s.anchorX, s.anchorY, T) / fe : w * fe) / u.aM, Ae = { getElevation: te, pitchedLabelPlaneMatrix: C, lineVertexArray: d, pitchWithMap: F, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: pe, unwrappedTileID: T, width: this.transform.width, height: this.transform.height, translation: X }, xe = en(be, g, s.lineOffsetX * be, s.lineOffsetY * be, !1, s, !1, Ae);
            let Ce = !1, Oe = !1, ke = !0;
            if (xe) {
              const je = 0.5 * q * fe + V, at = new u.P(-100, -100), tt = new u.P(this.screenRightBoundary, this.screenBottomBoundary), nt = new yt(), it = xe.first, St = xe.last;
              let It = [];
              for (let or = it.path.length - 1; or >= 1; or--) It.push(it.path[or]);
              for (let or = 1; or < St.path.length; or++) It.push(St.path[or]);
              const _t = 2.5 * je;
              if (F) {
                const or = this.projectPathToScreenSpace(It, Ae);
                It = or.some(((Or) => Or.signedDistanceFromCamera <= 0)) ? [] : or.map(((Or) => Or.point));
              }
              let Lt = [];
              if (It.length > 0) {
                const or = It[0].clone(), Or = It[0].clone();
                for (let an = 1; an < It.length; an++) or.x = Math.min(or.x, It[an].x), or.y = Math.min(or.y, It[an].y), Or.x = Math.max(Or.x, It[an].x), Or.y = Math.max(Or.y, It[an].y);
                Lt = or.x >= at.x && Or.x <= tt.x && or.y >= at.y && Or.y <= tt.y ? [It] : Or.x < at.x || or.x > tt.x || Or.y < at.y || or.y > tt.y ? [] : u.aJ([It], at.x, at.y, tt.x, tt.y);
              }
              for (const or of Lt) {
                nt.reset(or, 0.25 * je);
                let Or = 0;
                Or = nt.length <= 0.5 * je ? 1 : Math.ceil(nt.paddedLength / _t) + 1;
                for (let an = 0; an < Or; an++) {
                  const $r = an / Math.max(Or - 1, 1), hn = nt.lerp($r), Zr = hn.x + cn, Sn = hn.y + cn;
                  he.push(Zr, Sn, je, 0);
                  const dn = Zr - je, hi = Sn - je, Fn = Zr + je, An = Sn + je;
                  if (ke = ke && this.isOffscreen(dn, hi, Fn, An), Oe = Oe || this.isInsideGrid(dn, hi, Fn, An), t !== "always" && this.grid.hitTestCircle(Zr, Sn, je, t, O) && (Ce = !0, !A)) return { circles: [], offscreen: !1, collisionDetected: Ce };
                }
              }
            }
            return { circles: !A && Ce || !Oe || fe < this.perspectiveRatioCutoff ? [] : he, offscreen: ke, collisionDetected: Ce };
          }
          projectPathToScreenSpace(t, s) {
            const d = (function(g, w) {
              const T = u.N();
              return u.aB(T, w.pitchedLabelPlaneMatrix), g.map(((C) => {
                const A = we(C.x, C.y, T, w.getElevation), F = w.transform.projectTileCoordinates(A.point.x, A.point.y, w.unwrappedTileID, w.getElevation);
                return F.point.x = (0.5 * F.point.x + 0.5) * w.width, F.point.y = (0.5 * -F.point.y + 0.5) * w.height, F;
              }));
            })(t, s);
            return (function(g) {
              let w = 0, T = 0, C = 0, A = 0;
              for (let F = 0; F < g.length; F++) g[F].isOccluded ? (C = F + 1, A = 0) : (A++, A > T && (T = A, w = C));
              return g.slice(w, w + T);
            })(d);
          }
          queryRenderedSymbols(t) {
            if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const s = [], d = new u.aa();
            for (const q of t) {
              const V = new u.P(q.x + cn, q.y + cn);
              d.extend(V), s.push(V);
            }
            const { minX: g, minY: w, maxX: T, maxY: C } = d, A = this.grid.query(g, w, T, C).concat(this.ignoredGrid.query(g, w, T, C)), F = {}, O = {};
            for (const q of A) {
              const V = q.key;
              if (F[V.bucketInstanceId] === void 0 && (F[V.bucketInstanceId] = {}), F[V.bucketInstanceId][V.featureIndex]) continue;
              const X = [new u.P(q.x1, q.y1), new u.P(q.x2, q.y1), new u.P(q.x2, q.y2), new u.P(q.x1, q.y2)];
              u.aK(s, X) && (F[V.bucketInstanceId][V.featureIndex] = !0, O[V.bucketInstanceId] === void 0 && (O[V.bucketInstanceId] = []), O[V.bucketInstanceId].push(V.featureIndex));
            }
            return O;
          }
          insertCollisionBox(t, s, d, g, w, T) {
            (d ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: g, featureIndex: w, collisionGroupID: T, overlapMode: s }, t[0], t[1], t[2], t[3]);
          }
          insertCollisionCircles(t, s, d, g, w, T) {
            const C = d ? this.ignoredGrid : this.grid, A = { bucketInstanceId: g, featureIndex: w, collisionGroupID: T, overlapMode: s };
            for (let F = 0; F < t.length; F += 4) C.insertCircle(A, t[F], t[F + 1], t[F + 2]);
          }
          projectAndGetPerspectiveRatio(t, s, d, g, w) {
            if (w) {
              let T;
              g ? (T = [t, s, g(t, s), 1], u.aH(T, T, w)) : (T = [t, s, 0, 1], vl(T, T, w));
              const C = T[3];
              return { x: (T[0] / C + 1) / 2 * this.transform.width + cn, y: (-T[1] / C + 1) / 2 * this.transform.height + cn, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / C * 0.5, isOccluded: !1, signedDistanceFromCamera: C };
            }
            {
              const T = this.transform.projectTileCoordinates(t, s, d, g);
              return { x: (T.point.x + 1) / 2 * this.transform.width + cn, y: (1 - T.point.y) / 2 * this.transform.height + cn, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / T.signedDistanceFromCamera * 0.5, isOccluded: T.isOccluded, signedDistanceFromCamera: T.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(t, s, d, g) {
            const w = this.transform.projectTileCoordinates(t, s, d, g);
            return 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(t, s, d, g) {
            return d < cn || t >= this.screenRightBoundary || g < cn || s > this.screenBottomBoundary;
          }
          isInsideGrid(t, s, d, g) {
            return d >= 0 && t < this.gridRightBoundary && g >= 0 && s < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t = u.ar([]);
            return u.O(t, t, [-100, -100, 0]), t;
          }
          _projectCollisionBox(t, s, d, g, w, T, C, A, F, O, q) {
            let V = 1, X = 0, te = 0, he = 1;
            const pe = t.anchorPointX + C[0], fe = t.anchorPointY + C[1];
            if (T && !w) {
              const It = this.projectAndGetPerspectiveRatio(pe + 1, fe, g, F, q), _t = It.x - A.x, Lt = Math.atan((It.y - A.y) / _t) + (_t < 0 ? Math.PI : 0), or = Math.sin(Lt), Or = Math.cos(Lt);
              V = Or, X = or, te = -or, he = Or;
            } else if (!T && w) {
              const It = Gi(this.transform);
              V = It.vecEast[0], X = It.vecEast[1], te = It.vecSouth[0], he = It.vecSouth[1];
            }
            let be = A.x, Ae = A.y, xe = s;
            w && (be = pe, Ae = fe, xe = Math.pow(2, -(this.transform.zoom - d.overscaledZ)), xe *= this.transform.getPitchedTextCorrection(pe, fe, g), O || (xe *= u.an(0.5 + A.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), O && (be += V * O.x * xe + te * O.y * xe, Ae += X * O.x * xe + he * O.y * xe);
            const Ce = t.x1 * xe, Oe = t.x2 * xe, ke = (Ce + Oe) / 2, je = t.y1 * xe, at = t.y2 * xe, tt = (je + at) / 2, nt = [{ offsetX: Ce, offsetY: je }, { offsetX: ke, offsetY: je }, { offsetX: Oe, offsetY: je }, { offsetX: Oe, offsetY: tt }, { offsetX: Oe, offsetY: at }, { offsetX: ke, offsetY: at }, { offsetX: Ce, offsetY: at }, { offsetX: Ce, offsetY: tt }];
            let it = [];
            for (const { offsetX: It, offsetY: _t } of nt) it.push(new u.P(be + V * It + te * _t, Ae + X * It + he * _t));
            let St = !1;
            if (w) {
              const It = it.map(((_t) => this.projectAndGetPerspectiveRatio(_t.x, _t.y, g, F, q)));
              St = It.some(((_t) => !_t.isOccluded)), it = It.map(((_t) => new u.P(_t.x, _t.y)));
            } else St = !0;
            return { box: u.aL(it), allPointsOccluded: !St };
          }
        }
        class au {
          constructor(t, s, d, g) {
            this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : g && d ? 1 : 0, this.placed = d;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class ea {
          constructor(t, s, d, g, w) {
            this.text = new au(t ? t.text : null, s, d, w), this.icon = new au(t ? t.icon : null, s, g, w);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class bs {
          constructor(t, s, d) {
            this.text = t, this.icon = s, this.skipFade = d;
          }
        }
        class Rs {
          constructor(t, s, d, g, w) {
            this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = d, this.bucketIndex = g, this.tileID = w;
          }
        }
        class ou {
          constructor(t) {
            this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t]) {
              const s = ++this.maxGroupID;
              this.collisionGroups[t] = { ID: s, predicate: (d) => d.collisionGroupID === s };
            }
            return this.collisionGroups[t];
          }
        }
        function Fs(b, t, s, d, g) {
          const { horizontalAlign: w, verticalAlign: T } = u.aS(b);
          return new u.P(-(w - 0.5) * t + d[0] * g, -(T - 0.5) * s + d[1] * g);
        }
        class lu {
          constructor(t, s, d, g, w) {
            this.transform = t.clone(), this.terrain = s, this.collisionIndex = new su(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = d, this.retainedQueryData = {}, this.collisionGroups = new ou(g), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(t) {
            const s = this.terrain;
            return s ? (d, g) => s.getElevation(t, d, g) : null;
          }
          getBucketParts(t, s, d, g) {
            const w = d.getBucket(s), T = d.latestFeatureIndex;
            if (!w || !T || s.id !== w.layerIds[0]) return;
            const C = d.collisionBoxArray, A = w.layers[0].layout, F = w.layers[0].paint, O = Math.pow(2, this.transform.zoom - d.tileID.overscaledZ), q = d.tileSize / u.a5, V = d.tileID.toUnwrapped(), X = A.get("text-rotation-alignment") === "map", te = u.aN(d, 1, this.transform.zoom), he = u.aO(this.collisionIndex.transform, d, F.get("text-translate"), F.get("text-translate-anchor")), pe = u.aO(this.collisionIndex.transform, d, F.get("icon-translate"), F.get("icon-translate-anchor")), fe = mn(X, this.transform, te);
            this.retainedQueryData[w.bucketInstanceId] = new Rs(w.bucketInstanceId, T, w.sourceLayerIndex, w.index, d.tileID);
            const be = { bucket: w, layout: A, translationText: he, translationIcon: pe, unwrappedTileID: V, pitchedLabelPlaneMatrix: fe, scale: O, textPixelRatio: q, holdingForFade: d.holdingForSymbolFade(), collisionBoxArray: C, partiallyEvaluatedTextSize: u.ay(w.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(w.sourceID) };
            if (g) for (const Ae of w.sortKeyRanges) {
              const { sortKey: xe, symbolInstanceStart: Ce, symbolInstanceEnd: Oe } = Ae;
              t.push({ sortKey: xe, symbolInstanceStart: Ce, symbolInstanceEnd: Oe, parameters: be });
            }
            else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: w.symbolInstances.length, parameters: be });
          }
          attemptAnchorPlacement(t, s, d, g, w, T, C, A, F, O, q, V, X, te, he, pe, fe, be, Ae, xe) {
            const Ce = u.aP[t.textAnchor], Oe = [t.textOffset0, t.textOffset1], ke = Fs(Ce, d, g, Oe, w), je = this.collisionIndex.placeCollisionBox(s, V, A, F, O, C, T, pe, q.predicate, Ae, ke, xe);
            if ((!be || this.collisionIndex.placeCollisionBox(be, V, A, F, O, C, T, fe, q.predicate, Ae, ke, xe).placeable) && je.placeable) {
              let at;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[X.crossTileID] && this.prevPlacement.placements[X.crossTileID] && this.prevPlacement.placements[X.crossTileID].text && (at = this.prevPlacement.variableOffsets[X.crossTileID].anchor), X.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[X.crossTileID] = { textOffset: Oe, width: d, height: g, anchor: Ce, textBoxScale: w, prevAnchor: at }, this.markUsedJustification(te, Ce, X, he), te.allowVerticalPlacement && (this.markUsedOrientation(te, he, X), this.placedOrientations[X.crossTileID] = he), { shift: ke, placedGlyphBoxes: je };
            }
          }
          placeLayerBucketPart(t, s, d) {
            const { bucket: g, layout: w, translationText: T, translationIcon: C, unwrappedTileID: A, pitchedLabelPlaneMatrix: F, textPixelRatio: O, holdingForFade: q, collisionBoxArray: V, partiallyEvaluatedTextSize: X, collisionGroup: te } = t.parameters, he = w.get("text-optional"), pe = w.get("icon-optional"), fe = u.aQ(w, "text-overlap", "text-allow-overlap"), be = fe === "always", Ae = u.aQ(w, "icon-overlap", "icon-allow-overlap"), xe = Ae === "always", Ce = w.get("text-rotation-alignment") === "map", Oe = w.get("text-pitch-alignment") === "map", ke = w.get("icon-text-fit") !== "none", je = w.get("symbol-z-order") === "viewport-y", at = be && (xe || !g.hasIconData() || pe), tt = xe && (be || !g.hasTextData() || he);
            !g.collisionArrays && V && g.deserializeCollisionBoxes(V);
            const nt = this.retainedQueryData[g.bucketInstanceId].tileID, it = this._getTerrainElevationFunc(nt), St = this.transform.getFastPathSimpleProjectionMatrix(nt), It = (_t, Lt, or) => {
              var Or, an;
              if (s[_t.crossTileID]) return;
              if (q) return void (this.placements[_t.crossTileID] = new bs(!1, !1, !1));
              let $r = !1, hn = !1, Zr = !0, Sn = null, dn = { box: null, placeable: !1, offscreen: null, occluded: !1 }, hi = { placeable: !1 }, Fn = null, An = null, Ei = null, ho = 0, Da = 0, oa = 0;
              Lt.textFeatureIndex ? ho = Lt.textFeatureIndex : _t.useRuntimeCollisionCircles && (ho = _t.featureIndex), Lt.verticalTextFeatureIndex && (Da = Lt.verticalTextFeatureIndex);
              const Ki = Lt.textBox;
              if (Ki) {
                const ks = (Jr) => {
                  let Hr = u.az.horizontal;
                  if (g.allowVerticalPlacement && !Jr && this.prevPlacement) {
                    const Qn = this.prevPlacement.placedOrientations[_t.crossTileID];
                    Qn && (this.placedOrientations[_t.crossTileID] = Qn, Hr = Qn, this.markUsedOrientation(g, Hr, _t));
                  }
                  return Hr;
                }, la = (Jr, Hr) => {
                  if (g.allowVerticalPlacement && _t.numVerticalGlyphVertices > 0 && Lt.verticalTextBox) {
                    for (const Qn of g.writingModes) if (Qn === u.az.vertical ? (dn = Hr(), hi = dn) : dn = Jr(), dn && dn.placeable) break;
                  } else dn = Jr();
                }, Us = _t.textAnchorOffsetStartIndex, qs = _t.textAnchorOffsetEndIndex;
                if (qs === Us) {
                  const Jr = (Hr, Qn) => {
                    const ei = this.collisionIndex.placeCollisionBox(Hr, fe, O, nt, A, Oe, Ce, T, te.predicate, it, void 0, St);
                    return ei && ei.placeable && (this.markUsedOrientation(g, Qn, _t), this.placedOrientations[_t.crossTileID] = Qn), ei;
                  };
                  la((() => Jr(Ki, u.az.horizontal)), (() => {
                    const Hr = Lt.verticalTextBox;
                    return g.allowVerticalPlacement && _t.numVerticalGlyphVertices > 0 && Hr ? Jr(Hr, u.az.vertical) : { box: null, offscreen: null };
                  })), ks(dn && dn.placeable);
                } else {
                  let Jr = u.aP[(an = (Or = this.prevPlacement) === null || Or === void 0 ? void 0 : Or.variableOffsets[_t.crossTileID]) === null || an === void 0 ? void 0 : an.anchor];
                  const Hr = (ei, _p, yp) => {
                    const Jo = ei.x2 - ei.x1, mm = ei.y2 - ei.y1, vp = _t.textBoxScale, kd = ke && Ae === "never" ? _p : null;
                    let fo = null, po = fe === "never" ? 1 : 2, go = "never";
                    Jr && po++;
                    for (let Id = 0; Id < po; Id++) {
                      for (let Md = Us; Md < qs; Md++) {
                        const th = g.textAnchorOffsets.get(Md);
                        if (Jr && th.textAnchor !== Jr) continue;
                        const rh = this.attemptAnchorPlacement(th, ei, Jo, mm, vp, Ce, Oe, O, nt, A, te, go, _t, g, yp, T, C, kd, it);
                        if (rh && (fo = rh.placedGlyphBoxes, fo && fo.placeable)) return $r = !0, Sn = rh.shift, fo;
                      }
                      Jr ? Jr = null : go = fe;
                    }
                    return d && !fo && (fo = { box: this.collisionIndex.placeCollisionBox(Ki, "always", O, nt, A, Oe, Ce, T, te.predicate, it, void 0, St).box, offscreen: !1, placeable: !1, occluded: !1 }), fo;
                  };
                  la((() => Hr(Ki, Lt.iconBox, u.az.horizontal)), (() => {
                    const ei = Lt.verticalTextBox;
                    return g.allowVerticalPlacement && (!dn || !dn.placeable) && _t.numVerticalGlyphVertices > 0 && ei ? Hr(ei, Lt.verticalIconBox, u.az.vertical) : { box: null, occluded: !0, offscreen: null };
                  })), dn && ($r = dn.placeable, Zr = dn.offscreen);
                  const Qn = ks(dn && dn.placeable);
                  if (!$r && this.prevPlacement) {
                    const ei = this.prevPlacement.variableOffsets[_t.crossTileID];
                    ei && (this.variableOffsets[_t.crossTileID] = ei, this.markUsedJustification(g, ei.anchor, _t, Qn));
                  }
                }
              }
              if (Fn = dn, $r = Fn && Fn.placeable, Zr = Fn && Fn.offscreen, _t.useRuntimeCollisionCircles && _t.centerJustifiedTextSymbolIndex >= 0) {
                const ks = g.text.placedSymbolArray.get(_t.centerJustifiedTextSymbolIndex), la = u.aA(g.textSizeData, X, ks), Us = w.get("text-padding");
                An = this.collisionIndex.placeCollisionCircles(fe, ks, g.lineVertexArray, g.glyphOffsetArray, la, A, F, d, Oe, te.predicate, _t.collisionCircleDiameter, Us, T, it), An.circles.length && An.collisionDetected && !d && u.w("Collisions detected, but collision boxes are not shown"), $r = be || An.circles.length > 0 && !An.collisionDetected, Zr = Zr && An.offscreen;
              }
              if (Lt.iconFeatureIndex && (oa = Lt.iconFeatureIndex), Lt.iconBox) {
                const ks = (la) => this.collisionIndex.placeCollisionBox(la, Ae, O, nt, A, Oe, Ce, C, te.predicate, it, ke && Sn ? Sn : void 0, St);
                hi && hi.placeable && Lt.verticalIconBox ? (Ei = ks(Lt.verticalIconBox), hn = Ei.placeable) : (Ei = ks(Lt.iconBox), hn = Ei.placeable), Zr = Zr && Ei.offscreen;
              }
              const Wo = he || _t.numHorizontalGlyphVertices === 0 && _t.numVerticalGlyphVertices === 0, Yu = pe || _t.numIconVertices === 0;
              Wo || Yu ? Yu ? Wo || (hn = hn && $r) : $r = hn && $r : hn = $r = hn && $r;
              const Xo = hn && Ei.placeable;
              if ($r && Fn.placeable && this.collisionIndex.insertCollisionBox(Fn.box, fe, w.get("text-ignore-placement"), g.bucketInstanceId, hi && hi.placeable && Da ? Da : ho, te.ID), Xo && this.collisionIndex.insertCollisionBox(Ei.box, Ae, w.get("icon-ignore-placement"), g.bucketInstanceId, oa, te.ID), An && $r && this.collisionIndex.insertCollisionCircles(An.circles, fe, w.get("text-ignore-placement"), g.bucketInstanceId, ho, te.ID), d && this.storeCollisionData(g.bucketInstanceId, or, Lt, Fn, Ei, An), _t.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (g.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[_t.crossTileID] = new bs(($r || at) && !Fn?.occluded, (hn || tt) && !Ei?.occluded, Zr || g.justReloaded), s[_t.crossTileID] = !0;
            };
            if (je) {
              if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const _t = g.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Lt = _t.length - 1; Lt >= 0; --Lt) {
                const or = _t[Lt];
                It(g.symbolInstances.get(or), g.collisionArrays[or], or);
              }
            } else for (let _t = t.symbolInstanceStart; _t < t.symbolInstanceEnd; _t++) It(g.symbolInstances.get(_t), g.collisionArrays[_t], _t);
            g.justReloaded = !1;
          }
          storeCollisionData(t, s, d, g, w, T) {
            if (d.textBox || d.iconBox) {
              let C, A;
              this.collisionBoxArrays.has(t) ? C = this.collisionBoxArrays.get(t) : (C = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t, C)), C.has(s) ? A = C.get(s) : (A = { text: null, icon: null }, C.set(s, A)), d.textBox && (A.text = g.box), d.iconBox && (A.icon = w.box);
            }
            if (T) {
              let C = this.collisionCircleArrays[t];
              C === void 0 && (C = this.collisionCircleArrays[t] = []);
              for (let A = 0; A < T.circles.length; A += 4) C.push(T.circles[A + 0] - cn), C.push(T.circles[A + 1] - cn), C.push(T.circles[A + 2]), C.push(T.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(t, s, d, g) {
            let w;
            w = g === u.az.vertical ? d.verticalPlacedTextSymbolIndex : { left: d.leftJustifiedTextSymbolIndex, center: d.centerJustifiedTextSymbolIndex, right: d.rightJustifiedTextSymbolIndex }[u.aR(s)];
            const T = [d.leftJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.rightJustifiedTextSymbolIndex, d.verticalPlacedTextSymbolIndex];
            for (const C of T) C >= 0 && (t.text.placedSymbolArray.get(C).crossTileID = w >= 0 && C !== w ? 0 : d.crossTileID);
          }
          markUsedOrientation(t, s, d) {
            const g = s === u.az.horizontal || s === u.az.horizontalOnly ? s : 0, w = s === u.az.vertical ? s : 0, T = [d.leftJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.rightJustifiedTextSymbolIndex];
            for (const C of T) t.text.placedSymbolArray.get(C).placedOrientation = g;
            d.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(d.verticalPlacedTextSymbolIndex).placedOrientation = w);
          }
          commit(t) {
            this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const s = this.prevPlacement;
            let d = !1;
            this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
            const g = s ? s.symbolFadeChange(t) : 1, w = s ? s.opacities : {}, T = s ? s.variableOffsets : {}, C = s ? s.placedOrientations : {};
            for (const A in this.placements) {
              const F = this.placements[A], O = w[A];
              O ? (this.opacities[A] = new ea(O, g, F.text, F.icon), d = d || F.text !== O.text.placed || F.icon !== O.icon.placed) : (this.opacities[A] = new ea(null, g, F.text, F.icon, F.skipFade), d = d || F.text || F.icon);
            }
            for (const A in w) {
              const F = w[A];
              if (!this.opacities[A]) {
                const O = new ea(F, g, !1, !1);
                O.isHidden() || (this.opacities[A] = O, d = d || F.text.placed || F.icon.placed);
              }
            }
            for (const A in T) this.variableOffsets[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.variableOffsets[A] = T[A]);
            for (const A in C) this.placedOrientations[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.placedOrientations[A] = C[A]);
            if (s && s.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            d ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t);
          }
          updateLayerOpacities(t, s) {
            const d = {};
            for (const g of s) {
              const w = g.getBucket(t);
              w && g.latestFeatureIndex && t.id === w.layerIds[0] && this.updateBucketOpacities(w, g.tileID, d, g.collisionBoxArray);
            }
          }
          updateBucketOpacities(t, s, d, g) {
            t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = !1), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = !1), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
            const w = t.layers[0], T = w.layout, C = new ea(null, 0, !1, !1, !0), A = T.get("text-allow-overlap"), F = T.get("icon-allow-overlap"), O = w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset"), q = T.get("text-rotation-alignment") === "map", V = T.get("text-pitch-alignment") === "map", X = T.get("icon-text-fit") !== "none", te = new ea(null, 0, A && (F || !t.hasIconData() || T.get("icon-optional")), F && (A || !t.hasTextData() || T.get("text-optional")), !0);
            !t.collisionArrays && g && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(g);
            const he = (fe, be, Ae) => {
              for (let xe = 0; xe < be / 4; xe++) fe.opacityVertexArray.emplaceBack(Ae);
              fe.hasVisibleVertices = fe.hasVisibleVertices || Ae !== Ea;
            }, pe = this.collisionBoxArrays.get(t.bucketInstanceId);
            for (let fe = 0; fe < t.symbolInstances.length; fe++) {
              const be = t.symbolInstances.get(fe), { numHorizontalGlyphVertices: Ae, numVerticalGlyphVertices: xe, crossTileID: Ce } = be;
              let Oe = this.opacities[Ce];
              d[Ce] ? Oe = C : Oe || (Oe = te, this.opacities[Ce] = Oe), d[Ce] = !0;
              const ke = be.numIconVertices > 0, je = this.placedOrientations[be.crossTileID], at = je === u.az.vertical, tt = je === u.az.horizontal || je === u.az.horizontalOnly;
              if (Ae > 0 || xe > 0) {
                const it = du(Oe.text);
                he(t.text, Ae, at ? Ea : it), he(t.text, xe, tt ? Ea : it);
                const St = Oe.text.isHidden();
                [be.rightJustifiedTextSymbolIndex, be.centerJustifiedTextSymbolIndex, be.leftJustifiedTextSymbolIndex].forEach(((Lt) => {
                  Lt >= 0 && (t.text.placedSymbolArray.get(Lt).hidden = St || at ? 1 : 0);
                })), be.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(be.verticalPlacedTextSymbolIndex).hidden = St || tt ? 1 : 0);
                const It = this.variableOffsets[be.crossTileID];
                It && this.markUsedJustification(t, It.anchor, be, je);
                const _t = this.placedOrientations[be.crossTileID];
                _t && (this.markUsedJustification(t, "left", be, _t), this.markUsedOrientation(t, _t, be));
              }
              if (ke) {
                const it = du(Oe.icon), St = !(X && be.verticalPlacedIconSymbolIndex && at);
                be.placedIconSymbolIndex >= 0 && (he(t.icon, be.numIconVertices, St ? it : Ea), t.icon.placedSymbolArray.get(be.placedIconSymbolIndex).hidden = Oe.icon.isHidden()), be.verticalPlacedIconSymbolIndex >= 0 && (he(t.icon, be.numVerticalIconVertices, St ? Ea : it), t.icon.placedSymbolArray.get(be.verticalPlacedIconSymbolIndex).hidden = Oe.icon.isHidden());
              }
              const nt = pe && pe.has(fe) ? pe.get(fe) : { text: null, icon: null };
              if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                const it = t.collisionArrays[fe];
                if (it) {
                  let St = new u.P(0, 0);
                  if (it.textBox || it.verticalTextBox) {
                    let It = !0;
                    if (O) {
                      const _t = this.variableOffsets[Ce];
                      _t ? (St = Fs(_t.anchor, _t.width, _t.height, _t.textOffset, _t.textBoxScale), q && St._rotate(V ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : It = !1;
                    }
                    if (it.textBox || it.verticalTextBox) {
                      let _t;
                      it.textBox && (_t = at), it.verticalTextBox && (_t = tt), uu(t.textCollisionBox.collisionVertexArray, Oe.text.placed, !It || _t, nt.text, St.x, St.y);
                    }
                  }
                  if (it.iconBox || it.verticalIconBox) {
                    const It = !!(!tt && it.verticalIconBox);
                    let _t;
                    it.iconBox && (_t = It), it.verticalIconBox && (_t = !It), uu(t.iconCollisionBox.collisionVertexArray, Oe.icon.placed, _t, nt.icon, X ? St.x : 0, X ? St.y : 0);
                  }
                }
              }
            }
            if (t.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`);
            if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`);
            t.bucketInstanceId in this.collisionCircleArrays && (t.collisionCircleArray = this.collisionCircleArrays[t.bucketInstanceId], delete this.collisionCircleArrays[t.bucketInstanceId]);
          }
          symbolFadeChange(t) {
            return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t) {
            return Math.max(0, (this.transform.zoom - t) / 1.5);
          }
          hasTransitions(t) {
            return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t, s) {
            const d = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
            return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * d > t;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function uu(b, t, s, d, g, w) {
          d && d.length !== 0 || (d = [0, 0, 0, 0]);
          const T = d[0] - cn, C = d[1] - cn, A = d[2] - cn, F = d[3] - cn;
          b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, T, C), b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, A, C), b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, A, F), b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, T, F);
        }
        const cu = Math.pow(2, 25), hu = Math.pow(2, 24), wc = Math.pow(2, 17), Ns = Math.pow(2, 16), Ao = Math.pow(2, 9), Ec = Math.pow(2, 8), wa = Math.pow(2, 1);
        function du(b) {
          if (b.opacity === 0 && !b.placed) return 0;
          if (b.opacity === 1 && b.placed) return 4294967295;
          const t = b.placed ? 1 : 0, s = Math.floor(127 * b.opacity);
          return s * cu + t * hu + s * wc + t * Ns + s * Ao + t * Ec + s * wa + t;
        }
        const Ea = 0;
        class Pr {
          constructor(t) {
            this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t, s, d, g, w) {
            const T = this._bucketParts;
            for (; this._currentTileIndex < t.length; ) if (s.getBucketParts(T, g, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, w()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, T.sort(((C, A) => C.sortKey - A.sortKey))); this._currentPartIndex < T.length; ) if (s.placeLayerBucketPart(T[this._currentPartIndex], this._seenCrossTileIDs, d), this._currentPartIndex++, w()) return !0;
            return !1;
          }
        }
        class Wi {
          constructor(t, s, d, g, w, T, C, A) {
            this.placement = new lu(t, s, T, C, A), this._currentPlacementIndex = d.length - 1, this._forceFullPlacement = g, this._showCollisionBoxes = w, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t, s, d) {
            const g = _e(), w = () => !this._forceFullPlacement && _e() - g > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const T = s[t[this._currentPlacementIndex]], C = this.placement.collisionIndex.transform.zoom;
              if (T.type === "symbol" && (!T.minzoom || T.minzoom <= C) && (!T.maxzoom || T.maxzoom > C)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Pr(T)), this._inProgressLayer.continuePlacement(d[T.source], this.placement, this._showCollisionBoxes, T, w)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(t) {
            return this.placement.commit(t), this.placement;
          }
        }
        const cr = 512 / u.a5 / 2;
        class Lo {
          constructor(t, s, d) {
            this.tileID = t, this.bucketInstanceId = d, this._symbolsByKey = {};
            const g = /* @__PURE__ */ new Map();
            for (let w = 0; w < s.length; w++) {
              const T = s.get(w), C = T.key, A = g.get(C);
              A ? A.push(T) : g.set(C, [T]);
            }
            for (const [w, T] of g) {
              const C = { positions: T.map(((A) => ({ x: Math.floor(A.anchorX * cr), y: Math.floor(A.anchorY * cr) }))), crossTileIDs: T.map(((A) => A.crossTileID)) };
              if (C.positions.length > 128) {
                const A = new u.aT(C.positions.length, 16, Uint16Array);
                for (const { x: F, y: O } of C.positions) A.add(F, O);
                A.finish(), delete C.positions, C.index = A;
              }
              this._symbolsByKey[w] = C;
            }
          }
          getScaledCoordinates(t, s) {
            const { x: d, y: g, z: w } = this.tileID.canonical, { x: T, y: C, z: A } = s.canonical, F = cr / Math.pow(2, A - w), O = (C * u.a5 + t.anchorY) * F, q = g * u.a5 * cr;
            return { x: Math.floor((T * u.a5 + t.anchorX) * F - d * u.a5 * cr), y: Math.floor(O - q) };
          }
          findMatches(t, s, d) {
            const g = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z);
            for (let w = 0; w < t.length; w++) {
              const T = t.get(w);
              if (T.crossTileID) continue;
              const C = this._symbolsByKey[T.key];
              if (!C) continue;
              const A = this.getScaledCoordinates(T, s);
              if (C.index) {
                const F = C.index.range(A.x - g, A.y - g, A.x + g, A.y + g).sort();
                for (const O of F) {
                  const q = C.crossTileIDs[O];
                  if (!d[q]) {
                    d[q] = !0, T.crossTileID = q;
                    break;
                  }
                }
              } else if (C.positions) for (let F = 0; F < C.positions.length; F++) {
                const O = C.positions[F], q = C.crossTileIDs[F];
                if (Math.abs(O.x - A.x) <= g && Math.abs(O.y - A.y) <= g && !d[q]) {
                  d[q] = !0, T.crossTileID = q;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: t }) => t));
          }
        }
        class Xi {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class ki {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t) {
            const s = Math.round((t - this.lng) / 360);
            if (s !== 0) for (const d in this.indexes) {
              const g = this.indexes[d], w = {};
              for (const T in g) {
                const C = g[T];
                C.tileID = C.tileID.unwrapTo(C.tileID.wrap + s), w[C.tileID.key] = C;
              }
              this.indexes[d] = w;
            }
            this.lng = t;
          }
          addBucket(t, s, d) {
            if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
              if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
            }
            for (let w = 0; w < s.symbolInstances.length; w++) s.symbolInstances.get(w).crossTileID = 0;
            this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
            const g = this.usedCrossTileIDs[t.overscaledZ];
            for (const w in this.indexes) {
              const T = this.indexes[w];
              if (Number(w) > t.overscaledZ) for (const C in T) {
                const A = T[C];
                A.tileID.isChildOf(t) && A.findMatches(s.symbolInstances, t, g);
              }
              else {
                const C = T[t.scaledTo(Number(w)).key];
                C && C.findMatches(s.symbolInstances, t, g);
              }
            }
            for (let w = 0; w < s.symbolInstances.length; w++) {
              const T = s.symbolInstances.get(w);
              T.crossTileID || (T.crossTileID = d.generate(), g[T.crossTileID] = !0);
            }
            return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Lo(t, s.symbolInstances, s.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(t, s) {
            for (const d of s.getCrossTileIDsLists()) for (const g of d) delete this.usedCrossTileIDs[t][g];
          }
          removeStaleBuckets(t) {
            let s = !1;
            for (const d in this.indexes) {
              const g = this.indexes[d];
              for (const w in g) t[g[w].bucketInstanceId] || (this.removeBucketCrossTileIDs(d, g[w]), delete g[w], s = !0);
            }
            return s;
          }
        }
        class Xn {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Xi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t, s, d) {
            let g = this.layerIndexes[t.id];
            g === void 0 && (g = this.layerIndexes[t.id] = new ki());
            let w = !1;
            const T = {};
            g.handleWrapJump(d);
            for (const C of s) {
              const A = C.getBucket(t);
              A && t.id === A.layerIds[0] && (A.bucketInstanceId || (A.bucketInstanceId = ++this.maxBucketInstanceId), g.addBucket(C.tileID, A, this.crossTileIDs) && (w = !0), T[A.bucketInstanceId] = !0);
            }
            return g.removeStaleBuckets(T) && (w = !0), w;
          }
          pruneUnusedLayers(t) {
            const s = {};
            t.forEach(((d) => {
              s[d] = !0;
            }));
            for (const d in this.layerIndexes) s[d] || delete this.layerIndexes[d];
          }
        }
        var ai = "void main() {fragColor=vec4(1.0);}";
        const tn = { prelude: Kt(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Kt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Kt("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Kt(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Kt(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Kt(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Kt(ai, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Kt(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Kt(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Kt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Kt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Kt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Kt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Kt(ai, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Kt(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Kt(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Kt(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Kt(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Kt(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Kt(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Kt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Kt(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Kt(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Kt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Kt(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Kt(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Kt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Kt(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Kt(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Kt(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Kt(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Kt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Kt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Kt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Kt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Kt(`#ifdef GL_ES
precision highp float;
#endif
in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Kt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Kt(b, t) {
          const s = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = t.match(/in ([\w]+) ([\w]+)/g), g = b.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), T = w ? w.concat(g) : g, C = {};
          return { fragmentSource: b = b.replace(s, ((A, F, O, q, V) => (C[V] = !0, F === "define" ? `
#ifndef HAS_UNIFORM_u_${V}
in ${O} ${q} ${V};
#else
uniform ${O} ${q} u_${V};
#endif
` : `
#ifdef HAS_UNIFORM_u_${V}
    ${O} ${q} ${V} = u_${V};
#endif
`))), vertexSource: t = t.replace(s, ((A, F, O, q, V) => {
            const X = q === "float" ? "vec2" : "vec4", te = V.match(/color/) ? "color" : X;
            return C[V] ? F === "define" ? `
#ifndef HAS_UNIFORM_u_${V}
uniform lowp float u_${V}_t;
in ${O} ${X} a_${V};
out ${O} ${q} ${V};
#else
uniform ${O} ${q} u_${V};
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_${V}
    ${V} = a_${V};
#else
    ${O} ${q} ${V} = u_${V};
#endif
` : `
#ifndef HAS_UNIFORM_u_${V}
    ${V} = unpack_mix_${te}(a_${V}, u_${V}_t);
#else
    ${O} ${q} ${V} = u_${V};
#endif
` : F === "define" ? `
#ifndef HAS_UNIFORM_u_${V}
uniform lowp float u_${V}_t;
in ${O} ${X} a_${V};
#else
uniform ${O} ${q} u_${V};
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_${V}
    ${O} ${q} ${V} = a_${V};
#else
    ${O} ${q} ${V} = u_${V};
#endif
` : `
#ifndef HAS_UNIFORM_u_${V}
    ${O} ${q} ${V} = unpack_mix_${te}(a_${V}, u_${V}_t);
#else
    ${O} ${q} ${V} = u_${V};
#endif
`;
          })), staticAttributes: d, staticUniforms: T };
        }
        class Ar {
          constructor(t, s, d) {
            this.vertexBuffer = t, this.indexBuffer = s, this.segments = d;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var ta = u.aU([{ name: "a_pos", type: "Int16", components: 2 }]);
        const oi = "#define PROJECTION_MERCATOR", hr = "mercator";
        class rn {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return hr;
          }
          get shaderDefine() {
            return oi;
          }
          get shaderPreludeCode() {
            return tn.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return tn.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return u.aV.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(t) {
          }
          getMeshFromTileID(t, s, d, g, w) {
            if (this._cachedMesh) return this._cachedMesh;
            const T = new u.aW();
            T.emplaceBack(0, 0), T.emplaceBack(u.a5, 0), T.emplaceBack(0, u.a5), T.emplaceBack(u.a5, u.a5);
            const C = t.createVertexBuffer(T, ta.members), A = u.aX.simpleSegment(0, 0, 4, 2), F = new u.aY();
            F.emplaceBack(1, 0, 2), F.emplaceBack(1, 2, 3);
            const O = t.createIndexBuffer(F);
            return this._cachedMesh = new Ar(C, O, A), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(t) {
          }
        }
        class ra {
          constructor(t = 0, s = 0, d = 0, g = 0) {
            if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(d) || d < 0 || isNaN(g) || g < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t, this.bottom = s, this.left = d, this.right = g;
          }
          interpolate(t, s, d) {
            return s.top != null && t.top != null && (this.top = u.G.number(t.top, s.top, d)), s.bottom != null && t.bottom != null && (this.bottom = u.G.number(t.bottom, s.bottom, d)), s.left != null && t.left != null && (this.left = u.G.number(t.left, s.left, d)), s.right != null && t.right != null && (this.right = u.G.number(t.right, s.right, d)), this;
          }
          getCenter(t, s) {
            const d = u.an((this.left + t - this.right) / 2, 0, t), g = u.an((this.top + s - this.bottom) / 2, 0, s);
            return new u.P(d, g);
          }
          equals(t) {
            return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
          }
          clone() {
            return new ra(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Os(b, t) {
          if (!b.renderWorldCopies || b.lngRange) return;
          const s = t.lng - b.center.lng;
          t.lng += s > 180 ? -360 : s < -180 ? 360 : 0;
        }
        function qr(b) {
          return Math.max(0, Math.floor(b));
        }
        class na {
          constructor(t, s) {
            var d;
            this.applyConstrain = (g, w) => this._constrainOverride !== null ? this._constrainOverride(g, w) : this._callbacks.defaultConstrain(g, w), this._callbacks = t, this._tileSize = 512, this._renderWorldCopies = s?.renderWorldCopies === void 0 || !!s?.renderWorldCopies, this._minZoom = s?.minZoom || 0, this._maxZoom = s?.maxZoom || 22, this._minPitch = s?.minPitch == null ? 0 : s?.minPitch, this._maxPitch = s?.maxPitch == null ? 60 : s?.maxPitch, this._constrainOverride = (d = s?.constrainOverride) !== null && d !== void 0 ? d : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new u.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = qr(this._zoom), this._scale = u.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new ra(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(t, s, d) {
            this._constrainOverride = t.constrainOverride, this._latRange = t.latRange, this._lngRange = t.lngRange, this._width = t.width, this._height = t.height, this._center = t.center, this._elevation = t.elevation, this._minElevationForCurrentTile = t.minElevationForCurrentTile, this._zoom = t.zoom, this._tileZoom = qr(this._zoom), this._scale = u.aq(this._zoom), this._bearingInRadians = t.bearingInRadians, this._fovInRadians = t.fovInRadians, this._pitchInRadians = t.pitchInRadians, this._rollInRadians = t.rollInRadians, this._unmodified = t.unmodified, this._edgeInsets = new ra(t.padding.top, t.padding.bottom, t.padding.left, t.padding.right), this._minZoom = t.minZoom, this._maxZoom = t.maxZoom, this._minPitch = t.minPitch, this._maxPitch = t.maxPitch, this._renderWorldCopies = t.renderWorldCopies, this._cameraToCenterDistance = t.cameraToCenterDistance, this._nearZ = t.nearZ, this._farZ = t.farZ, this._autoCalculateNearFarZ = !d && t.autoCalculateNearFarZ, s && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(t) {
            this._minElevationForCurrentTile = t;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(t) {
            this._minZoom !== t && (this._minZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(t) {
            this._maxZoom !== t && (this._maxZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(t) {
            this._minPitch !== t && (this._minPitch = t, this.setPitch(Math.max(this.pitch, t)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(t) {
            this._maxPitch !== t && (this._maxPitch = t, this.setPitch(Math.min(this.pitch, t)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(t) {
            t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
          }
          get constrainOverride() {
            return this._constrainOverride;
          }
          setConstrainOverride(t) {
            t === void 0 && (t = null), this._constrainOverride !== t && (this._constrainOverride = t, this.constrainInternal(), this._calcMatrices());
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new u.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(t) {
            const s = u.W(t, -180, 180) * Math.PI / 180;
            var d, g, w, T, C, A, F, O, q;
            this._bearingInRadians !== s && (this._unmodified = !1, this._bearingInRadians = s, this._calcMatrices(), this._rotationMatrix = z(), d = this._rotationMatrix, w = -this._bearingInRadians, T = (g = this._rotationMatrix)[0], C = g[1], A = g[2], F = g[3], O = Math.sin(w), q = Math.cos(w), d[0] = T * q + A * O, d[1] = C * q + F * O, d[2] = T * -O + A * q, d[3] = C * -O + F * q);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(t) {
            const s = u.an(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== s && (this._unmodified = !1, this._pitchInRadians = s, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(t) {
            const s = t / 180 * Math.PI;
            this._rollInRadians !== s && (this._unmodified = !1, this._rollInRadians = s, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return u.aZ(this._fovInRadians);
          }
          setFov(t) {
            t = u.an(t, 0.1, 150), this.fov !== t && (this._unmodified = !1, this._fovInRadians = u.ap(t), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(t) {
            const s = this.applyConstrain(this._center, t).zoom;
            this._zoom !== s && (this._unmodified = !1, this._zoom = s, this._tileZoom = Math.max(0, Math.floor(s)), this._scale = u.aq(s), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(t) {
            t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(t) {
            t !== this._elevation && (this._elevation = t, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(t) {
            this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(t, s) {
            this._autoCalculateNearFarZ = !1, this._nearZ = t, this._farZ = s, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(t) {
            return this._edgeInsets.equals(t);
          }
          interpolatePadding(t, s, d) {
            this._unmodified = !1, this._edgeInsets.interpolate(t, s, d), this.constrainInternal(), this._calcMatrices();
          }
          resize(t, s, d = !0) {
            this._width = t, this._height = s, d && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Dr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(t) {
            t ? (this._lngRange = [t.getWest(), t.getEast()], this._latRange = [t.getSouth(), t.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-u.ao, u.ao]);
          }
          getCameraQueryGeometry(t, s) {
            if (s.length === 1) return [s[0], t];
            {
              const { minX: d, minY: g, maxX: w, maxY: T } = u.aa.fromPoints(s).extend(t);
              return [new u.P(d, g), new u.P(w, g), new u.P(w, T), new u.P(d, T), new u.P(d, g)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const t = this._unmodified, { center: s, zoom: d } = this.applyConstrain(this.center, this.zoom);
            this.setCenter(s), this.setZoom(d), this._unmodified = t, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let t = u.ar(new Float64Array(16));
              u.Q(t, t, [this._width / 2, -this._height / 2, 1]), u.O(t, t, [1, -1, 0]), this._clipSpaceToPixelsMatrix = t, t = u.ar(new Float64Array(16)), u.Q(t, t, [1, -1, 1]), u.O(t, t, [-1, -1, 0]), u.Q(t, t, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = t, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            const w = d !== void 0 ? d : this.bearing, T = g = g !== void 0 ? g : this.pitch, { distanceToCenter: C, clampedElevation: A } = this._distanceToCenterFromAltElevationPitch(s, this.elevation, T), { x: F, y: O } = Qt(T, w), q = u.a9.fromLngLat(t, s);
            let V, X, te = u.a_(1, q.y), he = 0;
            do {
              if (he += 1, he > 10) break;
              X = C / te, V = new u.a9(q.x + F * X, q.y + O * X), te = 1 / V.meterInMercatorCoordinateUnits();
            } while (Math.abs(C - X * te) > 1e-12);
            return { center: V.toLngLat(), elevation: A, zoom: u.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / X / this.tileSize) };
          }
          recalculateZoomAndCenter(t) {
            if (this.elevation - t == 0) return;
            const s = 1 / this.worldSize, d = u.as(1, this.center.lat) * this.worldSize, g = u.a9.fromLngLat(this.center, this.elevation), w = g.x / s, T = g.y / s, C = g.z / s, A = this.pitch, F = this.bearing, { x: O, y: q, z: V } = Qt(A, F), X = this.cameraToCenterDistance, te = w + X * -O, he = T + X * -q, pe = C + X * V, { distanceToCenter: fe, clampedElevation: be } = this._distanceToCenterFromAltElevationPitch(pe / d, t, A), Ae = fe * d, xe = new u.a9((te + O * Ae) * s, (he + q * Ae) * s, 0).toLngLat(), Ce = u.as(1, xe.lat), Oe = u.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / fe / Ce / this.tileSize);
            this._elevation = be, this._center = xe, this.setZoom(Oe);
          }
          _distanceToCenterFromAltElevationPitch(t, s, d) {
            const g = -Math.cos(u.ap(d)), w = t - s;
            let T, C = s;
            return g * w >= 0 || Math.abs(g) < 0.1 ? (T = 1e4, C = t + T * g) : T = -w / g, { distanceToCenter: T, clampedElevation: C };
          }
          getCameraPoint() {
            const t = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new u.P(t * Math.sin(this.rollInRadians), t * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const t = u.as(1, this.center.lat) * this.worldSize;
            return Be(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / t).toLngLat();
          }
          getMercatorTileCoordinates(t) {
            if (!t) return [0, 0, 1, 1];
            const s = t.canonical.z >= 0 ? 1 << t.canonical.z : Math.pow(2, t.canonical.z);
            return [t.canonical.x / s, t.canonical.y / s, 1 / s / u.a5, 1 / s / u.a5];
          }
        }
        class nn {
          constructor(t, s) {
            this.min = t, this.max = s, this.center = u.a$([], u.b0([], this.min, this.max), 0.5);
          }
          quadrant(t) {
            const s = [t % 2 == 0, t < 2], d = u.b1(this.min), g = u.b1(this.max);
            for (let w = 0; w < s.length; w++) d[w] = s[w] ? this.min[w] : this.center[w], g[w] = s[w] ? this.center[w] : this.max[w];
            return g[2] = this.max[2], new nn(d, g);
          }
          distanceX(t) {
            return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
          }
          distanceY(t) {
            return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
          }
          intersectsFrustum(t) {
            let s = !0;
            for (let d = 0; d < t.planes.length; d++) {
              const g = this.intersectsPlane(t.planes[d]);
              if (g === 0) return 0;
              g === 1 && (s = !1);
            }
            return s ? 2 : t.aabb.min[0] > this.max[0] || t.aabb.min[1] > this.max[1] || t.aabb.min[2] > this.max[2] || t.aabb.max[0] < this.min[0] || t.aabb.max[1] < this.min[1] || t.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(t) {
            let s = t[3], d = t[3];
            for (let g = 0; g < 3; g++) t[g] > 0 ? (s += t[g] * this.min[g], d += t[g] * this.max[g]) : (d += t[g] * this.min[g], s += t[g] * this.max[g]);
            return s >= 0 ? 2 : d < 0 ? 0 : 1;
          }
        }
        class Do {
          distanceToTile2d(t, s, d, g) {
            const w = g.distanceX([t, s]), T = g.distanceY([t, s]);
            return Math.hypot(w, T);
          }
          getWrap(t, s, d) {
            return d;
          }
          getTileBoundingVolume(t, s, d, g) {
            var w, T;
            let C = 0, A = 0;
            if (g?.terrain) {
              const O = new u.a2(t.z, s, t.z, t.x, t.y), q = g.terrain.getMinMaxElevation(O);
              C = (w = q.minElevation) !== null && w !== void 0 ? w : Math.min(0, d), A = (T = q.maxElevation) !== null && T !== void 0 ? T : Math.max(0, d);
            }
            const F = 1 << t.z;
            return new nn([s + t.x / F, t.y / F, C], [s + (t.x + 1) / F, (t.y + 1) / F, A]);
          }
          allowVariableZoom(t, s) {
            const d = t.fov * (Math.abs(Math.cos(t.rollInRadians)) * t.height + Math.abs(Math.sin(t.rollInRadians)) * t.width) / t.height, g = u.an(78.5 - d / 2, 0, 60);
            return !!s.terrain || t.pitch > g;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class li {
          constructor(t, s, d) {
            this.points = t, this.planes = s, this.aabb = d;
          }
          static fromInvProjectionMatrix(t, s = 1, d = 0, g, w) {
            const T = w ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], C = Math.pow(2, d), A = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((V) => (function(X, te, he, pe) {
              const fe = u.aH([], X, te), be = 1 / fe[3] / he * pe;
              return u.b6(fe, fe, [be, be, 1 / fe[3], be]);
            })(V, t, s, C)));
            g && (function(V, X, te, he) {
              const pe = he ? 4 : 0, fe = he ? 0 : 4;
              let be = 0;
              const Ae = [], xe = [];
              for (let ke = 0; ke < 4; ke++) {
                const je = u.b2([], V[ke + fe], V[ke + pe]), at = u.b7(je);
                u.a$(je, je, 1 / at), Ae.push(at), xe.push(je);
              }
              for (let ke = 0; ke < 4; ke++) {
                const je = u.b8(V[ke + pe], xe[ke], te);
                be = je !== null && je >= 0 ? Math.max(be, je) : Math.max(be, Ae[ke]);
              }
              const Ce = (function(ke, je) {
                const at = u.b2([], ke[je[0]], ke[je[1]]), tt = u.b2([], ke[je[2]], ke[je[1]]), nt = [0, 0, 0, 0];
                return u.b3(nt, u.b4([], at, tt)), nt[3] = -u.b5(nt, ke[je[0]]), nt;
              })(V, X), Oe = (function(ke, je) {
                const at = u.b9(ke), tt = u.ba([], ke, 1 / at), nt = u.b2([], je, u.a$([], tt, u.b5(je, tt))), it = u.b9(nt);
                if (it > 0) {
                  const St = Math.sqrt(1 - tt[3] * tt[3]), It = u.a$([], tt, -tt[3]), _t = u.b0([], It, u.a$([], nt, St / it));
                  return u.bb(je, _t);
                }
                return null;
              })(te, Ce);
              if (Oe !== null) {
                const ke = Oe / u.b5(xe[0], Ce);
                be = Math.min(be, ke);
              }
              for (let ke = 0; ke < 4; ke++) {
                const je = Math.min(be, Ae[ke]);
                V[ke + fe] = [V[ke + pe][0] + xe[ke][0] * je, V[ke + pe][1] + xe[ke][1] * je, V[ke + pe][2] + xe[ke][2] * je, 1];
              }
            })(A, T[0], g, w);
            const F = T.map(((V) => {
              const X = u.b2([], A[V[0]], A[V[1]]), te = u.b2([], A[V[2]], A[V[1]]), he = u.b3([], u.b4([], X, te)), pe = -u.b5(he, A[V[1]]);
              return he.concat(pe);
            })), O = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], q = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const V of A) for (let X = 0; X < 3; X++) O[X] = Math.min(O[X], V[X]), q[X] = Math.max(q[X], V[X]);
            return new li(A, F, new nn(O, q));
          }
        }
        class ia {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, s, d) {
            return this._helper.interpolatePadding(t, s, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, s, d = !0) {
            this._helper.resize(t, s, d);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, s) {
            this._helper.overrideNearFarZ(t, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t, s) {
          }
          constructor(t) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (s, d) => {
              d = u.an(+d, this.minZoom, this.maxZoom);
              const g = { center: new u.V(s.lng, s.lat), zoom: d };
              let w = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && w === null) {
                const xe = 179.9999999999;
                w = [-xe, xe];
              }
              const T = this.tileSize * u.aq(g.zoom);
              let C = 0, A = T, F = 0, O = T, q = 0, V = 0;
              const { x: X, y: te } = this.size;
              if (this._helper._latRange) {
                const xe = this._helper._latRange;
                C = u.X(xe[1]) * T, A = u.X(xe[0]) * T, A - C < te && (q = te / (A - C));
              }
              w && (F = u.W(u.Y(w[0]) * T, 0, T), O = u.W(u.Y(w[1]) * T, 0, T), O < F && (O += T), O - F < X && (V = X / (O - F)));
              const { x: he, y: pe } = $e(T, s);
              let fe, be;
              const Ae = Math.max(V || 0, q || 0);
              if (Ae) {
                const xe = new u.P(V ? (O + F) / 2 : he, q ? (A + C) / 2 : pe);
                return g.center = gt(T, xe).wrap(), g.zoom += u.at(Ae), g;
              }
              if (this._helper._latRange) {
                const xe = te / 2;
                pe - xe < C && (be = C + xe), pe + xe > A && (be = A - xe);
              }
              if (w) {
                const xe = (F + O) / 2;
                let Ce = he;
                this._helper._renderWorldCopies && (Ce = u.W(he, xe - T / 2, xe + T / 2));
                const Oe = X / 2;
                Ce - Oe < F && (fe = F + Oe), Ce + Oe > O && (fe = O - Oe);
              }
              if (fe !== void 0 || be !== void 0) {
                const xe = new u.P(fe ?? he, be ?? pe);
                g.center = gt(T, xe).wrap();
              }
              return g;
            }, this.applyConstrain = (s, d) => this._helper.applyConstrain(s, d), this._helper = new na({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (s, d) => this.defaultConstrain(s, d) }, t), this._coveringTilesDetailsProvider = new Do();
          }
          clone() {
            const t = new ia();
            return t.apply(this, !1), t;
          }
          apply(t, s, d) {
            this._helper.apply(t, s, d);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(t) {
            const s = [new u.bc(0, t)];
            if (this._helper._renderWorldCopies) {
              const d = this.screenPointToMercatorCoordinate(new u.P(0, 0)), g = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, 0)), w = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, this._helper._height)), T = this.screenPointToMercatorCoordinate(new u.P(0, this._helper._height)), C = Math.floor(Math.min(d.x, g.x, w.x, T.x)), A = Math.floor(Math.max(d.x, g.x, w.x, T.x)), F = 1;
              for (let O = C - F; O <= A + F; O++) O !== 0 && s.push(new u.bc(O, t));
            }
            return s;
          }
          getCameraFrustum() {
            return li.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            const s = this.screenPointToLocation(this.centerPoint, t), d = t ? t.getElevationForLngLatZoom(s, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(d);
          }
          setLocationAtPoint(t, s) {
            const d = u.as(this.elevation, this.center.lat), g = this.screenPointToMercatorCoordinateAtZ(s, d), w = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, d), T = u.a9.fromLngLat(t), C = new u.a9(T.x - (g.x - w.x), T.y - (g.y - w.y));
            this.setCenter(C?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(t, s) {
            return s ? this.coordinatePoint(u.a9.fromLngLat(t), s.getElevationForLngLat(t, this), this._pixelMatrix3D) : this.coordinatePoint(u.a9.fromLngLat(t));
          }
          screenPointToLocation(t, s) {
            var d;
            return (d = this.screenPointToMercatorCoordinate(t, s)) === null || d === void 0 ? void 0 : d.toLngLat();
          }
          screenPointToMercatorCoordinate(t, s) {
            if (s) {
              const d = s.pointCoordinate(t);
              if (d != null) return d;
            }
            return this.screenPointToMercatorCoordinateAtZ(t);
          }
          screenPointToMercatorCoordinateAtZ(t, s) {
            const d = s || 0, g = [t.x, t.y, 0, 1], w = [t.x, t.y, 1, 1];
            u.aH(g, g, this._pixelMatrixInverse), u.aH(w, w, this._pixelMatrixInverse);
            const T = g[3], C = w[3], A = g[1] / T, F = w[1] / C, O = g[2] / T, q = w[2] / C, V = O === q ? 0 : (d - O) / (q - O);
            return new u.a9(u.G.number(g[0] / T, w[0] / C, V) / this.worldSize, u.G.number(A, F, V) / this.worldSize, d);
          }
          coordinatePoint(t, s = 0, d = this._pixelMatrix) {
            const g = [t.x * this.worldSize, t.y * this.worldSize, s, 1];
            return u.aH(g, g, d), new u.P(g[0] / g[3], g[1] / g[3]);
          }
          getBounds() {
            const t = Math.max(0, this._helper._height / 2 - st(this));
            return new Dr().extend(this.screenPointToLocation(new u.P(0, t))).extend(this.screenPointToLocation(new u.P(this._helper._width, t))).extend(this.screenPointToLocation(new u.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new u.P(0, this._helper._height)));
          }
          isPointOnMapSurface(t, s) {
            return s ? s.pointCoordinate(t) != null : t.y > this.height / 2 - st(this);
          }
          calculatePosMatrix(t, s = !1, d) {
            var g;
            const w = (g = t.key) !== null && g !== void 0 ? g : u.bd(t.wrap, t.canonical.z, t.canonical.z, t.canonical.x, t.canonical.y), T = s ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (T.has(w)) {
              const F = T.get(w);
              return d ? F.f32 : F.f64;
            }
            const C = vt(t, this.worldSize);
            u.S(C, s ? this._alignedProjMatrix : this._viewProjMatrix, C);
            const A = { f64: C, f32: new Float32Array(C) };
            return T.set(w, A), d ? A.f32 : A.f64;
          }
          calculateFogMatrix(t) {
            const s = t.key, d = this._fogMatrixCacheF32;
            if (d.has(s)) return d.get(s);
            const g = vt(t, this.worldSize);
            return u.S(g, this._fogMatrix, g), d.set(s, new Float32Array(g)), d.get(s);
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, s, d, g);
          }
          _calculateNearFarZIfNeeded(t, s, d) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const g = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), w = t - g * this._helper._pixelPerMeter / Math.cos(s), T = g < 0 ? w : t, C = Math.PI / 2 + this.pitchInRadians, A = u.ap(this.fov) * (Math.abs(Math.cos(u.ap(this.roll))) * this.height + Math.abs(Math.sin(u.ap(this.roll))) * this.width) / this.height * (0.5 + d.y / this.height), F = Math.sin(A) * T / Math.sin(u.an(Math.PI - C - A, 0.01, Math.PI - 0.01)), O = st(this), q = Math.atan(O / this._helper.cameraToCenterDistance), V = u.ap(0.75), X = q > V ? 2 * q * (0.5 + d.y / (2 * O)) : V, te = Math.sin(X) * T / Math.sin(u.an(Math.PI - C - X, 0.01, Math.PI - 0.01)), he = Math.min(F, te);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - s) * he + T), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const t = this.centerOffset, s = $e(this.worldSize, this.center), d = s.x, g = s.y;
            this._helper._pixelPerMeter = u.as(1, this.center.lat) * this.worldSize;
            const w = u.ap(Math.min(this.pitch, Ve)), T = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(w));
            let C;
            this._calculateNearFarZIfNeeded(T, w, t), C = new Float64Array(16), u.be(C, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), u.aB(this._invProjMatrix, C), C[8] = 2 * -t.x / this._helper._width, C[9] = 2 * t.y / this._helper._height, this._projectionMatrix = u.bf(C), u.Q(C, C, [1, -1, 1]), u.O(C, C, [0, 0, -this._helper.cameraToCenterDistance]), u.bg(C, C, -this.rollInRadians), u.bh(C, C, this.pitchInRadians), u.bg(C, C, -this.bearingInRadians), u.O(C, C, [-d, -g, 0]), this._mercatorMatrix = u.Q([], C, [this.worldSize, this.worldSize, this.worldSize]), u.Q(C, C, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = u.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, C), u.O(C, C, [0, 0, -this.elevation]), this._viewProjMatrix = C, this._invViewProjMatrix = u.aB([], C);
            const A = [0, 0, -1, 1];
            u.aH(A, A, this._invViewProjMatrix), this._cameraPosition = [A[0] / A[3], A[1] / A[3], A[2] / A[3]], this._fogMatrix = new Float64Array(16), u.be(this._fogMatrix, this.fovInRadians, this.width / this.height, T, this._helper._farZ), this._fogMatrix[8] = 2 * -t.x / this.width, this._fogMatrix[9] = 2 * t.y / this.height, u.Q(this._fogMatrix, this._fogMatrix, [1, -1, 1]), u.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), u.bg(this._fogMatrix, this._fogMatrix, -this.rollInRadians), u.bh(this._fogMatrix, this._fogMatrix, this.pitchInRadians), u.bg(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), u.O(this._fogMatrix, this._fogMatrix, [-d, -g, 0]), u.Q(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), u.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = u.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, C);
            const F = this._helper._width % 2 / 2, O = this._helper._height % 2 / 2, q = Math.cos(this.bearingInRadians), V = Math.sin(-this.bearingInRadians), X = d - Math.round(d) + q * F + V * O, te = g - Math.round(g) + q * O + V * F, he = new Float64Array(C);
            if (u.O(he, he, [X > 0.5 ? X - 1 : X, te > 0.5 ? te - 1 : te, 0]), this._alignedProjMatrix = he, C = u.aB(new Float64Array(16), this._pixelMatrix), !C) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = C, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const t = this.screenPointToMercatorCoordinate(new u.P(0, 0)), s = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
            return u.aH(s, s, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const t = u.as(1, this.center.lat) * this.worldSize;
            return Be(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / t).toLngLat();
          }
          lngLatToCameraDepth(t, s) {
            const d = u.a9.fromLngLat(t), g = [d.x * this.worldSize, d.y * this.worldSize, s, 1];
            return u.aH(g, g, this._viewProjMatrix), g[2] / g[3];
          }
          getProjectionData(t) {
            const { overscaledTileID: s, aligned: d, applyTerrainMatrix: g } = t, w = this._helper.getMercatorTileCoordinates(s), T = s ? this.calculatePosMatrix(s, d, !0) : null;
            let C;
            return C = s && s.terrainRttPosMatrix32f && g ? s.terrainRttPosMatrix32f : T || u.bi(), { mainMatrix: C, tileMercatorCoords: w, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: C };
          }
          isLocationOccluded(t) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(t, s, d) {
            return 1;
          }
          transformLightDirection(t) {
            return u.b1(t);
          }
          getRayDirectionFromPixel(t) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(t, s, d, g) {
            const w = this.calculatePosMatrix(d);
            let T;
            g ? (T = [t, s, g(t, s), 1], u.aH(T, T, w)) : (T = [t, s, 0, 1], vl(T, T, w));
            const C = T[3];
            return { point: new u.P(T[0] / C, T[1] / C), signedDistanceFromCamera: C, isOccluded: !1 };
          }
          populateCache(t) {
            for (const s of t) this.calculatePosMatrix(s);
          }
          getMatrixForModel(t, s) {
            const d = u.a9.fromLngLat(t, s), g = d.meterInMercatorCoordinateUnits(), w = u.bj();
            return u.O(w, w, [d.x, d.y, d.z]), u.bg(w, w, Math.PI), u.bh(w, w, Math.PI / 2), u.Q(w, w, [-g, g, g]), w;
          }
          getProjectionDataForCustomLayer(t = !0) {
            const s = new u.a2(0, 0, 0, 0, 0), d = this.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: t }), g = vt(s, this.worldSize);
            u.S(g, this._viewProjMatrix, g), d.tileMercatorCoords = [0, 0, 1, 1];
            const w = [u.a5, u.a5, this.worldSize / this._helper.pixelsPerMeter], T = u.bk();
            return u.Q(T, g, w), d.fallbackMatrix = T, d.mainMatrix = T, d;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.calculatePosMatrix(t);
          }
        }
        function ws() {
          u.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Sc(b) {
          if (b.useSlerp) if (b.k < 1) {
            const t = u.bl(b.startEulerAngles.roll, b.startEulerAngles.pitch, b.startEulerAngles.bearing), s = u.bl(b.endEulerAngles.roll, b.endEulerAngles.pitch, b.endEulerAngles.bearing), d = new Float64Array(4);
            u.bm(d, t, s, b.k);
            const g = u.bn(d);
            b.tr.setRoll(g.roll), b.tr.setPitch(g.pitch), b.tr.setBearing(g.bearing);
          } else b.tr.setRoll(b.endEulerAngles.roll), b.tr.setPitch(b.endEulerAngles.pitch), b.tr.setBearing(b.endEulerAngles.bearing);
          else b.tr.setRoll(u.G.number(b.startEulerAngles.roll, b.endEulerAngles.roll, b.k)), b.tr.setPitch(u.G.number(b.startEulerAngles.pitch, b.endEulerAngles.pitch, b.k)), b.tr.setBearing(u.G.number(b.startEulerAngles.bearing, b.endEulerAngles.bearing, b.k));
        }
        function xl(b, t, s, d, g) {
          const w = g.padding, T = $e(g.worldSize, s.getNorthWest()), C = $e(g.worldSize, s.getNorthEast()), A = $e(g.worldSize, s.getSouthEast()), F = $e(g.worldSize, s.getSouthWest()), O = u.ap(-d), q = T.rotate(O), V = C.rotate(O), X = A.rotate(O), te = F.rotate(O), he = new u.P(Math.max(q.x, V.x, te.x, X.x), Math.max(q.y, V.y, te.y, X.y)), pe = new u.P(Math.min(q.x, V.x, te.x, X.x), Math.min(q.y, V.y, te.y, X.y)), fe = he.sub(pe), be = (g.width - (w.left + w.right + t.left + t.right)) / fe.x, Ae = (g.height - (w.top + w.bottom + t.top + t.bottom)) / fe.y;
          if (Ae < 0 || be < 0) return void ws();
          const xe = Math.min(u.at(g.scale * Math.min(be, Ae)), b.maxZoom), Ce = u.P.convert(b.offset), Oe = new u.P((t.left - t.right) / 2, (t.top - t.bottom) / 2).rotate(u.ap(d)), ke = Ce.add(Oe).mult(g.scale / u.aq(xe));
          return { center: gt(g.worldSize, T.add(A).div(2).sub(ke)), zoom: xe, bearing: d };
        }
        class vi {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(t, s) {
            const d = t.mag(), g = Math.abs(st(s));
            return { easingOffset: t.mult(Math.min(0.75 * g / d, 1)), easingCenter: s.center };
          }
          handleMapControlsRollPitchBearingZoom(t, s) {
            t.bearingDelta && s.setBearing(s.bearing + t.bearingDelta), t.pitchDelta && s.setPitch(s.pitch + t.pitchDelta), t.rollDelta && s.setRoll(s.roll + t.rollDelta), t.zoomDelta && s.setZoom(s.zoom + t.zoomDelta);
          }
          handleMapControlsPan(t, s, d) {
            t.around.distSqr(s.centerPoint) < 0.01 || s.setLocationAtPoint(d, t.around);
          }
          cameraForBoxAndBearing(t, s, d, g, w) {
            return xl(t, s, d, g, w);
          }
          handleJumpToCenterZoom(t, s) {
            t.zoom !== (s.zoom !== void 0 ? +s.zoom : t.zoom) && t.setZoom(+s.zoom), s.center !== void 0 && t.setCenter(u.V.convert(s.center));
          }
          handleEaseTo(t, s) {
            const d = t.zoom, g = t.padding, w = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, T = { roll: s.roll === void 0 ? t.roll : s.roll, pitch: s.pitch === void 0 ? t.pitch : s.pitch, bearing: s.bearing === void 0 ? t.bearing : s.bearing }, C = s.zoom !== void 0, A = !t.isPaddingEqual(s.padding);
            let F = !1;
            const O = C ? +s.zoom : t.zoom;
            let q = t.centerPoint.add(s.offsetAsPoint);
            const V = t.screenPointToLocation(q), { center: X, zoom: te } = t.applyConstrain(u.V.convert(s.center || V), O ?? d);
            Os(t, X);
            const he = $e(t.worldSize, V), pe = $e(t.worldSize, X).sub(he), fe = u.aq(te - d);
            return F = te !== d, { easeFunc: (be) => {
              if (F && t.setZoom(u.G.number(d, te, be)), u.bo(w, T) || Sc({ startEulerAngles: w, endEulerAngles: T, tr: t, k: be, useSlerp: w.roll != T.roll }), A && (t.interpolatePadding(g, s.padding, be), q = t.centerPoint.add(s.offsetAsPoint)), s.around) t.setLocationAtPoint(s.around, s.aroundPoint);
              else {
                const Ae = u.aq(t.zoom - d), xe = te > d ? Math.min(2, fe) : Math.max(0.5, fe), Ce = Math.pow(xe, 1 - be), Oe = gt(t.worldSize, he.add(pe.mult(be * Ce)).mult(Ae));
                t.setLocationAtPoint(t.renderWorldCopies ? Oe.wrap() : Oe, q);
              }
            }, isZooming: F, elevationCenter: X };
          }
          handleFlyTo(t, s) {
            const d = s.zoom !== void 0, g = t.zoom, w = t.applyConstrain(u.V.convert(s.center || s.locationAtOffset), d ? +s.zoom : g), T = w.center, C = w.zoom;
            Os(t, T);
            const A = $e(t.worldSize, s.locationAtOffset), F = $e(t.worldSize, T).sub(A), O = F.mag(), q = u.aq(C - g);
            let V;
            if (s.minZoom !== void 0) {
              const X = Math.min(+s.minZoom, g, C), te = t.applyConstrain(T, X).zoom;
              V = u.aq(te - g);
            }
            return { easeFunc: (X, te, he, pe) => {
              t.setZoom(X === 1 ? C : g + u.at(te));
              const fe = X === 1 ? T : gt(t.worldSize, A.add(F.mult(he)).mult(te));
              t.setLocationAtPoint(t.renderWorldCopies ? fe.wrap() : fe, pe);
            }, scaleOfZoom: q, targetCenter: T, scaleOfMinZoom: V, pixelPathLength: O };
          }
        }
        class Lr {
          constructor(t, s, d) {
            this.blendFunction = t, this.blendColor = s, this.mask = d;
          }
        }
        Lr.Replace = [1, 0], Lr.disabled = new Lr(Lr.Replace, u.bp.transparent, [!1, !1, !1, !1]), Lr.unblended = new Lr(Lr.Replace, u.bp.transparent, [!0, !0, !0, !0]), Lr.alphaBlended = new Lr([1, 771], u.bp.transparent, [!0, !0, !0, !0]);
        const Qa = 2305;
        class ar {
          constructor(t, s, d) {
            this.enable = t, this.mode = s, this.frontFace = d;
          }
        }
        ar.disabled = new ar(!1, 1029, Qa), ar.backCCW = new ar(!0, 1029, Qa), ar.frontCCW = new ar(!0, 1028, Qa);
        class sr {
          constructor(t, s, d) {
            this.func = t, this.mask = s, this.range = d;
          }
        }
        sr.ReadOnly = !1, sr.ReadWrite = !0, sr.disabled = new sr(519, sr.ReadOnly, [0, 1]);
        const eo = 7680;
        class pr {
          constructor(t, s, d, g, w, T) {
            this.test = t, this.ref = s, this.mask = d, this.fail = g, this.depthFail = w, this.pass = T;
          }
        }
        pr.disabled = new pr({ func: 519, mask: 0 }, 0, 0, eo, eo, eo);
        const to = /* @__PURE__ */ new WeakMap();
        function Jn(b) {
          var t;
          if (to.has(b)) return to.get(b);
          {
            const s = (t = b.getParameter(b.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0");
            return to.set(b, s), s;
          }
        }
        class ro {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(t) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = t;
            const s = t.context, d = s.gl;
            this._texFormat = d.RGBA, this._texType = d.UNSIGNED_BYTE;
            const g = new u.aW();
            g.emplaceBack(-1, -1), g.emplaceBack(2, -1), g.emplaceBack(-1, 2);
            const w = new u.aY();
            w.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Ar(s.createVertexBuffer(g, ta.members), s.createIndexBuffer(w), u.aX.simpleSegment(0, 0, g.length, w.length)), this._resultBuffer = new Uint8Array(4), s.activeTexture.set(d.TEXTURE1);
            const T = d.createTexture();
            d.bindTexture(d.TEXTURE_2D, T), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST), d.texImage2D(d.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = s.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(T), Jn(d) && (this._pbo = d.createBuffer(), d.bindBuffer(d.PIXEL_PACK_BUFFER, this._pbo), d.bufferData(d.PIXEL_PACK_BUFFER, 4, d.STREAM_READ), d.bindBuffer(d.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const t = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), t.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(t, s) {
            const d = this._updateCount;
            return this._readbackQueue ? d >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : d >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(t, s), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const t = this._cachedRenderContext.context, s = t.gl;
            t.activeTexture.set(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, this._fbo.colorAttachment.get()), t.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(t, s) {
            const d = this._cachedRenderContext.context, g = d.gl;
            if (this._bindFramebuffer(), d.viewport.set([0, 0, this._texWidth, this._texHeight]), d.clear({ color: u.bp.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(d, g.TRIANGLES, sr.disabled, pr.disabled, Lr.unblended, ar.disabled, /* @__PURE__ */ ((w, T) => ({ u_input: w, u_output_expected: T }))(t, s), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Jn(g)) {
              g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.readBuffer(g.COLOR_ATTACHMENT0), g.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), g.bindBuffer(g.PIXEL_PACK_BUFFER, null);
              const w = g.fenceSync(g.SYNC_GPU_COMMANDS_COMPLETE, 0);
              g.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: w };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const t = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Jn(t)) {
              const s = t.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (s === t.WAIT_FAILED) return u.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (s === t.TIMEOUT_EXPIRED) return;
              t.bindBuffer(t.PIXEL_PACK_BUFFER, this._pbo), t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), t.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ro._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(t) {
            let s = 0;
            return s += t[0] / 256, s += t[1] / 65536, s += t[2] / 16777216, t[3] < 127 && (s = -s), s / 128;
          }
        }
        const Kn = u.a5 / 128;
        function fu(b, t) {
          const s = b.granularity !== void 0 ? Math.max(b.granularity, 1) : 1, d = s + (b.generateBorders ? 2 : 0), g = s + (b.extendToNorthPole || b.generateBorders ? 1 : 0) + (b.extendToSouthPole || b.generateBorders ? 1 : 0), w = d + 1, T = g + 1, C = b.generateBorders ? -1 : 0, A = b.generateBorders || b.extendToNorthPole ? -1 : 0, F = s + (b.generateBorders ? 1 : 0), O = s + (b.generateBorders || b.extendToSouthPole ? 1 : 0), q = w * T, V = d * g * 6, X = w * T > 65536;
          if (X && t === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const te = X || t === "32bit", he = new Int16Array(2 * q);
          let pe = 0;
          for (let Ae = A; Ae <= O; Ae++) for (let xe = C; xe <= F; xe++) {
            let Ce = xe / s * u.a5;
            xe === -1 && (Ce = -Kn), xe === s + 1 && (Ce = u.a5 + Kn);
            let Oe = Ae / s * u.a5;
            Ae === -1 && (Oe = b.extendToNorthPole ? u.br : -Kn), Ae === s + 1 && (Oe = b.extendToSouthPole ? u.bs : u.a5 + Kn), he[pe++] = Ce, he[pe++] = Oe;
          }
          const fe = te ? new Uint32Array(V) : new Uint16Array(V);
          let be = 0;
          for (let Ae = 0; Ae < g; Ae++) for (let xe = 0; xe < d; xe++) {
            const Ce = xe + 1 + Ae * w, Oe = xe + (Ae + 1) * w, ke = xe + 1 + (Ae + 1) * w;
            fe[be++] = xe + Ae * w, fe[be++] = Oe, fe[be++] = Ce, fe[be++] = Ce, fe[be++] = Oe, fe[be++] = ke;
          }
          return { vertices: he.buffer.slice(0), indices: fe.buffer.slice(0), uses32bitIndices: te };
        }
        const Ro = new u.aV({ fill: new u.bt(128, 2), line: new u.bt(512, 0), tile: new u.bt(128, 32), stencil: new u.bt(128, 1), circle: 3 });
        class pu {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return tn.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return tn.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Ro;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(t) {
            this._errorMeasurement || (this._errorMeasurement = new ro(t));
            const s = u.X(this._errorQueryLatitudeDegrees), d = 2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) - 0.5 * Math.PI, g = this._errorMeasurement.updateErrorLoop(s, d), w = _e();
            g !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = g, this._errorMeasurementLastChangeTime = w);
            const T = Math.min(Math.max((w - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = u.bu(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, u.bv(T));
          }
          _getMeshKey(t) {
            return `${t.granularity.toString(36)}_${t.generateBorders ? "b" : ""}${t.extendToNorthPole ? "n" : ""}${t.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(t, s, d, g, w) {
            const T = (w === "stencil" ? Ro.stencil : Ro.tile).getGranularityForZoomLevel(s.z);
            return this._getMesh(t, { granularity: T, generateBorders: d, extendToNorthPole: s.y === 0 && g, extendToSouthPole: s.y === (1 << s.z) - 1 && g });
          }
          _getMesh(t, s) {
            const d = this._getMeshKey(s);
            if (d in this._tileMeshCache) return this._tileMeshCache[d];
            const g = (function(w, T) {
              const C = fu(T, "16bit"), A = u.aW.deserialize({ arrayBuffer: C.vertices, length: C.vertices.byteLength / 2 / 2 }), F = u.aY.deserialize({ arrayBuffer: C.indices, length: C.indices.byteLength / 2 / 3 });
              return new Ar(w.createVertexBuffer(A, ta.members), w.createIndexBuffer(F), u.aX.simpleSegment(0, 0, A.length, F.length));
            })(t, s);
            return this._tileMeshCache[d] = g, g;
          }
          recalculate(t) {
          }
          hasTransition() {
            const t = _e();
            let s = !1;
            return s = s || (t - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, s = s || this._errorMeasurement && this._errorMeasurement.awaitingQuery, s;
          }
          setErrorQueryLatitudeDegrees(t) {
            this._errorQueryLatitudeDegrees = t;
          }
        }
        const Kh = new u.t({ type: new u.D(u.u.projection.type) });
        class Tc extends u.E {
          constructor(t) {
            super(), this._transitionable = new u.x(Kh, void 0), this.setProjection(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.H(0)), this._mercatorProjection = new rn(), this._verticalPerspectiveProjection = new pu();
          }
          get transitionState() {
            const t = this.properties.get("type");
            if (typeof t == "string" && t === "mercator") return 0;
            if (typeof t == "string" && t === "vertical-perspective") return 1;
            if (t instanceof u.bw) {
              if (t.from === "vertical-perspective" && t.to === "mercator") return 1 - t.transition;
              if (t.from === "mercator" && t.to === "vertical-perspective") return t.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(t) {
            this._mercatorProjection.updateGPUdependent(t), this._verticalPerspectiveProjection.updateGPUdependent(t);
          }
          getMeshFromTileID(t, s, d, g, w) {
            return this.currentProjection.getMeshFromTileID(t, s, d, g, w);
          }
          setProjection(t) {
            this._transitionable.setValue("type", t?.type || "mercator");
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          setErrorQueryLatitudeDegrees(t) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(t), this._mercatorProjection.setErrorQueryLatitudeDegrees(t);
          }
        }
        function xi(b) {
          const t = ji(b.worldSize, b.center.lat);
          return 2 * Math.PI * t;
        }
        function Es(b, t, s, d, g) {
          const w = 1 / (1 << g), T = t / u.a5 * w + d * w, C = u.bz((b / u.a5 * w + s * w) * Math.PI * 2 + Math.PI, 2 * Math.PI), A = 2 * Math.atan(Math.exp(Math.PI - T * Math.PI * 2)) - 0.5 * Math.PI, F = Math.cos(A), O = new Float64Array(3);
          return O[0] = Math.sin(C) * F, O[1] = Math.sin(A), O[2] = Math.cos(C) * F, O;
        }
        function Xr(b) {
          return (function(t, s) {
            const d = Math.cos(s), g = new Float64Array(3);
            return g[0] = Math.sin(t) * d, g[1] = Math.sin(s), g[2] = Math.cos(t) * d, g;
          })(b.lng * Math.PI / 180, b.lat * Math.PI / 180);
        }
        function ji(b, t) {
          return b / (2 * Math.PI) / Math.cos(t * Math.PI / 180);
        }
        function bi(b) {
          const t = Math.asin(b[1]) / Math.PI * 180, s = Math.sqrt(b[0] * b[0] + b[2] * b[2]);
          if (s > 1e-6) {
            const d = b[0] / s, g = Math.acos(b[2] / s), w = (d > 0 ? g : -g) / Math.PI * 180;
            return new u.V(u.W(w, -180, 180), t);
          }
          return new u.V(0, t);
        }
        function Fo(b) {
          return Math.cos(b * Math.PI / 180);
        }
        function sn(b, t) {
          const s = Fo(b), d = Fo(t);
          return u.at(d / s);
        }
        function kc(b, t) {
          const s = b.rotate(t.bearingInRadians), d = t.zoom + sn(t.center.lat, 0), g = u.bu(1 / Fo(t.center.lat), 1 / Fo(Math.min(Math.abs(t.center.lat), 60)), u.bx(d, 7, 3, 0, 1)), w = 360 / xi({ worldSize: t.worldSize, center: { lat: t.center.lat } });
          return new u.V(t.center.lng - s.x * w * g, u.an(t.center.lat + s.y * w, -u.ao, u.ao));
        }
        function No(b) {
          const t = 0.5 * b, s = Math.sin(t), d = Math.cos(t);
          return Math.log(s + d) - Math.log(d - s);
        }
        function gu(b, t, s, d) {
          const g = b.lat + s * d;
          if (Math.abs(s) > 1) {
            const w = (Math.sign(b.lat + s) !== Math.sign(b.lat) ? -Math.abs(b.lat) : Math.abs(b.lat)) * Math.PI / 180, T = Math.abs(b.lat + s) * Math.PI / 180, C = No(w + d * (T - w)), A = No(w), F = No(T);
            return new u.V(b.lng + t * ((C - A) / (F - A)), g);
          }
          return new u.V(b.lng + t * d, g);
        }
        class mu {
          constructor(t) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = t;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const t = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = t, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(t, s, d, g) {
            const w = `${t.z}_${t.x}_${t.y}_${g?.terrain ? "t" : ""}`, T = this._cache.get(w);
            if (T) return T;
            const C = this._cachePrevious.get(w);
            if (C) return this._cache.set(w, C), C;
            const A = this._boundingVolumeFactory(t, s, d, g);
            return this._cache.set(w, A), this._hadAnyChanges = !0, A;
          }
        }
        class Sa {
          constructor(t, s, d, g) {
            this.min = d, this.max = g, this.points = t, this.planes = s;
          }
          static fromAabb(t, s) {
            const d = [];
            for (let g = 0; g < 8; g++) d.push([1 & ~g ? t[0] : s[0], (g >> 1 & 1) == 1 ? s[1] : t[1], (g >> 2 & 1) == 1 ? s[2] : t[2]]);
            return new Sa(d, [[-1, 0, 0, s[0]], [1, 0, 0, -t[0]], [0, -1, 0, s[1]], [0, 1, 0, -t[1]], [0, 0, -1, s[2]], [0, 0, 1, -t[2]]], t, s);
          }
          static fromCenterSizeAngles(t, s, d) {
            const g = u.bB([], d[0], d[1], d[2]), w = u.bC([], [s[0], 0, 0], g), T = u.bC([], [0, s[1], 0], g), C = u.bC([], [0, 0, s[2]], g), A = [...t], F = [...t];
            for (let q = 0; q < 8; q++) for (let V = 0; V < 3; V++) {
              const X = t[V] + w[V] * (1 & ~q ? -1 : 1) + T[V] * ((q >> 1 & 1) == 1 ? 1 : -1) + C[V] * ((q >> 2 & 1) == 1 ? 1 : -1);
              A[V] = Math.min(A[V], X), F[V] = Math.max(F[V], X);
            }
            const O = [];
            for (let q = 0; q < 8; q++) {
              const V = [...t];
              u.b0(V, V, u.a$([], w, 1 & ~q ? -1 : 1)), u.b0(V, V, u.a$([], T, (q >> 1 & 1) == 1 ? 1 : -1)), u.b0(V, V, u.a$([], C, (q >> 2 & 1) == 1 ? 1 : -1)), O.push(V);
            }
            return new Sa(O, [[...w, -u.b5(w, O[0])], [...T, -u.b5(T, O[0])], [...C, -u.b5(C, O[0])], [-w[0], -w[1], -w[2], -u.b5(w, O[7])], [-T[0], -T[1], -T[2], -u.b5(T, O[7])], [-C[0], -C[1], -C[2], -u.b5(C, O[7])]], A, F);
          }
          intersectsFrustum(t) {
            let s = !0;
            const d = this.points.length, g = this.planes.length, w = t.planes.length, T = t.points.length;
            for (let C = 0; C < w; C++) {
              const A = t.planes[C];
              let F = 0;
              for (let O = 0; O < d; O++) {
                const q = this.points[O];
                A[0] * q[0] + A[1] * q[1] + A[2] * q[2] + A[3] >= 0 && F++;
              }
              if (F === 0) return 0;
              F < d && (s = !1);
            }
            if (s) return 2;
            for (let C = 0; C < g; C++) {
              const A = this.planes[C];
              let F = 0;
              for (let O = 0; O < T; O++) {
                const q = t.points[O];
                A[0] * q[0] + A[1] * q[1] + A[2] * q[2] + A[3] >= 0 && F++;
              }
              if (F === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(t) {
            const s = this.points.length;
            let d = 0;
            for (let g = 0; g < s; g++) {
              const w = this.points[g];
              t[0] * w[0] + t[1] * w[1] + t[2] * w[2] + t[3] >= 0 && d++;
            }
            return d === s ? 2 : d === 0 ? 0 : 1;
          }
        }
        function Ii(b, t, s) {
          const d = b - t;
          return d < 0 ? -d : Math.max(0, d - s);
        }
        function Ta(b, t, s, d, g) {
          const w = b - s;
          let T;
          return T = w < 0 ? Math.min(-w, 1 + w - g) : w > 1 ? Math.min(Math.max(w - g, 0), 1 - w) : 0, Math.max(T, Ii(t, d, g));
        }
        class wi {
          constructor() {
            this._boundingVolumeCache = new mu(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(t, s, d, g) {
            const w = 1 << d.z, T = 1 / w, C = d.x / w, A = d.y / w;
            let F = 2;
            return F = Math.min(F, Ta(t, s, C, A, T)), F = Math.min(F, Ta(t, s, C + 0.5, -A - T, T)), F = Math.min(F, Ta(t, s, C + 0.5, 2 - A - T, T)), F;
          }
          getWrap(t, s, d) {
            const g = 1 << s.z, w = 1 / g, T = s.x / g, C = Ii(t.x, T, w), A = Ii(t.x, T - 1, w), F = Ii(t.x, T + 1, w), O = Math.min(C, A, F);
            return O === F ? 1 : O === A ? -1 : 0;
          }
          allowVariableZoom(t, s) {
            return Fr(t, s) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(t, s, d, g) {
            return this._boundingVolumeCache.getTileBoundingVolume(t, s, d, g);
          }
          _computeTileBoundingVolume(t, s, d, g) {
            var w, T;
            let C = 0, A = 0;
            if (g?.terrain) {
              const F = new u.a2(t.z, s, t.z, t.x, t.y), O = g.terrain.getMinMaxElevation(F);
              C = (w = O.minElevation) !== null && w !== void 0 ? w : Math.min(0, d), A = (T = O.maxElevation) !== null && T !== void 0 ? T : Math.max(0, d);
            }
            if (C /= u.bE, A /= u.bE, C += 1, A += 1, t.z <= 0) return Sa.fromAabb([-A, -A, -A], [A, A, A]);
            if (t.z === 1) return Sa.fromAabb([t.x === 0 ? -A : 0, t.y === 0 ? 0 : -A, -A], [t.x === 0 ? 0 : A, t.y === 0 ? A : 0, A]);
            {
              const F = [Es(0, 0, t.x, t.y, t.z), Es(u.a5, 0, t.x, t.y, t.z), Es(u.a5, u.a5, t.x, t.y, t.z), Es(0, u.a5, t.x, t.y, t.z)], O = [];
              for (const nt of F) O.push(u.a$([], nt, A));
              if (A !== C) for (const nt of F) O.push(u.a$([], nt, C));
              t.y === 0 && O.push([0, 1, 0]), t.y === (1 << t.z) - 1 && O.push([0, -1, 0]);
              const q = [1, 1, 1], V = [-1, -1, -1];
              for (const nt of O) for (let it = 0; it < 3; it++) q[it] = Math.min(q[it], nt[it]), V[it] = Math.max(V[it], nt[it]);
              const X = Es(u.a5 / 2, u.a5 / 2, t.x, t.y, t.z), te = u.b4([], [0, 1, 0], X);
              u.b3(te, te);
              const he = u.b4([], X, te);
              u.b3(he, he);
              const pe = u.b4([], F[2], F[1]);
              u.b3(pe, pe);
              const fe = u.b4([], F[0], F[3]);
              u.b3(fe, fe), O.push(u.a$([], X, A)), t.y >= (1 << t.z) / 2 && O.push(u.a$([], Es(u.a5 / 2, 0, t.x, t.y, t.z), A)), t.y < (1 << t.z) / 2 && O.push(u.a$([], Es(u.a5 / 2, u.a5, t.x, t.y, t.z), A));
              const be = zs(X, O), Ae = zs(he, O), xe = [-X[0], -X[1], -X[2], be.max], Ce = [X[0], X[1], X[2], -be.min], Oe = [-he[0], -he[1], -he[2], Ae.max], ke = [he[0], he[1], he[2], -Ae.min], je = [...pe, 0], at = [...fe, 0], tt = [];
              return t.y === 0 ? tt.push(u.bD(at, je, xe), u.bD(at, je, Ce)) : tt.push(u.bD(Oe, je, xe), u.bD(Oe, je, Ce), u.bD(Oe, at, xe), u.bD(Oe, at, Ce)), t.y === (1 << t.z) - 1 ? tt.push(u.bD(at, je, xe), u.bD(at, je, Ce)) : tt.push(u.bD(ke, je, xe), u.bD(ke, je, Ce), u.bD(ke, at, xe), u.bD(ke, at, Ce)), new Sa(tt, [xe, Ce, Oe, ke, je, at], q, V);
            }
          }
        }
        function zs(b, t) {
          let s = 1 / 0, d = -1 / 0;
          for (const g of t) {
            const w = u.b5(b, g);
            s = Math.min(s, w), d = Math.max(d, w);
          }
          return { min: s, max: d };
        }
        class no {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, s, d) {
            return this._helper.interpolatePadding(t, s, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, s) {
            this._helper.resize(t, s);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, s) {
            this._helper.overrideNearFarZ(t, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t) {
          }
          constructor(t) {
            this._cachedClippingPlane = u.bF(), this._projectionMatrix = u.bj(), this._globeViewProjMatrix32f = u.bi(), this._globeViewProjMatrixNoCorrection = u.bj(), this._globeViewProjMatrixNoCorrectionInverted = u.bj(), this._globeProjMatrixInverted = u.bj(), this._cameraPosition = u.bA(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (s, d) => {
              const g = u.an(s.lat, -u.ao, u.ao), w = u.an(+d, this.minZoom + sn(0, g), this.maxZoom);
              return { center: new u.V(s.lng, g), zoom: w };
            }, this.applyConstrain = (s, d) => this._helper.applyConstrain(s, d), this._helper = new na({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (s, d) => this.defaultConstrain(s, d) }, t), this._coveringTilesDetailsProvider = new wi();
          }
          clone() {
            const t = new no();
            return t.apply(this, !1), t;
          }
          apply(t, s, d) {
            this._globeLatitudeErrorCorrectionRadians = d || 0, this._helper.apply(t, s);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const t = u.bA();
            return t[0] = this._cameraPosition[0], t[1] = this._cameraPosition[1], t[2] = this._cameraPosition[2], t;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(t) {
            const { overscaledTileID: s, applyGlobeMatrix: d } = t, g = this._helper.getMercatorTileCoordinates(s);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: g, clippingPlane: this._cachedClippingPlane, projectionTransition: d ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(t) {
            const s = this.pitchInRadians, d = this.cameraToCenterDistance / t, g = Math.sin(s) * d, w = Math.cos(s) * d + 1, T = 1 / Math.sqrt(g * g + w * w) * 1;
            let C = -g, A = w;
            const F = Math.sqrt(C * C + A * A);
            C /= F, A /= F;
            const O = [0, C, A];
            u.bG(O, O, [0, 0, 0], -this.bearingInRadians), u.bH(O, O, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), u.bI(O, O, [0, 0, 0], this.center.lng * Math.PI / 180);
            const q = 1 / u.b7(O);
            return u.a$(O, O, q), [...O, -T * q];
          }
          isLocationOccluded(t) {
            return !this.isSurfacePointVisible(Xr(t));
          }
          transformLightDirection(t) {
            const s = this._helper._center.lng * Math.PI / 180, d = this._helper._center.lat * Math.PI / 180, g = Math.cos(d), w = [Math.sin(s) * g, Math.sin(d), Math.cos(s) * g], T = [w[2], 0, -w[0]], C = [0, 0, 0];
            u.b4(C, T, w), u.b3(T, T), u.b3(C, C);
            const A = [0, 0, 0];
            return u.b3(A, [T[0] * t[0] + C[0] * t[1] + w[0] * t[2], T[1] * t[0] + C[1] * t[1] + w[1] * t[2], T[2] * t[0] + C[2] * t[1] + w[2] * t[2]]), A;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(t, s, d) {
            const g = (function(C, A, F) {
              const O = 1 / (1 << F.z);
              return new u.a9(C / u.a5 * O + F.x * O, A / u.a5 * O + F.y * O);
            })(t, s, d.canonical), w = (T = g.y, [u.bz(g.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - T * Math.PI * 2)) - 0.5 * Math.PI]);
            var T;
            return this.getCircleRadiusCorrection() / Math.cos(w[1]);
          }
          projectTileCoordinates(t, s, d, g) {
            const w = d.canonical, T = Es(t, s, w.x, w.y, w.z), C = 1 + (g ? g(t, s) : 0) / u.bE, A = [T[0] * C, T[1] * C, T[2] * C, 1];
            u.aH(A, A, this._globeViewProjMatrixNoCorrection);
            const F = this._cachedClippingPlane, O = F[0] * T[0] + F[1] * T[1] + F[2] * T[2] + F[3] < 0;
            return { point: new u.P(A[0] / A[3], A[1] / A[3]), signedDistanceFromCamera: A[3], isOccluded: O };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const t = ji(this.worldSize, this.center.lat), s = u.bk(), d = u.bk();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * t), u.be(s, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const g = this.centerOffset;
            s[8] = 2 * -g.x / this._helper._width, s[9] = 2 * g.y / this._helper._height, this._projectionMatrix = u.bf(s), this._globeProjMatrixInverted = u.bk(), u.aB(this._globeProjMatrixInverted, s), u.O(s, s, [0, 0, -this.cameraToCenterDistance]), u.bg(s, s, this.rollInRadians), u.bh(s, s, -this.pitchInRadians), u.bg(s, s, this.bearingInRadians), u.O(s, s, [0, 0, -t]);
            const w = u.bA();
            w[0] = t, w[1] = t, w[2] = t, u.bh(d, s, this.center.lat * Math.PI / 180), u.bJ(d, d, -this.center.lng * Math.PI / 180), u.Q(d, d, w), this._globeViewProjMatrixNoCorrection = d, u.bh(s, s, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), u.bJ(s, s, -this.center.lng * Math.PI / 180), u.Q(s, s, w), this._globeViewProjMatrix32f = new Float32Array(s), this._globeViewProjMatrixNoCorrectionInverted = u.bk(), u.aB(this._globeViewProjMatrixNoCorrectionInverted, d);
            const T = u.bA();
            this._cameraPosition = u.bA(), this._cameraPosition[2] = this.cameraToCenterDistance / t, u.bG(this._cameraPosition, this._cameraPosition, T, -this.rollInRadians), u.bH(this._cameraPosition, this._cameraPosition, T, this.pitchInRadians), u.bG(this._cameraPosition, this._cameraPosition, T, -this.bearingInRadians), u.b0(this._cameraPosition, this._cameraPosition, [0, 0, 1]), u.bH(this._cameraPosition, this._cameraPosition, T, -this.center.lat * Math.PI / 180), u.bI(this._cameraPosition, this._cameraPosition, T, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(t);
            const C = u.bf(this._globeViewProjMatrixNoCorrectionInverted);
            u.Q(C, C, [1, 1, -1]), this._cachedFrustum = li.fromInvProjectionMatrix(C, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(t) {
            u.w("calculateFogMatrix is not supported on globe projection.");
            const s = u.bk();
            return u.ar(s), s;
          }
          getVisibleUnwrappedCoordinates(t) {
            return [new u.bc(0, t)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            t && u.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, s) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const d = Xr(t);
            u.a$(d, d, 1 + s / u.bE);
            const g = u.bF();
            return u.aH(g, [d[0], d[1], d[2], 1], this._globeViewProjMatrixNoCorrection), g[2] / g[3];
          }
          populateCache(t) {
          }
          getBounds() {
            const t = 0.5 * this.width, s = 0.5 * this.height, d = [new u.P(0, 0), new u.P(t, 0), new u.P(this.width, 0), new u.P(this.width, s), new u.P(this.width, this.height), new u.P(t, this.height), new u.P(0, this.height), new u.P(0, s)], g = [];
            for (const q of d) g.push(this.unprojectScreenPoint(q));
            let w = 0, T = 0, C = 0, A = 0;
            const F = this.center;
            for (const q of g) {
              const V = u.bK(F.lng, q.lng), X = u.bK(F.lat, q.lat);
              V < T && (T = V), V > w && (w = V), X < A && (A = X), X > C && (C = X);
            }
            const O = [F.lng + T, F.lat + A, F.lng + w, F.lat + C];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (O[3] = 90, O[0] = -180, O[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (O[1] = -90, O[0] = -180, O[2] = 180), new Dr(O);
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, s, d, g);
          }
          setLocationAtPoint(t, s) {
            const d = Xr(this.unprojectScreenPoint(s)), g = Xr(t), w = u.bA();
            u.bL(w);
            const T = u.bA();
            u.bI(T, d, w, -this.center.lng * Math.PI / 180), u.bH(T, T, w, this.center.lat * Math.PI / 180);
            const C = g[0] * g[0] + g[2] * g[2], A = T[0] * T[0];
            if (C < A) return;
            const F = Math.sqrt(C - A), O = -F, q = u.bM(g[0], g[2], T[0], F), V = u.bM(g[0], g[2], T[0], O), X = u.bA();
            u.bI(X, g, w, -q);
            const te = u.bM(X[1], X[2], T[1], T[2]), he = u.bA();
            u.bI(he, g, w, -V);
            const pe = u.bM(he[1], he[2], T[1], T[2]), fe = 0.5 * Math.PI, be = te >= -fe && te <= fe, Ae = pe >= -fe && pe <= fe;
            let xe, Ce;
            if (be && Ae) {
              const at = this.center.lng * Math.PI / 180, tt = this.center.lat * Math.PI / 180;
              u.bN(q, at) + u.bN(te, tt) < u.bN(V, at) + u.bN(pe, tt) ? (xe = q, Ce = te) : (xe = V, Ce = pe);
            } else if (be) xe = q, Ce = te;
            else {
              if (!Ae) return;
              xe = V, Ce = pe;
            }
            const Oe = xe / Math.PI * 180, ke = Ce / Math.PI * 180, je = this.center.lat;
            this.setCenter(new u.V(Oe, u.an(ke, -90, 90))), this.setZoom(this.zoom + sn(je, this.center.lat));
          }
          locationToScreenPoint(t, s) {
            const d = Xr(t);
            if (s) {
              const g = s.getElevationForLngLatZoom(t, this._helper._tileZoom);
              u.a$(d, d, 1 + g / u.bE);
            }
            return this._projectSurfacePointToScreen(d);
          }
          _projectSurfacePointToScreen(t) {
            const s = u.bF();
            return u.aH(s, [...t, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], new u.P((0.5 * s[0] + 0.5) * this.width, (0.5 * -s[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(t, s) {
            if (s) {
              const d = s.pointCoordinate(t);
              if (d) return d;
            }
            return u.a9.fromLngLat(this.unprojectScreenPoint(t));
          }
          screenPointToLocation(t, s) {
            var d;
            return (d = this.screenPointToMercatorCoordinate(t, s)) === null || d === void 0 ? void 0 : d.toLngLat();
          }
          isPointOnMapSurface(t, s) {
            const d = this._cameraPosition, g = this.getRayDirectionFromPixel(t);
            return !!this.rayPlanetIntersection(d, g);
          }
          getRayDirectionFromPixel(t) {
            const s = u.bF();
            s[0] = t.x / this.width * 2 - 1, s[1] = -1 * (t.y / this.height * 2 - 1), s[2] = 1, s[3] = 1, u.aH(s, s, this._globeViewProjMatrixNoCorrectionInverted), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3];
            const d = u.bA();
            d[0] = s[0] - this._cameraPosition[0], d[1] = s[1] - this._cameraPosition[1], d[2] = s[2] - this._cameraPosition[2];
            const g = u.bA();
            return u.b3(g, d), g;
          }
          isSurfacePointVisible(t) {
            const s = this._cachedClippingPlane;
            return s[0] * t[0] + s[1] * t[1] + s[2] * t[2] + s[3] >= 0;
          }
          isSurfacePointOnScreen(t) {
            if (!this.isSurfacePointVisible(t)) return !1;
            const s = u.bF();
            return u.aH(s, [...t, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3], s[0] > -1 && s[0] < 1 && s[1] > -1 && s[1] < 1 && s[2] > -1 && s[2] < 1;
          }
          rayPlanetIntersection(t, s) {
            const d = u.b5(t, s), g = u.bA(), w = u.bA();
            u.a$(w, s, d), u.b2(g, t, w);
            const T = 1 - u.b5(g, g);
            if (T < 0) return null;
            const C = u.b5(t, t) - 1, A = -d + (d < 0 ? 1 : -1) * Math.sqrt(T), F = C / A, O = A;
            return { tMin: Math.min(F, O), tMax: Math.max(F, O) };
          }
          unprojectScreenPoint(t) {
            const s = this._cameraPosition, d = this.getRayDirectionFromPixel(t), g = this.rayPlanetIntersection(s, d);
            if (g) {
              const O = u.bA();
              u.b0(O, s, [d[0] * g.tMin, d[1] * g.tMin, d[2] * g.tMin]);
              const q = u.bA();
              return u.b3(q, O), bi(q);
            }
            const w = this._cachedClippingPlane, T = w[0] * d[0] + w[1] * d[1] + w[2] * d[2], C = -u.bb(w, s) / T, A = u.bA();
            if (C > 0) u.b0(A, s, [d[0] * C, d[1] * C, d[2] * C]);
            else {
              const O = u.bA();
              u.b0(O, s, [2 * d[0], 2 * d[1], 2 * d[2]]);
              const q = u.bb(this._cachedClippingPlane, O);
              u.b2(A, O, [this._cachedClippingPlane[0] * q, this._cachedClippingPlane[1] * q, this._cachedClippingPlane[2] * q]);
            }
            const F = (function(O) {
              const q = u.bA();
              return q[0] = O[0] * -O[3], q[1] = O[1] * -O[3], q[2] = O[2] * -O[3], { center: q, radius: Math.sqrt(1 - O[3] * O[3]) };
            })(w);
            return bi((function(O, q, V) {
              const X = u.bA();
              u.b2(X, V, O);
              const te = u.bA();
              return u.by(te, O, X, q / u.b9(X)), te;
            })(F.center, F.radius, A));
          }
          getMatrixForModel(t, s) {
            const d = u.V.convert(t), g = 1 / u.bE, w = u.bj();
            return u.bJ(w, w, d.lng / 180 * Math.PI), u.bh(w, w, -d.lat / 180 * Math.PI), u.O(w, w, [0, 0, 1 + s / u.bE]), u.bh(w, w, 0.5 * Math.PI), u.Q(w, w, [g, g, g]), w;
          }
          getProjectionDataForCustomLayer(t = !0) {
            const s = this.getProjectionData({ overscaledTileID: new u.a2(0, 0, 0, 0, 0), applyGlobeMatrix: t });
            return s.tileMercatorCoords = [0, 0, 1, 1], s;
          }
          getFastPathSimpleProjectionMatrix(t) {
          }
        }
        class ka {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, s, d) {
            return this._helper.interpolatePadding(t, s, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, s, d = !0) {
            this._helper.resize(t, s, d);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, s) {
            this._helper.overrideNearFarZ(t, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(t, s) {
            this._globeness = t, this._globeLatitudeErrorCorrectionRadians = s, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(t) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (s, d) => this.currentTransform.defaultConstrain(s, d), this.applyConstrain = (s, d) => this._helper.applyConstrain(s, d), this._helper = new na({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (s, d) => this.defaultConstrain(s, d) }, t), this._globeness = 1, this._mercatorTransform = new ia(), this._verticalPerspectiveTransform = new no();
          }
          clone() {
            const t = new ka();
            return t._globeness = this._globeness, t._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, t.apply(this, !1), t;
          }
          apply(t, s) {
            this._helper.apply(t, s), this._mercatorTransform.apply(this, !1), this._verticalPerspectiveTransform.apply(this, !1, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(t) {
            const s = this._mercatorTransform.getProjectionData(t), d = this._verticalPerspectiveTransform.getProjectionData(t);
            return { mainMatrix: this.isGlobeRendering ? d.mainMatrix : s.mainMatrix, clippingPlane: d.clippingPlane, tileMercatorCoords: d.tileMercatorCoords, projectionTransition: t.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: s.fallbackMatrix };
          }
          isLocationOccluded(t) {
            return this.currentTransform.isLocationOccluded(t);
          }
          transformLightDirection(t) {
            return this.currentTransform.transformLightDirection(t);
          }
          getPixelScale() {
            return u.bu(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return u.bu(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(t, s, d) {
            const g = this._mercatorTransform.getPitchedTextCorrection(t, s, d), w = this._verticalPerspectiveTransform.getPitchedTextCorrection(t, s, d);
            return u.bu(g, w, this._globeness);
          }
          projectTileCoordinates(t, s, d, g) {
            return this.currentTransform.projectTileCoordinates(t, s, d, g);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, !1, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(t) {
            return this.currentTransform.calculateFogMatrix(t);
          }
          getVisibleUnwrappedCoordinates(t) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(t);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(t) {
            this._mercatorTransform.recalculateZoomAndCenter(t), this._verticalPerspectiveTransform.recalculateZoomAndCenter(t);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, s) {
            return this.currentTransform.lngLatToCameraDepth(t, s);
          }
          populateCache(t) {
            this._mercatorTransform.populateCache(t), this._verticalPerspectiveTransform.populateCache(t);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, s, d, g);
          }
          setLocationAtPoint(t, s) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(t, s), void this.apply(this._mercatorTransform, !1);
            this._verticalPerspectiveTransform.setLocationAtPoint(t, s), this.apply(this._verticalPerspectiveTransform, !1);
          }
          locationToScreenPoint(t, s) {
            return this.currentTransform.locationToScreenPoint(t, s);
          }
          screenPointToMercatorCoordinate(t, s) {
            return this.currentTransform.screenPointToMercatorCoordinate(t, s);
          }
          screenPointToLocation(t, s) {
            return this.currentTransform.screenPointToLocation(t, s);
          }
          isPointOnMapSurface(t, s) {
            return this.currentTransform.isPointOnMapSurface(t, s);
          }
          getRayDirectionFromPixel(t) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(t);
          }
          getMatrixForModel(t, s) {
            return this.currentTransform.getMatrixForModel(t, s);
          }
          getProjectionDataForCustomLayer(t = !0) {
            const s = this._mercatorTransform.getProjectionDataForCustomLayer(t);
            if (!this.isGlobeRendering) return s;
            const d = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(t);
            return d.fallbackMatrix = s.mainMatrix, d;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(t);
          }
        }
        class En {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(t, s) {
            const d = kc(t, s);
            return Math.abs(d.lng - s.center.lng) > 180 && (d.lng = s.center.lng + 179.5 * Math.sign(d.lng - s.center.lng)), { easingCenter: d, easingOffset: new u.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(t, s) {
            const d = t.around, g = s.screenPointToLocation(d);
            t.bearingDelta && s.setBearing(s.bearing + t.bearingDelta), t.pitchDelta && s.setPitch(s.pitch + t.pitchDelta), t.rollDelta && s.setRoll(s.roll + t.rollDelta);
            const w = s.zoom;
            t.zoomDelta && s.setZoom(s.zoom + t.zoomDelta);
            const T = s.zoom - w;
            if (T === 0) return;
            const C = u.bK(s.center.lng, g.lng), A = C / (Math.abs(C / 180) + 1), F = u.bK(s.center.lat, g.lat), O = s.getRayDirectionFromPixel(d), q = s.cameraPosition, V = -1 * u.b5(q, O), X = u.bA();
            u.b0(X, q, [O[0] * V, O[1] * V, O[2] * V]);
            const te = u.b7(X) - 1, he = Math.exp(0.5 * -Math.max(te - 0.3, 0)), pe = ji(s.worldSize, s.center.lat) / Math.min(s.width, s.height), fe = u.bx(pe, 0.9, 0.5, 1, 0.25), be = (1 - u.aq(-T)) * Math.min(he, fe), Ae = s.center.lat, xe = s.zoom, Ce = new u.V(s.center.lng + A * be, u.an(s.center.lat + F * be, -u.ao, u.ao));
            s.setLocationAtPoint(g, d);
            const Oe = s.center, ke = u.bx(Math.abs(C), 45, 85, 0, 1), je = u.bx(pe, 0.75, 0.35, 0, 1), at = Math.pow(Math.max(ke, je), 0.25), tt = u.bK(Oe.lng, Ce.lng), nt = u.bK(Oe.lat, Ce.lat);
            s.setCenter(new u.V(Oe.lng + tt * at, Oe.lat + nt * at).wrap()), s.setZoom(xe + sn(Ae, s.center.lat));
          }
          handleMapControlsPan(t, s, d) {
            if (!t.panDelta) return;
            const g = s.center.lat, w = s.zoom;
            s.setCenter(kc(t.panDelta, s).wrap()), s.setZoom(w + sn(g, s.center.lat));
          }
          cameraForBoxAndBearing(t, s, d, g, w) {
            const T = xl(t, s, d, g, w), C = s.left / w.width * 2 - 1, A = (w.width - s.right) / w.width * 2 - 1, F = s.top / w.height * -2 + 1, O = (w.height - s.bottom) / w.height * -2 + 1, q = u.bK(d.getWest(), d.getEast()) < 0, V = q ? d.getEast() : d.getWest(), X = q ? d.getWest() : d.getEast(), te = Math.max(d.getNorth(), d.getSouth()), he = Math.min(d.getNorth(), d.getSouth()), pe = V + 0.5 * u.bK(V, X), fe = te + 0.5 * u.bK(te, he), be = w.clone();
            be.setCenter(T.center), be.setBearing(T.bearing), be.setPitch(0), be.setRoll(0), be.setZoom(T.zoom);
            const Ae = be.modelViewProjectionMatrix, xe = [Xr(d.getNorthWest()), Xr(d.getNorthEast()), Xr(d.getSouthWest()), Xr(d.getSouthEast()), Xr(new u.V(X, fe)), Xr(new u.V(V, fe)), Xr(new u.V(pe, te)), Xr(new u.V(pe, he))], Ce = Xr(T.center);
            let Oe = Number.POSITIVE_INFINITY;
            for (const ke of xe) C < 0 && (Oe = En.getLesserNonNegativeNonNull(Oe, En.solveVectorScale(ke, Ce, Ae, "x", C))), A > 0 && (Oe = En.getLesserNonNegativeNonNull(Oe, En.solveVectorScale(ke, Ce, Ae, "x", A))), F > 0 && (Oe = En.getLesserNonNegativeNonNull(Oe, En.solveVectorScale(ke, Ce, Ae, "y", F))), O < 0 && (Oe = En.getLesserNonNegativeNonNull(Oe, En.solveVectorScale(ke, Ce, Ae, "y", O)));
            if (Number.isFinite(Oe) && Oe !== 0) return T.zoom = be.zoom + u.at(Oe), T;
            ws();
          }
          handleJumpToCenterZoom(t, s) {
            const d = t.center.lat, g = t.applyConstrain(s.center ? u.V.convert(s.center) : t.center, t.zoom).center;
            t.setCenter(g.wrap());
            const w = s.zoom !== void 0 ? +s.zoom : t.zoom + sn(d, g.lat);
            t.zoom !== w && t.setZoom(w);
          }
          handleEaseTo(t, s) {
            const d = t.zoom, g = t.center, w = t.padding, T = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, C = { roll: s.roll === void 0 ? t.roll : s.roll, pitch: s.pitch === void 0 ? t.pitch : s.pitch, bearing: s.bearing === void 0 ? t.bearing : s.bearing }, A = s.zoom !== void 0, F = !t.isPaddingEqual(s.padding);
            let O = !1;
            const q = s.center ? u.V.convert(s.center) : g, V = t.applyConstrain(q, d).center;
            Os(t, V);
            const X = t.clone();
            X.setCenter(V), X.setZoom(A ? +s.zoom : d + sn(g.lat, q.lat)), X.setBearing(s.bearing);
            const te = new u.P(u.an(t.centerPoint.x + s.offsetAsPoint.x, 0, t.width), u.an(t.centerPoint.y + s.offsetAsPoint.y, 0, t.height));
            X.setLocationAtPoint(V, te);
            const he = (s.offset && s.offsetAsPoint.mag()) > 0 ? X.center : V, pe = A ? +s.zoom : d + sn(g.lat, he.lat), fe = d + sn(g.lat, 0), be = pe + sn(he.lat, 0), Ae = u.bK(g.lng, he.lng), xe = u.bK(g.lat, he.lat), Ce = u.aq(be - fe);
            return O = pe !== d, { easeFunc: (Oe) => {
              if (u.bo(T, C) || Sc({ startEulerAngles: T, endEulerAngles: C, tr: t, k: Oe, useSlerp: T.roll != C.roll }), F && t.interpolatePadding(w, s.padding, Oe), s.around) u.w("Easing around a point is not supported under globe projection."), t.setLocationAtPoint(s.around, s.aroundPoint);
              else {
                const ke = be > fe ? Math.min(2, Ce) : Math.max(0.5, Ce), je = Math.pow(ke, 1 - Oe), at = gu(g, Ae, xe, Oe * je);
                t.setCenter(at.wrap());
              }
              if (O) {
                const ke = u.G.number(fe, be, Oe) + sn(0, t.center.lat);
                t.setZoom(ke);
              }
            }, isZooming: O, elevationCenter: he };
          }
          handleFlyTo(t, s) {
            const d = s.zoom !== void 0, g = t.center, w = t.zoom, T = t.padding, C = !t.isPaddingEqual(s.padding), A = t.applyConstrain(u.V.convert(s.center || s.locationAtOffset), w).center, F = d ? +s.zoom : t.zoom + sn(t.center.lat, A.lat), O = t.clone();
            O.setCenter(A), O.setZoom(F), O.setBearing(s.bearing);
            const q = new u.P(u.an(t.centerPoint.x + s.offsetAsPoint.x, 0, t.width), u.an(t.centerPoint.y + s.offsetAsPoint.y, 0, t.height));
            O.setLocationAtPoint(A, q);
            const V = O.center;
            Os(t, V);
            const X = (function(xe, Ce, Oe) {
              const ke = Xr(Ce), je = Xr(Oe), at = u.b5(ke, je), tt = Math.acos(at), nt = xi(xe);
              return tt / (2 * Math.PI) * nt;
            })(t, g, V), te = w + sn(g.lat, 0), he = F + sn(V.lat, 0), pe = u.aq(he - te);
            let fe;
            if (typeof s.minZoom == "number") {
              const xe = +s.minZoom + sn(V.lat, 0), Ce = Math.min(xe, te, he) + sn(0, V.lat), Oe = t.applyConstrain(V, Ce).zoom + sn(V.lat, 0);
              fe = u.aq(Oe - te);
            }
            const be = u.bK(g.lng, V.lng), Ae = u.bK(g.lat, V.lat);
            return { easeFunc: (xe, Ce, Oe, ke) => {
              const je = gu(g, be, Ae, Oe);
              C && t.interpolatePadding(T, s.padding, xe);
              const at = xe === 1 ? V : je;
              t.setCenter(at.wrap());
              const tt = te + u.at(Ce);
              t.setZoom(xe === 1 ? F : tt + sn(0, at.lat));
            }, scaleOfZoom: pe, targetCenter: V, scaleOfMinZoom: fe, pixelPathLength: X };
          }
          static solveVectorScale(t, s, d, g, w) {
            const T = g === "x" ? [d[0], d[4], d[8], d[12]] : [d[1], d[5], d[9], d[13]], C = [d[3], d[7], d[11], d[15]], A = t[0] * T[0] + t[1] * T[1] + t[2] * T[2], F = t[0] * C[0] + t[1] * C[1] + t[2] * C[2], O = s[0] * T[0] + s[1] * T[1] + s[2] * T[2], q = s[0] * C[0] + s[1] * C[1] + s[2] * C[2];
            return O + w * F === A + w * q || C[3] * (A - O) + T[3] * (q - F) + A * q == O * F ? null : (O + T[3] - w * q - w * C[3]) / (O - A - w * q + w * F);
          }
          static getLesserNonNegativeNonNull(t, s) {
            return s !== null && s >= 0 && s < t ? s : t;
          }
        }
        class _u {
          constructor(t) {
            this._globe = t, this._mercatorCameraHelper = new vi(), this._verticalPerspectiveCameraHelper = new En();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(t, s) {
            return this.currentHelper.handlePanInertia(t, s);
          }
          handleMapControlsRollPitchBearingZoom(t, s) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(t, s);
          }
          handleMapControlsPan(t, s, d) {
            this.currentHelper.handleMapControlsPan(t, s, d);
          }
          cameraForBoxAndBearing(t, s, d, g, w) {
            return this.currentHelper.cameraForBoxAndBearing(t, s, d, g, w);
          }
          handleJumpToCenterZoom(t, s) {
            this.currentHelper.handleJumpToCenterZoom(t, s);
          }
          handleEaseTo(t, s) {
            return this.currentHelper.handleEaseTo(t, s);
          }
          handleFlyTo(t, s) {
            return this.currentHelper.handleFlyTo(t, s);
          }
        }
        const sa = (b, t) => u.B(b, t && t.filter(((s) => s.identifier !== "source.canvas"))), Oo = u.bO();
        class Ia extends u.E {
          constructor(t, s = {}) {
            var d, g;
            super(), this._rtlPluginLoaded = () => {
              for (const T in this.tileManagers) {
                const C = this.tileManagers[T].getSource().type;
                C !== "vector" && C !== "geojson" || this.tileManagers[T].reload();
              }
            }, this.map = t, this.dispatcher = new fr(yi(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", ((T, C) => this.getGlyphs(T, C))), this.dispatcher.registerMessageHandler("GI", ((T, C) => this.getImages(T, C))), this.dispatcher.registerMessageHandler("GDA", ((T, C) => this.getDashes(T, C))), this.imageManager = new Ie(), this.imageManager.setEventedParent(this);
            const w = ((d = t._container) === null || d === void 0 ? void 0 : d.lang) || typeof document < "u" && ((g = document.documentElement) === null || g === void 0 ? void 0 : g.lang) || void 0;
            this.glyphManager = new Ge(t._requestManager, s.localIdeographFontFamily, w), this.lineAtlas = new zt(256, 512), this.crossTileSymbolIndex = new Xn(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", u.bP()), re().on(Fe, this._rtlPluginLoaded), this.on("data", ((T) => {
              if (T.dataType !== "source" || T.sourceDataType !== "metadata") return;
              const C = this.tileManagers[T.sourceId];
              if (!C) return;
              const A = C.getSource();
              if (A && A.vectorLayerIds) for (const F in this._layers) {
                const O = this._layers[F];
                O.source === A.id && this._validateLayer(O);
              }
            }));
          }
          _setInitialValues() {
            var t;
            this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new u.bQ(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = !1, this._changed = !1, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = !1, this._updatedPaintProps = {}, this._layerOrderChanged = !1, this.crossTileSymbolIndex = new (((t = this.crossTileSymbolIndex) === null || t === void 0 ? void 0 : t.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
          }
          setGlobalStateProperty(t, s) {
            var d, g, w;
            this._checkLoaded();
            const T = s === null ? (w = (g = (d = this.stylesheet.state) === null || d === void 0 ? void 0 : d[t]) === null || g === void 0 ? void 0 : g.default) !== null && w !== void 0 ? w : null : s;
            if (u.bR(T, this._globalState[t])) return this;
            this._globalState[t] = T, this._applyGlobalStateChanges([t]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(t) {
            this._checkLoaded();
            const s = [];
            for (const d in t) !u.bR(this._globalState[d], t[d].default) && (s.push(d), this._globalState[d] = t[d].default);
            this._applyGlobalStateChanges(s);
          }
          _applyGlobalStateChanges(t) {
            if (t.length === 0) return;
            const s = /* @__PURE__ */ new Set(), d = {};
            for (const g of t) {
              d[g] = this._globalState[g];
              for (const w in this._layers) {
                const T = this._layers[w], C = T.getLayoutAffectingGlobalStateRefs(), A = T.getPaintAffectingGlobalStateRefs(), F = T.getVisibilityAffectingGlobalStateRefs();
                if (C.has(g) && s.add(T.source), A.has(g)) for (const { name: O, value: q } of A.get(g)) this._updatePaintProperty(T, O, q);
                F?.has(g) && (T.recalculateVisibility(), this._updateLayer(T));
              }
            }
            this.dispatcher.broadcast("UGS", d);
            for (const g in this.tileManagers) s.has(g) && (this._reloadSource(g), this._changed = !0);
          }
          loadURL(t, s = {}, d) {
            this.fire(new u.l("dataloading", { dataType: "style" })), s.validate = typeof s.validate != "boolean" || s.validate;
            const g = this.map._requestManager.transformRequest(t, "Style");
            this._loadStyleRequest = new AbortController();
            const w = this._loadStyleRequest;
            u.j(g, this._loadStyleRequest).then(((T) => {
              this._loadStyleRequest = null, this._load(T.data, s, d);
            })).catch(((T) => {
              this._loadStyleRequest = null, T && !w.signal.aborted && this.fire(new u.k(T));
            }));
          }
          loadJSON(t, s = {}, d) {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), le.frameAsync(this._frameRequest, this.map._ownerWindow).then((() => {
              this._frameRequest = null, s.validate = s.validate !== !1, this._load(t, s, d);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._load(Oo, { validate: !1 });
          }
          _load(t, s, d) {
            var g, w;
            let T = s.transformStyle ? s.transformStyle(d, t) : t;
            if (!s.validate || !sa(this, u.C(T))) {
              T = Object.assign({}, T), this._loaded = !0, this.stylesheet = T;
              for (const C in T.sources) this.addSource(C, T.sources[C], { validate: !1 });
              T.sprite ? this._loadSprite(T.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(T.glyphs), this._createLayers(), this.light = new ft(this.stylesheet.light), this._setProjectionInternal(((g = this.stylesheet.projection) === null || g === void 0 ? void 0 : g.type) || "mercator"), this.sky = new Zt(this.stylesheet.sky), this.map.setTerrain((w = this.stylesheet.terrain) !== null && w !== void 0 ? w : null), this.fire(new u.l("data", { dataType: "style" })), this.fire(new u.l("style.load"));
            }
          }
          _createLayers() {
            var t, s, d;
            const g = u.bS(this.stylesheet.layers);
            this.setGlobalState((t = this.stylesheet.state) !== null && t !== void 0 ? t : null), this.dispatcher.broadcast("SL", g), this._order = g.map(((w) => w.id)), this._layers = {}, this._serializedLayers = null;
            for (const w of g) {
              const T = u.bT(w, this._globalState);
              if (T.setEventedParent(this, { layer: { id: w.id } }), this._layers[w.id] = T, u.bU(T) && this.tileManagers[T.source]) {
                const C = (d = (s = w.paint) === null || s === void 0 ? void 0 : s["raster-fade-duration"]) !== null && d !== void 0 ? d : T.paint.get("raster-fade-duration");
                this.tileManagers[T.source].setRasterFadeDuration(C);
              }
            }
          }
          _loadSprite(t, s = !1, d = void 0) {
            this.imageManager.setLoaded(!1);
            const g = new AbortController();
            let w;
            this._spriteRequest = g, (function(T, C, A, F) {
              return u._(this, void 0, void 0, (function* () {
                const O = se(T), q = A > 1 ? "@2x" : "", V = {}, X = {};
                for (const { id: te, url: he } of O) {
                  const pe = C.transformRequest(ge(he, q, ".json"), "SpriteJSON");
                  V[te] = u.j(pe, F);
                  const fe = C.transformRequest(ge(he, q, ".png"), "SpriteImage");
                  X[te] = ut.getImage(fe, F);
                }
                return yield Promise.all([...Object.values(V), ...Object.values(X)]), (function(te, he) {
                  return u._(this, void 0, void 0, (function* () {
                    const pe = {};
                    for (const fe in te) {
                      pe[fe] = {};
                      const be = le.getImageCanvasContext((yield he[fe]).data), Ae = (yield te[fe]).data;
                      for (const xe in Ae) {
                        const { width: Ce, height: Oe, x: ke, y: je, sdf: at, pixelRatio: tt, stretchX: nt, stretchY: it, content: St, textFitWidth: It, textFitHeight: _t } = Ae[xe];
                        pe[fe][xe] = { data: null, pixelRatio: tt, sdf: at, stretchX: nt, stretchY: it, content: St, textFitWidth: It, textFitHeight: _t, spriteData: { width: Ce, height: Oe, x: ke, y: je, context: be } };
                      }
                    }
                    return pe;
                  }));
                })(V, X);
              }));
            })(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((T) => {
              if (this._spriteRequest = null, T) for (const C in T) {
                this._spritesImagesIds[C] = [];
                const A = this._spritesImagesIds[C] ? this._spritesImagesIds[C].filter(((F) => !(F in T))) : [];
                for (const F of A) this.imageManager.removeImage(F), this._changedImages[F] = !0;
                for (const F in T[C]) {
                  const O = C === "default" ? F : `${C}:${F}`;
                  this._spritesImagesIds[C].push(O), O in this.imageManager.images ? this.imageManager.updateImage(O, T[C][F], !1) : this.imageManager.addImage(O, T[C][F]), s && (this._changedImages[O] = !0);
                }
              }
            })).catch(((T) => {
              this._spriteRequest = null, w = T, g.signal.aborted || this.fire(new u.k(w));
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), s && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" })), d && d(w);
            }));
          }
          _unloadSprite() {
            for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          _validateLayer(t) {
            const s = this.tileManagers[t.source];
            if (!s) return;
            const d = t.sourceLayer;
            if (!d) return;
            const g = s.getSource();
            (g.type === "geojson" || g.vectorLayerIds && g.vectorLayerIds.indexOf(d) === -1) && this.fire(new u.k(new Error(`Source layer "${d}" does not exist on source "${g.id}" as specified by style layer "${t.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const t in this.tileManagers) if (!this.tileManagers[t].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t, s = !1) {
            const d = this._serializedAllLayers();
            if (!t || t.length === 0) return Object.values(s ? u.bV(d) : d);
            const g = [];
            for (const w of t) if (d[w]) {
              const T = s ? u.bV(d[w]) : d[w];
              g.push(T);
            }
            return g;
          }
          _serializedAllLayers() {
            let t = this._serializedLayers;
            if (t) return t;
            t = this._serializedLayers = {};
            const s = Object.keys(this._layers);
            for (const d of s) {
              const g = this._layers[d];
              g.type !== "custom" && (t[d] = g.serialize());
            }
            return t;
          }
          hasTransitions() {
            var t, s, d;
            if (!((t = this.light) === null || t === void 0) && t.hasTransition() || !((s = this.sky) === null || s === void 0) && s.hasTransition() || !((d = this.projection) === null || d === void 0) && d.hasTransition()) return !0;
            for (const g in this.tileManagers) if (this.tileManagers[g].hasTransition()) return !0;
            for (const g in this._layers) if (this._layers[g].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(t) {
            if (!this._loaded) return;
            const s = this._changed;
            if (s) {
              const g = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              (g.length || w.length) && this._updateWorkerLayers(g, w);
              for (const T in this._updatedSources) {
                const C = this._updatedSources[T];
                if (C === "reload") this._reloadSource(T);
                else {
                  if (C !== "clear") throw new Error(`Invalid action ${C}`);
                  this._clearSource(T);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const T in this._updatedPaintProps) this._layers[T].updateTransitions(t);
              this.light.updateTransitions(t), this.sky.updateTransitions(t), this._resetUpdates();
            }
            const d = {};
            for (const g in this.tileManagers) {
              const w = this.tileManagers[g];
              d[g] = w.used, w.used = !1;
            }
            for (const g of this._order) {
              const w = this._layers[g];
              w.recalculate(t, this._availableImages), !w.isHidden(t.zoom) && w.source && (this.tileManagers[w.source].used = !0);
            }
            for (const g in d) {
              const w = this.tileManagers[g];
              !!d[g] != !!w.used && w.fire(new u.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: g }));
            }
            this.light.recalculate(t), this.sky.recalculate(t), this.projection.recalculate(t), this.z = t.zoom, s && this.fire(new u.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t = Object.keys(this._changedImages);
            if (t.length) {
              for (const s in this.tileManagers) this.tileManagers[s].reloadTilesForDependencies(["icons", "patterns"], t);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t in this.tileManagers) this.tileManagers[t].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(t, s) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t, !1), removedIds: s });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(t, s = {}) {
            var d;
            this._checkLoaded();
            const g = this.serialize();
            if (t = s.transformStyle ? s.transformStyle(g, t) : t, ((d = s.validate) === null || d === void 0 || d) && sa(this, u.C(t))) return !1;
            (t = u.bV(t)).layers = u.bS(t.layers);
            const w = u.bW(g, t), T = this._getOperationsToPerform(w);
            if (T.unimplemented.length > 0) throw new Error(`Unimplemented: ${T.unimplemented.join(", ")}.`);
            if (T.operations.length === 0) return !1;
            for (const C of T.operations) C();
            return this.stylesheet = t, this._serializedLayers = null, this.fire(new u.l("style.load", { style: this })), !0;
          }
          _getOperationsToPerform(t) {
            const s = [], d = [];
            for (const g of t) switch (g.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                s.push((() => this.addLayer.apply(this, g.args)));
                break;
              case "removeLayer":
                s.push((() => this.removeLayer.apply(this, g.args)));
                break;
              case "setPaintProperty":
                s.push((() => this.setPaintProperty.apply(this, g.args)));
                break;
              case "setLayoutProperty":
                s.push((() => this.setLayoutProperty.apply(this, g.args)));
                break;
              case "setFilter":
                s.push((() => this.setFilter.apply(this, g.args)));
                break;
              case "addSource":
                s.push((() => this.addSource.apply(this, g.args)));
                break;
              case "removeSource":
                s.push((() => this.removeSource.apply(this, g.args)));
                break;
              case "setLayerZoomRange":
                s.push((() => this.setLayerZoomRange.apply(this, g.args)));
                break;
              case "setLight":
                s.push((() => this.setLight.apply(this, g.args)));
                break;
              case "setGeoJSONSourceData":
                s.push((() => this.setGeoJSONSourceData.apply(this, g.args)));
                break;
              case "setGlyphs":
                s.push((() => this.setGlyphs.apply(this, g.args)));
                break;
              case "setSprite":
                s.push((() => this.setSprite.apply(this, g.args)));
                break;
              case "setTerrain":
                s.push((() => this.map.setTerrain.apply(this, g.args)));
                break;
              case "setSky":
                s.push((() => this.setSky.apply(this, g.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, g.args);
                break;
              case "setGlobalState":
                s.push((() => this.setGlobalState.apply(this, g.args)));
                break;
              case "setTransition":
                s.push((() => {
                }));
                break;
              default:
                d.push(g.command);
            }
            return { operations: s, unimplemented: d };
          }
          addImage(t, s) {
            if (this.getImage(t)) return this.fire(new u.k(new Error(`An image named "${t}" already exists.`)));
            this.imageManager.addImage(t, s), this._afterImageUpdated(t);
          }
          updateImage(t, s) {
            this.imageManager.updateImage(t, s);
          }
          getImage(t) {
            return this.imageManager.getImage(t);
          }
          removeImage(t) {
            if (!this.getImage(t)) return this.fire(new u.k(new Error(`An image named "${t}" does not exist.`)));
            this.imageManager.removeImage(t), this._afterImageUpdated(t);
          }
          _afterImageUpdated(t) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t, s, d = {}) {
            if (this._checkLoaded(), this.tileManagers[t] !== void 0) throw new Error(`Source "${t}" already exists.`);
            if (!s.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(u.C.source, `sources.${t}`, s, null, d)) return;
            this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0);
            const g = this.tileManagers[t] = new Wr(t, s, this.dispatcher);
            g.style = this, g.setEventedParent(this, (() => ({ isSourceLoaded: g.loaded(), source: g.serialize(), sourceId: t }))), g.onAdd(this.map), this._changed = !0;
          }
          removeSource(t) {
            if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error("There is no source with this ID");
            for (const d in this._layers) if (this._layers[d].source === t) return this.fire(new u.k(new Error(`Source "${t}" cannot be removed while layer "${d}" is using it.`)));
            const s = this.tileManagers[t];
            delete this.tileManagers[t], delete this._updatedSources[t], s.fire(new u.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), s.setEventedParent(null), s.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(t, s) {
            if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error(`There is no source with this ID=${t}`);
            const d = this.tileManagers[t].getSource();
            if (d.type !== "geojson") throw new Error(`geojsonSource.type is ${d.type}, which is !== 'geojson`);
            d.setData(s), this._changed = !0;
          }
          getSource(t) {
            return this.tileManagers[t] && this.tileManagers[t].getSource();
          }
          addLayer(t, s, d = {}) {
            this._checkLoaded();
            const g = t.id;
            if (this.getLayer(g)) return void this.fire(new u.k(new Error(`Layer "${g}" already exists on this map.`)));
            let w;
            if (t.type === "custom") {
              if (sa(this, u.bX(t))) return;
              w = u.bT(t, this._globalState);
            } else {
              if ("source" in t && typeof t.source == "object" && (this.addSource(g, t.source), t = u.bV(t), t = u.e(t, { source: g })), this._validate(u.C.layer, `layers.${g}`, t, { arrayIndex: -1 }, d)) return;
              w = u.bT(t, this._globalState), this._validateLayer(w), w.setEventedParent(this, { layer: { id: g } });
            }
            const T = s ? this._order.indexOf(s) : this._order.length;
            if (s && T === -1) this.fire(new u.k(new Error(`Cannot add layer "${g}" before non-existing layer "${s}".`)));
            else {
              if (this._order.splice(T, 0, g), this._layerOrderChanged = !0, this._layers[g] = w, this._removedLayers[g] && w.source && w.type !== "custom") {
                const C = this._removedLayers[g];
                delete this._removedLayers[g], C.type !== w.type ? this._updatedSources[w.source] = "clear" : (this._updatedSources[w.source] = "reload", this.tileManagers[w.source].pause());
              }
              this._updateLayer(w), w.onAdd && w.onAdd(this.map);
            }
          }
          moveLayer(t, s) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new u.k(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
            if (t === s) return;
            const d = this._order.indexOf(t);
            this._order.splice(d, 1);
            const g = s ? this._order.indexOf(s) : this._order.length;
            s && g === -1 ? this.fire(new u.k(new Error(`Cannot move layer "${t}" before non-existing layer "${s}".`))) : (this._order.splice(g, 0, t), this._layerOrderChanged = !0);
          }
          removeLayer(t) {
            this._checkLoaded();
            const s = this._layers[t];
            if (!s) return void this.fire(new u.k(new Error(`Cannot remove non-existing layer "${t}".`)));
            s.setEventedParent(null);
            const d = this._order.indexOf(t);
            this._order.splice(d, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = s, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], s.onRemove && s.onRemove(this.map);
          }
          getLayer(t) {
            return this._layers[t];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t) {
            return t in this._layers;
          }
          setLayerZoomRange(t, s, d) {
            this._checkLoaded();
            const g = this.getLayer(t);
            g ? g.minzoom === s && g.maxzoom === d || (s != null && (g.minzoom = s), d != null && (g.maxzoom = d), this._updateLayer(g)) : this.fire(new u.k(new Error(`Cannot set the zoom range of non-existing layer "${t}".`)));
          }
          setFilter(t, s, d = {}) {
            this._checkLoaded();
            const g = this.getLayer(t);
            if (g) {
              if (!u.bR(g.filter, s)) return s == null ? (g.setFilter(void 0), void this._updateLayer(g)) : void (this._validate(u.C.filter, `layers.${g.id}.filter`, s, null, d) || (g.setFilter(u.bV(s)), this._updateLayer(g)));
            } else this.fire(new u.k(new Error(`Cannot filter non-existing layer "${t}".`)));
          }
          getFilter(t) {
            return u.bV(this.getLayer(t).filter);
          }
          setLayoutProperty(t, s, d, g = {}) {
            this._checkLoaded();
            const w = this.getLayer(t);
            w ? u.bR(w.getLayoutProperty(s), d) || (w.setLayoutProperty(s, d, g), this._updateLayer(w)) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${t}".`)));
          }
          getLayoutProperty(t, s) {
            const d = this.getLayer(t);
            if (d) return d.getLayoutProperty(s);
            this.fire(new u.k(new Error(`Cannot get style of non-existing layer "${t}".`)));
          }
          setPaintProperty(t, s, d, g = {}) {
            this._checkLoaded();
            const w = this.getLayer(t);
            w ? u.bR(w.getPaintProperty(s), d) || this._updatePaintProperty(w, s, d, g) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${t}".`)));
          }
          _updatePaintProperty(t, s, d, g = {}) {
            t.setPaintProperty(s, d, g) && this._updateLayer(t), u.bU(t) && s === "raster-fade-duration" && this.tileManagers[t.source].setRasterFadeDuration(d), this._changed = !0, this._updatedPaintProps[t.id] = !0, this._serializedLayers = null;
          }
          getPaintProperty(t, s) {
            return this.getLayer(t).getPaintProperty(s);
          }
          setFeatureState(t, s) {
            this._checkLoaded();
            const d = t.source, g = t.sourceLayer, w = this.tileManagers[d];
            if (w === void 0) return void this.fire(new u.k(new Error(`The source '${d}' does not exist in the map's style.`)));
            const T = w.getSource().type;
            T === "geojson" && g ? this.fire(new u.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : T !== "vector" || g ? (t.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), w.setFeatureState(g, t.id, s)) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(t, s) {
            this._checkLoaded();
            const d = t.source, g = this.tileManagers[d];
            if (g === void 0) return void this.fire(new u.k(new Error(`The source '${d}' does not exist in the map's style.`)));
            const w = g.getSource().type, T = w === "vector" ? t.sourceLayer : void 0;
            w !== "vector" || T ? s && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new u.k(new Error("A feature id is required to remove its specific state property."))) : g.removeFeatureState(T, t.id, s) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(t) {
            this._checkLoaded();
            const s = t.source, d = t.sourceLayer, g = this.tileManagers[s];
            if (g !== void 0) return g.getSource().type !== "vector" || d ? (t.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), g.getFeatureState(d, t.id)) : void this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new u.k(new Error(`The source '${s}' does not exist in the map's style.`)));
          }
          getTransition() {
            return u.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const t = u.bY(this.tileManagers, ((w) => w.serialize())), s = this._serializeByIds(this._order, !0), d = this.map.getTerrain() || void 0, g = this.stylesheet;
            return u.bZ({ version: g.version, name: g.name, metadata: g.metadata, light: g.light, sky: g.sky, center: g.center, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, sprite: g.sprite, glyphs: g.glyphs, transition: g.transition, projection: g.projection, sources: t, layers: s, terrain: d }, ((w) => w !== void 0));
          }
          _updateLayer(t) {
            this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && this.tileManagers[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.tileManagers[t.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(t) {
            const s = (T) => this._layers[T].type === "fill-extrusion", d = {}, g = [];
            for (let T = this._order.length - 1; T >= 0; T--) {
              const C = this._order[T];
              if (s(C)) {
                d[C] = T;
                for (const A of t) {
                  const F = A[C];
                  if (F) for (const O of F) g.push(O);
                }
              }
            }
            g.sort(((T, C) => C.intersectionZ - T.intersectionZ));
            const w = [];
            for (let T = this._order.length - 1; T >= 0; T--) {
              const C = this._order[T];
              if (s(C)) for (let A = g.length - 1; A >= 0; A--) {
                const F = g[A].feature;
                if (d[F.layer.id] < T) break;
                w.push(F), g.pop();
              }
              else for (const A of t) {
                const F = A[C];
                if (F) for (const O of F) w.push(O.feature);
              }
            }
            return w;
          }
          queryRenderedFeatures(t, s, d) {
            s && s.filter && this._validate(u.C.filter, "queryRenderedFeatures.filter", s.filter, null, s);
            const g = {};
            if (s && s.layers) {
              if (!(Array.isArray(s.layers) || s.layers instanceof Set)) return this.fire(new u.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const F of s.layers) {
                const O = this._layers[F];
                if (!O) return this.fire(new u.k(new Error(`The layer '${F}' does not exist in the map's style and cannot be queried for features.`))), [];
                g[O.source] = !0;
              }
            }
            const w = [];
            s.availableImages = this._availableImages;
            const T = this._serializedAllLayers(), C = s.layers instanceof Set ? s.layers : Array.isArray(s.layers) ? new Set(s.layers) : null, A = Object.assign(Object.assign({}, s), { layers: C, globalState: this._globalState });
            for (const F in this.tileManagers) s.layers && !g[F] || w.push(br(this.tileManagers[F], this._layers, T, t, A, d, this.map.terrain ? (O, q, V) => this.map.terrain.getElevation(O, q, V) : void 0));
            return this.placement && w.push((function(F, O, q, V, X, te, he) {
              const pe = {}, fe = te.queryRenderedSymbols(V), be = [];
              for (const Ae of Object.keys(fe).map(Number)) be.push(he[Ae]);
              be.sort(ur);
              for (const Ae of be) {
                const xe = Ae.featureIndex.lookupSymbolFeatures(fe[Ae.bucketInstanceId], O, Ae.bucketIndex, Ae.sourceLayerIndex, { filterSpec: X.filter, globalState: X.globalState }, X.layers, X.availableImages, F);
                for (const Ce in xe) {
                  const Oe = pe[Ce] = pe[Ce] || [], ke = xe[Ce];
                  ke.sort(((je, at) => {
                    const tt = Ae.featureSortOrder;
                    if (tt) {
                      const nt = tt.indexOf(je.featureIndex);
                      return tt.indexOf(at.featureIndex) - nt;
                    }
                    return at.featureIndex - je.featureIndex;
                  }));
                  for (const je of ke) Oe.push(je);
                }
              }
              return (function(Ae, xe, Ce) {
                for (const Oe in Ae) for (const ke of Ae[Oe]) rr(ke, Ce[xe[Oe].source]);
                return Ae;
              })(pe, F, q);
            })(this._layers, T, this.tileManagers, t, A, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(w);
          }
          querySourceFeatures(t, s) {
            s?.filter && this._validate(u.C.filter, "querySourceFeatures.filter", s.filter, null, s);
            const d = this.tileManagers[t];
            return d ? (function(g, w) {
              const T = g.getRenderableIds().map(((F) => g.getTileByID(F))), C = [], A = {};
              for (let F = 0; F < T.length; F++) {
                const O = T[F], q = O.tileID.canonical.key;
                A[q] || (A[q] = !0, O.querySourceFeatures(C, w));
              }
              return C;
            })(d, s ? Object.assign(Object.assign({}, s), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t, s = {}) {
            this._checkLoaded();
            const d = this.light.getLight();
            let g = !1;
            for (const T in t) if (!u.bR(t[T], d[T])) {
              g = !0;
              break;
            }
            if (!g) return;
            const w = { now: _e(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t, s), this.light.updateTransitions(w);
          }
          getProjection() {
            var t;
            return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.projection;
          }
          setProjection(t) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === t.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = t, this._setProjectionInternal(t.type);
          }
          getSky() {
            var t;
            return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.sky;
          }
          setSky(t, s = {}) {
            this._checkLoaded();
            const d = this.getSky();
            let g = !1;
            if (!t && !d) return;
            if (t && !d) g = !0;
            else if (!t && d) g = !0;
            else for (const T in t) if (!u.bR(t[T], d[T])) {
              g = !0;
              break;
            }
            if (!g) return;
            const w = { now: _e(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = t, this.sky.setSky(t, s), this.sky.updateTransitions(w);
          }
          _setProjectionInternal(t) {
            const s = (function(d, g) {
              const w = { constrainOverride: g };
              if (Array.isArray(d)) {
                const T = new Tc({ type: d });
                return { projection: T, transform: new ka(w), cameraHelper: new _u(T) };
              }
              switch (d) {
                case "mercator":
                  return { projection: new rn(), transform: new ia(w), cameraHelper: new vi() };
                case "globe": {
                  const T = new Tc({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: T, transform: new ka(w), cameraHelper: new _u(T) };
                }
                case "vertical-perspective":
                  return { projection: new pu(), transform: new no(w), cameraHelper: new En() };
                default:
                  return u.w(`Unknown projection name: ${d}. Falling back to mercator projection.`), { projection: new rn(), transform: new ia(w), cameraHelper: new vi() };
              }
            })(t, this.map.transformConstrain);
            this.projection = s.projection, this.map.migrateProjection(s.transform, s.cameraHelper);
            for (const d in this.tileManagers) this.tileManagers[d].reload();
          }
          _validate(t, s, d, g, w = {}) {
            return (!w || w.validate !== !1) && sa(this, t.call(u.C, u.e({ key: s, style: this.serialize(), value: d, styleSpec: u.u }, g)));
          }
          _remove(t = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), re().off(Fe, this._rtlPluginLoaded);
            for (const s in this._layers) this._layers[s].setEventedParent(null);
            for (const s in this.tileManagers) {
              const d = this.tileManagers[s];
              d.setEventedParent(null), d.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
          }
          _clearSource(t) {
            this.tileManagers[t].clearTiles();
          }
          _reloadSource(t) {
            this.tileManagers[t].resume(), this.tileManagers[t].reload();
          }
          _updateSources(t) {
            for (const s in this.tileManagers) this.tileManagers[s].update(t, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t in this.tileManagers) this._reloadSource(t);
          }
          _updatePlacement(t, s, d, g, w = !1) {
            let T = !1, C = !1;
            const A = {};
            for (const F of this._order) {
              const O = this._layers[F];
              if (O.type !== "symbol") continue;
              if (!A[O.source]) {
                const V = this.tileManagers[O.source];
                A[O.source] = V.getRenderableIds(!0).map(((X) => V.getTileByID(X))).sort(((X, te) => te.tileID.overscaledZ - X.tileID.overscaledZ || (X.tileID.isLessThan(te.tileID) ? -1 : 1)));
              }
              const q = this.crossTileSymbolIndex.addLayer(O, A[O.source], t.center.lng);
              T = T || q;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((w = w || this._layerOrderChanged || d === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(_e(), t.zoom)) && (this.pauseablePlacement = new Wi(t, this.map.terrain, this._order, w, s, d, g, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, A), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(_e()), C = !0), T && this.pauseablePlacement.placement.setStale()), C || T) for (const F of this._order) {
              const O = this._layers[F];
              O.type === "symbol" && this.placement.updateLayerOpacities(O, A[O.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(_e());
          }
          _releaseSymbolFadeTiles() {
            for (const t in this.tileManagers) this.tileManagers[t].releaseSymbolFadeTiles();
          }
          getImages(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = yield this.imageManager.getImages(s.icons);
              this._updateTilesForChangedImages();
              const g = this.tileManagers[s.source];
              return g && g.setDependencies(s.tileID.key, s.type, s.icons), d;
            }));
          }
          getGlyphs(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = yield this.glyphManager.getGlyphs(s.stacks), g = this.tileManagers[s.source];
              return g && g.setDependencies(s.tileID.key, s.type, [""]), d;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t, s = {}) {
            this._checkLoaded(), t && this._validate(u.C.glyphs, "glyphs", t, null, s) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
          }
          getDashes(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = {};
              for (const [g, w] of Object.entries(s.dashes)) d[g] = this.lineAtlas.getDash(w.dasharray, w.round);
              return d;
            }));
          }
          addSprite(t, s, d = {}, g) {
            this._checkLoaded();
            const w = [{ id: t, url: s }], T = [...se(this.stylesheet.sprite), ...w];
            this._validate(u.C.sprite, "sprite", T, null, d) || (this.stylesheet.sprite = T, this._loadSprite(w, !0, g));
          }
          removeSprite(t) {
            this._checkLoaded();
            const s = se(this.stylesheet.sprite);
            if (s.find(((d) => d.id === t))) {
              if (this._spritesImagesIds[t]) for (const d of this._spritesImagesIds[t]) this.imageManager.removeImage(d), this._changedImages[d] = !0;
              s.splice(s.findIndex(((d) => d.id === t)), 1), this.stylesheet.sprite = s.length > 0 ? s : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
            } else this.fire(new u.k(new Error(`Sprite "${t}" doesn't exists on this map.`)));
          }
          getSprite() {
            return se(this.stylesheet.sprite);
          }
          setSprite(t, s = {}, d) {
            this._checkLoaded(), t && this._validate(u.C.sprite, "sprite", t, null, s) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, !0, d) : (this._unloadSprite(), d && d(null)));
          }
          destroy() {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
            for (const t in this.tileManagers) {
              const s = this.tileManagers[t];
              s.setEventedParent(null), s.onRemove(this.map);
            }
            this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
            for (const t in this._layers) {
              const s = this._layers[t];
              s.setEventedParent(null), s.onRemove && s.onRemove(this.map);
            }
            this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(!0), this._listeners = {}, this._oneTimeListeners = {};
          }
        }
        var Qh = u.aU([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class bl {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t, s, d, g, w, T, C, A, F) {
            this.context = t;
            let O = this.boundPaintVertexBuffers.length !== g.length;
            for (let q = 0; !O && q < g.length; q++) this.boundPaintVertexBuffers[q] !== g[q] && (O = !0);
            !this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== d || O || this.boundIndexBuffer !== w || this.boundVertexOffset !== T || this.boundDynamicVertexBuffer !== C || this.boundDynamicVertexBuffer2 !== A || this.boundDynamicVertexBuffer3 !== F ? this.freshBind(s, d, g, w, T, C, A, F) : (t.bindVertexArray.set(this.vao), C && C.bind(), w && w.dynamicDraw && w.bind(), A && A.bind(), F && F.bind());
          }
          freshBind(t, s, d, g, w, T, C, A) {
            const F = t.numAttributes, O = this.context, q = O.gl;
            this.vao && this.destroy(), this.vao = O.createVertexArray(), O.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = d, this.boundIndexBuffer = g, this.boundVertexOffset = w, this.boundDynamicVertexBuffer = T, this.boundDynamicVertexBuffer2 = C, this.boundDynamicVertexBuffer3 = A, s.enableAttributes(q, t);
            for (const V of d) V.enableAttributes(q, t);
            T && T.enableAttributes(q, t), C && C.enableAttributes(q, t), A && A.enableAttributes(q, t), s.bind(), s.setVertexAttribPointers(q, t, w);
            for (const V of d) V.bind(), V.setVertexAttribPointers(q, t, w);
            T && (T.bind(), T.setVertexAttribPointers(q, t, w)), g && g.bind(), C && (C.bind(), C.setVertexAttribPointers(q, t, w)), A && (A.bind(), A.setVertexAttribPointers(q, t, w)), O.currentNumAttributes = F;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const ed = (b, t, s, d, g) => ({ u_texture: 0, u_ele_delta: b, u_fog_matrix: t, u_fog_color: s ? s.properties.get("fog-color") : u.bp.white, u_fog_ground_blend: s ? s.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: g ? 0 : s ? s.calculateFogBlendOpacity(d) : 0, u_horizon_color: s ? s.properties.get("horizon-color") : u.bp.white, u_horizon_fog_blend: s ? s.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: g ? 1 : 0 }), io = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function wl(b) {
          const t = [];
          for (let s = 0; s < b.length; s++) {
            if (b[s] === null) continue;
            const d = b[s].split(" ");
            t.push(d.pop());
          }
          return t;
        }
        class Ic {
          constructor(t, s, d, g, w, T, C, A, F = []) {
            const O = t.gl;
            this.program = O.createProgram();
            const q = wl(s.staticAttributes), V = d ? d.getBinderAttributes() : [], X = q.concat(V), te = tn.prelude.staticUniforms ? wl(tn.prelude.staticUniforms) : [], he = C.staticUniforms ? wl(C.staticUniforms) : [], pe = s.staticUniforms ? wl(s.staticUniforms) : [], fe = d ? d.getBinderUniforms() : [], be = te.concat(he).concat(pe).concat(fe), Ae = [];
            for (const tt of be) Ae.indexOf(tt) < 0 && Ae.push(tt);
            const xe = d ? d.defines() : [];
            Jn(O) && xe.unshift("#version 300 es"), w && xe.push("#define OVERDRAW_INSPECTOR;"), T && xe.push("#define TERRAIN3D;"), A && xe.push(A), F && xe.push(...F);
            let Ce = xe.concat(tn.prelude.fragmentSource, C.fragmentSource, s.fragmentSource).join(`
`), Oe = xe.concat(tn.prelude.vertexSource, C.vertexSource, s.vertexSource).join(`
`);
            Jn(O) || (Ce = (function(tt) {
              return tt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(Ce), Oe = (function(tt) {
              return tt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(Oe));
            const ke = O.createShader(O.FRAGMENT_SHADER);
            if (O.isContextLost()) return void (this.failedToCreate = !0);
            if (O.shaderSource(ke, Ce), O.compileShader(ke), !O.getShaderParameter(ke, O.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${O.getShaderInfoLog(ke)}`);
            O.attachShader(this.program, ke);
            const je = O.createShader(O.VERTEX_SHADER);
            if (O.isContextLost()) return void (this.failedToCreate = !0);
            if (O.shaderSource(je, Oe), O.compileShader(je), !O.getShaderParameter(je, O.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${O.getShaderInfoLog(je)}`);
            O.attachShader(this.program, je), this.attributes = {};
            const at = {};
            this.numAttributes = X.length;
            for (let tt = 0; tt < this.numAttributes; tt++) X[tt] && (O.bindAttribLocation(this.program, tt, X[tt]), this.attributes[X[tt]] = tt);
            if (O.linkProgram(this.program), !O.getProgramParameter(this.program, O.LINK_STATUS)) throw new Error(`Program failed to link: ${O.getProgramInfoLog(this.program)}`);
            O.deleteShader(je), O.deleteShader(ke);
            for (let tt = 0; tt < Ae.length; tt++) {
              const nt = Ae[tt];
              if (nt && !at[nt]) {
                const it = O.getUniformLocation(this.program, nt);
                it && (at[nt] = it);
              }
            }
            this.fixedUniforms = g(t, at), this.terrainUniforms = ((tt, nt) => ({ u_depth: new u.b_(tt, nt.u_depth), u_terrain: new u.b_(tt, nt.u_terrain), u_terrain_dim: new u.bq(tt, nt.u_terrain_dim), u_terrain_matrix: new u.c0(tt, nt.u_terrain_matrix), u_terrain_unpack: new u.c1(tt, nt.u_terrain_unpack), u_terrain_exaggeration: new u.bq(tt, nt.u_terrain_exaggeration) }))(t, at), this.projectionUniforms = ((tt, nt) => ({ u_projection_matrix: new u.c0(tt, nt.u_projection_matrix), u_projection_tile_mercator_coords: new u.c1(tt, nt.u_projection_tile_mercator_coords), u_projection_clipping_plane: new u.c1(tt, nt.u_projection_clipping_plane), u_projection_transition: new u.bq(tt, nt.u_projection_transition), u_projection_fallback_matrix: new u.c0(tt, nt.u_projection_fallback_matrix) }))(t, at), this.binderUniforms = d ? d.getUniforms(t, at) : [];
          }
          draw(t, s, d, g, w, T, C, A, F, O, q, V, X, te, he, pe, fe, be, Ae) {
            const xe = t.gl;
            if (this.failedToCreate) return;
            if (t.program.set(this.program), t.setDepthMode(d), t.setStencilMode(g), t.setColorMode(w), t.setCullFace(T), A) {
              t.activeTexture.set(xe.TEXTURE2), xe.bindTexture(xe.TEXTURE_2D, A.depthTexture), t.activeTexture.set(xe.TEXTURE3), xe.bindTexture(xe.TEXTURE_2D, A.texture);
              for (const Oe in this.terrainUniforms) this.terrainUniforms[Oe].set(A[Oe]);
            }
            if (F) for (const Oe in F) this.projectionUniforms[io[Oe]].set(F[Oe]);
            if (C) for (const Oe in this.fixedUniforms) this.fixedUniforms[Oe].set(C[Oe]);
            pe && pe.setUniforms(t, this.binderUniforms, te, { zoom: he });
            let Ce = 0;
            switch (s) {
              case xe.LINES:
                Ce = 2;
                break;
              case xe.TRIANGLES:
                Ce = 3;
                break;
              case xe.LINE_STRIP:
                Ce = 1;
            }
            for (const Oe of X.get()) {
              const ke = Oe.vaos || (Oe.vaos = {});
              (ke[O] || (ke[O] = new bl())).bind(t, this, q, pe ? pe.getPaintVertexBuffers() : [], V, Oe.vertexOffset, fe, be, Ae), xe.drawElements(s, Oe.primitiveLength * Ce, xe.UNSIGNED_SHORT, Oe.primitiveOffset * Ce * 2);
            }
          }
        }
        function yu(b, t, s) {
          const d = 1 / u.aN(s, 1, t.transform.tileZoom), g = Math.pow(2, s.tileID.overscaledZ), w = s.tileSize * Math.pow(2, t.transform.tileZoom) / g, T = w * (s.tileID.canonical.x + s.tileID.wrap * g), C = w * s.tileID.canonical.y;
          return { u_image: 0, u_texsize: s.imageAtlasTexture.size, u_scale: [d, b.fromScale, b.toScale], u_fade: b.t, u_pixel_coord_upper: [T >> 16, C >> 16], u_pixel_coord_lower: [65535 & T, 65535 & C] };
        }
        const vu = (b, t, s, d) => {
          const g = b.style.light, w = g.properties.get("position"), T = [w.x, w.y, w.z], C = u.c4();
          g.properties.get("anchor") === "viewport" && u.c5(C, b.transform.bearingInRadians), u.c6(T, T, C);
          const A = b.transform.transformLightDirection(T), F = g.properties.get("color");
          return { u_lightpos: T, u_lightpos_globe: A, u_lightintensity: g.properties.get("intensity"), u_lightcolor: [F.r, F.g, F.b], u_vertical_gradient: +t, u_opacity: s, u_fill_translate: d };
        }, El = (b, t, s, d, g, w, T) => u.e(vu(b, t, s, d), yu(w, b, T), { u_height_factor: -Math.pow(2, g.overscaledZ) / T.tileSize / 8 }), xu = (b, t, s, d) => u.e(yu(t, b, s), { u_fill_translate: d }), Mc = (b, t) => ({ u_world: b, u_fill_translate: t }), Cc = (b, t, s, d, g) => u.e(xu(b, t, s, g), { u_world: d }), Pc = (b, t, s, d, g) => {
          const w = b.transform;
          let T, C, A = 0;
          if (s.paint.get("circle-pitch-alignment") === "map") {
            const F = u.aN(t, 1, w.zoom);
            T = !0, C = [F, F], A = F / (u.a5 * Math.pow(2, t.tileID.overscaledZ)) * 2 * Math.PI * g;
          } else T = !1, C = w.pixelsToGLUnits;
          return { u_camera_to_center_distance: w.cameraToCenterDistance, u_scale_with_map: +(s.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +T, u_device_pixel_ratio: b.pixelRatio, u_extrude_scale: C, u_globe_extrude_scale: A, u_translate: d };
        }, Ma = (b) => ({ u_pixel_extrude_scale: [1 / b.width, 1 / b.height] }), Ac = (b) => ({ u_viewport_size: [b.width, b.height] }), bu = (b, t = 1) => ({ u_color: b, u_overlay: 0, u_overlay_scale: t }), Ca = (b, t, s, d) => {
          const g = u.aN(b, 1, t) / (u.a5 * Math.pow(2, b.tileID.overscaledZ)) * 2 * Math.PI * d;
          return { u_extrude_scale: u.aN(b, 1, t), u_intensity: s, u_globe_extrude_scale: g };
        }, wu = (b, t, s, d) => {
          const g = u.N();
          u.c7(g, 0, b.width, b.height, 0, 0, 1);
          const w = b.context.gl;
          return { u_matrix: g, u_world: [w.drawingBufferWidth, w.drawingBufferHeight], u_image: s, u_color_ramp: d, u_opacity: t.paint.get("heatmap-opacity") };
        }, zo = (b, t, s) => {
          const d = s.paint.get("hillshade-accent-color");
          let g;
          switch (s.paint.get("hillshade-method")) {
            case "basic":
              g = 4;
              break;
            case "combined":
              g = 1;
              break;
            case "igor":
              g = 2;
              break;
            case "multidirectional":
              g = 3;
              break;
            default:
              g = 0;
          }
          const w = s.getIlluminationProperties();
          for (let T = 0; T < w.directionRadians.length; T++) s.paint.get("hillshade-illumination-anchor") === "viewport" && (w.directionRadians[T] += b.transform.bearingInRadians);
          return { u_image: 0, u_latrange: Lc(0, t.tileID), u_exaggeration: s.paint.get("hillshade-exaggeration"), u_altitudes: w.altitudeRadians, u_azimuths: w.directionRadians, u_accent: d, u_method: g, u_highlights: w.highlightColor, u_shadows: w.shadowColor };
        }, td = (b, t) => {
          const s = t.stride, d = u.N();
          return u.c7(d, 0, u.a5, -u.a5, 0, 0, 1), u.O(d, d, [0, -u.a5, 0]), { u_matrix: d, u_image: 1, u_dimension: [s, s], u_zoom: b.overscaledZ, u_unpack: t.getUnpackVector() };
        };
        function Lc(b, t) {
          const s = Math.pow(2, t.canonical.z), d = t.canonical.y;
          return [new u.a9(0, d / s).toLngLat().lat, new u.a9(0, (d + 1) / s).toLngLat().lat];
        }
        const Sl = (b, t, s = 0) => ({ u_image: 0, u_unpack: t.getUnpackVector(), u_dimension: [t.stride, t.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: s, u_opacity: b.paint.get("color-relief-opacity") }), Bo = (b, t, s, d) => {
          const g = b.transform;
          return { u_translation: Il(b, t, s), u_ratio: d / u.aN(t, 1, g.zoom), u_device_pixel_ratio: b.pixelRatio, u_units_to_pixels: [1 / g.pixelsToGLUnits[0], 1 / g.pixelsToGLUnits[1]] };
        }, Eu = (b, t, s, d, g) => u.e(Bo(b, t, s, d), { u_image: 0, u_image_height: g }), Tl = (b, t, s, d, g) => {
          const w = b.transform, T = ui(t, w);
          return { u_translation: Il(b, t, s), u_texsize: t.imageAtlasTexture.size, u_ratio: d / u.aN(t, 1, w.zoom), u_device_pixel_ratio: b.pixelRatio, u_image: 0, u_scale: [T, g.fromScale, g.toScale], u_fade: g.t, u_units_to_pixels: [1 / w.pixelsToGLUnits[0], 1 / w.pixelsToGLUnits[1]] };
        }, Dc = (b, t, s, d, g) => {
          const w = ui(t, b.transform);
          return u.e(Bo(b, t, s, d), { u_tileratio: w, u_crossfade_from: g.fromScale, u_crossfade_to: g.toScale, u_image: 0, u_mix: g.t, u_lineatlas_width: b.lineAtlas.width, u_lineatlas_height: b.lineAtlas.height });
        }, kl = (b, t, s, d, g, w) => {
          const T = ui(t, b.transform);
          return u.e(Bo(b, t, s, d), { u_image: 0, u_image_height: w, u_tileratio: T, u_crossfade_from: g.fromScale, u_crossfade_to: g.toScale, u_image_dash: 1, u_mix: g.t, u_lineatlas_width: b.lineAtlas.width, u_lineatlas_height: b.lineAtlas.height });
        };
        function ui(b, t) {
          return 1 / u.aN(b, 1, t.tileZoom);
        }
        function Il(b, t, s) {
          return u.aO(b.transform, t, s.paint.get("line-translate"), s.paint.get("line-translate-anchor"));
        }
        const Ml = (b, t, s, d, g) => {
          return { u_tl_parent: b, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: s.mix, u_opacity: s.opacity * d.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d.paint.get("raster-brightness-min"), u_brightness_high: d.paint.get("raster-brightness-max"), u_saturation_factor: (T = d.paint.get("raster-saturation"), T > 0 ? 1 - 1 / (1.001 - T) : -T), u_contrast_factor: (w = d.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Mi(d.paint.get("raster-hue-rotate")), u_coords_top: [g[0].x, g[0].y, g[1].x, g[1].y], u_coords_bottom: [g[3].x, g[3].y, g[2].x, g[2].y] };
          var w, T;
        };
        function Mi(b) {
          b *= Math.PI / 180;
          const t = Math.sin(b), s = Math.cos(b);
          return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3];
        }
        const Ji = (b, t, s, d, g, w, T, C, A, F, O, q, V) => {
          const X = T.transform;
          return { u_is_size_zoom_constant: +(b === "constant" || b === "source"), u_is_size_feature_constant: +(b === "constant" || b === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: X.cameraToCenterDistance, u_pitch: X.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +s, u_aspect_ratio: X.width / X.height, u_fade_change: T.options.fadeDuration ? T.symbolFadeChange : 1, u_label_plane_matrix: C, u_coord_matrix: A, u_is_text: +O, u_pitch_with_map: +d, u_is_along_line: g, u_is_variable_anchor: w, u_texsize: q, u_texture: 0, u_translation: F, u_pitched_scale: V };
        }, y = (b, t, s, d, g, w, T, C, A, F, O, q, V, X) => {
          const te = T.transform;
          return u.e(Ji(b, t, s, d, g, w, T, C, A, F, O, q, X), { u_gamma_scale: d ? Math.cos(te.pitch * Math.PI / 180) * te.cameraToCenterDistance : 1, u_device_pixel_ratio: T.pixelRatio, u_is_halo: 1 });
        }, o = (b, t, s, d, g, w, T, C, A, F, O, q, V) => u.e(y(b, t, s, d, g, w, T, C, A, F, !0, O, 0, V), { u_texsize_icon: q, u_texture_icon: 1 }), h = (b, t) => ({ u_opacity: b, u_color: t }), _ = (b, t, s, d, g) => u.e((function(w, T, C, A) {
          const F = C.imageManager.getPattern(w.from.toString()), O = C.imageManager.getPattern(w.to.toString()), { width: q, height: V } = C.imageManager.getPixelSize(), X = Math.pow(2, A.tileID.overscaledZ), te = A.tileSize * Math.pow(2, C.transform.tileZoom) / X, he = te * (A.tileID.canonical.x + A.tileID.wrap * X), pe = te * A.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: F.tl, u_pattern_br_a: F.br, u_pattern_tl_b: O.tl, u_pattern_br_b: O.br, u_texsize: [q, V], u_mix: T.t, u_pattern_size_a: F.displaySize, u_pattern_size_b: O.displaySize, u_scale_a: T.fromScale, u_scale_b: T.toScale, u_tile_units_to_pixels: 1 / u.aN(A, 1, C.transform.tileZoom), u_pixel_coord_upper: [he >> 16, pe >> 16], u_pixel_coord_lower: [65535 & he, 65535 & pe] };
        })(s, g, t, d), { u_opacity: b }), I = (b, t) => {
        }, D = { fillExtrusion: (b, t) => ({ u_lightpos: new u.c2(b, t.u_lightpos), u_lightpos_globe: new u.c2(b, t.u_lightpos_globe), u_lightintensity: new u.bq(b, t.u_lightintensity), u_lightcolor: new u.c2(b, t.u_lightcolor), u_vertical_gradient: new u.bq(b, t.u_vertical_gradient), u_opacity: new u.bq(b, t.u_opacity), u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillExtrusionPattern: (b, t) => ({ u_lightpos: new u.c2(b, t.u_lightpos), u_lightpos_globe: new u.c2(b, t.u_lightpos_globe), u_lightintensity: new u.bq(b, t.u_lightintensity), u_lightcolor: new u.c2(b, t.u_lightcolor), u_vertical_gradient: new u.bq(b, t.u_vertical_gradient), u_height_factor: new u.bq(b, t.u_height_factor), u_opacity: new u.bq(b, t.u_opacity), u_fill_translate: new u.c3(b, t.u_fill_translate), u_image: new u.b_(b, t.u_image), u_texsize: new u.c3(b, t.u_texsize), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade) }), fill: (b, t) => ({ u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillPattern: (b, t) => ({ u_image: new u.b_(b, t.u_image), u_texsize: new u.c3(b, t.u_texsize), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade), u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillOutline: (b, t) => ({ u_world: new u.c3(b, t.u_world), u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillOutlinePattern: (b, t) => ({ u_world: new u.c3(b, t.u_world), u_image: new u.b_(b, t.u_image), u_texsize: new u.c3(b, t.u_texsize), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade), u_fill_translate: new u.c3(b, t.u_fill_translate) }), circle: (b, t) => ({ u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_scale_with_map: new u.b_(b, t.u_scale_with_map), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_extrude_scale: new u.c3(b, t.u_extrude_scale), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_globe_extrude_scale: new u.bq(b, t.u_globe_extrude_scale), u_translate: new u.c3(b, t.u_translate) }), collisionBox: (b, t) => ({ u_pixel_extrude_scale: new u.c3(b, t.u_pixel_extrude_scale) }), collisionCircle: (b, t) => ({ u_viewport_size: new u.c3(b, t.u_viewport_size) }), debug: (b, t) => ({ u_color: new u.b$(b, t.u_color), u_overlay: new u.b_(b, t.u_overlay), u_overlay_scale: new u.bq(b, t.u_overlay_scale) }), depth: I, clippingMask: I, heatmap: (b, t) => ({ u_extrude_scale: new u.bq(b, t.u_extrude_scale), u_intensity: new u.bq(b, t.u_intensity), u_globe_extrude_scale: new u.bq(b, t.u_globe_extrude_scale) }), heatmapTexture: (b, t) => ({ u_matrix: new u.c0(b, t.u_matrix), u_world: new u.c3(b, t.u_world), u_image: new u.b_(b, t.u_image), u_color_ramp: new u.b_(b, t.u_color_ramp), u_opacity: new u.bq(b, t.u_opacity) }), hillshade: (b, t) => ({ u_image: new u.b_(b, t.u_image), u_latrange: new u.c3(b, t.u_latrange), u_exaggeration: new u.bq(b, t.u_exaggeration), u_altitudes: new u.c9(b, t.u_altitudes), u_azimuths: new u.c9(b, t.u_azimuths), u_accent: new u.b$(b, t.u_accent), u_method: new u.b_(b, t.u_method), u_shadows: new u.c8(b, t.u_shadows), u_highlights: new u.c8(b, t.u_highlights) }), hillshadePrepare: (b, t) => ({ u_matrix: new u.c0(b, t.u_matrix), u_image: new u.b_(b, t.u_image), u_dimension: new u.c3(b, t.u_dimension), u_zoom: new u.bq(b, t.u_zoom), u_unpack: new u.c1(b, t.u_unpack) }), colorRelief: (b, t) => ({ u_image: new u.b_(b, t.u_image), u_unpack: new u.c1(b, t.u_unpack), u_dimension: new u.c3(b, t.u_dimension), u_elevation_stops: new u.b_(b, t.u_elevation_stops), u_color_stops: new u.b_(b, t.u_color_stops), u_color_ramp_size: new u.b_(b, t.u_color_ramp_size), u_opacity: new u.bq(b, t.u_opacity) }), line: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels) }), lineGradient: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_image: new u.b_(b, t.u_image), u_image_height: new u.bq(b, t.u_image_height) }), linePattern: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_texsize: new u.c3(b, t.u_texsize), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_image: new u.b_(b, t.u_image), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade) }), lineSDF: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_image: new u.b_(b, t.u_image), u_mix: new u.bq(b, t.u_mix), u_tileratio: new u.bq(b, t.u_tileratio), u_crossfade_from: new u.bq(b, t.u_crossfade_from), u_crossfade_to: new u.bq(b, t.u_crossfade_to), u_lineatlas_width: new u.bq(b, t.u_lineatlas_width), u_lineatlas_height: new u.bq(b, t.u_lineatlas_height) }), lineGradientSDF: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_image: new u.b_(b, t.u_image), u_image_height: new u.bq(b, t.u_image_height), u_tileratio: new u.bq(b, t.u_tileratio), u_crossfade_from: new u.bq(b, t.u_crossfade_from), u_crossfade_to: new u.bq(b, t.u_crossfade_to), u_image_dash: new u.b_(b, t.u_image_dash), u_mix: new u.bq(b, t.u_mix), u_lineatlas_width: new u.bq(b, t.u_lineatlas_width), u_lineatlas_height: new u.bq(b, t.u_lineatlas_height) }), raster: (b, t) => ({ u_tl_parent: new u.c3(b, t.u_tl_parent), u_scale_parent: new u.bq(b, t.u_scale_parent), u_buffer_scale: new u.bq(b, t.u_buffer_scale), u_fade_t: new u.bq(b, t.u_fade_t), u_opacity: new u.bq(b, t.u_opacity), u_image0: new u.b_(b, t.u_image0), u_image1: new u.b_(b, t.u_image1), u_brightness_low: new u.bq(b, t.u_brightness_low), u_brightness_high: new u.bq(b, t.u_brightness_high), u_saturation_factor: new u.bq(b, t.u_saturation_factor), u_contrast_factor: new u.bq(b, t.u_contrast_factor), u_spin_weights: new u.c2(b, t.u_spin_weights), u_coords_top: new u.c1(b, t.u_coords_top), u_coords_bottom: new u.c1(b, t.u_coords_bottom) }), symbolIcon: (b, t) => ({ u_is_size_zoom_constant: new u.b_(b, t.u_is_size_zoom_constant), u_is_size_feature_constant: new u.b_(b, t.u_is_size_feature_constant), u_size_t: new u.bq(b, t.u_size_t), u_size: new u.bq(b, t.u_size), u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_pitch: new u.bq(b, t.u_pitch), u_rotate_symbol: new u.b_(b, t.u_rotate_symbol), u_aspect_ratio: new u.bq(b, t.u_aspect_ratio), u_fade_change: new u.bq(b, t.u_fade_change), u_label_plane_matrix: new u.c0(b, t.u_label_plane_matrix), u_coord_matrix: new u.c0(b, t.u_coord_matrix), u_is_text: new u.b_(b, t.u_is_text), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_is_along_line: new u.b_(b, t.u_is_along_line), u_is_variable_anchor: new u.b_(b, t.u_is_variable_anchor), u_texsize: new u.c3(b, t.u_texsize), u_texture: new u.b_(b, t.u_texture), u_translation: new u.c3(b, t.u_translation), u_pitched_scale: new u.bq(b, t.u_pitched_scale) }), symbolSDF: (b, t) => ({ u_is_size_zoom_constant: new u.b_(b, t.u_is_size_zoom_constant), u_is_size_feature_constant: new u.b_(b, t.u_is_size_feature_constant), u_size_t: new u.bq(b, t.u_size_t), u_size: new u.bq(b, t.u_size), u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_pitch: new u.bq(b, t.u_pitch), u_rotate_symbol: new u.b_(b, t.u_rotate_symbol), u_aspect_ratio: new u.bq(b, t.u_aspect_ratio), u_fade_change: new u.bq(b, t.u_fade_change), u_label_plane_matrix: new u.c0(b, t.u_label_plane_matrix), u_coord_matrix: new u.c0(b, t.u_coord_matrix), u_is_text: new u.b_(b, t.u_is_text), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_is_along_line: new u.b_(b, t.u_is_along_line), u_is_variable_anchor: new u.b_(b, t.u_is_variable_anchor), u_texsize: new u.c3(b, t.u_texsize), u_texture: new u.b_(b, t.u_texture), u_gamma_scale: new u.bq(b, t.u_gamma_scale), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_is_halo: new u.b_(b, t.u_is_halo), u_translation: new u.c3(b, t.u_translation), u_pitched_scale: new u.bq(b, t.u_pitched_scale) }), symbolTextAndIcon: (b, t) => ({ u_is_size_zoom_constant: new u.b_(b, t.u_is_size_zoom_constant), u_is_size_feature_constant: new u.b_(b, t.u_is_size_feature_constant), u_size_t: new u.bq(b, t.u_size_t), u_size: new u.bq(b, t.u_size), u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_pitch: new u.bq(b, t.u_pitch), u_rotate_symbol: new u.b_(b, t.u_rotate_symbol), u_aspect_ratio: new u.bq(b, t.u_aspect_ratio), u_fade_change: new u.bq(b, t.u_fade_change), u_label_plane_matrix: new u.c0(b, t.u_label_plane_matrix), u_coord_matrix: new u.c0(b, t.u_coord_matrix), u_is_text: new u.b_(b, t.u_is_text), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_is_along_line: new u.b_(b, t.u_is_along_line), u_is_variable_anchor: new u.b_(b, t.u_is_variable_anchor), u_texsize: new u.c3(b, t.u_texsize), u_texsize_icon: new u.c3(b, t.u_texsize_icon), u_texture: new u.b_(b, t.u_texture), u_texture_icon: new u.b_(b, t.u_texture_icon), u_gamma_scale: new u.bq(b, t.u_gamma_scale), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_is_halo: new u.b_(b, t.u_is_halo), u_translation: new u.c3(b, t.u_translation), u_pitched_scale: new u.bq(b, t.u_pitched_scale) }), background: (b, t) => ({ u_opacity: new u.bq(b, t.u_opacity), u_color: new u.b$(b, t.u_color) }), backgroundPattern: (b, t) => ({ u_opacity: new u.bq(b, t.u_opacity), u_image: new u.b_(b, t.u_image), u_pattern_tl_a: new u.c3(b, t.u_pattern_tl_a), u_pattern_br_a: new u.c3(b, t.u_pattern_br_a), u_pattern_tl_b: new u.c3(b, t.u_pattern_tl_b), u_pattern_br_b: new u.c3(b, t.u_pattern_br_b), u_texsize: new u.c3(b, t.u_texsize), u_mix: new u.bq(b, t.u_mix), u_pattern_size_a: new u.c3(b, t.u_pattern_size_a), u_pattern_size_b: new u.c3(b, t.u_pattern_size_b), u_scale_a: new u.bq(b, t.u_scale_a), u_scale_b: new u.bq(b, t.u_scale_b), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_tile_units_to_pixels: new u.bq(b, t.u_tile_units_to_pixels) }), terrain: (b, t) => ({ u_texture: new u.b_(b, t.u_texture), u_ele_delta: new u.bq(b, t.u_ele_delta), u_fog_matrix: new u.c0(b, t.u_fog_matrix), u_fog_color: new u.b$(b, t.u_fog_color), u_fog_ground_blend: new u.bq(b, t.u_fog_ground_blend), u_fog_ground_blend_opacity: new u.bq(b, t.u_fog_ground_blend_opacity), u_horizon_color: new u.b$(b, t.u_horizon_color), u_horizon_fog_blend: new u.bq(b, t.u_horizon_fog_blend), u_is_globe_mode: new u.bq(b, t.u_is_globe_mode) }), terrainDepth: (b, t) => ({ u_ele_delta: new u.bq(b, t.u_ele_delta) }), terrainCoords: (b, t) => ({ u_texture: new u.b_(b, t.u_texture), u_terrain_coords_id: new u.bq(b, t.u_terrain_coords_id), u_ele_delta: new u.bq(b, t.u_ele_delta) }), projectionErrorMeasurement: (b, t) => ({ u_input: new u.bq(b, t.u_input), u_output_expected: new u.bq(b, t.u_output_expected) }), atmosphere: (b, t) => ({ u_sun_pos: new u.c2(b, t.u_sun_pos), u_atmosphere_blend: new u.bq(b, t.u_atmosphere_blend), u_globe_position: new u.c2(b, t.u_globe_position), u_globe_radius: new u.bq(b, t.u_globe_radius), u_inv_proj_matrix: new u.c0(b, t.u_inv_proj_matrix) }), sky: (b, t) => ({ u_sky_color: new u.b$(b, t.u_sky_color), u_horizon_color: new u.b$(b, t.u_horizon_color), u_horizon: new u.c3(b, t.u_horizon), u_horizon_normal: new u.c3(b, t.u_horizon_normal), u_sky_horizon_blend: new u.bq(b, t.u_sky_horizon_blend), u_sky_blend: new u.bq(b, t.u_sky_blend) }) };
        class B {
          constructor(t, s, d) {
            this.context = t;
            const g = t.gl;
            this.buffer = g.createBuffer(), this.dynamicDraw = !!d, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), g.bufferData(g.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t) {
            const s = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const W = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class oe {
          constructor(t, s, d, g) {
            this.length = s.length, this.attributes = d, this.itemSize = s.bytesPerElement, this.dynamicDraw = g, this.context = t;
            const w = t.gl;
            this.buffer = w.createBuffer(), t.bindVertexBuffer.set(this.buffer), w.bufferData(w.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t) {
            if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`);
            const s = this.context.gl;
            this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          enableAttributes(t, s) {
            for (let d = 0; d < this.attributes.length; d++) {
              const g = s.attributes[this.attributes[d].name];
              g !== void 0 && t.enableVertexAttribArray(g);
            }
          }
          setVertexAttribPointers(t, s, d) {
            for (let g = 0; g < this.attributes.length; g++) {
              const w = this.attributes[g], T = s.attributes[w.name];
              T !== void 0 && t.vertexAttribPointer(T, w.components, t[W[w.type]], !1, this.itemSize, w.offset + this.itemSize * (d || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class de {
          constructor(t) {
            this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(t) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ze extends de {
          getDefault() {
            return u.bp.transparent;
          }
          set(t) {
            const s = this.current;
            (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class rt extends de {
          getDefault() {
            return 1;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
          }
        }
        class xt extends de {
          getDefault() {
            return 0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
          }
        }
        class jt extends de {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class qt extends de {
          getDefault() {
            return !0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
          }
        }
        class Wt extends de {
          getDefault() {
            return 255;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
          }
        }
        class _r extends de {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t) {
            const s = this.current;
            (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
          }
        }
        class lr extends de {
          getDefault() {
            const t = this.gl;
            return [t.KEEP, t.KEEP, t.KEEP];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
          }
        }
        class Br extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1;
          }
        }
        class qn extends de {
          getDefault() {
            return [0, 1];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
          }
        }
        class $n extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1;
          }
        }
        class Vi extends de {
          getDefault() {
            return this.gl.LESS;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
          }
        }
        class aa extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1;
          }
        }
        class Go extends de {
          getDefault() {
            const t = this.gl;
            return [t.ONE, t.ZERO];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);
          }
        }
        class so extends de {
          getDefault() {
            return u.bp.transparent;
          }
          set(t) {
            const s = this.current;
            (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class jo extends de {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);
          }
        }
        class Su extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1;
          }
        }
        class Pa extends de {
          getDefault() {
            return this.gl.BACK;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
          }
        }
        class Aa extends de {
          getDefault() {
            return this.gl.CCW;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
          }
        }
        class Cl extends de {
          getDefault() {
            return null;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);
          }
        }
        class Vo extends de {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
          }
        }
        class gr extends de {
          getDefault() {
            const t = this.gl;
            return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class Rc extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class nm extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Zf extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1;
          }
        }
        class Tu extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class im extends de {
          getDefault() {
            return null;
          }
          set(t) {
            const s = this.gl;
            s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class sm extends de {
          getDefault() {
            return null;
          }
          set(t) {
            var s;
            if (t === this.current && !this.dirty) return;
            const d = this.gl;
            Jn(d) ? d.bindVertexArray(t) : (s = d.getExtension("OES_vertex_array_object")) === null || s === void 0 || s.bindVertexArrayOES(t), this.current = t, this.dirty = !1;
          }
        }
        class Hf extends de {
          getDefault() {
            return 4;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
          }
        }
        class am extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class rd extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class Pl extends de {
          constructor(t, s) {
            super(t), this.context = t, this.parent = s;
          }
          getDefault() {
            return null;
          }
        }
        class ku extends Pl {
          setDirty() {
            this.dirty = !0;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
          }
        }
        class Fc extends Pl {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class nd extends Pl {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        const id = "Framebuffer is not complete";
        class Nc {
          constructor(t, s, d, g, w) {
            this.context = t, this.width = s, this.height = d;
            const T = t.gl, C = this.framebuffer = T.createFramebuffer();
            if (this.colorAttachment = new ku(t, C), g) this.depthAttachment = w ? new nd(t, C) : new Fc(t, C);
            else if (w) throw new Error("Stencil cannot be set without depth");
            if (T.checkFramebufferStatus(T.FRAMEBUFFER) !== T.FRAMEBUFFER_COMPLETE) throw new Error(id);
          }
          destroy() {
            const t = this.context.gl, s = this.colorAttachment.get();
            if (s && t.deleteTexture(s), this.depthAttachment) {
              const d = this.depthAttachment.get();
              d && t.deleteRenderbuffer(d);
            }
            t.deleteFramebuffer(this.framebuffer);
          }
        }
        class Oc {
          constructor(t) {
            var s, d;
            if (this.gl = t, this.clearColor = new Ze(this), this.clearDepth = new rt(this), this.clearStencil = new xt(this), this.colorMask = new jt(this), this.depthMask = new qt(this), this.stencilMask = new Wt(this), this.stencilFunc = new _r(this), this.stencilOp = new lr(this), this.stencilTest = new Br(this), this.depthRange = new qn(this), this.depthTest = new $n(this), this.depthFunc = new Vi(this), this.blend = new aa(this), this.blendFunc = new Go(this), this.blendColor = new so(this), this.blendEquation = new jo(this), this.cullFace = new Su(this), this.cullFaceSide = new Pa(this), this.frontFace = new Aa(this), this.program = new Cl(this), this.activeTexture = new Vo(this), this.viewport = new gr(this), this.bindFramebuffer = new Rc(this), this.bindRenderbuffer = new nm(this), this.bindTexture = new Zf(this), this.bindVertexBuffer = new Tu(this), this.bindElementBuffer = new im(this), this.bindVertexArray = new sm(this), this.pixelStoreUnpack = new Hf(this), this.pixelStoreUnpackPremultiplyAlpha = new am(this), this.pixelStoreUnpackFlipY = new rd(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), Jn(t)) {
              this.HALF_FLOAT = t.HALF_FLOAT;
              const g = t.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (s = t.RGBA16F) !== null && s !== void 0 ? s : g?.RGBA16F_EXT, this.RGB16F = (d = t.RGB16F) !== null && d !== void 0 ? d : g?.RGB16F_EXT, t.getExtension("EXT_color_buffer_float");
            } else {
              t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear");
              const g = t.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = g?.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(t, s) {
            return new B(this, t, s);
          }
          createVertexBuffer(t, s, d) {
            return new oe(this, t, s, d);
          }
          createRenderbuffer(t, s, d) {
            const g = this.gl, w = g.createRenderbuffer();
            return this.bindRenderbuffer.set(w), g.renderbufferStorage(g.RENDERBUFFER, t, s, d), this.bindRenderbuffer.set(null), w;
          }
          createFramebuffer(t, s, d, g) {
            return new Nc(this, t, s, d, g);
          }
          clear({ color: t, depth: s, stencil: d }) {
            const g = this.gl;
            let w = 0;
            t && (w |= g.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), s !== void 0 && (w |= g.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), d !== void 0 && (w |= g.STENCIL_BUFFER_BIT, this.clearStencil.set(d), this.stencilMask.set(255)), g.clear(w);
          }
          setCullFace(t) {
            t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
          }
          setDepthMode(t) {
            t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
          }
          setStencilMode(t) {
            t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(t) {
            u.bR(t.blendFunction, Lr.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
          }
          createVertexArray() {
            var t;
            return Jn(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES();
          }
          deleteVertexArray(t) {
            var s;
            return Jn(this.gl) ? this.gl.deleteVertexArray(t) : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.deleteVertexArrayOES(t);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let ao;
        function Uo(b, t, s, d, g) {
          const w = b.context, T = b.transform, C = w.gl, A = b.useProgram("collisionBox"), F = [];
          let O = 0, q = 0;
          for (let fe = 0; fe < d.length; fe++) {
            const be = d[fe], Ae = t.getTile(be).getBucket(s);
            if (!Ae) continue;
            const xe = g ? Ae.textCollisionBox : Ae.iconCollisionBox, Ce = Ae.collisionCircleArray;
            Ce.length > 0 && (F.push({ circleArray: Ce, circleOffset: q, coord: be }), O += Ce.length / 4, q = O), xe && A.draw(w, C.LINES, sr.disabled, pr.disabled, b.colorModeForRenderPass(), ar.disabled, Ma(b.transform), b.style.map.terrain && b.style.map.terrain.getTerrainData(be), T.getProjectionData({ overscaledTileID: be, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), s.id, xe.layoutVertexBuffer, xe.indexBuffer, xe.segments, null, b.transform.zoom, null, null, xe.collisionVertexBuffer);
          }
          if (!g || !F.length) return;
          const V = b.useProgram("collisionCircle"), X = new u.ca();
          X.resize(4 * O), X._trim();
          let te = 0;
          for (const fe of F) for (let be = 0; be < fe.circleArray.length / 4; be++) {
            const Ae = 4 * be, xe = fe.circleArray[Ae + 0], Ce = fe.circleArray[Ae + 1], Oe = fe.circleArray[Ae + 2], ke = fe.circleArray[Ae + 3];
            X.emplace(te++, xe, Ce, Oe, ke, 0), X.emplace(te++, xe, Ce, Oe, ke, 1), X.emplace(te++, xe, Ce, Oe, ke, 2), X.emplace(te++, xe, Ce, Oe, ke, 3);
          }
          (!ao || ao.length < 2 * O) && (ao = (function(fe) {
            const be = 2 * fe, Ae = new u.cc();
            Ae.resize(be), Ae._trim();
            for (let xe = 0; xe < be; xe++) {
              const Ce = 6 * xe;
              Ae.uint16[Ce + 0] = 4 * xe + 0, Ae.uint16[Ce + 1] = 4 * xe + 1, Ae.uint16[Ce + 2] = 4 * xe + 2, Ae.uint16[Ce + 3] = 4 * xe + 2, Ae.uint16[Ce + 4] = 4 * xe + 3, Ae.uint16[Ce + 5] = 4 * xe + 0;
            }
            return Ae;
          })(O));
          const he = w.createIndexBuffer(ao, !0), pe = w.createVertexBuffer(X, u.cb.members, !0);
          for (const fe of F) {
            const be = Ac(b.transform);
            V.draw(w, C.TRIANGLES, sr.disabled, pr.disabled, b.colorModeForRenderPass(), ar.disabled, be, b.style.map.terrain && b.style.map.terrain.getTerrainData(fe.coord), null, s.id, pe, he, u.aX.simpleSegment(0, 2 * fe.circleOffset, fe.circleArray.length, fe.circleArray.length / 2), null, b.transform.zoom, null, null, null);
          }
          pe.destroy(), he.destroy();
        }
        const sd = u.ar(new Float32Array(16));
        function om(b, t, s, d, g, w) {
          const { horizontalAlign: T, verticalAlign: C } = u.aS(b);
          return new u.P((-(T - 0.5) * t / g + d[0]) * w, (-(C - 0.5) * s / g + d[1]) * w);
        }
        function Iu(b, t, s, d, g, w) {
          const T = t.tileAnchorPoint.add(new u.P(t.translation[0], t.translation[1]));
          if (t.pitchWithMap) {
            let C = d.mult(w);
            s || (C = C.rotate(-g));
            const A = T.add(C);
            return we(A.x, A.y, t.pitchedLabelPlaneMatrix, t.getElevation).point;
          }
          if (s) {
            const C = Er(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(b), A = Math.atan(C.y / C.x) + (C.x < 0 ? Math.PI : 0);
            return b.add(d.rotate(A));
          }
          return b.add(d);
        }
        function lm(b, t, s, d, g, w, T, C, A, F, O, q) {
          const V = b.text.placedSymbolArray, X = b.text.dynamicLayoutVertexArray, te = b.icon.dynamicLayoutVertexArray, he = {};
          X.clear();
          for (let pe = 0; pe < V.length; pe++) {
            const fe = V.get(pe), be = fe.hidden || !fe.crossTileID || b.allowVerticalPlacement && !fe.placedOrientation ? null : d[fe.crossTileID];
            if (be) {
              const Ae = new u.P(fe.anchorX, fe.anchorY), xe = { getElevation: q, width: g.width, height: g.height, pitchedLabelPlaneMatrix: w, pitchWithMap: s, transform: g, tileAnchorPoint: Ae, translation: F, unwrappedTileID: O }, Ce = s ? Rn(Ae.x, Ae.y, xe) : Er(Ae.x, Ae.y, xe), Oe = Gt(g.cameraToCenterDistance, Ce.signedDistanceFromCamera);
              let ke = u.aA(b.textSizeData, C, fe) * Oe / u.aM;
              s && (ke *= b.tilePixelRatio / T);
              const { width: je, height: at, anchor: tt, textOffset: nt, textBoxScale: it } = be, St = om(tt, je, at, nt, it, ke), It = g.getPitchedTextCorrection(Ae.x + F[0], Ae.y + F[1], O), _t = Iu(Ce.point, xe, t, St, -g.bearingInRadians, It), Lt = b.allowVerticalPlacement && fe.placedOrientation === u.az.vertical ? Math.PI / 2 : 0;
              for (let or = 0; or < fe.numGlyphs; or++) u.aG(X, _t, Lt);
              A && fe.associatedIconIndex >= 0 && (he[fe.associatedIconIndex] = { shiftedAnchor: _t, angle: Lt });
            } else ba(fe.numGlyphs, X);
          }
          if (A) {
            te.clear();
            const pe = b.icon.placedSymbolArray;
            for (let fe = 0; fe < pe.length; fe++) {
              const be = pe.get(fe);
              if (be.hidden) ba(be.numGlyphs, te);
              else {
                const Ae = he[fe];
                if (Ae) for (let xe = 0; xe < be.numGlyphs; xe++) u.aG(te, Ae.shiftedAnchor, Ae.angle);
                else ba(be.numGlyphs, te);
              }
            }
            b.icon.dynamicLayoutVertexBuffer.updateData(te);
          }
          b.text.dynamicLayoutVertexBuffer.updateData(X);
        }
        function Yf(b, t, s) {
          return s.iconsInText && t ? "symbolTextAndIcon" : b ? "symbolSDF" : "symbolIcon";
        }
        function Mu(b, t, s, d, g, w, T, C, A, F, O, q, V) {
          const X = b.context, te = X.gl, he = b.transform, pe = C === "map", fe = A === "map", be = C !== "viewport" && s.layout.get("symbol-placement") !== "point", Ae = pe && !fe && !be, xe = !s.layout.get("symbol-sort-key").isConstant();
          let Ce = !1;
          const Oe = b.getDepthModeForSublayer(0, sr.ReadOnly), ke = s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset"), je = [], at = he.getCircleRadiusCorrection();
          for (const tt of d) {
            const nt = t.getTile(tt), it = nt.getBucket(s);
            if (!it) continue;
            const St = g ? it.text : it.icon;
            if (!St || !St.segments.get().length || !St.hasVisibleVertices) continue;
            const It = St.programConfigurations.get(s.id), _t = g || it.sdfIcons, Lt = g ? it.textSizeData : it.iconSizeData, or = fe || he.pitch !== 0, Or = b.useProgram(Yf(_t, g, it), It), an = u.ay(Lt, he.zoom), $r = b.style.map.terrain && b.style.map.terrain.getTerrainData(tt);
            let hn, Zr, Sn, dn, hi = [0, 0], Fn = null;
            if (g) Zr = nt.glyphAtlasTexture, Sn = te.LINEAR, hn = nt.glyphAtlasTexture.size, it.iconsInText && (hi = nt.imageAtlasTexture.size, Fn = nt.imageAtlasTexture, dn = or || b.options.rotating || b.options.zooming || Lt.kind === "composite" || Lt.kind === "camera" ? te.LINEAR : te.NEAREST);
            else {
              const Jr = s.layout.get("icon-size").constantOr(0) !== 1 || it.iconsNeedLinear;
              Zr = nt.imageAtlasTexture, Sn = _t || b.options.rotating || b.options.zooming || Jr || or ? te.LINEAR : te.NEAREST, hn = nt.imageAtlasTexture.size;
            }
            const An = u.aN(nt, 1, b.transform.zoom), Ei = mn(pe, b.transform, An), ho = u.N();
            u.aB(ho, Ei);
            const Da = Bi(fe, pe, b.transform, An), oa = u.aO(he, nt, w, T), Ki = he.getProjectionData({ overscaledTileID: tt, applyGlobeMatrix: !V, applyTerrainMatrix: !0 }), Wo = ke && it.hasTextData(), Yu = s.layout.get("icon-text-fit") !== "none" && Wo && it.hasIconData();
            if (be) {
              const Jr = b.style.map.terrain ? (Qn, ei) => b.style.map.terrain.getElevation(tt, Qn, ei) : null, Hr = s.layout.get("text-rotation-alignment") === "map";
              Sr(it, b, g, Ei, ho, fe, F, Hr, tt.toUnwrapped(), he.width, he.height, oa, Jr);
            }
            const Xo = g && ke || Yu, ks = be || Xo ? sd : fe ? Ei : b.transform.clipSpaceToPixelsMatrix, la = _t && s.paint.get(g ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Us;
            Us = _t ? it.iconsInText ? o(Lt.kind, an, Ae, fe, be, Xo, b, ks, Da, oa, hn, hi, at) : y(Lt.kind, an, Ae, fe, be, Xo, b, ks, Da, oa, g, hn, 0, at) : Ji(Lt.kind, an, Ae, fe, be, Xo, b, ks, Da, oa, g, hn, at);
            const qs = { program: Or, buffers: St, uniformValues: Us, projectionData: Ki, atlasTexture: Zr, atlasTextureIcon: Fn, atlasInterpolation: Sn, atlasInterpolationIcon: dn, isSDF: _t, hasHalo: la };
            if (xe && it.canOverlap) {
              Ce = !0;
              const Jr = St.segments.get();
              for (const Hr of Jr) je.push({ segments: new u.aX([Hr]), sortKey: Hr.sortKey, state: qs, terrainData: $r });
            } else je.push({ segments: St.segments, sortKey: 0, state: qs, terrainData: $r });
          }
          Ce && je.sort(((tt, nt) => tt.sortKey - nt.sortKey));
          for (const tt of je) {
            const nt = tt.state;
            if (X.activeTexture.set(te.TEXTURE0), nt.atlasTexture.bind(nt.atlasInterpolation, te.CLAMP_TO_EDGE), nt.atlasTextureIcon && (X.activeTexture.set(te.TEXTURE1), nt.atlasTextureIcon && nt.atlasTextureIcon.bind(nt.atlasInterpolationIcon, te.CLAMP_TO_EDGE)), nt.isSDF) {
              const it = nt.uniformValues;
              nt.hasHalo && (it.u_is_halo = 1, zc(nt.buffers, tt.segments, s, b, nt.program, Oe, O, q, it, nt.projectionData, tt.terrainData)), it.u_is_halo = 0;
            }
            zc(nt.buffers, tt.segments, s, b, nt.program, Oe, O, q, nt.uniformValues, nt.projectionData, tt.terrainData);
          }
        }
        function zc(b, t, s, d, g, w, T, C, A, F, O) {
          const q = d.context;
          g.draw(q, q.gl.TRIANGLES, w, T, C, ar.backCCW, A, O, F, s.id, b.layoutVertexBuffer, b.indexBuffer, t, s.paint, d.transform.zoom, b.programConfigurations.get(s.id), b.dynamicLayoutVertexBuffer, b.opacityVertexBuffer);
        }
        function Wf(b, t, s, d, g) {
          const w = b.context, T = w.gl, C = pr.disabled, A = new Lr([T.ONE, T.ONE], u.bp.transparent, [!0, !0, !0, !0]), F = t.getBucket(s);
          if (!F) return;
          const O = d.key;
          let q = s.heatmapFbos.get(O);
          q || (q = Cu(w, t.tileSize, t.tileSize), s.heatmapFbos.set(O, q)), w.bindFramebuffer.set(q.framebuffer), w.viewport.set([0, 0, t.tileSize, t.tileSize]), w.clear({ color: u.bp.transparent });
          const V = F.programConfigurations.get(s.id), X = b.useProgram("heatmap", V, !g), te = b.transform.getProjectionData({ overscaledTileID: t.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), he = b.style.map.terrain.getTerrainData(d);
          X.draw(w, T.TRIANGLES, sr.disabled, C, A, ar.disabled, Ca(t, b.transform.zoom, s.paint.get("heatmap-intensity"), 1), he, te, s.id, F.layoutVertexBuffer, F.indexBuffer, F.segments, s.paint, b.transform.zoom, V);
        }
        function Xf(b, t, s, d, g) {
          const w = b.context, T = w.gl, C = b.transform;
          w.setColorMode(b.colorModeForRenderPass());
          const A = Bc(w, t), F = s.key, O = t.heatmapFbos.get(F);
          if (!O) return;
          w.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, O.colorAttachment.get()), w.activeTexture.set(T.TEXTURE1), A.bind(T.LINEAR, T.CLAMP_TO_EDGE);
          const q = C.getProjectionData({ overscaledTileID: s, applyTerrainMatrix: g, applyGlobeMatrix: !d });
          b.useProgram("heatmapTexture").draw(w, T.TRIANGLES, sr.disabled, pr.disabled, b.colorModeForRenderPass(), ar.disabled, wu(b, t, 0, 1), null, q, t.id, b.rasterBoundsBuffer, b.quadTriangleIndexBuffer, b.rasterBoundsSegments, t.paint, C.zoom), O.destroy(), t.heatmapFbos.delete(F);
        }
        function Cu(b, t, s) {
          var d, g;
          const w = b.gl, T = w.createTexture();
          w.bindTexture(w.TEXTURE_2D, T), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.LINEAR), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.LINEAR);
          const C = (d = b.HALF_FLOAT) !== null && d !== void 0 ? d : w.UNSIGNED_BYTE, A = (g = b.RGBA16F) !== null && g !== void 0 ? g : w.RGBA;
          w.texImage2D(w.TEXTURE_2D, 0, A, t, s, 0, w.RGBA, C, null);
          const F = b.createFramebuffer(t, s, !1, !1);
          return F.colorAttachment.set(T), F;
        }
        function Bc(b, t) {
          return t.colorRampTexture || (t.colorRampTexture = new u.T(b, t.colorRamp, b.gl.RGBA)), t.colorRampTexture;
        }
        function Jf(b, t, s, d, g, w, T, C) {
          let A = 256;
          if (g.stepInterpolant) {
            const F = t.getSource().maxzoom, O = T.canonical.z === F ? Math.ceil(1 << b.transform.maxZoom - T.canonical.z) : 1;
            A = u.an(u.ce(w.maxLineLength / u.a5 * 1024 * O), 256, s.maxTextureSize);
          }
          return C.gradient = u.cf({ expression: g.gradientExpression(), evaluationKey: "lineProgress", resolution: A, image: C.gradient || void 0, clips: w.lineClipsArray }), C.texture ? C.texture.update(C.gradient) : C.texture = new u.T(s, C.gradient, d.RGBA), C.version = g.gradientVersion, C.texture;
        }
        function Kf(b, t, s, d, g) {
          b.activeTexture.set(t.TEXTURE0), s.imageAtlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE), d.updatePaintBuffers(g);
        }
        function Cn(b, t, s, d, g, w) {
          (g || b.lineAtlas.dirty) && (t.activeTexture.set(s.TEXTURE0), b.lineAtlas.bind(t)), d.updatePaintBuffers(w);
        }
        function qo(b, t, s, d, g, w, T) {
          const C = w.gradients[g.id];
          let A = C.texture;
          g.gradientVersion !== C.version && (A = Jf(b, t, s, d, g, w, T, C)), s.activeTexture.set(d.TEXTURE0), A.bind(g.stepInterpolant ? d.NEAREST : d.LINEAR, d.CLAMP_TO_EDGE);
        }
        function ls(b, t, s, d, g, w, T, C, A) {
          const F = w.gradients[g.id];
          let O = F.texture;
          g.gradientVersion !== F.version && (O = Jf(b, t, s, d, g, w, T, F)), s.activeTexture.set(d.TEXTURE0), O.bind(g.stepInterpolant ? d.NEAREST : d.LINEAR, d.CLAMP_TO_EDGE), s.activeTexture.set(d.TEXTURE1), b.lineAtlas.bind(s), C.updatePaintBuffers(A);
        }
        function Gc(b, t, s, d, g) {
          if (!s || !d || !d.imageAtlas) return;
          const w = d.imageAtlas.patternPositions;
          let T = w[s.to.toString()], C = w[s.from.toString()];
          if (!T && C && (T = C), !C && T && (C = T), !T || !C) {
            const A = g.getPaintProperty(t);
            T = w[A], C = w[A];
          }
          T && C && b.setConstantPatternPositions(T, C);
        }
        function Pu(b, t, s, d, g, w, T, C) {
          const A = b.context.gl, F = "fill-pattern", O = s.paint.get(F), q = O && O.constantOr(1), V = s.getCrossfadeParameters();
          let X, te, he, pe, fe;
          const be = b.transform, Ae = s.paint.get("fill-translate"), xe = s.paint.get("fill-translate-anchor");
          T ? (te = q && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", X = A.LINES) : (te = q ? "fillPattern" : "fill", X = A.TRIANGLES);
          const Ce = O.constantOr(null);
          for (const Oe of d) {
            const ke = t.getTile(Oe);
            if (q && !ke.patternsLoaded()) continue;
            const je = ke.getBucket(s);
            if (!je) continue;
            const at = je.programConfigurations.get(s.id), tt = b.useProgram(te, at), nt = b.style.map.terrain && b.style.map.terrain.getTerrainData(Oe);
            q && (b.context.activeTexture.set(A.TEXTURE0), ke.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), at.updatePaintBuffers(V)), Gc(at, F, Ce, ke, s);
            const it = be.getProjectionData({ overscaledTileID: Oe, applyGlobeMatrix: !C, applyTerrainMatrix: !0 }), St = u.aO(be, ke, Ae, xe);
            if (T) {
              pe = je.indexBuffer2, fe = je.segments2;
              const _t = [A.drawingBufferWidth, A.drawingBufferHeight];
              he = te === "fillOutlinePattern" && q ? Cc(b, V, ke, _t, St) : Mc(_t, St);
            } else pe = je.indexBuffer, fe = je.segments, he = q ? xu(b, V, ke, St) : { u_fill_translate: St };
            const It = b.stencilModeForClipping(Oe);
            tt.draw(b.context, X, g, It, w, ar.backCCW, he, nt, it, s.id, je.layoutVertexBuffer, pe, fe, s.paint, b.transform.zoom, at);
          }
        }
        function jc(b, t, s, d, g, w, T, C) {
          const A = b.context, F = A.gl, O = "fill-extrusion-pattern", q = s.paint.get(O), V = q.constantOr(1), X = s.getCrossfadeParameters(), te = s.paint.get("fill-extrusion-opacity"), he = q.constantOr(null), pe = b.transform;
          for (const fe of d) {
            const be = t.getTile(fe), Ae = be.getBucket(s);
            if (!Ae) continue;
            const xe = b.style.map.terrain && b.style.map.terrain.getTerrainData(fe), Ce = Ae.programConfigurations.get(s.id), Oe = b.useProgram(V ? "fillExtrusionPattern" : "fillExtrusion", Ce);
            V && (b.context.activeTexture.set(F.TEXTURE0), be.imageAtlasTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), Ce.updatePaintBuffers(X));
            const ke = pe.getProjectionData({ overscaledTileID: fe, applyGlobeMatrix: !C, applyTerrainMatrix: !0 });
            Gc(Ce, O, he, be, s);
            const je = u.aO(pe, be, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), at = s.paint.get("fill-extrusion-vertical-gradient"), tt = V ? El(b, at, te, je, fe, X, be) : vu(b, at, te, je);
            Oe.draw(A, A.gl.TRIANGLES, g, w, T, ar.backCCW, tt, xe, ke, s.id, Ae.layoutVertexBuffer, Ae.indexBuffer, Ae.segments, s.paint, b.transform.zoom, Ce, b.style.map.terrain && Ae.centroidVertexBuffer);
          }
        }
        function oo(b, t, s, d, g, w, T, C, A) {
          var F;
          const O = b.style.projection, q = b.context, V = b.transform, X = q.gl, te = [`#define NUM_ILLUMINATION_SOURCES ${s.paint.get("hillshade-highlight-color").values.length}`], he = b.useProgram("hillshade", null, !1, te), pe = !b.options.moving;
          for (const fe of d) {
            const be = t.getTile(fe), Ae = be.fbo;
            if (!Ae) continue;
            const xe = O.getMeshFromTileID(q, fe.canonical, C, !0, "raster"), Ce = (F = b.style.map.terrain) === null || F === void 0 ? void 0 : F.getTerrainData(fe);
            q.activeTexture.set(X.TEXTURE0), X.bindTexture(X.TEXTURE_2D, Ae.colorAttachment.get());
            const Oe = V.getProjectionData({ overscaledTileID: fe, aligned: pe, applyGlobeMatrix: !A, applyTerrainMatrix: !0 });
            he.draw(q, X.TRIANGLES, w, g[fe.overscaledZ], T, ar.backCCW, zo(b, be, s), Ce, Oe, s.id, xe.vertexBuffer, xe.indexBuffer, xe.segments);
          }
        }
        function Au(b, t, s, d, g, w, T, C, A) {
          var F;
          const O = b.style.projection, q = b.context, V = b.transform, X = q.gl, te = b.useProgram("colorRelief"), he = !b.options.moving;
          let pe = !0, fe = 0;
          for (const be of d) {
            const Ae = t.getTile(be), xe = Ae.dem;
            if (pe) {
              const tt = X.getParameter(X.MAX_TEXTURE_SIZE), { elevationTexture: nt, colorTexture: it } = s.getColorRampTextures(q, tt, xe.getUnpackVector());
              q.activeTexture.set(X.TEXTURE1), nt.bind(X.NEAREST, X.CLAMP_TO_EDGE), q.activeTexture.set(X.TEXTURE4), it.bind(X.LINEAR, X.CLAMP_TO_EDGE), pe = !1, fe = nt.size[0];
            }
            if (!xe || !xe.data) continue;
            const Ce = xe.stride, Oe = xe.getPixels();
            if (q.activeTexture.set(X.TEXTURE0), q.pixelStoreUnpackPremultiplyAlpha.set(!1), Ae.demTexture = Ae.demTexture || b.getTileTexture(Ce), Ae.demTexture) {
              const tt = Ae.demTexture;
              tt.update(Oe, { premultiply: !1 }), tt.bind(X.LINEAR, X.CLAMP_TO_EDGE);
            } else Ae.demTexture = new u.T(q, Oe, X.RGBA, { premultiply: !1 }), Ae.demTexture.bind(X.LINEAR, X.CLAMP_TO_EDGE);
            const ke = O.getMeshFromTileID(q, be.canonical, C, !0, "raster"), je = (F = b.style.map.terrain) === null || F === void 0 ? void 0 : F.getTerrainData(be), at = V.getProjectionData({ overscaledTileID: be, aligned: he, applyGlobeMatrix: !A, applyTerrainMatrix: !0 });
            te.draw(q, X.TRIANGLES, w, g[be.overscaledZ], T, ar.backCCW, Sl(s, Ae.dem, fe), je, at, s.id, ke.vertexBuffer, ke.indexBuffer, ke.segments);
          }
        }
        const $o = [new u.P(0, 0), new u.P(u.a5, 0), new u.P(u.a5, u.a5), new u.P(0, u.a5)];
        function Al(b, t, s, d, g, w, T, C, A = !1, F = !1) {
          const O = d[d.length - 1].overscaledZ, q = b.context, V = q.gl, X = b.useProgram("raster"), te = b.transform, he = b.style.projection, pe = b.colorModeForRenderPass(), fe = !b.options.moving, be = s.paint.get("raster-opacity"), Ae = s.paint.get("raster-resampling"), xe = s.paint.get("raster-fade-duration"), Ce = !!b.style.map.terrain;
          for (const Oe of d) {
            const ke = b.getDepthModeForSublayer(Oe.overscaledZ - O, be === 1 ? sr.ReadWrite : sr.ReadOnly, V.LESS), je = t.getTile(Oe), at = Ae === "nearest" ? V.NEAREST : V.LINEAR;
            q.activeTexture.set(V.TEXTURE0), je.texture.bind(at, V.CLAMP_TO_EDGE, V.LINEAR_MIPMAP_NEAREST), q.activeTexture.set(V.TEXTURE1);
            const { parentTile: tt, parentScaleBy: nt, parentTopLeft: it, fadeValues: St } = Qf(je, t, xe, Ce);
            je.fadeOpacity = St.tileOpacity, tt ? (tt.fadeOpacity = St.parentTileOpacity, tt.texture.bind(at, V.CLAMP_TO_EDGE, V.LINEAR_MIPMAP_NEAREST)) : je.texture.bind(at, V.CLAMP_TO_EDGE, V.LINEAR_MIPMAP_NEAREST), je.texture.useMipmap && q.extTextureFilterAnisotropic && b.transform.pitch > 20 && V.texParameterf(V.TEXTURE_2D, q.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, q.extTextureFilterAnisotropicMax);
            const It = b.style.map.terrain && b.style.map.terrain.getTerrainData(Oe), _t = te.getProjectionData({ overscaledTileID: Oe, aligned: fe, applyGlobeMatrix: !F, applyTerrainMatrix: !0 }), Lt = Ml(it, nt, St.fadeMix, s, C), or = he.getMeshFromTileID(q, Oe.canonical, w, T, "raster");
            X.draw(q, V.TRIANGLES, ke, g ? g[Oe.overscaledZ] : pr.disabled, pe, A ? ar.frontCCW : ar.backCCW, Lt, It, _t, s.id, or.vertexBuffer, or.indexBuffer, or.segments);
          }
        }
        function Qf(b, t, s, d) {
          const g = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (s === 0 || d) return g;
          if (b.fadingParentID) {
            const w = t.getLoadedTile(b.fadingParentID);
            if (!w) return g;
            const T = Math.pow(2, w.tileID.overscaledZ - b.tileID.overscaledZ), C = [b.tileID.canonical.x * T % 1, b.tileID.canonical.y * T % 1], A = (function(F, O, q) {
              const V = _e(), X = (V - O.timeAdded) / q, te = F.fadingDirection === me.Incoming, he = u.an((V - F.timeAdded) / q, 0, 1), pe = u.an(1 - X, 0, 1), fe = te ? he : pe;
              return { tileOpacity: fe, parentTileOpacity: te ? pe : he, fadeMix: { opacity: 1, mix: 1 - fe } };
            })(b, w, s);
            return { parentTile: w, parentScaleBy: T, parentTopLeft: C, fadeValues: A };
          }
          if (b.selfFading) {
            const w = (function(T, C) {
              const A = (_e() - T.timeAdded) / C, F = u.an(A, 0, 1);
              return { tileOpacity: F, fadeMix: { opacity: F, mix: 0 } };
            })(b, s);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: w };
          }
          return g;
        }
        const ep = new u.bp(1, 0, 0, 1), tp = new u.bp(0, 1, 0, 1), rp = new u.bp(0, 0, 1, 1), np = new u.bp(1, 0, 1, 1), lo = new u.bp(0, 1, 1, 1);
        function ad(b, t, s, d) {
          Lu(b, 0, t + s / 2, b.transform.width, s, d);
        }
        function od(b, t, s, d) {
          Lu(b, t - s / 2, 0, s, b.transform.height, d);
        }
        function Lu(b, t, s, d, g, w) {
          const T = b.context, C = T.gl;
          C.enable(C.SCISSOR_TEST), C.scissor(t * b.pixelRatio, s * b.pixelRatio, d * b.pixelRatio, g * b.pixelRatio), T.clear({ color: w }), C.disable(C.SCISSOR_TEST);
        }
        function ip(b, t, s) {
          const d = b.context, g = d.gl, w = b.useProgram("debug"), T = sr.disabled, C = pr.disabled, A = b.colorModeForRenderPass(), F = "$debug", O = b.style.map.terrain && b.style.map.terrain.getTerrainData(s);
          d.activeTexture.set(g.TEXTURE0);
          const q = t.getTileByID(s.key).latestRawTileData, V = Math.floor((q && q.byteLength || 0) / 1024), X = t.getTile(s).tileSize, te = 512 / Math.min(X, 512) * (s.overscaledZ / b.transform.zoom) * 0.5;
          let he = s.canonical.toString();
          s.overscaledZ !== s.canonical.z && (he += ` => ${s.overscaledZ}`), (function(fe, be) {
            fe.initDebugOverlayCanvas();
            const Ae = fe.debugOverlayCanvas, xe = fe.context.gl, Ce = fe.debugOverlayCanvas.getContext("2d");
            Ce.clearRect(0, 0, Ae.width, Ae.height), Ce.shadowColor = "white", Ce.shadowBlur = 2, Ce.lineWidth = 1.5, Ce.strokeStyle = "white", Ce.textBaseline = "top", Ce.font = "bold 36px Open Sans, sans-serif", Ce.fillText(be, 5, 5), Ce.strokeText(be, 5, 5), fe.debugOverlayTexture.update(Ae), fe.debugOverlayTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE);
          })(b, `${he} ${V}kB`);
          const pe = b.transform.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          w.draw(d, g.TRIANGLES, T, C, Lr.alphaBlended, ar.disabled, bu(u.bp.transparent, te), null, pe, F, b.debugBuffer, b.quadTriangleIndexBuffer, b.debugSegments), w.draw(d, g.LINE_STRIP, T, C, A, ar.disabled, bu(u.bp.red), O, pe, F, b.debugBuffer, b.tileBorderIndexBuffer, b.debugSegments);
        }
        function ld(b, t, s, d) {
          const { isRenderingGlobe: g } = d, w = b.context, T = w.gl, C = b.transform, A = b.colorModeForRenderPass(), F = b.getDepthModeFor3D(), O = b.useProgram("terrain");
          w.bindFramebuffer.set(null), w.viewport.set([0, 0, b.width, b.height]);
          for (const q of s) {
            const V = t.getTerrainMesh(q.tileID), X = b.renderToTexture.getTexture(q), te = t.getTerrainData(q.tileID);
            w.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, X.texture);
            const he = t.getMeshFrameDelta(C.zoom), pe = C.calculateFogMatrix(q.tileID.toUnwrapped()), fe = ed(he, pe, b.style.sky, C.pitch, g), be = C.getProjectionData({ overscaledTileID: q.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            O.draw(w, T.TRIANGLES, F, pr.disabled, A, ar.backCCW, fe, te, be, "terrain", V.vertexBuffer, V.indexBuffer, V.segments);
          }
        }
        function ud(b, t) {
          if (!t.mesh) {
            const s = new u.aW();
            s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(1, 1), s.emplaceBack(-1, 1);
            const d = new u.aY();
            d.emplaceBack(0, 1, 2), d.emplaceBack(0, 2, 3), t.mesh = new Ar(b.createVertexBuffer(s, ta.members), b.createIndexBuffer(d), u.aX.simpleSegment(0, 0, s.length, d.length));
          }
          return t.mesh;
        }
        class sp {
          constructor(t, s) {
            this.context = new Oc(t), this.transform = s, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: u.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Wr.maxOverzooming + Wr.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Xn();
          }
          resize(t, s, d) {
            if (this.width = Math.floor(t * d), this.height = Math.floor(s * d), this.pixelRatio = d, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const g of this.style._order) this.style._layers[g].resize();
          }
          setup() {
            const t = this.context, s = new u.aW();
            s.emplaceBack(0, 0), s.emplaceBack(u.a5, 0), s.emplaceBack(0, u.a5), s.emplaceBack(u.a5, u.a5), this.tileExtentBuffer = t.createVertexBuffer(s, ta.members), this.tileExtentSegments = u.aX.simpleSegment(0, 0, 4, 2);
            const d = new u.aW();
            d.emplaceBack(0, 0), d.emplaceBack(u.a5, 0), d.emplaceBack(0, u.a5), d.emplaceBack(u.a5, u.a5), this.debugBuffer = t.createVertexBuffer(d, ta.members), this.debugSegments = u.aX.simpleSegment(0, 0, 4, 5);
            const g = new u.ch();
            g.emplaceBack(0, 0, 0, 0), g.emplaceBack(u.a5, 0, u.a5, 0), g.emplaceBack(0, u.a5, 0, u.a5), g.emplaceBack(u.a5, u.a5, u.a5, u.a5), this.rasterBoundsBuffer = t.createVertexBuffer(g, Qh.members), this.rasterBoundsSegments = u.aX.simpleSegment(0, 0, 4, 2);
            const w = new u.aW();
            w.emplaceBack(0, 0), w.emplaceBack(u.a5, 0), w.emplaceBack(0, u.a5), w.emplaceBack(u.a5, u.a5), this.rasterBoundsBufferPosOnly = t.createVertexBuffer(w, ta.members), this.rasterBoundsSegmentsPosOnly = u.aX.simpleSegment(0, 0, 4, 5);
            const T = new u.aW();
            T.emplaceBack(0, 0), T.emplaceBack(1, 0), T.emplaceBack(0, 1), T.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(T, ta.members), this.viewportSegments = u.aX.simpleSegment(0, 0, 4, 2);
            const C = new u.ci();
            C.emplaceBack(0), C.emplaceBack(1), C.emplaceBack(3), C.emplaceBack(2), C.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(C);
            const A = new u.aY();
            A.emplaceBack(1, 0, 2), A.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(A);
            const F = this.context.gl;
            this.stencilClearMode = new pr({ func: F.ALWAYS, mask: 0 }, 0, 255, F.ZERO, F.ZERO, F.ZERO), this.tileExtentMesh = new Ar(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const t = this.context, s = t.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const d = u.N();
            u.c7(d, 0, this.width, this.height, 0, 0, 1), u.Q(d, d, [s.drawingBufferWidth, s.drawingBufferHeight, 0]);
            const g = { mainMatrix: d, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: d };
            this.useProgram("clippingMask", null, !0).draw(t, s.TRIANGLES, sr.disabled, this.stencilClearMode, Lr.disabled, ar.disabled, null, null, g, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t, s, d) {
            if (this.currentStencilSource === t.source || !t.isTileClipped() || !s || !s.length) return;
            this.currentStencilSource = t.source, this.nextStencilID + s.length > 256 && this.clearStencil();
            const g = this.context;
            g.setColorMode(Lr.disabled), g.setDepthMode(sr.disabled);
            const w = {};
            for (const T of s) w[T.key] = this.nextStencilID++;
            this._renderTileMasks(w, s, d, !0), this._renderTileMasks(w, s, d, !1), this._tileClippingMaskIDs = w;
          }
          _renderTileMasks(t, s, d, g) {
            const w = this.context, T = w.gl, C = this.style.projection, A = this.transform, F = this.useProgram("clippingMask");
            for (const O of s) {
              const q = t[O.key], V = this.style.map.terrain && this.style.map.terrain.getTerrainData(O), X = C.getMeshFromTileID(this.context, O.canonical, g, !0, "stencil"), te = A.getProjectionData({ overscaledTileID: O, applyGlobeMatrix: !d, applyTerrainMatrix: !0 });
              F.draw(w, T.TRIANGLES, sr.disabled, new pr({ func: T.ALWAYS, mask: 0 }, q, 255, T.KEEP, T.KEEP, T.REPLACE), Lr.disabled, d ? ar.disabled : ar.backCCW, null, V, te, "$clipping", X.vertexBuffer, X.indexBuffer, X.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const t = this.context, s = t.gl, d = this.style.projection, g = this.transform, w = this.useProgram("depth"), T = this.getDepthModeFor3D(), C = wr(g, { tileSize: g.tileSize });
            for (const A of C) {
              const F = this.style.map.terrain && this.style.map.terrain.getTerrainData(A), O = d.getMeshFromTileID(this.context, A.canonical, !0, !0, "raster"), q = g.getProjectionData({ overscaledTileID: A, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              w.draw(t, s.TRIANGLES, T, pr.disabled, Lr.disabled, ar.backCCW, null, F, q, "$clipping", O.vertexBuffer, O.indexBuffer, O.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t = this.nextStencilID++, s = this.context.gl;
            return new pr({ func: s.NOTEQUAL, mask: 255 }, t, 255, s.KEEP, s.KEEP, s.REPLACE);
          }
          stencilModeForClipping(t) {
            const s = this.context.gl;
            return new pr({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(t) {
            const s = this.context.gl, d = t.sort(((T, C) => C.overscaledZ - T.overscaledZ)), g = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - g + 1;
            if (w > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
              const T = {};
              for (let C = 0; C < w; C++) T[C + g] = new pr({ func: s.GEQUAL, mask: 255 }, C + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
              return this.nextStencilID += w, [T, d];
            }
            return [{ [g]: pr.disabled }, d];
          }
          stencilConfigForOverlapTwoPass(t) {
            const s = this.context.gl, d = t.sort(((T, C) => C.overscaledZ - T.overscaledZ)), g = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - g + 1;
            if (this.clearStencil(), w > 1) {
              const T = {}, C = {};
              for (let A = 0; A < w; A++) T[A + g] = new pr({ func: s.GREATER, mask: 255 }, w + 1 + A, 255, s.KEEP, s.KEEP, s.REPLACE), C[A + g] = new pr({ func: s.GREATER, mask: 255 }, 1 + A, 255, s.KEEP, s.KEEP, s.REPLACE);
              return this.nextStencilID = 2 * w + 1, [T, C, d];
            }
            return this.nextStencilID = 3, [{ [g]: new pr({ func: s.GREATER, mask: 255 }, 2, 255, s.KEEP, s.KEEP, s.REPLACE) }, { [g]: new pr({ func: s.GREATER, mask: 255 }, 1, 255, s.KEEP, s.KEEP, s.REPLACE) }, d];
          }
          colorModeForRenderPass() {
            const t = this.context.gl;
            return this._showOverdrawInspector ? new Lr([t.CONSTANT_COLOR, t.ONE], new u.bp(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Lr.unblended : Lr.alphaBlended;
          }
          getDepthModeForSublayer(t, s, d) {
            if (!this.opaquePassEnabledForLayer()) return sr.disabled;
            const g = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
            return new sr(d || this.context.gl.LEQUAL, s, [g, g]);
          }
          getDepthModeFor3D() {
            return new sr(this.context.gl.LEQUAL, sr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t, s) {
            var d, g;
            this.style = t, this.options = s, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(_e()), this.imageManager.beginFrame();
            const w = this.style._order, T = this.style.tileManagers, C = {}, A = {}, F = {}, O = { isRenderingToTexture: !1, isRenderingGlobe: ((d = t.projection) === null || d === void 0 ? void 0 : d.transitionState) > 0 };
            for (const V in T) {
              const X = T[V];
              X.used && X.prepare(this.context), C[V] = X.getVisibleCoordinates(!1), A[V] = C[V].slice().reverse(), F[V] = X.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let V = 0; V < w.length; V++) if (this.style._layers[w[V]].is3D()) {
              this.opaquePassCutoff = V;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const V of w) {
              const X = this.style._layers[V];
              if (!X.hasOffscreenPass() || X.isHidden(this.transform.zoom)) continue;
              const te = A[X.source];
              (X.type === "custom" || te.length) && this.renderLayer(this, T[X.source], X, te, O);
            }
            if ((g = this.style.projection) === null || g === void 0 || g.updateGPUdependent({ context: this.context, useProgram: (V) => this.useProgram(V) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: s.showOverdrawInspector ? u.bp.black : u.bp.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(V, X) {
              const te = V.context, he = te.gl, pe = ((Oe, ke, je) => {
                const at = Math.cos(ke.rollInRadians), tt = Math.sin(ke.rollInRadians), nt = st(ke), it = ke.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: Oe.properties.get("sky-color"), u_horizon_color: Oe.properties.get("horizon-color"), u_horizon: [(ke.width / 2 - nt * tt) * je, (ke.height / 2 + nt * at) * je], u_horizon_normal: [-tt, at], u_sky_horizon_blend: Oe.properties.get("sky-horizon-blend") * ke.height / 2 * je, u_sky_blend: it };
              })(X, V.style.map.transform, V.pixelRatio), fe = new sr(he.LEQUAL, sr.ReadWrite, [0, 1]), be = pr.disabled, Ae = V.colorModeForRenderPass(), xe = V.useProgram("sky"), Ce = ud(te, X);
              xe.draw(te, he.TRIANGLES, fe, be, Ae, ar.disabled, pe, null, void 0, "sky", Ce.vertexBuffer, Ce.indexBuffer, Ce.segments);
            })(this, this.style.sky), this._showOverdrawInspector = s.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = w.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const V = this.style._layers[w[this.currentLayer]], X = T[V.source], te = C[V.source];
              this._renderTileClippingMasks(V, te, !1), this.renderLayer(this, X, V, te, O);
            }
            this.renderPass = "translucent";
            let q = !1;
            for (this.currentLayer = 0; this.currentLayer < w.length; this.currentLayer++) {
              const V = this.style._layers[w[this.currentLayer]], X = T[V.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(V, O)) continue;
              this.opaquePassEnabledForLayer() || q || (q = !0, O.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const te = (V.type === "symbol" ? F : A)[V.source];
              this._renderTileClippingMasks(V, C[V.source], !!this.renderToTexture), this.renderLayer(this, X, V, te, O);
            }
            if (O.isRenderingGlobe && (function(V, X, te) {
              const he = V.context, pe = he.gl, fe = V.useProgram("atmosphere"), be = new sr(pe.LEQUAL, sr.ReadOnly, [0, 1]), Ae = V.transform, xe = (function(it, St) {
                const It = it.properties.get("position"), _t = [-It.x, -It.y, -It.z], Lt = u.ar(new Float64Array(16));
                return it.properties.get("anchor") === "map" && (u.bg(Lt, Lt, St.rollInRadians), u.bh(Lt, Lt, -St.pitchInRadians), u.bg(Lt, Lt, St.bearingInRadians), u.bh(Lt, Lt, St.center.lat * Math.PI / 180), u.bJ(Lt, Lt, -St.center.lng * Math.PI / 180)), u.cg(_t, _t, Lt), _t;
              })(te, V.transform), Ce = Ae.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Oe = X.properties.get("atmosphere-blend") * Ce.projectionTransition;
              if (Oe === 0) return;
              const ke = ji(Ae.worldSize, Ae.center.lat), je = Ae.inverseProjectionMatrix, at = new Float64Array(4);
              at[3] = 1, u.aH(at, at, Ae.modelViewProjectionMatrix), at[0] /= at[3], at[1] /= at[3], at[2] /= at[3], at[3] = 1, u.aH(at, at, je), at[0] /= at[3], at[1] /= at[3], at[2] /= at[3], at[3] = 1;
              const tt = /* @__PURE__ */ ((it, St, It, _t, Lt) => ({ u_sun_pos: it, u_atmosphere_blend: St, u_globe_position: It, u_globe_radius: _t, u_inv_proj_matrix: Lt }))(xe, Oe, [at[0], at[1], at[2]], ke, je), nt = ud(he, X);
              fe.draw(he, pe.TRIANGLES, be, pr.disabled, Lr.alphaBlended, ar.disabled, tt, null, null, "atmosphere", nt.vertexBuffer, nt.indexBuffer, nt.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const V = (function(X, te) {
                let he = null;
                const pe = Object.values(X._layers).flatMap(((xe) => xe.source && !xe.isHidden(te) ? [X.tileManagers[xe.source]] : [])), fe = pe.filter(((xe) => xe.getSource().type === "vector")), be = pe.filter(((xe) => xe.getSource().type !== "vector")), Ae = (xe) => {
                  (!he || he.getSource().maxzoom < xe.getSource().maxzoom) && (he = xe);
                };
                return fe.forEach(((xe) => Ae(xe))), he || be.forEach(((xe) => Ae(xe))), he;
              })(this.style, this.transform.zoom);
              V && (function(X, te, he) {
                for (let pe = 0; pe < he.length; pe++) ip(X, te, he[pe]);
              })(this, V, V.getVisibleCoordinates());
            }
            this.options.showPadding && (function(V) {
              const X = V.transform.padding;
              ad(V, V.transform.height - (X.top || 0), 3, ep), ad(V, X.bottom || 0, 3, tp), od(V, X.left || 0, 3, rp), od(V, V.transform.width - (X.right || 0), 3, np);
              const te = V.transform.centerPoint;
              (function(he, pe, fe, be) {
                Lu(he, pe - 1, fe - 10, 2, 20, be), Lu(he, pe - 10, fe - 1, 20, 2, be);
              })(V, te.x, V.transform.height - te.y, lo);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(t) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const s = this.terrainFacilitator.matrix, d = this.transform.modelViewProjectionMatrix;
            let g = this.terrainFacilitator.dirty;
            g || (g = t ? !u.cj(s, d) : !u.ck(s, d)), g || (g = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), g && (u.cl(s, d), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(w, T) {
              const C = w.context, A = C.gl, F = w.transform, O = Lr.unblended, q = new sr(A.LEQUAL, sr.ReadWrite, [0, 1]), V = T.tileManager.getRenderableTiles(), X = w.useProgram("terrainDepth");
              C.bindFramebuffer.set(T.getFramebuffer("depth").framebuffer), C.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), C.clear({ color: u.bp.transparent, depth: 1 });
              for (const te of V) {
                const he = T.getTerrainMesh(te.tileID), pe = T.getTerrainData(te.tileID), fe = F.getProjectionData({ overscaledTileID: te.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), be = { u_ele_delta: T.getMeshFrameDelta(F.zoom) };
                X.draw(C, A.TRIANGLES, q, pr.disabled, O, ar.backCCW, be, pe, fe, "terrain", he.vertexBuffer, he.indexBuffer, he.segments);
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, w.width, w.height]);
            })(this, this.style.map.terrain), (function(w, T) {
              const C = w.context, A = C.gl, F = w.transform, O = Lr.unblended, q = new sr(A.LEQUAL, sr.ReadWrite, [0, 1]), V = T.getCoordsTexture(), X = T.tileManager.getRenderableTiles(), te = w.useProgram("terrainCoords");
              C.bindFramebuffer.set(T.getFramebuffer("coords").framebuffer), C.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), C.clear({ color: u.bp.transparent, depth: 1 }), T.coordsIndex = [];
              for (const he of X) {
                const pe = T.getTerrainMesh(he.tileID), fe = T.getTerrainData(he.tileID);
                C.activeTexture.set(A.TEXTURE0), A.bindTexture(A.TEXTURE_2D, V.texture);
                const be = { u_terrain_coords_id: (255 - T.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: T.getMeshFrameDelta(F.zoom) }, Ae = F.getProjectionData({ overscaledTileID: he.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                te.draw(C, A.TRIANGLES, q, pr.disabled, O, ar.backCCW, be, fe, Ae, "terrain", pe.vertexBuffer, pe.indexBuffer, pe.segments), T.coordsIndex.push(he.tileID.key);
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, w.width, w.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(t, s, d, g, w) {
            d.isHidden(this.transform.zoom) || (d.type === "background" || d.type === "custom" || (g || []).length) && (this.id = d.id, u.cm(d) ? (function(T, C, A, F, O, q) {
              if (T.renderPass !== "translucent") return;
              const { isRenderingToTexture: V } = q, X = pr.disabled, te = T.colorModeForRenderPass();
              (A._unevaluatedLayout.hasValue("text-variable-anchor") || A._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(he, pe, fe, be, Ae, xe, Ce, Oe, ke) {
                const je = pe.transform, at = pe.style.map.terrain, tt = Ae === "map", nt = xe === "map";
                for (const it of he) {
                  const St = be.getTile(it), It = St.getBucket(fe);
                  if (!It || !It.text || !It.text.segments.get().length) continue;
                  const _t = u.ay(It.textSizeData, je.zoom), Lt = u.aN(St, 1, pe.transform.zoom), or = mn(tt, pe.transform, Lt), Or = fe.layout.get("icon-text-fit") !== "none" && It.hasIconData();
                  if (_t) {
                    const an = Math.pow(2, je.zoom - St.tileID.overscaledZ), $r = at ? (hn, Zr) => at.getElevation(it, hn, Zr) : null;
                    lm(It, tt, nt, ke, je, or, an, _t, Or, u.aO(je, St, Ce, Oe), it.toUnwrapped(), $r);
                  }
                }
              })(F, T, A, C, A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), O), A.paint.get("icon-opacity").constantOr(1) !== 0 && Mu(T, C, A, F, !1, A.paint.get("icon-translate"), A.paint.get("icon-translate-anchor"), A.layout.get("icon-rotation-alignment"), A.layout.get("icon-pitch-alignment"), A.layout.get("icon-keep-upright"), X, te, V), A.paint.get("text-opacity").constantOr(1) !== 0 && Mu(T, C, A, F, !0, A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.layout.get("text-keep-upright"), X, te, V), C.map.showCollisionBoxes && (Uo(T, C, A, F, !0), Uo(T, C, A, F, !1));
            })(t, s, d, g, this.style.placement.variableOffsets, w) : u.cn(d) ? (function(T, C, A, F, O) {
              if (T.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = O, V = A.paint.get("circle-opacity"), X = A.paint.get("circle-stroke-width"), te = A.paint.get("circle-stroke-opacity"), he = !A.layout.get("circle-sort-key").isConstant();
              if (V.constantOr(1) === 0 && (X.constantOr(1) === 0 || te.constantOr(1) === 0)) return;
              const pe = T.context, fe = pe.gl, be = T.transform, Ae = T.getDepthModeForSublayer(0, sr.ReadOnly), xe = pr.disabled, Ce = T.colorModeForRenderPass(), Oe = [], ke = be.getCircleRadiusCorrection();
              for (let je = 0; je < F.length; je++) {
                const at = F[je], tt = C.getTile(at), nt = tt.getBucket(A);
                if (!nt) continue;
                const it = A.paint.get("circle-translate"), St = A.paint.get("circle-translate-anchor"), It = u.aO(be, tt, it, St), _t = nt.programConfigurations.get(A.id), Lt = T.useProgram("circle", _t), or = nt.layoutVertexBuffer, Or = nt.indexBuffer, an = T.style.map.terrain && T.style.map.terrain.getTerrainData(at), $r = { programConfiguration: _t, program: Lt, layoutVertexBuffer: or, indexBuffer: Or, uniformValues: Pc(T, tt, A, It, ke), terrainData: an, projectionData: be.getProjectionData({ overscaledTileID: at, applyGlobeMatrix: !q, applyTerrainMatrix: !0 }) };
                if (he) {
                  const hn = nt.segments.get();
                  for (const Zr of hn) Oe.push({ segments: new u.aX([Zr]), sortKey: Zr.sortKey, state: $r });
                } else Oe.push({ segments: nt.segments, sortKey: 0, state: $r });
              }
              he && Oe.sort(((je, at) => je.sortKey - at.sortKey));
              for (const je of Oe) {
                const { programConfiguration: at, program: tt, layoutVertexBuffer: nt, indexBuffer: it, uniformValues: St, terrainData: It, projectionData: _t } = je.state;
                tt.draw(pe, fe.TRIANGLES, Ae, xe, Ce, ar.backCCW, St, It, _t, A.id, nt, it, je.segments, A.paint, T.transform.zoom, at);
              }
            })(t, s, d, g, w) : u.co(d) ? (function(T, C, A, F, O) {
              if (A.paint.get("heatmap-opacity") === 0) return;
              const q = T.context, { isRenderingToTexture: V, isRenderingGlobe: X } = O;
              if (T.style.map.terrain) {
                for (const te of F) {
                  const he = C.getTile(te);
                  C.hasRenderableParent(te) || (T.renderPass === "offscreen" ? Wf(T, he, A, te, X) : T.renderPass === "translucent" && Xf(T, A, te, V, X));
                }
                q.viewport.set([0, 0, T.width, T.height]);
              } else T.renderPass === "offscreen" ? (function(te, he, pe, fe) {
                const be = te.context, Ae = be.gl, xe = te.transform, Ce = pr.disabled, Oe = new Lr([Ae.ONE, Ae.ONE], u.bp.transparent, [!0, !0, !0, !0]);
                (function(ke, je, at) {
                  const tt = ke.gl;
                  ke.activeTexture.set(tt.TEXTURE1), ke.viewport.set([0, 0, je.width / 4, je.height / 4]);
                  let nt = at.heatmapFbos.get(u.cd);
                  nt ? (tt.bindTexture(tt.TEXTURE_2D, nt.colorAttachment.get()), ke.bindFramebuffer.set(nt.framebuffer)) : (nt = Cu(ke, je.width / 4, je.height / 4), at.heatmapFbos.set(u.cd, nt));
                })(be, te, pe), be.clear({ color: u.bp.transparent });
                for (let ke = 0; ke < fe.length; ke++) {
                  const je = fe[ke];
                  if (he.hasRenderableParent(je)) continue;
                  const at = he.getTile(je), tt = at.getBucket(pe);
                  if (!tt) continue;
                  const nt = tt.programConfigurations.get(pe.id), it = te.useProgram("heatmap", nt), St = xe.getProjectionData({ overscaledTileID: je, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), It = xe.getCircleRadiusCorrection();
                  it.draw(be, Ae.TRIANGLES, sr.disabled, Ce, Oe, ar.backCCW, Ca(at, xe.zoom, pe.paint.get("heatmap-intensity"), It), null, St, pe.id, tt.layoutVertexBuffer, tt.indexBuffer, tt.segments, pe.paint, xe.zoom, nt);
                }
                be.viewport.set([0, 0, te.width, te.height]);
              })(T, C, A, F) : T.renderPass === "translucent" && (function(te, he) {
                const pe = te.context, fe = pe.gl;
                pe.setColorMode(te.colorModeForRenderPass());
                const be = he.heatmapFbos.get(u.cd);
                be && (pe.activeTexture.set(fe.TEXTURE0), fe.bindTexture(fe.TEXTURE_2D, be.colorAttachment.get()), pe.activeTexture.set(fe.TEXTURE1), Bc(pe, he).bind(fe.LINEAR, fe.CLAMP_TO_EDGE), te.useProgram("heatmapTexture").draw(pe, fe.TRIANGLES, sr.disabled, pr.disabled, te.colorModeForRenderPass(), ar.disabled, wu(te, he, 0, 1), null, null, he.id, te.viewportBuffer, te.quadTriangleIndexBuffer, te.viewportSegments, he.paint, te.transform.zoom));
              })(T, A);
            })(t, s, d, g, w) : u.cp(d) ? (function(T, C, A, F, O) {
              if (T.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = O, V = A.paint.get("line-opacity"), X = A.paint.get("line-width");
              if (V.constantOr(1) === 0 || X.constantOr(1) === 0) return;
              const te = T.getDepthModeForSublayer(0, sr.ReadOnly), he = T.colorModeForRenderPass(), pe = A.paint.get("line-dasharray"), fe = pe.constantOr(1), be = A.paint.get("line-pattern"), Ae = be.constantOr(1), xe = A.paint.get("line-gradient"), Ce = A.getCrossfadeParameters();
              let Oe;
              Oe = Ae ? "linePattern" : fe && xe ? "lineGradientSDF" : fe ? "lineSDF" : xe ? "lineGradient" : "line";
              const ke = T.context, je = ke.gl, at = T.transform;
              let tt = !0;
              for (const nt of F) {
                const it = C.getTile(nt);
                if (Ae && !it.patternsLoaded()) continue;
                const St = it.getBucket(A);
                if (!St) continue;
                const It = St.programConfigurations.get(A.id), _t = T.context.program.get(), Lt = T.useProgram(Oe, It), or = tt || Lt.program !== _t, Or = T.style.map.terrain && T.style.map.terrain.getTerrainData(nt), an = be.constantOr(null), $r = pe && pe.constantOr(null);
                if (an && it.imageAtlas) {
                  const hi = it.imageAtlas, Fn = hi.patternPositions[an.to.toString()], An = hi.patternPositions[an.from.toString()];
                  Fn && An && It.setConstantPatternPositions(Fn, An);
                } else if ($r) {
                  const hi = A.layout.get("line-cap") === "round", Fn = T.lineAtlas.getDash($r.to, hi), An = T.lineAtlas.getDash($r.from, hi);
                  It.setConstantDashPositions(Fn, An);
                }
                const hn = at.getProjectionData({ overscaledTileID: nt, applyGlobeMatrix: !q, applyTerrainMatrix: !0 }), Zr = at.getPixelScale();
                let Sn;
                Ae ? (Sn = Tl(T, it, A, Zr, Ce), Kf(ke, je, it, It, Ce)) : fe && xe ? (Sn = kl(T, it, A, Zr, Ce, St.lineClipsArray.length), ls(T, C, ke, je, A, St, nt, It, Ce)) : fe ? (Sn = Dc(T, it, A, Zr, Ce), Cn(T, ke, je, It, or, Ce)) : xe ? (Sn = Eu(T, it, A, Zr, St.lineClipsArray.length), qo(T, C, ke, je, A, St, nt)) : Sn = Bo(T, it, A, Zr);
                const dn = T.stencilModeForClipping(nt);
                Lt.draw(ke, je.TRIANGLES, te, dn, he, ar.disabled, Sn, Or, hn, A.id, St.layoutVertexBuffer, St.indexBuffer, St.segments, A.paint, T.transform.zoom, It, St.layoutVertexBuffer2), tt = !1;
              }
            })(t, s, d, g, w) : u.cq(d) ? (function(T, C, A, F, O) {
              const q = A.paint.get("fill-color"), V = A.paint.get("fill-opacity");
              if (V.constantOr(1) === 0) return;
              const { isRenderingToTexture: X } = O, te = T.colorModeForRenderPass(), he = A.paint.get("fill-pattern"), pe = T.opaquePassEnabledForLayer() && !he.constantOr(1) && q.constantOr(u.bp.transparent).a === 1 && V.constantOr(0) === 1 ? "opaque" : "translucent";
              if (T.renderPass === pe) {
                const fe = T.getDepthModeForSublayer(1, T.renderPass === "opaque" ? sr.ReadWrite : sr.ReadOnly);
                Pu(T, C, A, F, fe, te, !1, X);
              }
              if (T.renderPass === "translucent" && A.paint.get("fill-antialias")) {
                const fe = T.getDepthModeForSublayer(A.getPaintProperty("fill-outline-color") ? 2 : 0, sr.ReadOnly);
                Pu(T, C, A, F, fe, te, !0, X);
              }
            })(t, s, d, g, w) : u.cr(d) ? (function(T, C, A, F, O) {
              const q = A.paint.get("fill-extrusion-opacity");
              if (q === 0) return;
              const { isRenderingToTexture: V } = O;
              if (T.renderPass === "translucent") {
                const X = new sr(T.context.gl.LEQUAL, sr.ReadWrite, T.depthRangeFor3D);
                if (q !== 1 || A.paint.get("fill-extrusion-pattern").constantOr(1)) jc(T, C, A, F, X, pr.disabled, Lr.disabled, V), jc(T, C, A, F, X, T.stencilModeFor3D(), T.colorModeForRenderPass(), V);
                else {
                  const te = T.colorModeForRenderPass();
                  jc(T, C, A, F, X, pr.disabled, te, V);
                }
              }
            })(t, s, d, g, w) : u.cs(d) ? (function(T, C, A, F, O) {
              if (T.renderPass !== "offscreen" && T.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = O, V = T.context, X = T.style.projection.useSubdivision, te = T.getDepthModeForSublayer(0, sr.ReadOnly), he = T.colorModeForRenderPass();
              if (T.renderPass === "offscreen") (function(pe, fe, be, Ae, xe, Ce, Oe) {
                const ke = pe.context, je = ke.gl;
                for (const at of be) {
                  const tt = fe.getTile(at), nt = tt.dem;
                  if (!nt || !nt.data || !tt.needsHillshadePrepare) continue;
                  const it = nt.dim, St = nt.stride, It = nt.getPixels();
                  if (ke.activeTexture.set(je.TEXTURE1), ke.pixelStoreUnpackPremultiplyAlpha.set(!1), tt.demTexture = tt.demTexture || pe.getTileTexture(St), tt.demTexture) {
                    const Lt = tt.demTexture;
                    Lt.update(It, { premultiply: !1 }), Lt.bind(je.NEAREST, je.CLAMP_TO_EDGE);
                  } else tt.demTexture = new u.T(ke, It, je.RGBA, { premultiply: !1 }), tt.demTexture.bind(je.NEAREST, je.CLAMP_TO_EDGE);
                  ke.activeTexture.set(je.TEXTURE0);
                  let _t = tt.fbo;
                  if (!_t) {
                    const Lt = new u.T(ke, { width: it, height: it, data: null }, je.RGBA);
                    Lt.bind(je.LINEAR, je.CLAMP_TO_EDGE), _t = tt.fbo = ke.createFramebuffer(it, it, !0, !1), _t.colorAttachment.set(Lt.texture);
                  }
                  ke.bindFramebuffer.set(_t.framebuffer), ke.viewport.set([0, 0, it, it]), pe.useProgram("hillshadePrepare").draw(ke, je.TRIANGLES, xe, Ce, Oe, ar.disabled, td(tt.tileID, nt), null, null, Ae.id, pe.rasterBoundsBuffer, pe.quadTriangleIndexBuffer, pe.rasterBoundsSegments), tt.needsHillshadePrepare = !1;
                }
              })(T, C, F, A, te, pr.disabled, he), V.viewport.set([0, 0, T.width, T.height]);
              else if (T.renderPass === "translucent") if (X) {
                const [pe, fe, be] = T.stencilConfigForOverlapTwoPass(F);
                oo(T, C, A, be, pe, te, he, !1, q), oo(T, C, A, be, fe, te, he, !0, q);
              } else {
                const [pe, fe] = T.getStencilConfigForOverlapAndUpdateStencilID(F);
                oo(T, C, A, fe, pe, te, he, !1, q);
              }
            })(t, s, d, g, w) : u.ct(d) ? (function(T, C, A, F, O) {
              if (T.renderPass !== "translucent" || !F.length) return;
              const { isRenderingToTexture: q } = O, V = T.style.projection.useSubdivision, X = T.getDepthModeForSublayer(0, sr.ReadOnly), te = T.colorModeForRenderPass();
              if (V) {
                const [he, pe, fe] = T.stencilConfigForOverlapTwoPass(F);
                Au(T, C, A, fe, he, X, te, !1, q), Au(T, C, A, fe, pe, X, te, !0, q);
              } else {
                const [he, pe] = T.getStencilConfigForOverlapAndUpdateStencilID(F);
                Au(T, C, A, pe, he, X, te, !1, q);
              }
            })(t, s, d, g, w) : u.bU(d) ? (function(T, C, A, F, O) {
              if (T.renderPass !== "translucent" || A.paint.get("raster-opacity") === 0 || !F.length) return;
              const { isRenderingToTexture: q } = O, V = C.getSource(), X = T.style.projection.useSubdivision;
              if (V instanceof ln) Al(T, C, A, F, null, !1, !1, V.tileCoords, V.flippedWindingOrder, q);
              else if (X) {
                const [te, he, pe] = T.stencilConfigForOverlapTwoPass(F);
                Al(T, C, A, pe, te, !1, !0, $o, !1, q), Al(T, C, A, pe, he, !0, !0, $o, !1, q);
              } else {
                const [te, he] = T.getStencilConfigForOverlapAndUpdateStencilID(F);
                Al(T, C, A, he, te, !1, !0, $o, !1, q);
              }
            })(t, s, d, g, w) : u.cu(d) ? (function(T, C, A, F, O) {
              const q = A.paint.get("background-color"), V = A.paint.get("background-opacity");
              if (V === 0) return;
              const { isRenderingToTexture: X } = O, te = T.context, he = te.gl, pe = T.style.projection, fe = T.transform, be = fe.tileSize, Ae = A.paint.get("background-pattern");
              if (T.isPatternMissing(Ae)) return;
              const xe = !Ae && q.a === 1 && V === 1 && T.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (T.renderPass !== xe) return;
              const Ce = pr.disabled, Oe = T.getDepthModeForSublayer(0, xe === "opaque" ? sr.ReadWrite : sr.ReadOnly), ke = T.colorModeForRenderPass(), je = T.useProgram(Ae ? "backgroundPattern" : "background"), at = F || wr(fe, { tileSize: be, terrain: T.style.map.terrain });
              Ae && (te.activeTexture.set(he.TEXTURE0), T.imageManager.bind(T.context));
              const tt = A.getCrossfadeParameters();
              for (const nt of at) {
                const it = fe.getProjectionData({ overscaledTileID: nt, applyGlobeMatrix: !X, applyTerrainMatrix: !0 }), St = Ae ? _(V, T, Ae, { tileID: nt, tileSize: be }, tt) : h(V, q), It = T.style.map.terrain && T.style.map.terrain.getTerrainData(nt), _t = pe.getMeshFromTileID(te, nt.canonical, !1, !0, "raster");
                je.draw(te, he.TRIANGLES, Oe, Ce, ke, ar.backCCW, St, It, it, A.id, _t.vertexBuffer, _t.indexBuffer, _t.segments);
              }
            })(t, 0, d, g, w) : u.cv(d) && (function(T, C, A, F) {
              const { isRenderingGlobe: O } = F, q = T.context, V = A.implementation, X = T.style.projection, te = T.transform, he = te.getProjectionDataForCustomLayer(O), pe = { farZ: te.farZ, nearZ: te.nearZ, fov: te.fov * Math.PI / 180, modelViewProjectionMatrix: te.modelViewProjectionMatrix, projectionMatrix: te.projectionMatrix, shaderData: { variantName: X.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${X.shaderPreludeCode.vertexSource}`, define: X.shaderDefine }, defaultProjectionData: he }, fe = V.renderingMode ? V.renderingMode : "2d";
              if (T.renderPass === "offscreen") {
                const be = V.prerender;
                be && (T.setCustomLayerDefaults(), q.setColorMode(T.colorModeForRenderPass()), be.call(V, q.gl, pe), q.setDirty(), T.setBaseState());
              } else if (T.renderPass === "translucent") {
                T.setCustomLayerDefaults(), q.setColorMode(T.colorModeForRenderPass()), q.setStencilMode(pr.disabled);
                const be = fe === "3d" ? T.getDepthModeFor3D() : T.getDepthModeForSublayer(0, sr.ReadOnly);
                q.setDepthMode(be), V.render(q.gl, pe), q.setDirty(), T.setBaseState(), q.bindFramebuffer.set(null);
              }
            })(t, 0, d, w));
          }
          saveTileTexture(t) {
            const s = this._tileTextures[t.size[0]];
            s ? s.push(t) : this._tileTextures[t.size[0]] = [t];
          }
          getTileTexture(t) {
            const s = this._tileTextures[t];
            return s && s.length > 0 ? s.pop() : null;
          }
          isPatternMissing(t) {
            if (!t) return !1;
            if (!t.from || !t.to) return !0;
            const s = this.imageManager.getPattern(t.from.toString()), d = this.imageManager.getPattern(t.to.toString());
            return !s || !d;
          }
          useProgram(t, s, d = !1, g = []) {
            this.cache = this.cache || {};
            const w = !!this.style.map.terrain, T = this.style.projection, C = d ? tn.projectionMercator : T.shaderPreludeCode, A = d ? oi : T.shaderDefine, F = t + (s ? s.cacheKey : "") + `/${d ? hr : T.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (w ? "/terrain" : "") + (g ? `/${g.join("/")}` : "");
            return this.cache[F] || (this.cache[F] = new Ic(this.context, tn[t], s, D[t], this._showOverdrawInspector, w, C, A, g)), this.cache[F];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new u.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            var t, s;
            if (this._tileTextures) {
              for (const d in this._tileTextures) {
                const g = this._tileTextures[d];
                if (g) for (const w of g) w.destroy();
              }
              this._tileTextures = {};
            }
            if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && ((t = this.tileExtentMesh.vertexBuffer) === null || t === void 0 || t.destroy()), this.tileExtentMesh && ((s = this.tileExtentMesh.indexBuffer) === null || s === void 0 || s.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
              for (const d in this.cache) {
                const g = this.cache[d];
                g && g.program && this.context.gl.deleteProgram(g.program);
              }
              this.cache = {};
            }
            this.context && this.context.setDefault();
          }
          overLimit() {
            const { drawingBufferWidth: t, drawingBufferHeight: s } = this.context.gl;
            return this.width !== t || this.height !== s;
          }
        }
        function cd(b, t) {
          let s, d = !1, g = null, w = null;
          const T = () => {
            g = null, d && (b.apply(w, s), g = setTimeout(T, t), d = !1);
          };
          return (...C) => (d = !0, w = this, s = C, g || T(), g);
        }
        class hd {
          constructor(t) {
            this._getCurrentHash = () => {
              const s = window.location.hash.replace("#", "");
              if (this._hashName) {
                let d;
                return s.split("&").map(((g) => g.split("="))).forEach(((g) => {
                  g[0] === this._hashName && (d = g);
                })), (d && d[1] || "").split("/");
              }
              return s.split("/");
            }, this._onHashChange = () => {
              const s = this._getCurrentHash();
              if (!this._isValidHash(s)) return !1;
              const d = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(s[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: d, pitch: +(s[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const s = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, s);
            }, this._removeHash = () => {
              const s = this._getCurrentHash();
              if (s.length === 0) return;
              const d = s.join("/");
              let g = d;
              g.split("&").length > 0 && (g = g.split("&")[0]), this._hashName && (g = `${this._hashName}=${d}`);
              let w = window.location.hash.replace(g, "");
              w.startsWith("#&") ? w = w.slice(0, 1) + w.slice(2) : w === "#" && (w = "");
              let T = window.location.href.replace(/(#.+)?$/, w);
              T = T.replace("&&", "&"), window.history.replaceState(window.history.state, null, T);
            }, this._updateHash = cd(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t);
          }
          addTo(t) {
            return this._map = t, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(t) {
            const s = this._map.getCenter(), d = Math.round(100 * this._map.getZoom()) / 100, g = Math.ceil((d * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), w = Math.pow(10, g), T = Math.round(s.lng * w) / w, C = Math.round(s.lat * w) / w, A = this._map.getBearing(), F = this._map.getPitch();
            let O = "";
            if (O += t ? `/${T}/${C}/${d}` : `${d}/${C}/${T}`, (A || F) && (O += "/" + Math.round(10 * A) / 10), F && (O += `/${Math.round(F)}`), this._hashName) {
              const q = this._hashName;
              let V = !1;
              const X = window.location.hash.slice(1).split("&").map(((te) => {
                const he = te.split("=")[0];
                return he === q ? (V = !0, `${he}=${O}`) : te;
              })).filter(((te) => te));
              return V || X.push(`${q}=${O}`), `#${X.join("&")}`;
            }
            return `#${O}`;
          }
          _isValidHash(t) {
            if (t.length < 3 || t.some(isNaN)) return !1;
            try {
              new u.V(+t[2], +t[1]);
            } catch {
              return !1;
            }
            const s = +t[0], d = +(t[3] || 0), g = +(t[4] || 0);
            return s >= this._map.getMinZoom() && s <= this._map.getMaxZoom() && d >= -180 && d <= 180 && g >= this._map.getMinPitch() && g <= this._map.getMaxPitch();
          }
        }
        const uo = { linearity: 0.3, easing: u.cw(0, 0, 0.3, 1) }, ap = u.e({ deceleration: 2500, maxSpeed: 1400 }, uo), Ss = u.e({ deceleration: 20, maxSpeed: 1400 }, uo), Bs = u.e({ deceleration: 1e3, maxSpeed: 360 }, uo), op = u.e({ deceleration: 1e3, maxSpeed: 90 }, uo), Gs = u.e({ deceleration: 1e3, maxSpeed: 360 }, uo);
        class um {
          constructor(t) {
            this._map = t, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: _e(), settings: t });
          }
          _drainInertiaBuffer() {
            const t = this._inertiaBuffer, s = _e();
            for (; t.length > 0 && s - t[0].time > 160; ) t.shift();
          }
          _onMoveEnd(t) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const s = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new u.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: w } of this._inertiaBuffer) s.zoom += w.zoomDelta || 0, s.bearing += w.bearingDelta || 0, s.pitch += w.pitchDelta || 0, s.roll += w.rollDelta || 0, w.panDelta && s.pan._add(w.panDelta), w.around && (s.around = w.around), w.pinchAround && (s.pinchAround = w.pinchAround);
            const d = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, g = {};
            if (s.pan.mag()) {
              const w = Ru(s.pan.mag(), d, u.e({}, ap, t || {})), T = s.pan.mult(w.amount / s.pan.mag()), C = this._map.cameraHelper.handlePanInertia(T, this._map.transform);
              g.center = C.easingCenter, g.offset = C.easingOffset, Du(g, w);
            }
            if (s.zoom) {
              const w = Ru(s.zoom, d, Ss), T = u.cx(this._map.transform.zoom + w.amount, this._map.getZoomSnap(), w.amount);
              g.zoom = T, Du(g, w);
            }
            if (s.bearing) {
              const w = Ru(s.bearing, d, Bs);
              g.bearing = this._map.transform.bearing + u.an(w.amount, -179, 179), Du(g, w);
            }
            if (s.pitch) {
              const w = Ru(s.pitch, d, op);
              g.pitch = this._map.transform.pitch + w.amount, Du(g, w);
            }
            if (s.roll) {
              const w = Ru(s.roll, d, Gs);
              g.roll = this._map.transform.roll + u.an(w.amount, -179, 179), Du(g, w);
            }
            if (g.zoom || g.bearing) {
              const w = s.pinchAround === void 0 ? s.around : s.pinchAround;
              g.around = w ? this._map.unproject(w) : this._map.getCenter();
            }
            return this.clear(), u.e(g, { noMoveStart: !0 });
          }
        }
        function Du(b, t) {
          (!b.duration || b.duration < t.duration) && (b.duration = t.duration, b.easing = t.easing);
        }
        function Ru(b, t, s) {
          const { maxSpeed: d, linearity: g, deceleration: w } = s, T = u.an(b * g / (t / 1e3), -d, d), C = Math.abs(T) / (w * g);
          return { easing: s.easing, duration: 1e3 * C, amount: T * (C / 2) };
        }
        class ci extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, s, d, g = {}) {
            d = d instanceof MouseEvent ? d : new MouseEvent(t, d);
            const w = ne.mousePos(s.getCanvas(), d), T = s.unproject(w);
            super(t, u.e({ point: w, lngLat: T, originalEvent: d }, g)), this._defaultPrevented = !1, this.target = s;
          }
        }
        class Fu extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, s, d) {
            const g = t === "touchend" ? d.changedTouches : d.touches, w = ne.touchPos(s.getCanvasContainer(), g), T = w.map(((A) => s.unproject(A))), C = w.reduce(((A, F, O, q) => A.add(F.div(q.length))), new u.P(0, 0));
            super(t, { points: w, point: C, lngLats: T, lngLat: s.unproject(C), originalEvent: d }), this._defaultPrevented = !1;
          }
        }
        class lp extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, s, d) {
            super(t, { originalEvent: d }), this._defaultPrevented = !1;
          }
        }
        class cm {
          constructor(t, s) {
            this._map = t, this._clickTolerance = s.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t) {
            return this._firePreventable(new lp(t.type, this._map, t));
          }
          mousedown(t, s) {
            return this._mousedownPos = s, this._firePreventable(new ci(t.type, this._map, t));
          }
          mouseup(t) {
            this._map.fire(new ci(t.type, this._map, t));
          }
          click(t, s) {
            this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || this._map.fire(new ci(t.type, this._map, t));
          }
          dblclick(t) {
            return this._firePreventable(new ci(t.type, this._map, t));
          }
          mouseover(t) {
            this._map.fire(new ci(t.type, this._map, t));
          }
          mouseout(t) {
            this._map.fire(new ci(t.type, this._map, t));
          }
          touchstart(t) {
            return this._firePreventable(new Fu(t.type, this._map, t));
          }
          touchmove(t) {
            this._map.fire(new Fu(t.type, this._map, t));
          }
          touchend(t) {
            this._map.fire(new Fu(t.type, this._map, t));
          }
          touchcancel(t) {
            this._map.fire(new Fu(t.type, this._map, t));
          }
          _firePreventable(t) {
            if (this._map.fire(t), t.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class hm {
          constructor(t) {
            this._map = t;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(t) {
            this._map.fire(new ci(t.type, this._map, t));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ci("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t) {
            this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new ci(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ll {
          constructor(t) {
            this._map = t;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t) {
            return this.transform.screenPointToLocation(u.P.convert(t), this._map.terrain);
          }
        }
        class Dl {
          constructor(t, s) {
            this._map = t, this._tr = new Ll(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(t, s) {
            this.isEnabled() && t.shiftKey && t.button === 0 && (ne.disableDrag(), this._startPos = this._lastPos = s, this._active = !0);
          }
          mousemoveWindow(t, s) {
            if (!this._active) return;
            const d = s;
            if (this._lastPos.equals(d) || !this._box && d.dist(this._startPos) < this._clickTolerance) return;
            const g = this._startPos;
            this._lastPos = d, this._box || (this._box = ne.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));
            const w = Math.min(g.x, d.x), T = Math.max(g.x, d.x), C = Math.min(g.y, d.y), A = Math.max(g.y, d.y);
            ne.setTransform(this._box, `translate(${w}px,${C}px)`), this._box.style.width = T - w + "px", this._box.style.height = A - C + "px";
          }
          mouseupWindow(t, s) {
            if (!this._active || t.button !== 0) return;
            const d = this._startPos, g = s;
            if (this.reset(), ne.suppressClick(), d.x !== g.x || d.y !== g.y) return this._map.fire(new u.l("boxzoomend", { originalEvent: t })), { cameraAnimation: (w) => w.fitScreenCoordinates(d, g, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", t);
          }
          keydown(t) {
            this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (ne.remove(this._box), this._box = null), ne.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t, s) {
            return this._map.fire(new u.l(t, { originalEvent: s }));
          }
        }
        function js(b, t) {
          if (b.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${b.length}, points ${t.length}`);
          const s = {};
          for (let d = 0; d < b.length; d++) s[b[d].identifier] = t[d];
          return s;
        }
        class Vt {
          constructor(t) {
            this.reset(), this.numTouches = t.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(t, s, d) {
            (this.centroid || d.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), d.length === this.numTouches && (this.centroid = (function(g) {
              const w = new u.P(0, 0);
              for (const T of g) w._add(T);
              return w.div(g.length);
            })(s), this.touches = js(d, s)));
          }
          touchmove(t, s, d) {
            if (this.aborted || !this.centroid) return;
            const g = js(d, s);
            for (const w in this.touches) {
              const T = g[w];
              (!T || T.dist(this.touches[w]) > 30) && (this.aborted = !0);
            }
          }
          touchend(t, s, d) {
            if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), d.length === 0) {
              const g = !this.aborted && this.centroid;
              if (this.reset(), g) return g;
            }
          }
        }
        class Vc {
          constructor(t) {
            this.singleTap = new Vt(t), this.numTaps = t.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t, s, d) {
            this.singleTap.touchstart(t, s, d);
          }
          touchmove(t, s, d) {
            this.singleTap.touchmove(t, s, d);
          }
          touchend(t, s, d) {
            const g = this.singleTap.touchend(t, s, d);
            if (g) {
              const w = t.timeStamp - this.lastTime < 500, T = !this.lastTap || this.lastTap.dist(g) < 30;
              if (w && T || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = g, this.count === this.numTaps) return this.reset(), g;
            }
          }
        }
        class dd {
          constructor(t) {
            this._tr = new Ll(t), this._zoomIn = new Vc({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vc({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t, s, d) {
            this._zoomIn.touchstart(t, s, d), this._zoomOut.touchstart(t, s, d);
          }
          touchmove(t, s, d) {
            this._zoomIn.touchmove(t, s, d), this._zoomOut.touchmove(t, s, d);
          }
          touchend(t, s, d) {
            const g = this._zoomIn.touchend(t, s, d), w = this._zoomOut.touchend(t, s, d), T = this._tr;
            return g ? (this._active = !0, t.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: u.cx(T.zoom + 1, C.getZoomSnap()), around: T.unproject(g) }, { originalEvent: t }) }) : w ? (this._active = !0, t.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: u.cx(T.zoom - 1, C.getZoomSnap()), around: T.unproject(w) }, { originalEvent: t }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Rl {
          constructor(t) {
            this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset();
          }
          reset(t) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(t);
          }
          _move(...t) {
            const s = this._moveFunction(...t);
            if (s.bearingDelta || s.pitchDelta || s.rollDelta || s.around || s.panDelta) return this._active = !0, s;
          }
          dragStart(t, s) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = Array.isArray(s) ? s[0] : s, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(t, s) {
            if (!this.isEnabled()) return;
            const d = this._lastPoint;
            if (!d) return;
            if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t);
            const g = Array.isArray(s) ? s[0] : s;
            return !this._moved && g.dist(d) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = g, this._move(d, g));
          }
          dragEnd(t) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && ne.suppressClick(), this.reset(t));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Nu = 0, Ou = 2, fd = { [Nu]: 1, [Ou]: 2 };
        class zu {
          constructor(t) {
            this._correctEvent = t.checkCorrectEvent;
          }
          startMove(t) {
            const s = ne.mouseButton(t);
            this._eventButton = s;
          }
          endMove(t) {
            delete this._eventButton;
          }
          isValidStartEvent(t) {
            return this._correctEvent(t);
          }
          isValidMoveEvent(t) {
            return !(function(s, d) {
              const g = fd[d];
              return s.buttons === void 0 || (s.buttons & g) !== g;
            })(t, this._eventButton);
          }
          isValidEndEvent(t) {
            return ne.mouseButton(t) === this._eventButton;
          }
        }
        class pd {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t) {
            return t.targetTouches.length === 1;
          }
          _isSameTouchEvent(t) {
            return t.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t) {
            this._firstTouch = t.targetTouches[0].identifier;
          }
          endMove(t) {
            delete this._firstTouch;
          }
          isValidStartEvent(t) {
            return this._isOneFingerTouch(t);
          }
          isValidMoveEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
          isValidEndEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
        }
        class up {
          constructor(t = new zu({ checkCorrectEvent: () => !0 }), s = new pd()) {
            this.mouseMoveStateManager = t, this.oneFingerTouchMoveStateManager = s;
          }
          _executeRelevantHandler(t, s, d) {
            return t instanceof MouseEvent ? s(t) : typeof TouchEvent < "u" && t instanceof TouchEvent ? d(t) : void 0;
          }
          startMove(t) {
            this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.startMove(s)), ((s) => this.oneFingerTouchMoveStateManager.startMove(s)));
          }
          endMove(t) {
            this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.endMove(s)), ((s) => this.oneFingerTouchMoveStateManager.endMove(s)));
          }
          isValidStartEvent(t) {
            return this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.isValidStartEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidStartEvent(s)));
          }
          isValidMoveEvent(t) {
            return this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.isValidMoveEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(s)));
          }
          isValidEndEvent(t) {
            return this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.isValidEndEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidEndEvent(s)));
          }
        }
        const Fl = (b) => {
          b.mousedown = b.dragStart, b.mousemoveWindow = b.dragMove, b.mouseup = b.dragEnd, b.contextmenu = (t) => {
            t.preventDefault();
          };
        };
        class dm {
          constructor(t, s) {
            this._clickTolerance = t.clickTolerance || 1, this._map = s, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new u.P(0, 0);
          }
          _shouldBePrevented(t) {
            return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(t, s, d) {
            return this._calculateTransform(t, s, d);
          }
          touchmove(t, s, d) {
            if (this._active) {
              if (!this._shouldBePrevented(d.length)) return t.preventDefault(), this._calculateTransform(t, s, d);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t);
            }
          }
          touchend(t, s, d) {
            this._calculateTransform(t, s, d), this._active && this._shouldBePrevented(d.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t, s, d) {
            d.length > 0 && (this._active = !0);
            const g = js(d, s), w = new u.P(0, 0), T = new u.P(0, 0);
            let C = 0;
            for (const F in g) {
              const O = g[F], q = this._touches[F];
              q && (w._add(O), T._add(O.sub(q)), C++, g[F] = O);
            }
            if (this._touches = g, this._shouldBePrevented(C) || !T.mag()) return;
            const A = T.div(C);
            return this._sum._add(A), this._sum.mag() < this._clickTolerance ? void 0 : { around: w.div(C), panDelta: A };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Uc {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(t, s, d) {
            this._firstTwoTouches || d.length < 2 || (this._firstTwoTouches = [d[0].identifier, d[1].identifier], this._start([s[0], s[1]]));
          }
          touchmove(t, s, d) {
            if (!this._firstTwoTouches) return;
            t.preventDefault();
            const [g, w] = this._firstTwoTouches, T = qc(d, s, g), C = qc(d, s, w);
            if (!T || !C) return;
            const A = this._aroundCenter ? null : T.add(C).div(2);
            return this._move([T, C], A, t);
          }
          touchend(t, s, d) {
            if (!this._firstTwoTouches) return;
            const [g, w] = this._firstTwoTouches, T = qc(d, s, g), C = qc(d, s, w);
            T && C || (this._active && ne.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t) {
            this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function qc(b, t, s) {
          for (let d = 0; d < b.length; d++) if (b[d].identifier === s) return t[d];
        }
        function cp(b, t) {
          return Math.log(b / t) / Math.LN2;
        }
        class gd extends Uc {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t) {
            this._startDistance = this._distance = t[0].dist(t[1]);
          }
          _move(t, s) {
            const d = this._distance;
            if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(cp(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: cp(this._distance, d), pinchAround: s };
          }
        }
        function hp(b, t) {
          return 180 * b.angleWith(t) / Math.PI;
        }
        class md extends Uc {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t) {
            this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
          }
          _move(t, s, d) {
            const g = this._vector;
            if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: hp(this._vector, g), pinchAround: s };
          }
          _isBelowThreshold(t) {
            this._minDiameter = Math.min(this._minDiameter, t.mag());
            const s = 25 / (Math.PI * this._minDiameter) * 360, d = hp(t, this._startVector);
            return Math.abs(d) < s;
          }
        }
        function _d(b) {
          return Math.abs(b.y) > Math.abs(b.x);
        }
        class dp extends Uc {
          constructor(t) {
            super(), this._currentTouchCount = 0, this._map = t;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t, s, d) {
            super.touchstart(t, s, d), this._currentTouchCount = d.length;
          }
          _start(t) {
            this._lastPoints = t, _d(t[0].sub(t[1])) && (this._valid = !1);
          }
          _move(t, s, d) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const g = t[0].sub(this._lastPoints[0]), w = t[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(g, w, d.timeStamp), this._valid ? (this._lastPoints = t, this._active = !0, { pitchDelta: (g.y + w.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t, s, d) {
            if (this._valid !== void 0) return this._valid;
            const g = t.mag() >= 2, w = s.mag() >= 2;
            if (!g && !w) return;
            if (!g || !w) return this._firstMove === void 0 && (this._firstMove = d), d - this._firstMove < 100 && void 0;
            const T = t.y > 0 == s.y > 0;
            return _d(t) && _d(s) && T;
          }
        }
        const co = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Vr {
          constructor(t) {
            this._tr = new Ll(t);
            const s = co;
            this._panStep = s.panStep, this._bearingStep = s.bearingStep, this._pitchStep = s.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(t) {
            if (t.altKey || t.ctrlKey || t.metaKey) return;
            let s = 0, d = 0, g = 0, w = 0, T = 0;
            switch (t.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                s = 1;
                break;
              case 189:
              case 109:
              case 173:
                s = -1;
                break;
              case 37:
                t.shiftKey ? d = -1 : (t.preventDefault(), w = -1);
                break;
              case 39:
                t.shiftKey ? d = 1 : (t.preventDefault(), w = 1);
                break;
              case 38:
                t.shiftKey ? g = 1 : (t.preventDefault(), T = -1);
                break;
              case 40:
                t.shiftKey ? g = -1 : (t.preventDefault(), T = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (d = 0, g = 0), { cameraAnimation: (C) => {
              const A = this._tr;
              C.easeTo({ duration: 300, easeId: "keyboardHandler", easing: fm, zoom: s ? u.cx(A.zoom + s * (t.shiftKey ? 2 : 1), C.getZoomSnap()) : A.zoom, bearing: A.bearing + d * this._bearingStep, pitch: A.pitch + g * this._pitchStep, offset: [-w * this._panStep, -T * this._panStep], center: A.center }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function fm(b) {
          return b * (2 - b);
        }
        const Bu = 4.000244140625, $c = 1 / 450;
        class Zc {
          constructor(t, s) {
            this._onTimeout = (d) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(d);
            }, this._map = t, this._tr = new Ll(t), this._triggerRenderFrame = s, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = $c;
          }
          setZoomRate(t) {
            this._defaultZoomRate = t;
          }
          setWheelZoomRate(t) {
            this._wheelZoomRate = t;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(t) {
            return !!this._map.cooperativeGestures.isEnabled() && !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t));
          }
          wheel(t) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(t)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t);
            let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
            const d = _e(), g = d - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = d, s !== 0 && s % Bu == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : g > 400 ? (this._type = null, this._lastValue = s, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(g * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault();
          }
          _start(t) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const s = ne.mousePos(this._map.getCanvas(), t), d = this._tr;
            this._aroundPoint = this._aroundCenter ? d.transform.locationToScreenPoint(u.V.convert(d.center)) : s, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const t = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const C = t.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += C), typeof this._targetZoom == "number" && (this._targetZoom += C);
            }
            if (this._delta !== 0) {
              const C = this._type === "wheel" && Math.abs(this._delta) > Bu ? this._wheelZoomRate : this._defaultZoomRate;
              let A = 2 / (1 + Math.exp(-Math.abs(this._delta * C)));
              this._delta < 0 && A !== 0 && (A = 1 / A);
              const F = typeof this._targetZoom != "number" ? t.scale : u.aq(this._targetZoom), O = t.applyConstrain(t.getCameraLngLat(), u.at(F * A)).zoom, q = this._map.getZoomSnap();
              if (this._type === "wheel" && q > 0) {
                const V = u.cx(t.zoom, q);
                this._targetZoom = u.cx(O, q, O - V);
              } else this._targetZoom = O;
              this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const s = typeof this._targetZoom != "number" ? t.zoom : this._targetZoom, d = this._startZoom, g = this._easing;
            let w, T = !1;
            if (this._type === "wheel" && d && g) {
              const C = _e() - this._lastWheelEventTime, A = Math.min((C + 5) / 200, 1), F = g(A);
              w = u.G.number(d, s, F), A < 1 ? this._frameId || (this._frameId = !0) : T = !0;
            } else w = s, T = !0;
            return this._active = !0, T && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = w, { noInertia: !0, needsRenderFrame: !T, zoomDelta: w - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t) {
            let s = u.cz;
            if (this._prevEase) {
              const d = this._prevEase, g = (_e() - d.start) / d.duration, w = d.easing(g + 0.01) - d.easing(g), T = 0.27 / Math.sqrt(w * w + 1e-4) * 0.01, C = Math.sqrt(0.0729 - T * T);
              s = u.cw(T, C, 0.25, 1);
            }
            return this._prevEase = { start: _e(), duration: t, easing: s }, s;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class yd {
          constructor(t, s) {
            this._clickZoom = t, this._tapZoom = s;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class fp {
          constructor(t) {
            this._tr = new Ll(t), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(t, s) {
            return t.preventDefault(), { cameraAnimation: (d) => {
              d.easeTo({ duration: 300, zoom: u.cx(this._tr.zoom + (t.shiftKey ? -1 : 1), d.getZoomSnap()), around: this._tr.unproject(s) }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class pp {
          constructor() {
            this._tap = new Vc({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t, s, d) {
            if (!this._swipePoint) if (this._tapTime) {
              const g = s[0], w = t.timeStamp - this._tapTime < 500, T = this._tapPoint.dist(g) < 30;
              w && T ? d.length > 0 && (this._swipePoint = g, this._swipeTouch = d[0].identifier) : this.reset();
            } else this._tap.touchstart(t, s, d);
          }
          touchmove(t, s, d) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (d[0].identifier !== this._swipeTouch) return;
                const g = s[0], w = g.y - this._swipePoint.y;
                return this._swipePoint = g, t.preventDefault(), this._active = !0, { zoomDelta: w / 128 };
              }
            } else this._tap.touchmove(t, s, d);
          }
          touchend(t, s, d) {
            if (this._tapTime) this._swipePoint && d.length === 0 && this.reset();
            else {
              const g = this._tap.touchend(t, s, d);
              g && (this._tapTime = t.timeStamp, this._tapPoint = g);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class gp {
          constructor(t, s, d) {
            this._el = t, this._mousePan = s, this._touchPan = d;
          }
          enable(t) {
            this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Vs {
          constructor(t, s, d, g) {
            this._pitchWithRotate = t.pitchWithRotate, this._rollEnabled = t.rollEnabled, this._mouseRotate = s, this._mousePitch = d, this._mouseRoll = g;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Gu {
          constructor(t, s, d, g) {
            this._el = t, this._touchZoom = s, this._touchRotate = d, this._tapDragZoom = g, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(t) {
            this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class $t {
          constructor(t, s) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = s, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const t = this._map.getCanvasContainer();
            t.classList.add("maplibregl-cooperative-gestures"), this._container = ne.create("div", "maplibregl-cooperative-gesture-screen", t);
            let s = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (s = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const d = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), g = document.createElement("div");
            g.className = "maplibregl-desktop-message", g.textContent = s, this._container.appendChild(g);
            const w = document.createElement("div");
            w.className = "maplibregl-mobile-message", w.textContent = d, this._container.appendChild(w), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (ne.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(t) {
            return t[this._bypassKey];
          }
          notifyGestureBlocked(t, s) {
            this._enabled && (this._map.fire(new u.l("cooperativegestureprevented", { gestureType: t, originalEvent: s })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const Xt = (b) => b.zoom || b.drag || b.roll || b.pitch || b.rotate;
        class ju extends u.l {
        }
        function Hc(b) {
          return b.panDelta && b.panDelta.mag() || b.zoomDelta || b.bearingDelta || b.pitchDelta || b.rollDelta;
        }
        class Yc {
          get _ownerDocument() {
            var t;
            return ((t = this._el) === null || t === void 0 ? void 0 : t.ownerDocument) || document;
          }
          get _ownerWindow() {
            var t, s;
            return ((s = (t = this._el) === null || t === void 0 ? void 0 : t.ownerDocument) === null || s === void 0 ? void 0 : s.defaultView) || window;
          }
          constructor(t, s) {
            this.handleWindowEvent = (g) => {
              this.handleEvent(g, `${g.type}Window`);
            }, this.handleEvent = (g, w) => {
              if (g.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const T = g.type === "renderFrame" ? void 0 : g, C = { needsRenderFrame: !1 }, A = {}, F = {};
              for (const { handlerName: V, handler: X, allowed: te } of this._handlers) {
                if (!X.isEnabled()) continue;
                let he;
                if (this._blockedByActive(F, te, V)) X.reset();
                else if (X[w || g.type]) {
                  if (u.cA(g, w || g.type)) {
                    const pe = ne.mousePos(this._map.getCanvas(), g);
                    he = X[w || g.type](g, pe);
                  } else if (u.cB(g, w || g.type)) {
                    const pe = this._getMapTouches(g.touches), fe = ne.touchPos(this._map.getCanvas(), pe);
                    he = X[w || g.type](g, fe, pe);
                  } else u.cC(w || g.type) || (he = X[w || g.type](g));
                  this.mergeHandlerResult(C, A, he, V, T), he && he.needsRenderFrame && this._triggerRenderFrame();
                }
                (he || X.isActive()) && (F[V] = X);
              }
              const O = {};
              for (const V in this._previousActiveHandlers) F[V] || (O[V] = T);
              this._previousActiveHandlers = F, (Object.keys(O).length || Hc(C)) && (this._changes.push([C, A, O]), this._triggerRenderFrame()), (Object.keys(F).length || Hc(C)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: q } = C;
              q && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], q(this._map));
            }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new um(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(s);
            const d = this._el;
            this._listeners = [[d, "touchstart", { passive: !0 }], [d, "touchmove", { passive: !1 }], [d, "touchend", void 0], [d, "touchcancel", void 0], [d, "mousedown", void 0], [d, "mousemove", void 0], [d, "mouseup", void 0], [this._ownerDocument, "mousemove", { capture: !0 }], [this._ownerDocument, "mouseup", void 0], [d, "mouseover", void 0], [d, "mouseout", void 0], [d, "dblclick", void 0], [d, "click", void 0], [d, "keydown", { capture: !1 }], [d, "keyup", void 0], [d, "wheel", { passive: !1 }], [d, "contextmenu", void 0], [this._ownerWindow, "blur", void 0]];
            for (const [g, w, T] of this._listeners) ne.addEventListener(g, w, g === this._ownerDocument ? this.handleWindowEvent : this.handleEvent, T);
          }
          destroy() {
            for (const [t, s, d] of this._listeners) ne.removeEventListener(t, s, t === this._ownerDocument ? this.handleWindowEvent : this.handleEvent, d);
          }
          _addDefaultHandlers(t) {
            const s = this._map, d = s.getCanvasContainer();
            this._add("mapEvent", new cm(s, t));
            const g = s.boxZoom = new Dl(s, t);
            this._add("boxZoom", g), t.interactive && t.boxZoom && g.enable();
            const w = s.cooperativeGestures = new $t(s, t.cooperativeGestures);
            this._add("cooperativeGestures", w), t.cooperativeGestures && w.enable();
            const T = new dd(s), C = new fp(s);
            s.doubleClickZoom = new yd(C, T), this._add("tapZoom", T), this._add("clickZoom", C), t.interactive && t.doubleClickZoom && s.doubleClickZoom.enable();
            const A = new pp();
            this._add("tapDragZoom", A);
            const F = s.touchPitch = new dp(s);
            this._add("touchPitch", F), t.interactive && t.touchPitch && s.touchPitch.enable(t.touchPitch);
            const O = () => s.project(s.getCenter()), q = (function({ enable: xe, clickTolerance: Ce, aroundCenter: Oe = !0, minPixelCenterThreshold: ke = 100, rotateDegreesPerPixelMoved: je = 0.8 }, at) {
              const tt = new zu({ checkCorrectEvent: (nt) => ne.mouseButton(nt) === 0 && nt.ctrlKey || ne.mouseButton(nt) === 2 && !nt.ctrlKey });
              return new Rl({ clickTolerance: Ce, move: (nt, it) => {
                const St = at();
                if (Oe && Math.abs(St.y - nt.y) > ke) return { bearingDelta: u.cy(new u.P(nt.x, it.y), it, St) };
                let It = (it.x - nt.x) * je;
                return Oe && it.y < St.y && (It = -It), { bearingDelta: It };
              }, moveStateManager: tt, enable: xe, assignEvents: Fl });
            })(t, O), V = (function({ enable: xe, clickTolerance: Ce, pitchDegreesPerPixelMoved: Oe = -0.5 }) {
              const ke = new zu({ checkCorrectEvent: (je) => ne.mouseButton(je) === 0 && je.ctrlKey || ne.mouseButton(je) === 2 });
              return new Rl({ clickTolerance: Ce, move: (je, at) => ({ pitchDelta: (at.y - je.y) * Oe }), moveStateManager: ke, enable: xe, assignEvents: Fl });
            })(t), X = (function({ enable: xe, clickTolerance: Ce, rollDegreesPerPixelMoved: Oe = 0.3 }, ke) {
              const je = new zu({ checkCorrectEvent: (at) => ne.mouseButton(at) === 2 && at.ctrlKey });
              return new Rl({ clickTolerance: Ce, move: (at, tt) => {
                const nt = ke();
                let it = (tt.x - at.x) * Oe;
                return tt.y < nt.y && (it = -it), { rollDelta: it };
              }, moveStateManager: je, enable: xe, assignEvents: Fl });
            })(t, O);
            s.dragRotate = new Vs(t, q, V, X), this._add("mouseRotate", q, ["mousePitch"]), this._add("mousePitch", V, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", X, ["mousePitch"]), t.interactive && t.dragRotate && s.dragRotate.enable();
            const te = (function({ enable: xe, clickTolerance: Ce }) {
              const Oe = new zu({ checkCorrectEvent: (ke) => ne.mouseButton(ke) === 0 && !ke.ctrlKey });
              return new Rl({ clickTolerance: Ce, move: (ke, je) => ({ around: je, panDelta: je.sub(ke) }), activateOnStart: !0, moveStateManager: Oe, enable: xe, assignEvents: Fl });
            })(t), he = new dm(t, s);
            s.dragPan = new gp(d, te, he), this._add("mousePan", te), this._add("touchPan", he, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && s.dragPan.enable(t.dragPan);
            const pe = new md(), fe = new gd();
            s.touchZoomRotate = new Gu(d, fe, pe, A), this._add("touchRotate", pe, ["touchPan", "touchZoom"]), this._add("touchZoom", fe, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && s.touchZoomRotate.enable(t.touchZoomRotate), this._add("blockableMapEvent", new hm(s));
            const be = s.scrollZoom = new Zc(s, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", be, ["mousePan"]), t.interactive && t.scrollZoom && s.scrollZoom.enable(t.scrollZoom);
            const Ae = s.keyboard = new Vr(s);
            this._add("keyboard", Ae), t.interactive && t.keyboard && s.keyboard.enable();
          }
          _add(t, s, d) {
            this._handlers.push({ handlerName: t, handler: s, allowed: d }), this._handlersById[t] = s;
          }
          stop(t) {
            if (!this._updatingCamera) {
              for (const { handler: s } of this._handlers) s.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Xt(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(t, s, d) {
            for (const g in t) if (g !== d && (!s || s.indexOf(g) < 0)) return !0;
            return !1;
          }
          _getMapTouches(t) {
            const s = [];
            for (const d of t) this._el.contains(d.target) && s.push(d);
            return s;
          }
          mergeHandlerResult(t, s, d, g, w) {
            if (!d) return;
            u.e(t, d);
            const T = { handlerName: g, originalEvent: d.originalEvent || w };
            d.zoomDelta !== void 0 && (s.zoom = T), d.panDelta !== void 0 && (s.drag = T), d.rollDelta !== void 0 && (s.roll = T), d.pitchDelta !== void 0 && (s.pitch = T), d.bearingDelta !== void 0 && (s.rotate = T);
          }
          _applyChanges() {
            const t = {}, s = {}, d = {};
            for (const [g, w, T] of this._changes) g.panDelta && (t.panDelta = (t.panDelta || new u.P(0, 0))._add(g.panDelta)), g.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + g.zoomDelta), g.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + g.bearingDelta), g.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + g.pitchDelta), g.rollDelta && (t.rollDelta = (t.rollDelta || 0) + g.rollDelta), g.around !== void 0 && (t.around = g.around), g.pinchAround !== void 0 && (t.pinchAround = g.pinchAround), g.noInertia && (t.noInertia = g.noInertia), u.e(s, w), u.e(d, T);
            this._updateMapTransform(t, s, d), this._changes = [];
          }
          _updateMapTransform(t, s, d) {
            const g = this._map, w = g._getTransformForUpdate(), T = g.terrain;
            if (!(Hc(t) || T && this._terrainMovement)) return this._fireEvents(s, d, !0);
            g._stop(!0);
            let { panDelta: C, zoomDelta: A, bearingDelta: F, pitchDelta: O, rollDelta: q, around: V, pinchAround: X } = t;
            X !== void 0 && (V = X), V = V || g.transform.centerPoint, T && !w.isPointOnMapSurface(V) && (V = w.centerPoint);
            const te = { panDelta: C, zoomDelta: A, rollDelta: q, pitchDelta: O, bearingDelta: F, around: V };
            this._map.cameraHelper.useGlobeControls && !w.isPointOnMapSurface(V) && (V = w.centerPoint);
            const he = V.distSqr(w.centerPoint) < 0.01 ? w.center : w.screenPointToLocation(C ? V.sub(C) : V);
            this._handleMapControls({ terrain: T, tr: w, deltasForHelper: te, preZoomAroundLoc: he, combinedEventsInProgress: s, panDelta: C }), g._applyUpdatedTransform(w), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, d, !0);
          }
          _handleMapControls({ terrain: t, tr: s, deltasForHelper: d, preZoomAroundLoc: g, combinedEventsInProgress: w, panDelta: T }) {
            const C = this._map.cameraHelper;
            if (C.handleMapControlsRollPitchBearingZoom(d, s), t) return C.useGlobeControls ? (this._terrainMovement || !w.drag && !w.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void C.handleMapControlsPan(d, s, g)) : this._terrainMovement || !w.drag && !w.zoom ? void (w.drag && this._terrainMovement && T ? s.setCenter(s.screenPointToLocation(s.centerPoint.sub(T))) : C.handleMapControlsPan(d, s, g)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void C.handleMapControlsPan(d, s, g));
            C.handleMapControlsPan(d, s, g);
          }
          _fireEvents(t, s, d) {
            const g = Xt(this._eventsInProgress), w = Xt(t), T = {};
            for (const q in t) {
              const { originalEvent: V } = t[q];
              this._eventsInProgress[q] || (T[`${q}start`] = V), this._eventsInProgress[q] = t[q];
            }
            !g && w && this._fireEvent("movestart", w.originalEvent);
            for (const q in T) this._fireEvent(q, T[q]);
            w && this._fireEvent("move", w.originalEvent);
            for (const q in t) {
              const { originalEvent: V } = t[q];
              this._fireEvent(q, V);
            }
            const C = {};
            let A;
            for (const q in this._eventsInProgress) {
              const { handlerName: V, originalEvent: X } = this._eventsInProgress[q];
              this._handlersById[V].isActive() || (delete this._eventsInProgress[q], A = s[V] || X, C[`${q}end`] = A);
            }
            for (const q in C) this._fireEvent(q, C[q]);
            const F = Xt(this._eventsInProgress), O = (g || w) && !F;
            if (O && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const q = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && q.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(q);
            }
            if (d && O) {
              this._updatingCamera = !0;
              const q = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), V = (X) => X !== 0 && -this._bearingSnap < X && X < this._bearingSnap;
              !q || !q.essential && le.prefersReducedMotion ? (this._map.fire(new u.l("moveend", { originalEvent: A })), V(this._map.getBearing()) && this._map.resetNorth()) : (V(q.bearing || this._map.getBearing()) && (q.bearing = 0), q.freezeElevation = !0, this._map.easeTo(q, { originalEvent: A })), this._updatingCamera = !1;
            }
          }
          _fireEvent(t, s) {
            this._map.fire(new u.l(t, s ? { originalEvent: s } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((t) => {
              delete this._frameId, this.handleEvent(new ju("renderFrame", { timeStamp: t })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Ui extends u.E {
          constructor(t, s, d) {
            super(), this._renderFrameCallback = () => {
              const g = Math.min((_e() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(g)), g < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = d.bearingSnap, this._zoomSnap = d.zoomSnap, this.cameraHelper = s, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(t, s) {
            t.apply(this.transform, !0), this.transform = t, this.cameraHelper = s;
          }
          getCenter() {
            return new u.V(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t, s) {
            return this.jumpTo({ center: t }, s);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(t, s) {
            return this.jumpTo({ elevation: t }, s), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(t) {
            this._centerClampedToGround = t;
          }
          panBy(t, s, d) {
            return t = u.P.convert(t).mult(-1), this.panTo(this.transform.center, u.e({ offset: t }, s), d);
          }
          panTo(t, s, d) {
            return this.easeTo(u.e({ center: t }, s), d);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t, s) {
            return this.jumpTo({ zoom: t }, s), this;
          }
          zoomTo(t, s, d) {
            return this.easeTo(u.e({ zoom: t }, s), d);
          }
          zoomIn(t, s) {
            return this.zoomTo(u.cx(this.getZoom() + 1, this._zoomSnap), t, s), this;
          }
          zoomOut(t, s) {
            return this.zoomTo(u.cx(this.getZoom() - 1, this._zoomSnap), t, s), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(t, s) {
            return t != this.transform.fov && (this.transform.setFov(t), this.fire(new u.l("movestart", s)).fire(new u.l("move", s)).fire(new u.l("moveend", s))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setZoomSnap(t) {
            return this._zoomSnap = t, this;
          }
          getZoomSnap() {
            return this._zoomSnap;
          }
          setBearing(t, s) {
            return this.jumpTo({ bearing: t }, s), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t, s) {
            return this.jumpTo({ padding: t }, s), this;
          }
          rotateTo(t, s, d) {
            return this.easeTo(u.e({ bearing: t }, s), d);
          }
          resetNorth(t, s) {
            return this.rotateTo(0, u.e({ duration: 1e3 }, t), s), this;
          }
          resetNorthPitch(t, s) {
            return this.easeTo(u.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, t), s), this;
          }
          snapToNorth(t, s) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t, s) {
            return this.jumpTo({ pitch: t }, s), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(t, s) {
            return this.jumpTo({ roll: t }, s), this;
          }
          cameraForBounds(t, s) {
            t = Dr.convert(t).adjustAntiMeridian();
            const d = s && s.bearing || 0;
            return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), d, s);
          }
          _cameraForBoxAndBearing(t, s, d, g) {
            const w = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (g = u.e({ padding: w, offset: [0, 0], maxZoom: this.transform.maxZoom }, g)).padding == "number") {
              const F = g.padding;
              g.padding = { top: F, bottom: F, right: F, left: F };
            }
            const T = u.e(w, g.padding);
            g.padding = T;
            const C = this.transform, A = new Dr(t, s);
            return this.cameraHelper.cameraForBoxAndBearing(g, T, A, d, C);
          }
          fitBounds(t, s, d) {
            return this._fitInternal(this.cameraForBounds(t, s), s, d);
          }
          fitScreenCoordinates(t, s, d, g, w) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(u.P.convert(t)), this.transform.screenPointToLocation(u.P.convert(s)), d, g), g, w);
          }
          _fitInternal(t, s, d) {
            return t ? (delete (s = u.e(t, s)).padding, s.linear ? this.easeTo(s, d) : this.flyTo(s, d)) : this;
          }
          jumpTo(t, s) {
            this.stop();
            const d = this._getTransformForUpdate();
            let g = !1, w = !1, T = !1;
            const C = d.zoom;
            this.cameraHelper.handleJumpToCenterZoom(d, t);
            const A = d.zoom !== C;
            return "elevation" in t && d.elevation !== +t.elevation && d.setElevation(+t.elevation), "bearing" in t && d.bearing !== +t.bearing && (g = !0, d.setBearing(+t.bearing)), "pitch" in t && d.pitch !== +t.pitch && (w = !0, d.setPitch(+t.pitch)), "roll" in t && d.roll !== +t.roll && (T = !0, d.setRoll(+t.roll)), t.padding == null || d.isPaddingEqual(t.padding) || d.setPadding(t.padding), this._applyUpdatedTransform(d), this.fire(new u.l("movestart", s)).fire(new u.l("move", s)), A && this.fire(new u.l("zoomstart", s)).fire(new u.l("zoom", s)).fire(new u.l("zoomend", s)), g && this.fire(new u.l("rotatestart", s)).fire(new u.l("rotate", s)).fire(new u.l("rotateend", s)), w && this.fire(new u.l("pitchstart", s)).fire(new u.l("pitch", s)).fire(new u.l("pitchend", s)), T && this.fire(new u.l("rollstart", s)).fire(new u.l("roll", s)).fire(new u.l("rollend", s)), this.fire(new u.l("moveend", s));
          }
          calculateCameraOptionsFromTo(t, s, d, g = 0) {
            const w = u.a9.fromLngLat(t, s), T = u.a9.fromLngLat(d, g), C = T.x - w.x, A = T.y - w.y, F = T.z - w.z, O = Math.hypot(C, A, F);
            if (O === 0) throw new Error("Can't calculate camera options with same From and To");
            const q = Math.hypot(C, A), V = u.at(this.transform.cameraToCenterDistance / O / this.transform.tileSize), X = 180 * Math.atan2(C, -A) / Math.PI;
            let te = 180 * Math.acos(q / O) / Math.PI;
            return te = F < 0 ? 90 - te : 90 + te, { center: T.toLngLat(), elevation: g, zoom: V, pitch: te, bearing: X };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(t, s, d, g, w) {
            const T = this.transform.calculateCenterFromCameraLngLatAlt(t, s, d, g);
            return { center: T.center, elevation: T.elevation, zoom: T.zoom, bearing: d, pitch: g, roll: w };
          }
          easeTo(t, s) {
            this._stop(!1, t.easeId), ((t = u.e({ offset: [0, 0], duration: 500, easing: u.cz }, t)).animate === !1 || !t.essential && le.prefersReducedMotion) && (t.duration = 0);
            const d = this._getTransformForUpdate(), g = this.getBearing(), w = d.pitch, T = d.roll, C = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, A = "pitch" in t ? +t.pitch : w, F = "roll" in t ? this._normalizeBearing(t.roll, T) : T, O = "padding" in t ? t.padding : d.padding, q = u.P.convert(t.offset);
            let V, X;
            t.around && (V = u.V.convert(t.around), X = d.locationToScreenPoint(V));
            const te = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, he = this.cameraHelper.handleEaseTo(d, { bearing: C, pitch: A, roll: F, padding: O, around: V, aroundPoint: X, offsetAsPoint: q, offset: t.offset, zoom: t.zoom, center: t.center });
            return this._rotating = this._rotating || g !== C, this._pitching = this._pitching || A !== w, this._rolling = this._rolling || F !== T, this._padding = !d.isPaddingEqual(O), this._zooming = this._zooming || he.isZooming, this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, te), this.terrain && this._prepareElevation(he.elevationCenter), this._ease(((pe) => {
              he.easeFunc(pe), this.terrain && !t.freezeElevation && this._updateElevation(pe), this._applyUpdatedTransform(d), this._fireMoveEvents(s);
            }), ((pe) => {
              this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s, pe);
            }), t), this;
          }
          _prepareEase(t, s, d = {}) {
            this._moving = !0, s || d.moving || this.fire(new u.l("movestart", t)), this._zooming && !d.zooming && this.fire(new u.l("zoomstart", t)), this._rotating && !d.rotating && this.fire(new u.l("rotatestart", t)), this._pitching && !d.pitching && this.fire(new u.l("pitchstart", t)), this._rolling && !d.rolling && this.fire(new u.l("rollstart", t));
          }
          _prepareElevation(t) {
            this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(t) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const s = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (t < 1 && s !== this._elevationTarget) {
              const d = this._elevationTarget - this._elevationStart;
              this._elevationStart += t * (d - (s - (d * t + this._elevationStart)) / (1 - t)), this._elevationTarget = s;
            }
            this.transform.setElevation(u.G.number(this._elevationStart, this._elevationTarget, t));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(t) {
            if (!this.terrain && t.elevation >= 0 && t.pitch <= 90) return {};
            const s = t.getCameraLngLat(), d = t.getCameraAltitude(), g = this.terrain ? this.terrain.getElevationForLngLatZoom(s, t.zoom) : 0;
            if (d < g) {
              const w = this.calculateCameraOptionsFromTo(s, g, t.center, t.elevation);
              return { pitch: w.pitch, zoom: w.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(t) {
            const s = [];
            if (s.push(((g) => this._elevateCameraIfInsideTerrain(g))), this.transformCameraUpdate && s.push(((g) => this.transformCameraUpdate(g))), !s.length) return;
            const d = t.clone();
            for (const g of s) {
              const w = d.clone(), { center: T, zoom: C, roll: A, pitch: F, bearing: O, elevation: q } = g(w);
              T && w.setCenter(T), q !== void 0 && w.setElevation(q), C !== void 0 && w.setZoom(C), A !== void 0 && w.setRoll(A), F !== void 0 && w.setPitch(F), O !== void 0 && w.setBearing(O), d.apply(w, !1);
            }
            this.transform.apply(d, !1);
          }
          _fireMoveEvents(t) {
            this.fire(new u.l("move", t)), this._zooming && this.fire(new u.l("zoom", t)), this._rotating && this.fire(new u.l("rotate", t)), this._pitching && this.fire(new u.l("pitch", t)), this._rolling && this.fire(new u.l("roll", t));
          }
          _afterEase(t, s) {
            if (this._easeId && s && this._easeId === s) return;
            delete this._easeId;
            const d = this._zooming, g = this._rotating, w = this._pitching, T = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, d && this.fire(new u.l("zoomend", t)), g && this.fire(new u.l("rotateend", t)), w && this.fire(new u.l("pitchend", t)), T && this.fire(new u.l("rollend", t)), this.fire(new u.l("moveend", t));
          }
          flyTo(t, s) {
            if (!t.essential && le.prefersReducedMotion) {
              const it = u.U(t, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(it, s);
            }
            this.stop(), t = u.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: u.cz }, t);
            const d = this._getTransformForUpdate(), g = d.bearing, w = d.pitch, T = d.roll, C = d.padding, A = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, F = "pitch" in t ? +t.pitch : w, O = "roll" in t ? this._normalizeBearing(t.roll, T) : T, q = "padding" in t ? t.padding : d.padding, V = u.P.convert(t.offset);
            let X = d.centerPoint.add(V);
            const te = d.screenPointToLocation(X), he = this.cameraHelper.handleFlyTo(d, { bearing: A, pitch: F, roll: O, padding: q, locationAtOffset: te, offsetAsPoint: V, center: t.center, minZoom: t.minZoom, zoom: t.zoom });
            let pe = t.curve;
            const fe = Math.max(d.width, d.height), be = fe / he.scaleOfZoom, Ae = he.pixelPathLength;
            typeof he.scaleOfMinZoom == "number" && (pe = Math.sqrt(fe / he.scaleOfMinZoom / Ae * 2));
            const xe = pe * pe;
            function Ce(it) {
              const St = (be * be - fe * fe + (it ? -1 : 1) * xe * xe * Ae * Ae) / (2 * (it ? be : fe) * xe * Ae);
              return Math.log(Math.sqrt(St * St + 1) - St);
            }
            function Oe(it) {
              return (Math.exp(it) - Math.exp(-it)) / 2;
            }
            function ke(it) {
              return (Math.exp(it) + Math.exp(-it)) / 2;
            }
            const je = Ce(!1);
            let at = function(it) {
              return ke(je) / ke(je + pe * it);
            }, tt = function(it) {
              return fe * ((ke(je) * (Oe(St = je + pe * it) / ke(St)) - Oe(je)) / xe) / Ae;
              var St;
            }, nt = (Ce(!0) - je) / pe;
            if (Math.abs(Ae) < 2e-6 || !isFinite(nt)) {
              if (Math.abs(fe - be) < 1e-6) return this.easeTo(t, s);
              const it = be < fe ? -1 : 1;
              nt = Math.abs(Math.log(be / fe)) / pe, tt = () => 0, at = (St) => Math.exp(it * pe * St);
            }
            return t.duration = "duration" in t ? +t.duration : 1e3 * nt / ("screenSpeed" in t ? +t.screenSpeed / pe : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = g !== A, this._pitching = F !== w, this._rolling = O !== T, this._padding = !d.isPaddingEqual(q), this._prepareEase(s, !1), this.terrain && this._prepareElevation(he.targetCenter), this._ease(((it) => {
              const St = it * nt, It = 1 / at(St), _t = tt(St);
              this._rotating && d.setBearing(u.G.number(g, A, it)), this._pitching && d.setPitch(u.G.number(w, F, it)), this._rolling && d.setRoll(u.G.number(T, O, it)), this._padding && (d.interpolatePadding(C, q, it), X = d.centerPoint.add(V)), he.easeFunc(it, It, _t, X), this.terrain && !t.freezeElevation && this._updateElevation(it), this._applyUpdatedTransform(d), this._fireMoveEvents(s);
            }), (() => {
              this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s);
            }), t), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t, s) {
            var d;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const g = this._onEaseEnd;
              delete this._onEaseEnd, g.call(this, s);
            }
            return t || (d = this.handlers) === null || d === void 0 || d.stop(!1), this;
          }
          _ease(t, s, d) {
            d.animate === !1 || d.duration === 0 ? (t(1), s()) : (this._easeStart = _e(), this._easeOptions = d, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(t, s) {
            t = u.W(t, -180, 180);
            const d = Math.abs(t - s);
            return Math.abs(t - 360 - s) < d && (t -= 360), Math.abs(t + 360 - s) < d && (t += 360), t;
          }
          queryTerrainElevation(t) {
            return this.terrain ? this.terrain.getElevationForLngLat(u.V.convert(t), this.transform) : null;
          }
        }
        const Ts = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class vd {
          constructor(t = Ts) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (s) => {
              !s || s.sourceDataType !== "metadata" && s.sourceDataType !== "visibility" && s.dataType !== "style" && s.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t) {
            return this._map = t, this._compact = this.options.compact, this._container = ne.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = ne.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = ne.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            ne.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t, s) {
            const d = this._map._getUIString(`AttributionControl.${s}`);
            t.title = d, t.setAttribute("aria-label", d);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(((g) => typeof g != "string" ? "" : g))) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const g = this._map.style.stylesheet;
              this.styleOwner = g.owner, this.styleId = g.id;
            }
            const s = this._map.style.tileManagers;
            for (const g in s) {
              const w = s[g];
              if (w.used || w.usedForTerrain) {
                const T = w.getSource();
                T.attribution && t.indexOf(T.attribution) < 0 && t.push(T.attribution);
              }
            }
            t = t.filter(((g) => String(g).trim())), t.sort(((g, w) => g.length - w.length)), t = t.filter(((g, w) => {
              for (let T = w + 1; T < t.length; T++) if (t[T].indexOf(g) >= 0) return !1;
              return !0;
            }));
            const d = t.join(" | ");
            d !== this._attribHTML && (this._attribHTML = d, t.length ? (this._innerContainer.innerHTML = ne.sanitize(d), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class mp {
          constructor(t = {}) {
            this._updateCompact = () => {
              const s = this._container.children;
              if (s.length) {
                const d = s[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && d.classList.add("maplibregl-compact") : d.classList.remove("maplibregl-compact");
              }
            }, this.options = t;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t) {
            this._map = t, this._compact = this.options && this.options.compact, this._container = ne.create("div", "maplibregl-ctrl");
            const s = ne.create("a", "maplibregl-ctrl-logo");
            return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://maplibre.org/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            ne.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class pm {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(t) {
            const s = ++this._id;
            return this._queue.push({ callback: t, id: s, cancelled: !1 }), s;
          }
          remove(t) {
            const s = this._currentlyRunning, d = s ? this._queue.concat(s) : this._queue;
            for (const g of d) if (g.id === t) return void (g.cancelled = !0);
          }
          run(t = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const s = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const d of s) if (!d.cancelled && (d.callback(t), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var gm = u.aU([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Vu extends u.E {
          constructor(t) {
            super(), this._lastTilesetChange = _e(), this.tileManager = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = t._source.tileSize * 2 ** this.deltaZoom, t.usedForTerrain = !0, t.tileSize = this.tileSize;
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null;
          }
          getSource() {
            return this.tileManager._source;
          }
          update(t, s) {
            this.tileManager.update(t, s), this._renderableTilesKeys = [];
            const d = {};
            for (const g of wr(t, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: s, calculateTileZoom: this.tileManager._source.calculateTileZoom })) d[g.key] = !0, this._renderableTilesKeys.push(g.key), this._tiles[g.key] || (g.terrainRttPosMatrix32f = new Float64Array(16), u.c7(g.terrainRttPosMatrix32f, 0, u.a5, u.a5, 0, 0, 1), this._tiles[g.key] = new Ye(g, this.tileSize), this._lastTilesetChange = _e());
            for (const g in this._tiles) d[g] || delete this._tiles[g];
          }
          freeRtt(t) {
            for (const s in this._tiles) {
              const d = this._tiles[s];
              (!t || d.tileID.equals(t) || d.tileID.isChildOf(t) || t.isChildOf(d.tileID)) && (d.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((t) => this.getTileByID(t)));
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          getTerrainCoords(t, s) {
            return s ? this._getTerrainCoordsForTileRanges(t, s) : this._getTerrainCoordsForRegularTile(t);
          }
          _getTerrainCoordsForRegularTile(t) {
            const s = {};
            for (const d of this._renderableTilesKeys) {
              const g = this._tiles[d].tileID, w = t.clone(), T = u.bk();
              if (g.canonical.equals(t.canonical)) u.c7(T, 0, u.a5, u.a5, 0, 0, 1);
              else if (g.canonical.isChildOf(t.canonical)) {
                const C = g.canonical.z - t.canonical.z, A = g.canonical.x - (g.canonical.x >> C << C), F = g.canonical.y - (g.canonical.y >> C << C), O = u.a5 >> C;
                u.c7(T, 0, O, O, 0, 0, 1), u.O(T, T, [-A * O, -F * O, 0]);
              } else {
                if (!t.canonical.isChildOf(g.canonical)) continue;
                {
                  const C = t.canonical.z - g.canonical.z, A = t.canonical.x - (t.canonical.x >> C << C), F = t.canonical.y - (t.canonical.y >> C << C), O = u.a5 >> C;
                  u.c7(T, 0, u.a5, u.a5, 0, 0, 1), u.O(T, T, [A * O, F * O, 0]), u.Q(T, T, [1 / 2 ** C, 1 / 2 ** C, 0]);
                }
              }
              w.terrainRttPosMatrix32f = new Float32Array(T), s[d] = w;
            }
            return s;
          }
          _getTerrainCoordsForTileRanges(t, s) {
            const d = {};
            for (const g of this._renderableTilesKeys) {
              const w = this._tiles[g].tileID;
              if (!this._isWithinTileRanges(w, s)) continue;
              const T = t.clone(), C = u.bk();
              if (w.canonical.z === t.canonical.z) {
                const A = t.canonical.x - w.canonical.x + t.wrap * (1 << t.canonical.z), F = t.canonical.y - w.canonical.y;
                u.c7(C, 0, u.a5, u.a5, 0, 0, 1), u.O(C, C, [A * u.a5, F * u.a5, 0]);
              } else if (w.canonical.z > t.canonical.z) {
                const A = w.canonical.z - t.canonical.z, F = w.canonical.x - (w.canonical.x >> A << A) + t.wrap * (1 << w.canonical.z), O = w.canonical.y - (w.canonical.y >> A << A), q = t.canonical.x - (w.canonical.x >> A), V = t.canonical.y - (w.canonical.y >> A), X = u.a5 >> A;
                u.c7(C, 0, X, X, 0, 0, 1), u.O(C, C, [-F * X + q * u.a5, -O * X + V * u.a5, 0]);
              } else {
                const A = t.canonical.z - w.canonical.z, F = t.canonical.x - (t.canonical.x >> A << A) + t.wrap * (1 << t.canonical.z), O = t.canonical.y - (t.canonical.y >> A << A), q = (t.canonical.x >> A) - w.canonical.x, V = (t.canonical.y >> A) - w.canonical.y, X = u.a5 << A;
                u.c7(C, 0, X, X, 0, 0, 1), u.O(C, C, [F * u.a5 + q * X, O * u.a5 + V * X, 0]);
              }
              T.terrainRttPosMatrix32f = new Float32Array(C), d[g] = T;
            }
            return d;
          }
          getSourceTile(t, s) {
            const d = this.tileManager._source;
            let g = t.overscaledZ - this.deltaZoom;
            if (g > d.maxzoom && (g = d.maxzoom), g < d.minzoom) return;
            this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(g).key);
            let w = this.findTileInCaches(this._sourceTileCache[t.key]);
            if (!w?.dem && s) for (; g >= d.minzoom && !w?.dem; ) w = this.findTileInCaches(t.scaledTo(g--).key);
            return w;
          }
          findTileInCaches(t) {
            let s = this.tileManager.getTileByID(t);
            return s || (s = this.tileManager._outOfViewCache.getByKey(t), s);
          }
          anyTilesAfterTime(t = Date.now()) {
            return this._lastTilesetChange >= t;
          }
          _isWithinTileRanges(t, s) {
            const d = s[t.canonical.z];
            return !!d && (t.wrap > d.minWrap || t.wrap < d.maxWrap || t.canonical.x >= d.minTileXWrapped && t.canonical.x <= d.maxTileXWrapped && t.canonical.y >= d.minTileY && t.canonical.y <= d.maxTileY);
          }
        }
        class yn {
          constructor(t, s, d) {
            this._meshCache = {}, this.painter = t, this.tileManager = new Vu(s), this.options = d, this.exaggeration = typeof d.exaggeration == "number" ? d.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(t, s, d, g = u.a5) {
            var w;
            if (!(s >= 0 && s < g && d >= 0 && d < g)) return 0;
            const T = this.getTerrainData(t), C = (w = T.tile) === null || w === void 0 ? void 0 : w.dem;
            if (!C) return 0;
            const A = u.cD([], [s / g * u.a5, d / g * u.a5], T.u_terrain_matrix), F = [A[0] * C.dim, A[1] * C.dim], O = Math.floor(F[0]), q = Math.floor(F[1]), V = F[0] - O, X = F[1] - q;
            return C.get(O, q) * (1 - V) * (1 - X) + C.get(O + 1, q) * V * (1 - X) + C.get(O, q + 1) * (1 - V) * X + C.get(O + 1, q + 1) * V * X;
          }
          getElevationForLngLatZoom(t, s) {
            if (!u.cE(s, t.wrap())) return 0;
            const { tileID: d, mercatorX: g, mercatorY: w } = this._getOverscaledTileIDFromLngLatZoom(t, s);
            return this.getElevation(d, g % u.a5, w % u.a5, u.a5);
          }
          getElevationForLngLat(t, s) {
            const d = wr(s, { maxzoom: this.tileManager.maxzoom, minzoom: this.tileManager.minzoom, tileSize: 512, terrain: this });
            let g = 0;
            for (const w of d) w.canonical.z > g && (g = Math.min(w.canonical.z, this.tileManager.maxzoom));
            return this.getElevationForLngLatZoom(t, g);
          }
          getElevation(t, s, d, g = u.a5) {
            return this.getDEMElevation(t, s, d, g) * this.exaggeration;
          }
          getTerrainData(t) {
            if (!this._emptyDemTexture) {
              const g = this.painter.context, w = new u.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new u.T(g, w, g.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new u.T(g, new u.R({ width: 1, height: 1 }), g.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = u.ar([]);
            }
            const s = this.tileManager.getSourceTile(t, !0);
            if (s && s.dem && (!s.demTexture || s.needsTerrainPrepare)) {
              const g = this.painter.context;
              s.demTexture = this.painter.getTileTexture(s.dem.stride), s.demTexture ? s.demTexture.update(s.dem.getPixels(), { premultiply: !1 }) : s.demTexture = new u.T(g, s.dem.getPixels(), g.gl.RGBA, { premultiply: !1 }), s.demTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), s.needsTerrainPrepare = !1;
            }
            const d = s && s.toString() + s.tileID.key + t.key;
            if (d && !this._demMatrixCache[d]) {
              const g = this.tileManager.getSource().maxzoom;
              let w = t.canonical.z - s.tileID.canonical.z;
              t.overscaledZ > t.canonical.z && (t.canonical.z >= g ? w = t.canonical.z - g : u.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const T = t.canonical.x - (t.canonical.x >> w << w), C = t.canonical.y - (t.canonical.y >> w << w), A = u.cF(new Float64Array(16), [1 / (u.a5 << w), 1 / (u.a5 << w), 0]);
              u.O(A, A, [T * u.a5, C * u.a5, 0]), this._demMatrixCache[t.key] = { matrix: A, coord: t };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: s && s.dem && s.dem.dim || 1, u_terrain_matrix: d ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: s && s.dem && s.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (s && s.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: s };
          }
          getFramebuffer(t) {
            const s = this.painter, d = s.width / devicePixelRatio, g = s.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === d && this._fbo.height === g || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new u.T(s.context, { width: d, height: g, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new u.T(s.context, { width: d, height: g, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = s.context.createFramebuffer(d, g, !0, !1), this._fbo.depthAttachment.set(s.context.createRenderbuffer(s.context.gl.DEPTH_COMPONENT16, d, g))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const t = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const s = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let w = 0, T = 0; w < this._coordsTextureSize; w++) for (let C = 0; C < this._coordsTextureSize; C++, T += 4) s[T + 0] = 255 & C, s[T + 1] = 255 & w, s[T + 2] = C >> 8 << 4 | w >> 8, s[T + 3] = 0;
            const d = new u.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(s.buffer)), g = new u.T(t, d, t.gl.RGBA, { premultiply: !1 });
            return g.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = g, g;
          }
          pointCoordinate(t) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const s = new Uint8Array(4), d = this.painter.context, g = d.gl, w = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), T = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), C = Math.round(this.painter.height / devicePixelRatio);
            d.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), g.readPixels(w, C - T - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, s), d.bindFramebuffer.set(null);
            const A = s[0] + (s[2] >> 4 << 8), F = s[1] + ((15 & s[2]) << 8), O = this.coordsIndex[255 - s[3]], q = O && this.tileManager.getTileByID(O);
            if (!q) return null;
            const V = this._coordsTextureSize, X = (1 << q.tileID.canonical.z) * V;
            return new u.a9((q.tileID.canonical.x * V + A) / X + q.tileID.wrap, (q.tileID.canonical.y * V + F) / X, this.getElevation(q.tileID, A, F, V));
          }
          depthAtPoint(t) {
            const s = new Uint8Array(4), d = this.painter.context, g = d.gl;
            return d.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), g.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, s), d.bindFramebuffer.set(null), (s[0] / 16777216 + s[1] / 65536 + s[2] / 256 + s[3]) / 256;
          }
          getTerrainMesh(t) {
            var s;
            const d = ((s = this.painter.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0, g = d && t.canonical.y === 0, w = d && t.canonical.y === (1 << t.canonical.z) - 1, T = `m_${g ? "n" : ""}_${w ? "s" : ""}`;
            if (this._meshCache[T]) return this._meshCache[T];
            const C = this.painter.context, A = new u.cG(), F = new u.aY(), O = this.meshSize, q = u.a5 / O, V = O * O;
            for (let ke = 0; ke <= O; ke++) for (let je = 0; je <= O; je++) A.emplaceBack(je * q, ke * q, 0);
            for (let ke = 0; ke < V; ke += O + 1) for (let je = 0; je < O; je++) F.emplaceBack(je + ke, O + je + ke + 1, O + je + ke + 2), F.emplaceBack(je + ke, O + je + ke + 2, je + ke + 1);
            const X = A.length, te = X + (O + 1), he = (O + 1) * O, pe = g ? u.br : 0, fe = g ? 0 : 1, be = w ? u.bs : u.a5, Ae = w ? 0 : 1;
            for (let ke = 0; ke <= O; ke++) A.emplaceBack(ke * q, pe, fe);
            for (let ke = 0; ke <= O; ke++) A.emplaceBack(ke * q, be, Ae);
            for (let ke = 0; ke < O; ke++) F.emplaceBack(he + ke, te + ke, te + ke + 1), F.emplaceBack(he + ke, te + ke + 1, he + ke + 1), F.emplaceBack(0 + ke, X + ke + 1, X + ke), F.emplaceBack(0 + ke, 0 + ke + 1, X + ke + 1);
            const xe = A.length, Ce = xe + 2 * (O + 1);
            for (const ke of [0, 1]) for (let je = 0; je <= O; je++) for (const at of [0, 1]) A.emplaceBack(ke * u.a5, je * q, at);
            for (let ke = 0; ke < 2 * O; ke += 2) F.emplaceBack(xe + ke, xe + ke + 1, xe + ke + 3), F.emplaceBack(xe + ke, xe + ke + 3, xe + ke + 2), F.emplaceBack(Ce + ke, Ce + ke + 3, Ce + ke + 1), F.emplaceBack(Ce + ke, Ce + ke + 2, Ce + ke + 3);
            const Oe = new Ar(C.createVertexBuffer(A, gm.members), C.createIndexBuffer(F), u.aX.simpleSegment(0, 0, A.length, F.length));
            return this._meshCache[T] = Oe, Oe;
          }
          getMeshFrameDelta(t) {
            return 2 * Math.PI * u.bE / Math.pow(2, Math.max(t, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(t, s) {
            var d;
            if (!u.cE(s, t.wrap())) return 0;
            const { tileID: g } = this._getOverscaledTileIDFromLngLatZoom(t, s);
            return (d = this.getMinMaxElevation(g).minElevation) !== null && d !== void 0 ? d : 0;
          }
          getMinMaxElevation(t) {
            const s = this.getTerrainData(t).tile, d = { minElevation: null, maxElevation: null };
            return s && s.dem && (d.minElevation = s.dem.min * this.exaggeration, d.maxElevation = s.dem.max * this.exaggeration), d;
          }
          _getOverscaledTileIDFromLngLatZoom(t, s) {
            const d = u.a9.fromLngLat(t.wrap()), g = (1 << s) * u.a5, w = d.x * g, T = d.y * g, C = Math.floor(w / u.a5), A = Math.floor(T / u.a5);
            return { tileID: new u.a2(s, 0, s, C, A), mercatorX: w, mercatorY: T };
          }
        }
        class Pn {
          constructor(t, s, d) {
            this._context = t, this._size = s, this._tileSize = d, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
          }
          _createObject(t) {
            const s = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), d = new u.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return d.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), s.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), s.colorAttachment.set(d.texture), { id: t, fbo: s, texture: d, stamp: -1, inUse: !1 };
          }
          getObjectForId(t) {
            return this._objects[t];
          }
          useObject(t) {
            t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((s) => t.id !== s)), this._recentlyUsed.push(t.id);
          }
          stampObject(t) {
            t.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const s of this._recentlyUsed) if (!this._objects[s].inUse) return this._objects[s];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t = this._createObject(this._objects.length);
            return this._objects.push(t), t;
          }
          freeObject(t) {
            t.inUse = !1;
          }
          freeAllObjects() {
            for (const t of this._objects) this.freeObject(t);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((t) => !t.inUse)) === !1;
          }
        }
        const Zo = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Uu {
          constructor(t, s) {
            this.painter = t, this.terrain = s, this.pool = new Pn(t.context, 30, s.tileManager.tileSize * s.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t) {
            return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t, s) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = t._order.filter(((d) => !t._layers[d].isHidden(s))), this._coordsAscending = {};
            for (const d in t.tileManagers) {
              this._coordsAscending[d] = {};
              const g = t.tileManagers[d].getVisibleCoordinates(), w = t.tileManagers[d].getSource(), T = w instanceof ln ? w.terrainTileRanges : null;
              for (const C of g) {
                const A = this.terrain.tileManager.getTerrainCoords(C, T);
                for (const F in A) this._coordsAscending[d][F] || (this._coordsAscending[d][F] = []), this._coordsAscending[d][F].push(A[F]);
              }
            }
            this._coordsAscendingStr = {};
            for (const d of t._order) {
              const g = t._layers[d], w = g.source;
              if (Zo[g.type] && !this._coordsAscendingStr[w]) {
                this._coordsAscendingStr[w] = {};
                for (const T in this._coordsAscending[w]) this._coordsAscendingStr[w][T] = this._coordsAscending[w][T].map(((C) => C.key)).sort().join();
              }
            }
            for (const d of this._renderableTiles) for (const g in this._coordsAscendingStr) {
              const w = this._coordsAscendingStr[g][d.tileID.key];
              w && w !== d.rttCoords[g] && (d.rtt = []);
            }
          }
          renderLayer(t, s) {
            if (t.isHidden(this.painter.transform.zoom)) return !1;
            const d = Object.assign(Object.assign({}, s), { isRenderingToTexture: !0 }), g = t.type, w = this.painter, T = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
            if (Zo[g] && (this._prevType && Zo[this._prevType] || this._stacks.push([]), this._prevType = g, this._stacks[this._stacks.length - 1].push(t.id), !T)) return !0;
            if (Zo[this._prevType] || Zo[g] && T) {
              this._prevType = g;
              const C = this._stacks.length - 1, A = this._stacks[C] || [];
              for (const F of this._renderableTiles) {
                if (this.pool.isFull() && (ld(this.painter, this.terrain, this._rttTiles, d), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(F), F.rtt[C]) {
                  const q = this.pool.getObjectForId(F.rtt[C].id);
                  if (q.stamp === F.rtt[C].stamp) {
                    this.pool.useObject(q);
                    continue;
                  }
                }
                const O = this.pool.getOrCreateFreeObject();
                this.pool.useObject(O), this.pool.stampObject(O), F.rtt[C] = { id: O.id, stamp: O.stamp }, w.context.bindFramebuffer.set(O.fbo.framebuffer), w.context.clear({ color: u.bp.transparent, stencil: 0 }), w.currentStencilSource = void 0;
                for (let q = 0; q < A.length; q++) {
                  const V = w.style._layers[A[q]], X = V.source ? this._coordsAscending[V.source][F.tileID.key] : [F.tileID];
                  w.context.viewport.set([0, 0, O.fbo.width, O.fbo.height]), w._renderTileClippingMasks(V, X, !0), w.renderLayer(w, w.style.tileManagers[V.source], V, X, d), V.source && (F.rttCoords[V.source] = this._coordsAscendingStr[V.source][F.tileID.key]);
                }
              }
              return ld(this.painter, this.terrain, this._rttTiles, d), this._rttTiles = [], this.pool.freeAllObjects(), Zo[g];
            }
            return !1;
          }
        }
        const Wc = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, xd = R, Xc = { hash: !1, interactive: !0, bearingSnap: 7, zoomSnap: 0, attributionControl: Ts, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: u.c.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, reduceMotion: void 0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0, experimentalZoomLevelsToOverscale: void 0 }, bd = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class qu {
          constructor(t, s, d = !1) {
            this.mousedown = (w) => {
              this.startMove(w, ne.mousePos(this.element, w)), ne.addEventListener(window, "mousemove", this.mousemove), ne.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (w) => {
              this.move(w, ne.mousePos(this.element, w));
            }, this.mouseup = (w) => {
              this._rotatePitchHandler.dragEnd(w), this.offTemp();
            }, this.touchstart = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ne.touchPos(this.element, w.targetTouches)[0], this.startMove(w, this._startPos), ne.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ne.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ne.touchPos(this.element, w.targetTouches)[0], this.move(w, this._lastPos));
            }, this.touchend = (w) => {
              w.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = s;
            const g = new up();
            this._rotatePitchHandler = new Rl({ clickTolerance: 3, move: (w, T) => {
              const C = s.getBoundingClientRect(), A = new u.P((C.bottom - C.top) / 2, (C.right - C.left) / 2);
              return { bearingDelta: u.cy(new u.P(w.x, T.y), T, A), pitchDelta: d ? -0.5 * (T.y - w.y) : void 0 };
            }, moveStateManager: g, enable: !0, assignEvents: () => {
            } }), this.map = t, ne.addEventListener(s, "mousedown", this.mousedown), ne.addEventListener(s, "touchstart", this.touchstart, { passive: !1 }), ne.addEventListener(s, "touchcancel", this.reset);
          }
          startMove(t, s) {
            this._rotatePitchHandler.dragStart(t, s), ne.disableDrag();
          }
          move(t, s) {
            const d = this.map, { bearingDelta: g, pitchDelta: w } = this._rotatePitchHandler.dragMove(t, s) || {};
            g && d.setBearing(d.getBearing() + g), w && d.setPitch(d.getPitch() + w);
          }
          off() {
            const t = this.element;
            ne.removeEventListener(t, "mousedown", this.mousedown), ne.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), ne.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ne.removeEventListener(window, "touchend", this.touchend), ne.removeEventListener(t, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            ne.enableDrag(), ne.removeEventListener(window, "mousemove", this.mousemove), ne.removeEventListener(window, "mouseup", this.mouseup), ne.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ne.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let La;
        function Jc(b, t, s, d = !1) {
          if (d || !s.getCoveringTilesDetailsProvider().allowWorldCopies()) return b?.wrap();
          const g = new u.V(b.lng, b.lat);
          if (b = new u.V(b.lng, b.lat), t) {
            const w = new u.V(b.lng - 360, b.lat), T = new u.V(b.lng + 360, b.lat), C = s.locationToScreenPoint(b).distSqr(t);
            s.locationToScreenPoint(w).distSqr(t) < C ? b = w : s.locationToScreenPoint(T).distSqr(t) < C && (b = T);
          }
          for (; Math.abs(b.lng - s.center.lng) > 180; ) {
            const w = s.locationToScreenPoint(b);
            if (w.x >= 0 && w.y >= 0 && w.x <= s.width && w.y <= s.height) break;
            b.lng > s.center.lng ? b.lng -= 360 : b.lng += 360;
          }
          return b.lng !== g.lng && s.isPointOnMapSurface(s.locationToScreenPoint(b)) ? b : g;
        }
        const $u = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Kc(b, t, s) {
          const d = b.classList;
          for (const g in $u) d.remove(`maplibregl-${s}-anchor-${g}`);
          d.add(`maplibregl-${s}-anchor-${t}`);
        }
        class Zu extends u.E {
          constructor(t) {
            if (super(), this._onKeyPress = (s) => {
              const d = s.code, g = s.charCode || s.keyCode;
              d !== "Space" && d !== "Enter" && g !== 32 && g !== 13 || this.togglePopup();
            }, this._onMapClick = (s) => {
              const d = s.originalEvent.target, g = this._element;
              this._popup && (d === g || g.contains(d)) && this.togglePopup();
            }, this._update = (s) => {
              if (!this._map) return;
              const d = this._map.loaded() && !this._map.isMoving();
              (s?.type === "terrain" || s?.type === "render" && !d) && this._map.once("render", this._update), this._lngLat = Jc(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let g = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? g = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (g = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let w = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? w = "rotateX(0deg)" : this._pitchAlignment === "map" && (w = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || s && s.type !== "moveend" || (this._pos = this._pos.round()), ne.setTransform(this._element, `${$u[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${w} ${g}`), le.frameAsync(new AbortController(), this._map._ownerWindow).then((() => {
                this._updateOpacity(s && s.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (s) => {
              if (!this._isDragging) {
                const d = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = s.point.dist(this._pointerdownPos) >= d;
              }
              this._isDragging && (this._pos = s.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new u.l("dragstart"))), this.fire(new u.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new u.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (s) => {
              this._element.contains(s.originalEvent.target) && (s.preventDefault(), this._positionDelta = s.point.sub(this._pos).add(this._offset), this._pointerdownPos = s.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._subpixelPositioning = t && t.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(t?.opacity, t?.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = u.P.convert(t && t.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = ne.create("div");
              const s = ne.createNS("http://www.w3.org/2000/svg", "svg"), d = 41, g = 27;
              s.setAttributeNS(null, "display", "block"), s.setAttributeNS(null, "height", `${d}px`), s.setAttributeNS(null, "width", `${g}px`), s.setAttributeNS(null, "viewBox", `0 0 ${g} ${d}`);
              const w = ne.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
              const T = ne.createNS("http://www.w3.org/2000/svg", "g");
              T.setAttributeNS(null, "fill-rule", "nonzero");
              const C = ne.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), C.setAttributeNS(null, "fill", "#000000");
              const A = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const fe of A) {
                const be = ne.createNS("http://www.w3.org/2000/svg", "ellipse");
                be.setAttributeNS(null, "opacity", "0.04"), be.setAttributeNS(null, "cx", "10.5"), be.setAttributeNS(null, "cy", "5.80029008"), be.setAttributeNS(null, "rx", fe.rx), be.setAttributeNS(null, "ry", fe.ry), C.appendChild(be);
              }
              const F = ne.createNS("http://www.w3.org/2000/svg", "g");
              F.setAttributeNS(null, "fill", this._color);
              const O = ne.createNS("http://www.w3.org/2000/svg", "path");
              O.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), F.appendChild(O);
              const q = ne.createNS("http://www.w3.org/2000/svg", "g");
              q.setAttributeNS(null, "opacity", "0.25"), q.setAttributeNS(null, "fill", "#000000");
              const V = ne.createNS("http://www.w3.org/2000/svg", "path");
              V.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), q.appendChild(V);
              const X = ne.createNS("http://www.w3.org/2000/svg", "g");
              X.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), X.setAttributeNS(null, "fill", "#FFFFFF");
              const te = ne.createNS("http://www.w3.org/2000/svg", "g");
              te.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const he = ne.createNS("http://www.w3.org/2000/svg", "circle");
              he.setAttributeNS(null, "fill", "#000000"), he.setAttributeNS(null, "opacity", "0.25"), he.setAttributeNS(null, "cx", "5.5"), he.setAttributeNS(null, "cy", "5.5"), he.setAttributeNS(null, "r", "5.4999962");
              const pe = ne.createNS("http://www.w3.org/2000/svg", "circle");
              pe.setAttributeNS(null, "fill", "#FFFFFF"), pe.setAttributeNS(null, "cx", "5.5"), pe.setAttributeNS(null, "cy", "5.5"), pe.setAttributeNS(null, "r", "5.4999962"), te.appendChild(he), te.appendChild(pe), T.appendChild(C), T.appendChild(F), T.appendChild(q), T.appendChild(X), T.appendChild(te), s.appendChild(T), s.setAttributeNS(null, "height", d * this._scale + "px"), s.setAttributeNS(null, "width", g * this._scale + "px"), this._element.appendChild(s), this._offset = u.P.convert(t && t.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((s) => {
              s.preventDefault();
            })), this._element.addEventListener("mousedown", ((s) => {
              s.preventDefault();
            })), Kc(this._element, this._anchor, "marker"), t && t.className) for (const s of t.className.split(" ")) this._element.classList.add(s);
            this._popup = null;
          }
          addTo(t) {
            return this.remove(), this._map = t, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), t.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), ne.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return this._lngLat = u.V.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
              if (!("offset" in t.options)) {
                const g = Math.abs(13.5) / Math.SQRT2;
                t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [g, -1 * (38.1 - 13.5 + g)], "bottom-right": [-g, -1 * (38.1 - 13.5 + g)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(t) {
            return this._subpixelPositioning = t, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this;
          }
          _updateOpacity(t = !1) {
            var s, d;
            const g = (s = this._map) === null || s === void 0 ? void 0 : s.terrain, w = this._map.transform.isLocationOccluded(this._lngLat);
            if (!g || w) {
              const X = w ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== X && (this._element.style.opacity = X));
            }
            if (t) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const T = this._map, C = T.terrain.depthAtPoint(this._pos), A = T.terrain.getElevationForLngLat(this._lngLat, T.transform);
            if (T.transform.lngLatToCameraDepth(this._lngLat, A) - C < 6e-3) return void (this._element.style.opacity = this._opacity);
            const F = -this._offset.y / T.transform.pixelsPerMeter, O = Math.sin(T.getPitch() * Math.PI / 180) * F, q = T.terrain.depthAtPoint(new u.P(this._pos.x, this._pos.y - this._offset.y)), V = T.transform.lngLatToCameraDepth(this._lngLat, A + O) - q > 6e-3;
            !((d = this._popup) === null || d === void 0) && d.isOpen() && V && this._popup.remove(), this._element.style.opacity = V ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t) {
            return this._offset = u.P.convert(t), this._update(), this;
          }
          addClassName(t) {
            this._element.classList.add(t);
          }
          removeClassName(t) {
            this._element.classList.remove(t);
          }
          toggleClassName(t) {
            return this._element.classList.toggle(t);
          }
          setDraggable(t) {
            return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t) {
            return this._rotation = t || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t) {
            return this._rotationAlignment = t || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t) {
            return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t, s) {
            return (this._opacity === void 0 || t === void 0 && s === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), s !== void 0 && (this._opacityWhenCovered = s), this._map && this._updateOpacity(!0), this;
          }
        }
        const wd = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let Nl = 0, Ho = !1;
        const Ed = { maxWidth: 100, unit: "metric" };
        function Hu(b, t, s) {
          const d = s && s.maxWidth || 100, g = b._container.clientHeight / 2, w = b._container.clientWidth / 2, T = b.unproject([w - d / 2, g]), C = b.unproject([w + d / 2, g]), A = Math.round(b.project(C).x - b.project(T).x), F = Math.min(d, A, b._container.clientWidth), O = T.distanceTo(C);
          if (s && s.unit === "imperial") {
            const q = 3.2808 * O;
            q > 5280 ? Yo(t, F, q / 5280, b._getUIString("ScaleControl.Miles")) : Yo(t, F, q, b._getUIString("ScaleControl.Feet"));
          } else s && s.unit === "nautical" ? Yo(t, F, O / 1852, b._getUIString("ScaleControl.NauticalMiles")) : O >= 1e3 ? Yo(t, F, O / 1e3, b._getUIString("ScaleControl.Kilometers")) : Yo(t, F, O, b._getUIString("ScaleControl.Meters"));
        }
        function Yo(b, t, s, d) {
          const g = (function(w) {
            const T = Math.pow(10, `${Math.floor(w)}`.length - 1);
            let C = w / T;
            return C = C >= 10 ? 10 : C >= 5 ? 5 : C >= 3 ? 3 : C >= 2 ? 2 : C >= 1 ? 1 : (function(A) {
              const F = Math.pow(10, Math.ceil(-Math.log(A) / Math.LN10));
              return Math.round(A * F) / F;
            })(C), T * C;
          })(s);
          b.style.width = t * (g / s) + "px", b.innerHTML = `${g}&nbsp;${d}`;
        }
        const Sd = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0, padding: void 0 }, Qc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function eh(b) {
          if (b) {
            if (typeof b == "number") {
              const t = Math.round(Math.abs(b) / Math.SQRT2);
              return { center: new u.P(0, 0), top: new u.P(0, b), "top-left": new u.P(t, t), "top-right": new u.P(-t, t), bottom: new u.P(0, -b), "bottom-left": new u.P(t, -t), "bottom-right": new u.P(-t, -t), left: new u.P(b, 0), right: new u.P(-b, 0) };
            }
            if (b instanceof u.P || Array.isArray(b)) {
              const t = u.P.convert(b);
              return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t };
            }
            return { center: u.P.convert(b.center || [0, 0]), top: u.P.convert(b.top || [0, 0]), "top-left": u.P.convert(b["top-left"] || [0, 0]), "top-right": u.P.convert(b["top-right"] || [0, 0]), bottom: u.P.convert(b.bottom || [0, 0]), "bottom-left": u.P.convert(b["bottom-left"] || [0, 0]), "bottom-right": u.P.convert(b["bottom-right"] || [0, 0]), left: u.P.convert(b.left || [0, 0]), right: u.P.convert(b.right || [0, 0]) };
          }
          return eh(new u.P(0, 0));
        }
        const Td = R;
        S.AJAXError = u.cJ, S.Event = u.l, S.Evented = u.E, S.LngLat = u.V, S.MercatorCoordinate = u.a9, S.Point = u.P, S.addProtocol = u.cK, S.config = u.c, S.removeProtocol = u.cL, S.AttributionControl = vd, S.BoxZoomHandler = Dl, S.CanvasSource = Un, S.CooperativeGesturesHandler = $t, S.DoubleClickZoomHandler = yd, S.DragPanHandler = gp, S.DragRotateHandler = Vs, S.EdgeInsets = ra, S.FullscreenControl = class extends u.E {
          constructor(b = {}) {
            super(), this._onFullscreenChange = () => {
              var t;
              let s = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((t = s?.shadowRoot) === null || t === void 0) && t.fullscreenElement; ) s = s.shadowRoot.fullscreenElement;
              s === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, b && b.container && (b.container instanceof HTMLElement ? this._container = b.container : u.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(b) {
            return this._map = b, this._container || (this._container = this._map.getContainer()), this._controlContainer = ne.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            ne.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const b = this._fullscreenButton = ne.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            ne.create("span", "maplibregl-ctrl-icon", b).setAttribute("aria-hidden", "true"), b.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const b = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", b), this._fullscreenButton.title = b;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new u.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new u.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, S.GeoJSONSource = tr, S.GeolocateControl = class extends u.E {
          constructor(b) {
            super(), this._onSuccess = (t) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new u.l("outofmaxbounds", t)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new u.l("geolocate", t)), this._finish();
              }
            }, this._updateCamera = (t) => {
              const s = new u.V(t.coords.longitude, t.coords.latitude), d = t.coords.accuracy, g = this._map.getBearing(), w = u.e({ bearing: g }, this.options.fitBoundsOptions), T = Dr.fromLngLat(s, d);
              this._map.fitBounds(T, w, { geolocateSource: !0 });
            }, this._updateMarker = (t) => {
              if (t) {
                const s = new u.V(t.coords.longitude, t.coords.latitude);
                this._accuracyCircleMarker.setLngLat(s).addTo(this._map), this._userLocationDotMarker.setLngLat(s).addTo(this._map), this._accuracy = t.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (t) => {
              if (this._map) {
                if (t.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (t.code === 3 && Ho) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new u.l("error", t)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((t) => t.preventDefault())), this._geolocateButton = ne.create("button", "maplibregl-ctrl-geolocate", this._container), ne.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (t) => {
              if (this._map) {
                if (t === !1) {
                  u.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
                } else {
                  const s = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = ne.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Zu({ element: this._dotElement }), this._circleElement = ne.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Zu({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((s) => {
                  const d = s?.[0] instanceof ResizeObserverEntry;
                  s.geolocateSource || this._watchState !== "ACTIVE_LOCK" || d || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new u.l("trackuserlocationend")), this.fire(new u.l("userlocationlostfocus")));
                }));
              }
            }, this.options = u.e({}, wd, b);
          }
          onAdd(b) {
            return this._map = b, this._container = ne.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return u._(this, arguments, void 0, (function* (t = !1) {
                if (La !== void 0 && !t) return La;
                if (window.navigator.permissions === void 0) return La = !!window.navigator.geolocation, La;
                try {
                  La = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  La = !!window.navigator.geolocation;
                }
                return La;
              }));
            })().then(((t) => this._finishSetupUI(t))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), ne.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Nl = 0, Ho = !1;
          }
          _isOutOfMapMaxBounds(b) {
            const t = this._map.getMaxBounds(), s = b.coords;
            return t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const b = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && b)) return;
            const t = this._map.project(b), s = this._map.unproject([t.x + 100, t.y]), d = b.distanceTo(s) / 100, g = 2 * this._accuracy / d;
            this._circleElement.style.width = `${g.toFixed(2)}px`, this._circleElement.style.height = `${g.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return u.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new u.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Nl--, Ho = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new u.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new u.l("trackuserlocationstart")), this.fire(new u.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let b;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Nl++, Nl > 1 ? (b = { maximumAge: 6e5, timeout: 0 }, Ho = !0) : (b = this.options.positionOptions, Ho = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, b);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, S.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var b;
              const t = (b = this._map.getProjection()) === null || b === void 0 ? void 0 : b.type;
              this._map.setProjection(t !== "mercator" && t ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var b;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((b = this._map.getProjection()) === null || b === void 0 ? void 0 : b.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(b) {
            return this._map = b, this._container = ne.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = ne.create("button", "maplibregl-ctrl-globe", this._container), ne.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            ne.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, S.Hash = hd, S.ImageSource = ln, S.KeyboardHandler = Vr, S.LngLatBounds = Dr, S.LogoControl = mp, S.Map = class extends Ui {
          get _ownerWindow() {
            var b, t;
            return ((t = (b = this._container) === null || b === void 0 ? void 0 : b.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView) || window;
          }
          constructor(b) {
            var t, s;
            u.cH.mark(u.cI.create);
            const d = Object.assign(Object.assign(Object.assign({}, Xc), b), { canvasContextAttributes: Object.assign(Object.assign({}, Xc.canvasContextAttributes), b.canvasContextAttributes) });
            if (d.minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (d.minPitch != null && d.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (d.maxPitch != null && d.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const g = new ia(), w = new vi();
            d.minZoom !== void 0 && g.setMinZoom(d.minZoom), d.maxZoom !== void 0 && g.setMaxZoom(d.maxZoom), d.minPitch !== void 0 && g.setMinPitch(d.minPitch), d.maxPitch !== void 0 && g.setMaxPitch(d.maxPitch), d.renderWorldCopies !== void 0 && g.setRenderWorldCopies(d.renderWorldCopies), d.transformConstrain !== null && g.setConstrainOverride(d.transformConstrain), super(g, w, { bearingSnap: d.bearingSnap, zoomSnap: d.zoomSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new pm(), this._controls = [], this._mapId = u.af(), this._lostContextStyle = { style: null, images: null }, this._contextLost = (C) => {
              C.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
              for (const A of Object.values(this.style._layers)) if (A.type === "custom" && console.warn(`Custom layer with id '${A.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), A._listeners) for (const [F] of Object.entries(A._listeners)) console.warn(`Custom layer with id '${A.id}' had event listeners for event '${F}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
              this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new u.l("webglcontextlost", { originalEvent: C }));
            }, this._contextRestored = (C) => {
              this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: !1 }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._lostContextStyle = { style: null, images: null }, this._setupPainter(), this.resize(), this._update(), this._resizeInternal(), this.fire(new u.l("webglcontextrestored", { originalEvent: C }));
            }, this._onMapScroll = (C) => {
              if (C.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._maxTileCacheZoomLevels = d.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, d.canvasContextAttributes), this._trackResize = d.trackResize === !0, this._bearingSnap = d.bearingSnap, this._zoomSnap = d.zoomSnap, this._centerClampedToGround = d.centerClampedToGround, this._refreshExpiredTiles = d.refreshExpiredTiles === !0, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions === !0, this._collectResourceTiming = d.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Wc), d.locale), this._clickTolerance = d.clickTolerance, this._overridePixelRatio = d.pixelRatio, this._maxCanvasSize = d.maxCanvasSize, this._zoomLevelsToOverscale = d.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = d.transformCameraUpdate, this.transformConstrain = d.transformConstrain, this.cancelPendingTileRequestsWhileZooming = d.cancelPendingTileRequestsWhileZooming === !0, d.reduceMotion !== void 0 && (le.prefersReducedMotion = d.reduceMotion), this._imageQueueHandle = ut.addThrottleControl((() => this.isMoving())), this._requestManager = new Q(d.transformRequest), this._container = this._resolveContainer(d.container), d.maxBounds && this.setMaxBounds(d.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            })), this.once("idle", (() => {
              this._idleTriggered = !0;
            })), typeof window < "u" && (this._ownerWindow.addEventListener("online", this._onWindowOnline, !1), this._setupResizeObserver()), this.handlers = new Yc(this, d), this._hash = d.hash && new hd(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, elevation: d.elevation, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch, roll: d.roll }), d.bounds && (this.resize(), this.fitBounds(d.bounds, u.e({}, d.fitBoundsOptions, { duration: 0 }))));
            const T = typeof d.style == "string" || ((s = (t = d.style) === null || t === void 0 ? void 0 : t.projection) === null || s === void 0 ? void 0 : s.type) !== "globe";
            this.resize(null, T), this._localIdeographFontFamily = d.localIdeographFontFamily, this._validateStyle = d.validateStyle, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new vd(typeof d.attributionControl == "boolean" ? void 0 : d.attributionControl)), d.maplibreLogo && this.addControl(new mp(), d.logoPosition), this.on("style.load", (() => {
              if (T || this._resizeTransform(), this.transform.unmodified) {
                const C = u.U(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(C);
              }
            })), this.on("data", ((C) => {
              this._update(C.dataType === "style"), this.fire(new u.l(`${C.dataType}data`, C));
            })), this.on("dataloading", ((C) => {
              this.fire(new u.l(`${C.dataType}dataloading`, C));
            })), this.on("dataabort", ((C) => {
              this.fire(new u.l("sourcedataabort", C));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(b, t) {
            return this.style.setGlobalStateProperty(b, t), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(b, t) {
            if (t === void 0 && (t = b.getDefaultPosition ? b.getDefaultPosition() : "top-right"), !b || !b.onAdd) return this.fire(new u.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s = b.onAdd(this);
            this._controls.push(b);
            const d = this._controlPositions[t];
            return t.indexOf("bottom") !== -1 ? d.insertBefore(s, d.firstChild) : d.appendChild(s), this;
          }
          removeControl(b) {
            if (!b || !b.onRemove) return this.fire(new u.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const t = this._controls.indexOf(b);
            return t > -1 && this._controls.splice(t, 1), b.onRemove(this), this;
          }
          hasControl(b) {
            return this._controls.indexOf(b) > -1;
          }
          coveringTiles(b) {
            return wr(this.transform, b);
          }
          calculateCameraOptionsFromTo(b, t, s, d) {
            return d == null && this.terrain && (d = this.terrain.getElevationForLngLat(s, this.transform)), super.calculateCameraOptionsFromTo(b, t, s, d);
          }
          resize(b, t = !0) {
            if (this._lostContextStyle.style !== null) return this;
            this._resizeInternal(t);
            const s = !this._moving;
            return s && (this.stop(), this.fire(new u.l("movestart", b)).fire(new u.l("move", b))), this.fire(new u.l("resize", b)), s && this.fire(new u.l("moveend", b)), this;
          }
          _resizeInternal(b = !0) {
            const [t, s] = this._containerDimensions(), d = this._getClampedPixelRatio(t, s);
            if (this._resizeCanvas(t, s, d), this.painter.resize(t, s, d), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const w = this._getClampedPixelRatio(t, s);
              this._resizeCanvas(t, s, w), this.painter.resize(t, s, w);
            }
            this._resizeTransform(b);
          }
          _resizeTransform(b = !0) {
            var t;
            const [s, d] = this._containerDimensions();
            this.transform.resize(s, d, b), (t = this._requestedCameraState) === null || t === void 0 || t.resize(s, d, b);
          }
          _getClampedPixelRatio(b, t) {
            const { 0: s, 1: d } = this._maxCanvasSize, g = this.getPixelRatio(), w = b * g, T = t * g;
            return Math.min(w > s ? s / w : 1, T > d ? d / T : 1) * g;
          }
          getPixelRatio() {
            var b;
            return (b = this._overridePixelRatio) !== null && b !== void 0 ? b : devicePixelRatio;
          }
          setPixelRatio(b) {
            this._overridePixelRatio = b, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(b) {
            return this.transform.setMaxBounds(Dr.convert(b)), this._update();
          }
          setMinZoom(b) {
            if ((b = b ?? -2) >= -2 && b <= this.transform.maxZoom) {
              const t = this.transform.zoom, s = this._getTransformForUpdate();
              return s.setMinZoom(b), this._applyUpdatedTransform(s), this._update(), t !== this.transform.zoom && this.fire(new u.l("zoomstart")).fire(new u.l("zoom")).fire(new u.l("zoomend")).fire(new u.l("movestart")).fire(new u.l("move")).fire(new u.l("moveend")), this;
            }
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(b) {
            if ((b = b ?? 22) >= this.transform.minZoom) {
              const t = this.transform.zoom, s = this._getTransformForUpdate();
              return s.setMaxZoom(b), this._applyUpdatedTransform(s), this._update(), t !== this.transform.zoom && this.fire(new u.l("zoomstart")).fire(new u.l("zoom")).fire(new u.l("zoomend")).fire(new u.l("movestart")).fire(new u.l("move")).fire(new u.l("moveend")), this;
            }
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(b) {
            if ((b = b ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (b >= 0 && b <= this.transform.maxPitch) {
              const t = this.transform.pitch, s = this._getTransformForUpdate();
              return s.setMinPitch(b), this._applyUpdatedTransform(s), this._update(), t !== this.transform.pitch && this.fire(new u.l("pitchstart")).fire(new u.l("pitch")).fire(new u.l("pitchend")).fire(new u.l("movestart")).fire(new u.l("move")).fire(new u.l("moveend")), this;
            }
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(b) {
            if ((b = b ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (b >= this.transform.minPitch) {
              const t = this.transform.pitch, s = this._getTransformForUpdate();
              return s.setMaxPitch(b), this._applyUpdatedTransform(s), this._update(), t !== this.transform.pitch && this.fire(new u.l("pitchstart")).fire(new u.l("pitch")).fire(new u.l("pitchend")).fire(new u.l("movestart")).fire(new u.l("move")).fire(new u.l("moveend")), this;
            }
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(b) {
            return this.transform.setRenderWorldCopies(b), this._update();
          }
          setTransformConstrain(b) {
            return this.transform.setConstrainOverride(b), this._update();
          }
          project(b) {
            return this.transform.locationToScreenPoint(u.V.convert(b), this.style && this.terrain);
          }
          unproject(b) {
            return this.transform.screenPointToLocation(u.P.convert(b), this.terrain);
          }
          isMoving() {
            var b;
            return this._moving || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isMoving());
          }
          isZooming() {
            var b;
            return this._zooming || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isZooming());
          }
          isRotating() {
            var b;
            return this._rotating || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isRotating());
          }
          _createDelegatedListener(b, t, s) {
            if (b === "mouseenter" || b === "mouseover") {
              let d = !1;
              return { layers: t, listener: s, delegates: { mousemove: (w) => {
                const T = t.filter(((A) => this.getLayer(A))), C = T.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: T }) : [];
                C.length ? d || (d = !0, s.call(this, new ci(b, this, w.originalEvent, { features: C }))) : d = !1;
              }, mouseout: () => {
                d = !1;
              } } };
            }
            if (b === "mouseleave" || b === "mouseout") {
              let d = !1;
              return { layers: t, listener: s, delegates: { mousemove: (T) => {
                const C = t.filter(((A) => this.getLayer(A)));
                (C.length !== 0 ? this.queryRenderedFeatures(T.point, { layers: C }) : []).length ? d = !0 : d && (d = !1, s.call(this, new ci(b, this, T.originalEvent)));
              }, mouseout: (T) => {
                d && (d = !1, s.call(this, new ci(b, this, T.originalEvent)));
              } } };
            }
            {
              const d = (g) => {
                const w = t.filter(((C) => this.getLayer(C))), T = w.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: w }) : [];
                T.length && (g.features = T, s.call(this, g), delete g.features);
              };
              return { layers: t, listener: s, delegates: { [b]: d } };
            }
          }
          _saveDelegatedListener(b, t) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[b] = this._delegatedListeners[b] || [], this._delegatedListeners[b].push(t);
          }
          _removeDelegatedListener(b, t, s) {
            if (!this._delegatedListeners || !this._delegatedListeners[b]) return;
            const d = this._delegatedListeners[b];
            for (let g = 0; g < d.length; g++) {
              const w = d[g];
              if (w.listener === s && w.layers.length === t.length && w.layers.every(((T) => t.includes(T)))) {
                for (const T in w.delegates) this.off(T, w.delegates[T]);
                return void d.splice(g, 1);
              }
            }
          }
          on(b, t, s) {
            if (s === void 0) return super.on(b, t);
            const d = typeof t == "string" ? [t] : t, g = this._createDelegatedListener(b, d, s);
            this._saveDelegatedListener(b, g);
            for (const w in g.delegates) this.on(w, g.delegates[w]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(b, d, s);
            } };
          }
          once(b, t, s) {
            if (s === void 0) return super.once(b, t);
            const d = typeof t == "string" ? [t] : t, g = this._createDelegatedListener(b, d, s);
            for (const w in g.delegates) {
              const T = g.delegates[w];
              g.delegates[w] = (...C) => {
                this._removeDelegatedListener(b, d, s), T(...C);
              };
            }
            this._saveDelegatedListener(b, g);
            for (const w in g.delegates) this.once(w, g.delegates[w]);
            return this;
          }
          off(b, t, s) {
            return s === void 0 ? super.off(b, t) : (this._removeDelegatedListener(b, typeof t == "string" ? [t] : t, s), this);
          }
          queryRenderedFeatures(b, t) {
            if (!this.style) return [];
            let s;
            const d = b instanceof u.P || Array.isArray(b), g = d ? b : [[0, 0], [this.transform.width, this.transform.height]];
            if (t = t || (d ? {} : b) || {}, g instanceof u.P || typeof g[0] == "number") s = [u.P.convert(g)];
            else {
              const w = u.P.convert(g[0]), T = u.P.convert(g[1]);
              s = [w, new u.P(T.x, w.y), T, new u.P(w.x, T.y), w];
            }
            return this.style.queryRenderedFeatures(s, t, this.transform);
          }
          querySourceFeatures(b, t) {
            return this.style.querySourceFeatures(b, t);
          }
          setStyle(b, t) {
            return (t = u.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && b ? (this._diffStyle(b, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(b, t));
          }
          setTransformRequest(b) {
            return this._requestManager.setTransformRequest(b), this;
          }
          _getUIString(b) {
            const t = this._locale[b];
            if (t == null) throw new Error(`Missing UI string '${b}'`);
            return t;
          }
          _updateStyle(b, t) {
            var s, d;
            if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(b, t)));
            const g = this.style && t.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!b)), b ? (this.style = new Ia(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof b == "string" ? this.style.loadURL(b, t, g) : this.style.loadJSON(b, t, g), this) : ((d = (s = this.style) === null || s === void 0 ? void 0 : s.projection) === null || d === void 0 || d.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ia(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(b, t) {
            if (typeof b == "string") {
              const s = this._requestManager.transformRequest(b, "Style");
              u.j(s, new AbortController()).then(((d) => {
                this._updateDiff(d.data, t);
              })).catch(((d) => {
                d && this.fire(new u.k(d));
              }));
            } else typeof b == "object" && this._updateDiff(b, t);
          }
          _updateDiff(b, t) {
            try {
              this.style.setState(b, t) && this._update(!0);
            } catch (s) {
              u.w(`Unable to perform style diff: ${s.message || s.error || s}.  Rebuilding the style from scratch.`), this._updateStyle(b, t);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          _getStyleAndImages() {
            return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} };
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : u.w("There is no style added to the map.");
          }
          addSource(b, t) {
            return this._lazyInitEmptyStyle(), this.style.addSource(b, t), this._update(!0);
          }
          isSourceLoaded(b) {
            const t = this.style && this.style.tileManagers[b];
            if (t !== void 0) return t.loaded();
            this.fire(new u.k(new Error(`There is no tile manager with ID '${b}'`)));
          }
          setTerrain(b) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), b) {
              const t = this.style.tileManagers[b.source];
              if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${b.source}`);
              this.terrain === null && t.reload();
              for (const s in this.style._layers) {
                const d = this.style._layers[s];
                d.type === "hillshade" && d.source === b.source && u.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), d.type === "color-relief" && d.source === b.source && u.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new yn(this.painter, t, b), this.painter.renderToTexture = new Uu(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (s) => {
                var d;
                s.dataType === "style" ? this.terrain.tileManager.freeRtt() : s.dataType === "source" && s.tile && (s.sourceId !== b.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((d = s.source) === null || d === void 0 ? void 0 : d.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(s.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new u.l("terrain", { terrain: b })), this;
          }
          getTerrain() {
            var b, t;
            return (t = (b = this.terrain) === null || b === void 0 ? void 0 : b.options) !== null && t !== void 0 ? t : null;
          }
          areTilesLoaded() {
            const b = this.style && this.style.tileManagers;
            for (const t of Object.values(b)) if (!t.areTilesLoaded()) return !1;
            return !0;
          }
          removeSource(b) {
            return this.style.removeSource(b), this._update(!0);
          }
          getSource(b) {
            return this.style.getSource(b);
          }
          setSourceTileLodParams(b, t, s) {
            if (s) {
              const d = this.getSource(s);
              if (!d) throw new Error(`There is no source with ID "${s}", cannot set LOD parameters`);
              d.calculateTileZoom = lt(Math.max(1, b), Math.max(1, t));
            } else for (const d in this.style.tileManagers) this.style.tileManagers[d].getSource().calculateTileZoom = lt(Math.max(1, b), Math.max(1, t));
            return this._update(!0), this;
          }
          refreshTiles(b, t) {
            const s = this.style.tileManagers[b];
            if (!s) throw new Error(`There is no tile manager with ID "${b}", cannot refresh tile`);
            t === void 0 ? s.reload(!0) : s.refreshTiles(t.map(((d) => new u.ac(d.z, d.x, d.y))));
          }
          addImage(b, t, s = {}) {
            const { pixelRatio: d = 1, sdf: g = !1, stretchX: w, stretchY: T, content: C, textFitWidth: A, textFitHeight: F } = s;
            if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || u.b(t))) {
              if (t.width === void 0 || t.height === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: O, height: q, data: V } = t, X = t;
                return this.style.addImage(b, { data: new u.R({ width: O, height: q }, new Uint8Array(V)), pixelRatio: d, stretchX: w, stretchY: T, content: C, textFitWidth: A, textFitHeight: F, sdf: g, version: 0, userImage: X }), X.onAdd && X.onAdd(this, b), this;
              }
            }
            {
              const { width: O, height: q, data: V } = le.getImageData(t);
              this.style.addImage(b, { data: new u.R({ width: O, height: q }, V), pixelRatio: d, stretchX: w, stretchY: T, content: C, textFitWidth: A, textFitHeight: F, sdf: g, version: 0 });
            }
          }
          updateImage(b, t) {
            const s = this.style.getImage(b);
            if (!s) return this.fire(new u.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const d = t instanceof HTMLImageElement || u.b(t) ? le.getImageData(t) : t, { width: g, height: w, data: T } = d;
            if (g === void 0 || w === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (g !== s.data.width || w !== s.data.height) return this.fire(new u.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const C = !(t instanceof HTMLImageElement || u.b(t));
            return s.data.replace(T, C), this.style.updateImage(b, s), this;
          }
          getImage(b) {
            return this.style.getImage(b);
          }
          hasImage(b) {
            return b ? !!this.style.getImage(b) : (this.fire(new u.k(new Error("Missing required image id"))), !1);
          }
          removeImage(b) {
            this.style.removeImage(b);
          }
          loadImage(b) {
            return ut.getImage(this._requestManager.transformRequest(b, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(b, t) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(b, t), this._update(!0);
          }
          moveLayer(b, t) {
            return this.style.moveLayer(b, t), this._update(!0);
          }
          removeLayer(b) {
            return this.style.removeLayer(b), this._update(!0);
          }
          getLayer(b) {
            return this.style.getLayer(b);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(b, t, s) {
            return this.style.setLayerZoomRange(b, t, s), this._update(!0);
          }
          setFilter(b, t, s = {}) {
            return this.style.setFilter(b, t, s), this._update(!0);
          }
          getFilter(b) {
            return this.style.getFilter(b);
          }
          setPaintProperty(b, t, s, d = {}) {
            return this.style.setPaintProperty(b, t, s, d), this._update(!0);
          }
          getPaintProperty(b, t) {
            return this.style.getPaintProperty(b, t);
          }
          setLayoutProperty(b, t, s, d = {}) {
            return this.style.setLayoutProperty(b, t, s, d), this._update(!0);
          }
          getLayoutProperty(b, t) {
            return this.style.getLayoutProperty(b, t);
          }
          setGlyphs(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(b, t), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(b, t, s = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(b, t, s, ((d) => {
              d || this._update(!0);
            })), this;
          }
          removeSprite(b) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(b), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(b, t, ((s) => {
              s || this._update(!0);
            })), this;
          }
          setLight(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(b, t), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(b, t), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(b, t) {
            return this.style.setFeatureState(b, t), this._update();
          }
          removeFeatureState(b, t) {
            return this.style.removeFeatureState(b, t), this._update();
          }
          getFeatureState(b) {
            return this.style.getFeatureState(b);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let b = 0, t = 0;
            return this._container && (b = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [b, t];
          }
          _setupResizeObserver() {
            var b;
            let t = !1;
            const s = cd(((g) => {
              this._trackResize && !this._removed && (this.resize(g), this.redraw());
            }), 50), d = (b = this._ownerWindow.ResizeObserver) !== null && b !== void 0 ? b : ResizeObserver;
            this._resizeObserver = new d(((g) => {
              t ? s(g) : t = !0;
            })), this._resizeObserver.observe(this._container);
          }
          _resolveContainer(b) {
            if (typeof b == "string") {
              const t = document.getElementById(b);
              if (!t) throw new Error(`Container '${b}' not found.`);
              return t;
            }
            if (b instanceof HTMLElement || b && typeof b == "object" && b.nodeType === 1) return b;
            throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
          }
          _setupContainer() {
            const b = this._container;
            b.classList.add("maplibregl-map");
            const t = this._canvasContainer = ne.create("div", "maplibregl-canvas-container", b);
            this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = ne.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const s = this._containerDimensions(), d = this._getClampedPixelRatio(s[0], s[1]);
            this._resizeCanvas(s[0], s[1], d);
            const g = this._controlContainer = ne.create("div", "maplibregl-control-container", b), w = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((T) => {
              w[T] = ne.create("div", `maplibregl-ctrl-${T} `, g);
            })), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(b, t, s) {
            this._canvas.width = Math.floor(s * b), this._canvas.height = Math.floor(s * t), this._canvas.style.width = `${b}px`, this._canvas.style.height = `${t}px`;
          }
          _setupPainter() {
            const b = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let t = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((d) => {
              t = { requestedAttributes: b }, d && (t.statusMessage = d.statusMessage, t.type = d.type);
            }), { once: !0 });
            let s = null;
            if (s = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, b) : this._canvas.getContext("webgl2", b) || this._canvas.getContext("webgl", b), !s) {
              const d = "Failed to initialize WebGL";
              throw t ? (t.message = d, new Error(JSON.stringify(t))) : new Error(d);
            }
            this.painter = new sp(s, this.transform), Pe.testSupport(s);
          }
          migrateProjection(b, t) {
            super.migrateProjection(b, t), this.painter.transform = b, this.fire(new u.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(b) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || b, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(b) {
            return this._update(), this._renderTaskQueue.add(b);
          }
          _cancelRenderFrame(b) {
            this._renderTaskQueue.remove(b);
          }
          _render(b) {
            var t, s, d, g, w;
            const T = this._idleTriggered ? this._fadeDuration : 0, C = ((t = this.style.projection) === null || t === void 0 ? void 0 : t.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(b), this._removed) return;
            let A = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const q = this.transform.zoom, V = _e();
              this.style.zoomHistory.update(q, V);
              const X = new u.H(q, { now: V, fadeDuration: T, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), te = X.crossFadingFactor();
              te === 1 && te === this._crossFadingFactor || (A = !0, this._crossFadingFactor = te), this.style.update(X);
            }
            const F = ((s = this.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0 !== C;
            (d = this.style.projection) === null || d === void 0 || d.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((g = this.style.projection) === null || g === void 0 ? void 0 : g.transitionState, (w = this.style.projection) === null || w === void 0 ? void 0 : w.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || F) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, T, this._crossSourceCollisions, F), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: T, showPadding: this.showPadding }), this.fire(new u.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, u.cH.mark(u.cI.load), this.fire(new u.l("load"))), this.style && (this.style.hasTransitions() || A) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const O = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return O || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new u.l("idle")), !this._loaded || this._fullyLoaded || O || (this._fullyLoaded = !0, u.cH.mark(u.cI.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var b;
            this._hash && this._hash.remove();
            for (const s of this._controls) s.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && this._ownerWindow.removeEventListener("online", this._onWindowOnline, !1), ut.removeThrottleControl(this._imageQueueHandle), (b = this._resizeObserver) === null || b === void 0 || b.disconnect();
            const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t?.loseContext && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), ne.remove(this._canvasContainer), ne.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), u.cH.clearMetrics(), this._removed = !0, this.fire(new u.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), le.frame(this._frameRequest, ((b) => {
              u.cH.frame(b), this._frameRequest = null;
              try {
                this._render(b);
              } catch (t) {
                if (!u.Z(t) && !(function(s) {
                  return s.message === id;
                })(t)) throw t;
              }
            }), (() => {
            }), this._ownerWindow));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(b) {
            this._showTileBoundaries !== b && (this._showTileBoundaries = b, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(b) {
            this._showPadding !== b && (this._showPadding = b, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(b) {
            this._showCollisionBoxes !== b && (this._showCollisionBoxes = b, b ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(b) {
            this._showOverdrawInspector !== b && (this._showOverdrawInspector = b, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(b) {
            this._repaint !== b && (this._repaint = b, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(b) {
            this._vertices = b, this._update();
          }
          get version() {
            return xd;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(b) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(b), this._update(!0);
          }
        }, S.MapMouseEvent = ci, S.MapTouchEvent = Fu, S.MapWheelEvent = lp, S.Marker = Zu, S.NavigationControl = class {
          constructor(b) {
            this._updateZoomButtons = () => {
              const t = this._map.getZoom(), s = t === this._map.getMaxZoom(), d = t === this._map.getMinZoom();
              this._zoomInButton.disabled = s, this._zoomOutButton.disabled = d, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", d.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (t, s) => {
              const d = this._map._getUIString(`NavigationControl.${s}`);
              t.title = d, t.setAttribute("aria-label", d);
            }, this.options = u.e({}, bd, b), this._container = ne.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((t) => t.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((t) => this._map.zoomIn({}, { originalEvent: t }))), ne.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((t) => this._map.zoomOut({}, { originalEvent: t }))), ne.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((t) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
            })), this._compassIcon = ne.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(b) {
            return this._map = b, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new qu(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            ne.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(b, t) {
            const s = ne.create("button", b, this._container);
            return s.type = "button", s.addEventListener("click", t), s;
          }
        }, S.Popup = class extends u.E {
          constructor(b) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && ne.remove(this._content), this._container && (ne.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new u.l("close"))), this), this._onMouseUp = (t) => {
              this._update(t.point);
            }, this._onMouseMove = (t) => {
              this._update(t.point);
            }, this._onDrag = (t) => {
              this._update(t.point);
            }, this._update = (t) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = ne.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = ne.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const T of this.options.className.split(" ")) this._container.classList.add(T);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Jc(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !t) return;
              const s = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationToScreenPoint(this._lngLat));
              let d = this.options.anchor;
              const g = eh(this.options.offset);
              if (!d) {
                const T = this._container.offsetWidth, C = this._container.offsetHeight, A = (function(O) {
                  var q, V, X, te;
                  return O ? { top: (q = O.top) !== null && q !== void 0 ? q : 0, right: (V = O.right) !== null && V !== void 0 ? V : 0, bottom: (X = O.bottom) !== null && X !== void 0 ? X : 0, left: (te = O.left) !== null && te !== void 0 ? te : 0 } : { top: 0, right: 0, bottom: 0, left: 0 };
                })(this.options.padding);
                let F;
                F = s.y + g.bottom.y < C + A.top ? ["top"] : s.y > this._map.transform.height - C - A.bottom ? ["bottom"] : [], s.x < T / 2 + A.left ? F.push("left") : s.x > this._map.transform.width - T / 2 - A.right && F.push("right"), d = F.length === 0 ? "bottom" : F.join("-");
              }
              let w = s.add(g[d]);
              this.options.subpixelPositioning || (w = w.round()), ne.setTransform(this._container, `${$u[d]} translate(${w.x}px,${w.y}px)`), Kc(this._container, d, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = u.e(Object.create(Sd), b);
          }
          addTo(b) {
            return this._map && this.remove(), this._map = b, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new u.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(b) {
            return this._lngLat = u.V.convert(b), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(b) {
            return this.setDOMContent(document.createTextNode(b));
          }
          setHTML(b) {
            const t = document.createDocumentFragment(), s = document.createElement("body");
            let d;
            for (s.innerHTML = b; d = s.firstChild, d; ) t.appendChild(d);
            return this.setDOMContent(t);
          }
          getMaxWidth() {
            var b;
            return (b = this._container) === null || b === void 0 ? void 0 : b.style.maxWidth;
          }
          setMaxWidth(b) {
            return this.options.maxWidth = b, this._update(), this;
          }
          setDOMContent(b) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = ne.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(b), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(b) {
            return this._container && this._container.classList.add(b), this;
          }
          removeClassName(b) {
            return this._container && this._container.classList.remove(b), this;
          }
          setOffset(b) {
            return this.options.offset = b, this._update(), this;
          }
          toggleClassName(b) {
            if (this._container) return this._container.classList.toggle(b);
          }
          setSubpixelPositioning(b) {
            this.options.subpixelPositioning = b;
          }
          setPadding(b) {
            this.options.padding = b, this._update();
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = ne.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const b = this._container.querySelector(Qc);
            b && b.focus();
          }
        }, S.RasterDEMTileSource = Ti, S.RasterTileSource = Zi, S.ScaleControl = class {
          constructor(b) {
            this._onMove = () => {
              Hu(this._map, this._container, this.options);
            }, this.setUnit = (t) => {
              this.options.unit = t, Hu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, Ed), b);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(b) {
            return this._map = b, this._container = ne.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", b.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            ne.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, S.ScrollZoomHandler = Zc, S.Style = Ia, S.TerrainControl = class {
          constructor(b) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = b;
          }
          onAdd(b) {
            return this._map = b, this._container = ne.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = ne.create("button", "maplibregl-ctrl-terrain", this._container), ne.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            ne.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, S.TwoFingersTouchPitchHandler = dp, S.TwoFingersTouchRotateHandler = md, S.TwoFingersTouchZoomHandler = gd, S.TwoFingersTouchZoomRotateHandler = Gu, S.VectorTileSource = Mt, S.VideoSource = Vn, S.addSourceType = (b, t) => u._(void 0, void 0, void 0, (function* () {
          if (os(b)) throw new Error(`A source type called "${b}" already exists.`);
          ((s, d) => {
            Jt[s] = d;
          })(b, t);
        })), S.clearPrewarmedResources = function() {
          const b = mr;
          b && (b.isPreloaded() && b.numActive() === 1 ? (b.release(At), mr = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, S.createTileMesh = fu, S.getMaxParallelImageRequests = function() {
          return u.c.MAX_PARALLEL_IMAGE_REQUESTS;
        }, S.getRTLTextPluginStatus = function() {
          return re().getRTLTextPluginStatus();
        }, S.getVersion = function() {
          return Td;
        }, S.getWorkerCount = function() {
          return Dt.workerCount;
        }, S.getWorkerUrl = function() {
          return u.c.WORKER_URL;
        }, S.importScriptInWorkers = function(b) {
          return Bt().broadcast("IS", b);
        }, S.isTimeFrozen = function() {
          return ce.isFrozen();
        }, S.now = _e, S.prewarm = function() {
          yi().acquire(At);
        }, S.restoreNow = function() {
          ce.restoreNow();
        }, S.setMaxParallelImageRequests = function(b) {
          u.c.MAX_PARALLEL_IMAGE_REQUESTS = b;
        }, S.setNow = function(b) {
          ce.setNow(b);
        }, S.setRTLTextPlugin = function(b, t) {
          return re().setRTLTextPlugin(b, t);
        }, S.setWorkerCount = function(b) {
          Dt.workerCount = b;
        }, S.setWorkerUrl = function(b) {
          u.c.WORKER_URL = b;
        };
      }));
      var M = l;
      return M;
    }));
  })(hg)), hg.exports;
}
var XT = WT();
const Gg = /* @__PURE__ */ HT(XT), JT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mLYpUHOwgopChOtlFRRxrFYpQIdQKrTqYXPoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJESv0sKLWK847iH97735e47QGhWmWaFEoCm22YmlRRz+VWx5xUhmmGMIi4zy5iTpDR8x9c9Any/i/Ms/7o/R79asBgQEIkTzDBt4g3imU3b4LxPHGVlWSU+J54w6YLEj1xXPH7jXHJZ4JlRM5uZJ44Si6UuVrqYlU2NeJo4pmo65Qs5j1XOW5y1ap2178lfGCnoK8tcpzWCFBaxBAkiFNRRQRU24rTrpFjI0HnSxz/s+iVyKeSqgJFjATVokF0/+B/87q1VnJr0kiJJIPziOB9jQM8u0Go4zvex47ROgOAzcKV3/LUmMPtJeqOjxY6AgW3g4rqjKXvA5Q4w9GTIpuxKQVpCsQi8n9E35YHBW6Bvzetb+xynD0CWepW+AQ4OgfESZa/7vLu3u2//1rT79wN2rHKoBaSKHQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+gEBAUlKJesuC4AABWbSURBVHja7Z3fcxTHEce/t1ohYekA2QaBDBgocGLHNmW7Kg4pV9l5SeUleci/4b9H/0aeU3mJXXEF5yEmEOw4hgKFH7JBtpEQwhLS3eVhunV9w+7tHWh3e2Z7q64OyZJ18+Mz3+7pme4W7Bn6tBdXWwD4lYj3FMA0gCkAswCOAJihrw8AOAfgdwDOAmgDmKDf3YunB6ADYB3AdQB/BnANwEMAWwA2ANwH8Ii+3gSwA6BLv8vvvfWPD/VslPOflnVBLhQQYKQCiEl6zQCYB/AigGMA3gBwGMB+guQQgFfpfZKg2sunC2AbwCqA/9H7FoCfAKwA+ArAtwB+BHCPoNmmFwOzw6AAgMFigIyrFhMChgMERJu+PkJQHCNI5un7qfi9F+i9VUJf88TeBvCY3js06TcIih8Jkq9IUTZIde6R2myI3zNVMUBGAiOlST1NrwMAjgM4BeAtAUKbIJklxZim35WAJSXB4UPSlROcINkkRXlEcKwLcP4NYAnAHQJlk17bUlUMlIYDkgHGPpr8BwEcJWVYAPA2AXKcwGAza0ooRiL6s1Vx//Yy3rtCUbaEebVOYCwBuAJgmZTmOwBrBNETA6XBgAwBYw7ACYLhbYLjRYLlIP3MpOest2oAYhxgep5zvk0QrBEUPxIkVwia2wAeGCgNBGQEME4DeIcAOUHm1bRwztMaVWIv1WVHOOubZGbdJkAuAbhpoDQIELErlRSAcZq+nhNqMeEpReh91vOUpSNU5QGBcbMAlG5Tdr1aDYGjRROdYxZFYOzzHO4Y+8o3w3YIgCJQOLbSaYKatBoAR0JKsB/Ay2Q+nRkRjKaYoL0RQblBZtj3cPGWbQDdmCFpRQyGVI0DcFuybwL4FVx0+6SBMRYot+Ci9p8DuAq3dfwwdjVpRQxHCheoO0xKcY7geJNgaRsYY4GyTlBcJUiukbKswAUqd2KEpBUhHBM06WfgotznAVwgQE6TmbWffiYxMEYCpUsA/ETm1U0C5CKAy3DR+g36mU5MkLQiAsM3qeYJjg/pfZ6+P4X+wUEDYzxQOmRSPYSLyF8G8Cm934vR5GpFBEeWSXWB4DiGwXNSMDieCRJg8LzXtwTHxVhNrlZEcMzCRb59k+owgZOaauypmuwQCCsZJtcy3HZw8JCkEcHxCoB3AXxkJlUli2oqVHmGFqIZsRDdZUjai6vBBhXTwOHgo+gMx2/ofcEzqQyMvYfEP7YzhcGjOCBINgBshwpJGigciYBjwYPjFQFHYnCUDgovQKzi/rMsIAkuqJgGCscU+kfSz5NZxXDMmr9ROSS8YPmQsLrwUfqt0CBpBQrHS+SE/xzArwmSBYNDjfP+iJTjMoC/A/ianPgf4LaBg4GkFRAcLbjI9xyA1wH8Fu6G31m4yLjtVOmC5DFc5P063A3GvwD4D9yxlScIZHcrCQgO9jmOknK8Re9Hvd0Tg6N+5z0tGKtJAC1xDcEAeU44UuGQnyez6iz6x0ZsG1cfJBPon6A+65nCuwuadkiSQODIinMcMTiCgeTIsM0UzZCkyjvZh0PGOV4wOILwbydorBbQP67Cz24wMeO/GSAF6iE71o9z2G5VWJDIhc536u8A2Ggvrqp02lPFcEzBHV+wOEeckPBu1xYrSHtxVd1R+UQhHGxaHYA7bHghy7kzOIL0SfzNlgs0xge0+iOpwo7kTpyHCwaew2BaT4MjfCXxx3eFlKSrzR9RoyCe33EsZ4Wxs1XhQ5LkWAjHeONFk4okiuBIPL+DbwIexuCRdXvCh2SiYKwTLZAkSuDgSHnuqmJwRAlJnrWgJtKuxcSSAaU8v8Oe+CDJ8kdkALjZCuKZVi+jn7dqYGcDcWY19EsX5L3kz8YGiL9jyWmZXtZiaqVKVpFZuIyHfgfFYlrllSfojdFPdZZXqMIf4QVyDS5Dyjr6JRt6jQMk4wj7GfSPrquR2D2Cwi9BwAEyruxUpPI8ieROntbSC89rYp+luXAHlGurvbjaqiuAmNa8erANegIuV+5JuIyHIZtWWdnT/SI2G/DS4xT0Eacz4qPiecV7QuwzGR9p0xx4By5TCt8dqU1FagEkQz1O02uOvhdivMNP18n1N7LKoN2HuzwkA2S9HLOKt0NfR7+Sblb5t0mEm0aV2+rPh9t1q0haY4f46nEi0F2rvITPsoJTViHNFfTTdfZG6KcryC8gKitghZpvOGtO1K4ilQMygnqEMqhFJQOWMFgD0C/FvAWvDPOQnZ4HBJQsQX0VT9dQDLmUQ968qFVFUiUrRWjqIZ3tvFoaS/S1rCK74znrow42A8WmyAO4JNJchfc6ATKs5kkSCCSqVKRSQCJQDz+J8yMUly3z65Dv7nCNuhpSv3VF32yLv79GCnWL/nZW1Sz2VbRfMFOnIqmCFSIU9cjKSbsEV3WpsPDlOED4j/i9ngcM1xfMUjEG5Qypi8xRDOWQqFGRyjpJRM33w12a+RDAH+HO4cyhX15Zs0nVwWDOp4tk3txCTRVhCyr3noSLK8g7NbN4uq67tofLVT+gfv4TXJmFu3A1SirLq1W1giRkNx8lxzIE9fDriy8D+ALAJzR4XIqsllLJ9Hd6BMq25xc9FDtn/Nn44tmkYkh8FXkbwH8hEs/FaGLxsYJpsfuye3JT6UCxv8G1xLlozCcEyTKZW9vsY9QV8c0AhQOUm56pt4N+5vtp6DzO45/wXqA5M00K3qnKzKoEkIwj7bLBE8rh4AyBN5BdA6MDRak0BShyQ+GugGMD7tTsGfQzUmqFJGtBXYNLhF2Js55W2FiWzOMkmUep8YlSOLq0+t4H8E8AnwH4BoFUUVr/+FCvvbjKO2eP4M42bdFnfw3ABwDeo3HYr9Tc8k3ya7RjV5mzXvrkzEjEcIpeB5WaV9LneEjK8RmAfwD4EoMFK1Xnl2U1wWDJtC+pLZ9R2x5KE1GpmXVQzJtKEzykFa8E83B5Wo8rdc6lWbJBPsc1Uo5lAKu0CgdTyTXD5OLP/Q21ja+5tqHvZLBvebwFd4btB1KRbhUTt8qVoE2QtBWrh5++/yKZVWuhwZEBCgc416hNmTUFlapILXOnKvtfVoSSW4xanXJ/K3clZDhyIFlB9o5cB/puL9Y2f0r9IxnZ2Y8oVQ/2O4ZOnBjqfgtIhi0EmvwRX0WOoMLs8GlFELL/8QY1cEqZgkjTaikA02OvTcmsBWxS0QLG92L4mP9VuMOapQcNkwro5+uiL8LdX9CWW5cd1ydwRxtuwB0fuS9NjhjUI2N3S8Z5rlPbdytAKVkU/DIYfAemkpwFpQGSUd+j0oY9w2q6AXfQ7xLc2ard7c+Y4PAgkdvZt6jtuydnlZlZuQttmWZW2QriS+M8dAUHffW4icGTo1HCkQFJXvs1pRuqxVSvwsRi+/Yw9CWgzlIPjSto0/ugVTCXggSEG8WX8aehKzBYpB69mNUjwx8JQUUYkmkMJvcI1sSqvEGmHtGrSKULbimAZMQ/KpPEMdVjGy6qvESvRqnHEBXh/lhD/1CgFkgy51RZjnpSMnwyp9Nh6Ip/8Gnd7+CyjzRVPfJU5Ar1zSYqvKCkbU6V7YNwinttDro8cvEjXLCMt3UbpR4ZKsLbvpyuiFOk1t0nWVZJ6XdZkhIbw///FP00mZrMK44kf0sTYRM6zyHVsXBsop/wTp4k0GRmyVzFKGtuVXWaV5NzzubVFlwE+Su4Y+2aTAkNpuc99LNBbinqmxaeznYflpM+RFG0rJJsSqzDS2rQRPMqw8xiX4TzCWty1CudU0lD54LMUsLJ3Uw9rH8aD0hIK6RKhW1aHzVRQeS9D78EgT3WR40HRB7zXjH/o9AP4Qwujdzha6KJxSskV31qamBwlL6SfdT1+tAAacAE6JrvUeiLdJvcP4lNAnusjwwQe+wxQOyxxwCxp+qnZYDY4NuT3TeVnXkyQHROAG2HKLX1T2WnZg0QXYqh8Ri+iifnNqjWGiIGSEmQZF7kqiKdfkDzQvNtUAPEBl+FeaU1XVN0gGhLhKw9mbYW51xjuqZK51RSUUO0HekIoRyDBgXRmq6psiMwScl0azwUWGs6/QAddG2VwCo9RJmU3JDMY+UKQNGeM7juvtFYrqKWY/hlNlrrpZu8rPOaS1JX2Tey9LK2chWVz6lSAMm5dKMtjaVMp881uCebamYNqWWvqVxF7pwq67JbUlGDNtGvSqrFWfdrcJ+Azsq7VTvmM9QX2mrZS+f8Cc2p0hfcJLYGPYOjLmtwz9GuTaNURKjHPuoD7g9ttewrX3CrUpANhY66v2K+02AV0d4XtZnsZQOiOTuGv2qeplejVCRDPZ7qByWLRS1zqTRAAsnSZyoSRh/Ulg0zqYh8rVn6ilbPJGYVobYlAahHbfMoqZN8xSpyEv1t3yghEXDwtu5J5epRiyVSlYJoztLnq8gZAGfhIsi79yBigkT4HXzs/wi1+Yxi9ahlDpUKSEDZwmVk/RSACwDOwwXLZiP0R2R7F6itF6jt2tpbazb+pMIVQHO2cDY3+J7IeQAfAXiXJtALACZiUBFqAyvHArXxI2qzvBujqa21zZ+0xhVgjuzfnpLB8CeOVL/d08jtxdVOqDl8BRxDFwKF6lGbBVKlgoRQ0SnP9DgNF1WeClVJPDgOUptCMCVrrXhVuoKsf3yo115czasJOKtsxeLPMUE7OfMAzgF4Da48MuBKI2+1F1c7CCAjvOeQMxwL1KZz1MYZMQ7aqoHl1kysou+TihuaWVUW+kp7ye3PMwA+APA+gF/AHQEP4oJVxgWoY9SG96lNZyC2s6G3VF5tVXerPKXp1yW/A711yRmSabgt0PcA/B7AHwD8EsBxYZKojJOIOAebjMfps/+B2vIetW0aOpPDSd/jDmqq216Fky7NrG0yUZbo9aqYaD1lgySd9qPIrve+DHerbbu9uNrVYHIJ1WAVzNqtmifl0HpJTKqHnC9rqLiWfVrzivAzAC9Bb9odhmQ/nk40x6bLfTIBngDYoYWgclAEGPy59hEERzJ2q2aUmlXqLI7KAPFURNqUGp31PJ+kDeAVz66/DuAWOfEbVYOSA8YM3Db6SbgIub9bNaEcDt85H/BZq1x80pobzrsSh6ArJpIHSUvY85z04QaASwBuAridBwovEnsIBYaAcQJuG/cdcsRPoZ9CVHsCuDznfBM11ElMa+gAua/9Je2qvAz92Q1bos/YD2kTLKcJkCxQtmlguwQLxgXGA0ICO4F+fi8fjNP09RxBLe+Wa47jqHDOawEksJhIHiS+E+xPTgZliUB5SO3jK8d8TVQCM46C8c7UNL0O0N8+lQHGDClLijDKGKhxzutUkDz78qByMyvPL8kzb5Zo9WMT4Z5QlG0MJtPrFQDJGwSTAsp59DOyvE2AZIHRQlhpVVWFA1IlnXCWBnsf+kkCEAAkLRq0LFBepV069rX4mMQG3HmiUe5V+1kO2+jnFH4D/ZxeR2mBCRkMVc55bYAMiYmcFLZ9L6CBzQNlFm4Le4vMybcIDD50599r6OWolMxEz2lSOWUq+xbT4m+HCIY657xuBZGO2G2y2eVVz8kABzgLlCka3IO0EcHm1QaZRY9HVBAZpGQzi2Mycss25Az1/pyo1TmvFRChIk9ot+cmvU4EqiJ5oMidpin084TN0YTvjDD4/P+Y8pxtP+N6yHdVWD14PtTunNetILGqiA8KPFh4kCUw4+5iIRIoiubCbSg4q1db3EFcx/VV5AF9T9sp371QlUS8UmGKDXtNCuVIEF/h0cJ5UOf5tlThyhGTihSpC2BVrdSqR60K0kAVsScw9agdkBBWEHuaPfa1A2IqYuqhVT20KIipiKmH2jFXAYipiKmHRvXQpCCmIqYeKsdaDSCmIqYe2tRDm4KYiph6qBtjVYCMoCJdgyR4OLqhqIdGBclbYW7BHRXXVFfEnmczrXZoLG+FYCGoAyRDRW7AZQ65D+AnuBOw9oT5dGgM79OY3tCsHkD9Z7GKVOQR3LHnz9G/Mcf5nEK4Y23PoGm1BeB7AFdpTJcgcu1q/OAqs4jQShJkh9oz8oJ3lcZ2C0BXaxLwRHnHDpNkc9jDdMyDMpnVAuKVb5NOnTns4TvmA2OouYSEagURppY57HE65l3t9VXSADrYHHZzzE1BnsFhvwm9RXjsCdgxDwqQHKm+Ri8ztcwxN0CEw85JxW5mrUimIuaYN1ZBLDZijrkBsgedb5DUrh6dmBaxoAApiI2Yw67HtMo1g0NSjyAVpCA2UpTr1p5yAeFT2Pdi2UhJAx8M3kK8iH5cZIL+HVP2wVBMq8dwpR4u05gMbMWHph6h+iC+w75CA/IpvQ8rKWBPOXAUjkWIcAQLiICkcNUySCrxO+T2+0Uai29pbDqhwhE0IDHbvYE9WQFcLjcXvD8YNCDerpYFEOszrbKOAAUVEIxVQaSpZWe16jWt/IWpEzocUQBSIPVmall/GyAjntWqrRBkhOpRqNgxqEdUCjLCsXi7gbh3plVU0fJhTxrhIGZJ/2G4moBc+swCiM8OSKN2DWPyQfJMraf25U1Fnsu0ii5a3hhAMkytvMiuQfLsfkd00fJGASIgGbbamT/yfH5HVNHypvkgRfay+SN704/RRMsbpyCeP7Jj/khpfkcU0fJGAuKZWuaPlON3dGKGI3pAzB8xv8N8EPNHzO8wBTF/xPwOA8T8EfM7DJAA/JGm3h/hAGvj/Y7GAjKifd1poNPeE+rReL+j0YAU+CPLaGaWRpklZrnpfkfTFSTPH/kEwBc0QZrktEuzc5n64JMm+x3ySdHQZ/3jQ7324qqcGJxHK4Xb+uVt3wnEu/070kLRVDgaDUiOaZHCJZ07TO8MSYwFeoY55U01Nc3EyvFHRnFOe5HBMdJmRZPVo/GACEiGraSxQeLDkeeUd5sOhwEymtN+NzJzQ5qVd80pNx/keZx2floAjiP8pNhZO1Z/NafcAHnW1ZXhiGFnq0kqaSZWyU57oX0e2EQa2c8y9TBAxoUk9J2tkdtjcBgg40ASw86W7VgZIKVCMqrN3lMOh+1YmZNeDiRDdrYA4BUAs6IfW8rhsB0rA6SUyebvbOVB0lL6mSUctmNlgOy5imAIJNpiJMNiHQNwmHoYIGVDoi1GMrLfZHCYk16G0645RmKxDgNEHSRaYiQW6zBAVEGiKUZisQ4DRCUkGmIkFuswJ121415njMRiHQaI+mecGMleQlIEh8U6DBA1KoKKIRkLDlMPA6RJkBgcBohBYnAYIAbJeJAYHAaIQWJwGCAGyXiQGBwGiEGSA4nBYYAYJDmQGBwGiEGSAwkMDgPEIBkOicFhgBgkGZDM0L83DA4DxCDpP1xi4Sh9/R2ASwaHAdJkSPjuRgJgEv167QBwFcDfAPwLdhuw1sfug9QAiXDCH8Pd+Psa7v7GHXpdpu/do58xOGp6/g9eQPkxBqxc0wAAAABJRU5ErkJggg==";
let H_;
try {
  H_ = "free";
} catch {
  H_ = process.env.VITE_GEOMAN_VERSION || null;
}
const Ni = "gm", Ot = `_${Ni}`, Ri = H_ === "pro", j1 = {
  draw: {
    marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "marker",
      settings: {
        exclusive: !0
      }
    },
    circle_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle_marker",
      settings: {
        exclusive: !0
      }
    },
    text_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "text_marker",
      settings: {
        exclusive: !0
      }
    },
    circle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle",
      settings: {
        exclusive: !0
      }
    },
    ellipse: {
      type: "draw",
      eventType: "toggle",
      targetMode: "ellipse",
      settings: {
        exclusive: !0
      }
    },
    line: {
      type: "draw",
      eventType: "toggle",
      targetMode: "line",
      settings: {
        exclusive: !0
      }
    },
    rectangle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "rectangle",
      settings: {
        exclusive: !0
      }
    },
    polygon: {
      type: "draw",
      eventType: "toggle",
      targetMode: "polygon",
      settings: {
        exclusive: !0
      }
    },
    freehand: {
      type: "draw",
      eventType: "toggle",
      targetMode: "freehand",
      settings: {
        exclusive: !0
      }
    },
    custom_shape: {
      type: "draw",
      eventType: "toggle",
      targetMode: "custom_shape",
      settings: {
        exclusive: !0
      }
    }
  },
  edit: {
    drag: {
      type: "edit",
      eventType: "toggle",
      targetMode: "drag",
      settings: {
        exclusive: !0
      }
    },
    change: {
      type: "edit",
      eventType: "toggle",
      targetMode: "change",
      settings: {
        exclusive: !0
      }
    },
    rotate: {
      type: "edit",
      eventType: "toggle",
      targetMode: "rotate",
      settings: {
        exclusive: !0
      }
    },
    scale: {
      type: "edit",
      eventType: "toggle",
      targetMode: "scale",
      settings: {
        exclusive: !0
      }
    },
    copy: {
      type: "edit",
      eventType: "toggle",
      targetMode: "copy",
      settings: {
        exclusive: !0
      }
    },
    cut: {
      type: "edit",
      eventType: "toggle",
      targetMode: "cut",
      settings: {
        exclusive: !0
      }
    },
    split: {
      type: "edit",
      eventType: "toggle",
      targetMode: "split",
      settings: {
        exclusive: !0
      }
    },
    union: {
      type: "edit",
      eventType: "toggle",
      targetMode: "union",
      settings: {
        exclusive: !0
      }
    },
    difference: {
      type: "edit",
      eventType: "toggle",
      targetMode: "difference",
      settings: {
        exclusive: !0
      }
    },
    line_simplification: {
      type: "edit",
      eventType: "toggle",
      targetMode: "line_simplification",
      settings: {
        exclusive: !0
      }
    },
    lasso: {
      type: "edit",
      eventType: "toggle",
      targetMode: "lasso",
      settings: {
        exclusive: !0
      }
    },
    delete: {
      type: "edit",
      eventType: "toggle",
      targetMode: "delete",
      settings: {
        exclusive: !0
      }
    }
  },
  helper: {
    shape_markers: {
      type: "helper",
      eventType: "toggle",
      targetMode: "shape_markers",
      settings: {
        exclusive: !1,
        enabledBy: ["drag", "change", "rotate", "scale", "line_simplification"]
      }
    },
    snapping: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snapping",
      settings: {
        exclusive: !1
      }
    },
    pin: {
      type: "helper",
      eventType: "toggle",
      targetMode: "pin",
      settings: {
        exclusive: !1
      }
    },
    snap_guides: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snap_guides",
      settings: {
        exclusive: !1
      }
    },
    measurements: {
      type: "helper",
      eventType: "toggle",
      targetMode: "measurements",
      settings: {
        exclusive: !1
      }
    },
    auto_trace: {
      type: "helper",
      eventType: "toggle",
      targetMode: "auto_trace",
      settings: {
        exclusive: !1
      }
    },
    geofencing: {
      type: "helper",
      eventType: "toggle",
      targetMode: "geofencing",
      settings: {
        exclusive: !1
      }
    },
    zoom_to_features: {
      type: "helper",
      eventType: "click",
      targetMode: "zoom_to_features",
      settings: {
        exclusive: !1
      }
    },
    click_to_edit: {
      type: "helper",
      eventType: "toggle",
      targetMode: "click_to_edit",
      settings: {
        exclusive: !1
      }
    }
  }
}, KT = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="m22.775 29.562 6.75-6.75-5.625-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.626-5.55-6.75 6.75zm25.95 26.101 6.75-6.825-5.624-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.55-5.55-6.75 6.75zm.6-46.126 5.25 5.25ZM16.7 59.039H5v-11.7l14.55-14.551L2 15.237l13.05-13.2 17.7 17.624L46.1 6.312q.676-.676 1.5-.976.826-.3 1.65-.3.826 0 1.65.3.826.3 1.5.976l5.326 5.325q.675.675.975 1.5.3.825.3 1.65t-.3 1.65q-.3.825-.975 1.5l-13.35 13.35L62 48.913l-13.125 13.05-17.551-17.55Zm-7.2-4.5h5.25l29.476-29.552-5.25-5.25L9.5 49.288Zm32.1-32.178-2.625-2.625 5.25 5.25Z"/>
</svg>`, V1 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" stroke-width="7"/>
    <circle cx="32" cy="32" r="5" fill="currentColor"/>
</svg>`, QT = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" stroke-width="7"/>
    <path stroke="currentColor" stroke-dasharray="3" stroke-width="4" d="M6 32h52M32 6v52"/>
</svg>`, ek = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   viewBox="0 0 64 64"
   version="1.1"
   id="svg2"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs2" />
  <path
     fill="none"
     d="M 0,0 H 24 V 24 H 0 Z"
     id="path1"
     style="display:inline" />
  <ellipse
     cx="32"
     cy="32"
     fill="currentColor"
     fill-opacity="0.15"
     stroke="currentColor"
     stroke-width="7"
     id="circle1"
     rx="26.787416"
     ry="15.158148" />
  <path
     stroke="currentColor"
     stroke-dasharray="3"
     stroke-width="4"
     d="M 6.4966994,32 H 58 M 32,18.552705 v 30.15073"
     id="path2"
     style="stroke-width:3;stroke-dasharray:3;stroke-dashoffset:0" />
</svg>
`, tk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path
            fill="currentColor"
            d="M32 61.4 19.85 49.42l3.28-3.235 6.634 6.542V34.205H10.98l6.26 6.174-3.279 3.234L2.185 32l11.852-11.686 3.28 3.234-6.336 6.247h18.783V11.273l-6.261 6.174-3.28-3.234L32 2.6l11.777 11.613-3.28 3.234-6.26-6.174v18.522h18.782l-6.26-6.174 3.279-3.234L61.815 32 50.038 43.613l-3.28-3.234 6.261-6.174H34.236v18.522l6.634-6.542 3.28 3.234z"
    />
</svg>
`, rk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <line x1="8" y1="50" x2="24" y2="20" stroke="currentColor" stroke-width="8"/>
    <line x1="24" y1="20" x2="40" y2="54" stroke="currentColor" stroke-width="8"/>
    <line x1="40" y1="54" x2="54" y2="10" stroke="currentColor" stroke-width="8"/>
    <circle cx="8" cy="50" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="24" cy="20" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, nk = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M32 62.81s23.107-21.898 23.107-38.512a23.107 23.107 0 0 0-46.214 0C8.893 40.912 32 62.809 32 62.809m0-26.958a11.554 11.554 0 1 1 0-23.107 11.554 11.554 0 0 1 0 23.107"/>
</svg>
`, ik = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Polygon -->
    <polygon points="8,28 40,6 55,35 51,55 18,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="9" cy="28" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="8" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="55" cy="35" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="50" cy="55" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="18" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, sk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Rectangle -->
    <polygon points="10,10 54,10 54,54 10,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="10" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="10" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, ak = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M39.063 42.14 22.288 28.12 7.96 44.603l11.338 9.854h9.059zm-3.498 12.317h25.941v5.465h-44.25L4.377 48.726a5.465 5.465 0 0 1-.542-7.711L34.311 5.958a5.465 5.465 0 0 1 7.712-.538l16.496 14.343a5.465 5.465 0 0 1 .541 7.709z"/>
</svg>`, ok = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M58.709 17.724c-.3-.6-.601-.901-.902-1.502l-.3-.601c-.301-.601-.602-.902-.902-1.503l-.3-.601c-.301-.601-.602-.902-1.203-1.503l-.6-.901 8.414-9.317-13.825.3-13.824.301 1.502 13.524 1.503 13.524 9.617-10.819v.3l.3.602c.301.3.301.6.602.6l.3.602c0 .6 0 .901.3 1.202.903 2.104 1.804 4.208 2.105 6.311.6 4.208 0 8.716-1.804 12.623l-.6 1.202-.301.3-.902 1.503-.3.601c-.601.601-1.202 1.503-1.804 2.104-1.502 1.503-3.305 3.005-5.109 3.907-1.803 1.202-3.907 1.803-6.311 2.404-2.104.301-4.508.601-6.612.301-2.404-.3-4.508-.902-6.612-1.503-2.103-.901-3.907-2.104-5.71-3.606l-1.202-1.202-.601-.902-.601-.601c-.3-.3-.601-.601-.601-.902l-.902-1.202-.3-.3-.602-1.203c0-.3-.3-.3-.3-.6l-.902-1.503-.3-.601-.902-2.705q-.901-3.607-.901-7.213V27.04c0-.601 0-.901.3-1.202l.3-1.803.602-1.803c.901-2.405 2.103-4.509 3.606-6.612q2.254-3.156 5.41-5.41c.6-.3.901-1.202.3-1.803-.3-.3-.6-.601-.901-.601h-.601l-.3.3c-2.706 1.202-4.81 3.006-6.913 4.809-2.104 2.104-3.607 4.508-5.11 7.213-2.704 5.41-3.606 11.42-2.404 17.431.3 1.503.601 2.705.902 4.207l.902 2.405c.3.3.6.6.6 1.202l.602 1.202c0 .3.3.601.3.601l.902 1.503c.3.601.6.901.901 1.503l.301.6c.3.301.601.902.902 1.203l2.103 1.803c2.104 2.104 4.809 3.907 7.514 5.41q4.057 2.254 9.016 2.705c1.503.3 3.005.3 4.508.3 1.803 0 3.306 0 4.809-.3 3.005-.602 6.311-1.503 9.016-3.006l.6-.3c.602-.3.903-.601 1.504-.902l2.103-1.202c.601-.3.902-.601 1.203-.902l.6-.6a3.622 3.622 0 0 0 1.503-1.504l.3-.3c.902-.902 2.105-2.104 2.706-3.005l1.803-2.705 1.202-1.804c3.005-5.71 4.208-12.322 3.306-18.633-.601-3.306-1.503-6.612-3.005-9.317z"/>
</svg>
`, lk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <path fill="currentColor"
          d="M6.962 3.385h50.076a3.577 3.577 0 0 1 3.577 3.577v50.076a3.577 3.577 0 0 1-3.577 3.577H6.962a3.577 3.577 0 0 1-3.577-3.577V6.962a3.577 3.577 0 0 1 3.577-3.577Zm3.577 7.154v42.922h42.922V10.539Zm7.154 7.154h28.614v7.153H17.693Zm0 14.307h28.614v7.154H17.693Z"/>
</svg>
`, uk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path stroke="currentColor" fill="currentColor" stroke-width="2"
          d="M44.095 2.247a2.285 2.285 0 0 0-.135.04L12.025 12.762a2.285 2.285 0 0 0-1.497 1.588l-7.772 29.4a2.285 2.285 0 0 0 1.213 2.641L35.397 61.6a2.285 2.285 0 0 0 2.873-.754l22.64-32.582a2.285 2.285 0 0 0 .05-2.534L46.6 3.23a2.285 2.285 0 0 0-2.504-.982ZM43.7 7.182l12.203 19.12-5.167 1.76 1.052 3.09 2.031-.693L38.07 53.122l.01-1.375-3.262-.023-.034 4.5-27.13-13.127 6.975-26.38Zm3.946 21.932-6.18 2.105 1.052 3.09 6.18-2.105zm-9.27 3.157-2.329.793a1.632 1.632 0 0 0-1.105 1.534l-.03 4.068 3.265.024.02-2.91 1.232-.419zm-3.488 9.66-.047 6.529 3.264.023.048-6.528z"/>
</svg>
`, ck = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor" fill-rule="evenodd"
          d="M19.435 3.417c-4.478 0-8.96 1.693-12.343 5.076-6.766 6.766-6.766 17.913 0 24.679h.006c2.754 2.749 5.563 5.561 8.357 8.357 1.857 1.859 3.696 3.696 5.553 5.553l.949.949 1.892 1.898 9.496-9.49-1.898-1.898-6.502-6.502c-2.796-2.797-5.6-5.606-8.363-8.362-1.65-1.653-1.652-4.042 0-5.694 1.653-1.653 4.047-1.653 5.7 0l8.357 8.362 6.502 6.502 1.898 1.893 9.49-9.49-1.893-1.893-6.507-6.502-8.357-8.362c-3.384-3.383-7.86-5.076-12.337-5.076Zm0 2.68c3.789 0 7.577 1.432 10.439 4.294l8.357 8.362-5.694 5.694-8.357-8.362a6.7 6.7 0 0 0-9.496 0 6.697 6.697 0 0 0 0 9.49c2.76 2.755 5.566 5.564 8.363 8.362l-5.694 5.694c-2.795-2.796-5.601-5.607-8.357-8.357H8.99c-5.724-5.724-5.724-15.16 0-20.883 2.861-2.862 6.655-4.294 10.444-4.294ZM57.709 29.03a4.266 4.266 0 0 0-4.268 4.268c0 1.594.881 2.973 2.176 3.707-.714 4.997-1.424 10.107-2.176 15.037-.934 0-1.792.309-2.495.818l-7.115-5.07a4.25 4.25 0 0 0 .115-.965 4.27 4.27 0 1 0-4.268 4.268 4.23 4.23 0 0 0 2.732-1.012l6.973 4.965a4.22 4.22 0 0 0-.215 1.269 4.27 4.27 0 0 0 4.273 4.268 4.266 4.266 0 0 0 4.268-4.268 4.247 4.247 0 0 0-1.657-3.356l2.208-15.446c2.095-.273 3.722-2.045 3.722-4.215a4.27 4.27 0 0 0-4.273-4.268z"
    />
</svg>
`, hk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.585 1.585V13.75h5.17v1.52H8.58v-1.52h5.17V1.585Zm3.041 3.041h6.083v6.083H4.626Zm9.429 2.13V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0v1.597a1.521 1.521 0 0 0-.325.152l-15.686 9.758a1.52 1.52 0 0 0-.199 2.437l23.512 20.553a1.52 1.52 0 0 0 2.477-.78l4.212-17.037v.352h1.825v-3.65H55.42v1.524a1.52 1.52 0 0 0-.222-.296L43.002 8.741a1.521 1.521 0 0 0-.182-.16h2.259V6.754Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm3.042 2.432v3.65h1.825v-3.65Zm-13.752 2.549 10.757 11.137-3.57 14.446-20.087-17.559Zm13.752 2.926v3.65h1.825v-3.65ZM6.755 17.096v3.65H8.58v-3.65zm0 5.475v3.65h1.628a1.52 1.52 0 0 0 1.02.909l12.683 3.406 7.905 12.694c.168.27.417.481.712.602l13.39 4.576a1.52 1.52 0 0 0 1.157-2.814l-12.936-4.389L24.35 28.42a1.52 1.52 0 0 0-.896-.664L10.19 24.193a1.52 1.52 0 0 0-1.61.557v-2.178zm48.665 3.042v3.65h1.825v-3.65ZM6.755 28.046v3.65H8.58v-3.65zm48.665 3.042v3.65h1.825v-3.65ZM6.755 33.52v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65ZM6.755 38.996v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65zm-35.382.913c-3.454 0-6.287 2.833-6.287 6.287 0 3.076 2.248 5.654 5.179 6.183h-1.225v1.825h3.65V55.42h-.206c2.712-.5 4.777-2.796 5.055-5.59l.002-.002a1.52 1.52 0 0 0 0-1.18c-.314-3.168-2.922-5.698-6.168-5.698zM6.755 44.47v3.65H8.58v-3.65zm13.283 1.521a3.223 3.223 0 0 1 3.246 3.246 3.223 3.223 0 0 1-3.246 3.246 3.223 3.223 0 0 1-3.246-3.246 3.223 3.223 0 0 1 3.246-3.246zm35.382 1.52v2.738h-5.17v12.166h12.165V50.25h-5.17v-2.737ZM6.755 49.946v3.65H8.58v-3.65zm46.536 3.346h6.083v6.083H53.29ZM6.755 55.42v1.825h3.65V55.42H7.668Zm5.475 0v1.825h3.65V55.42zm10.95 0v1.825h3.65V55.42zm5.474 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42z"/>
</svg>
`, ds = {
  marker: nk,
  circle: QT,
  ellipse: ek,
  circle_marker: V1,
  text_marker: lk,
  line: rk,
  rectangle: sk,
  polygon: ik,
  drag: tk,
  change: KT,
  rotate: ok,
  cut: uk,
  delete: ak,
  snapping: ck,
  zoom_to_features: hk
}, g_ = (a) => [
  {
    type: "circle",
    paint: {
      "circle-radius": a.circleMarkerRadius,
      "circle-color": a.fillColor,
      "circle-opacity": a.fillOpacity,
      "circle-stroke-color": a.lineColor,
      "circle-stroke-width": a.lineWidth,
      "circle-stroke-opacity": a.lineOpacity
    }
  }
], xh = (a) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 7,
      "circle-color": "#ffffff",
      "circle-opacity": 1,
      "circle-stroke-color": a.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
], m_ = (a) => [
  {
    type: "line",
    paint: {
      "line-color": a.lineColor,
      "line-opacity": a.lineOpacity,
      "line-width": a.lineWidth
    }
  }
], __ = () => [
  {
    type: "symbol",
    layout: {
      "icon-image": "default-marker",
      "icon-size": 0.18,
      "icon-allow-overlap": !0,
      "icon-anchor": "bottom"
    }
  }
], ca = (a) => [
  {
    type: "fill",
    paint: {
      "fill-color": a.fillColor,
      "fill-opacity": a.fillOpacity
    }
  },
  {
    type: "line",
    paint: {
      "line-color": a.lineColor,
      "line-opacity": a.lineOpacity,
      "line-width": a.lineWidth
    }
  }
], y_ = (a) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 6,
      "circle-color": "#ffffff",
      "circle-opacity": 0.6,
      "circle-stroke-color": a.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
], v_ = () => [
  {
    type: "line",
    paint: {
      "line-color": "#00979f",
      "line-width": 1.8,
      "line-dasharray": [2, 1]
    }
  }
], ns = `__${Ni}_`, Ws = `${ns}id`, Nx = 6e4, Et = {
  // order matters here, layers order will be aligned according to these items
  ...Ri && { standby: `${Ni}_standby` },
  // available only in the pro version
  main: `${Ni}_main`,
  temporary: `${Ni}_temporary`
}, x_ = () => [
  {
    type: "symbol",
    layout: {
      "text-field": ["get", `${ns}text`],
      "text-justify": "center"
    },
    paint: {
      "text-color": "black",
      "text-halo-color": "#fff",
      "text-halo-width": 2
    }
  }
], gn = {
  [Et.main]: {
    lineColor: "#278cda",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  [Et.temporary]: {
    lineColor: "#ff5600",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  ...Ri && {
    [Et.standby]: {
      lineColor: "#787878",
      lineOpacity: 0.8,
      lineWidth: 3,
      fillColor: "#a5a5a5",
      fillOpacity: 0.4,
      circleMarkerRadius: 10
    }
  }
}, dk = {
  // order matters here, layers order will be aligned according to these items
  polygon: {
    [Et.main]: ca(gn[Et.main]),
    [Et.temporary]: ca(gn[Et.temporary]),
    ...Ri && { [Et.standby]: ca(gn[Et.standby]) }
  },
  ellipse: {
    [Et.main]: ca(gn[Et.main]),
    [Et.temporary]: ca(gn[Et.temporary]),
    ...Ri && { [Et.standby]: ca(gn[Et.standby]) }
  },
  rectangle: {
    [Et.main]: ca(gn[Et.main]),
    [Et.temporary]: ca(gn[Et.temporary]),
    ...Ri && { [Et.standby]: ca(gn[Et.standby]) }
  },
  circle: {
    [Et.main]: ca(gn[Et.main]),
    [Et.temporary]: ca(gn[Et.temporary]),
    ...Ri && { [Et.standby]: ca(gn[Et.standby]) }
  },
  circle_marker: {
    [Et.main]: g_(gn[Et.main]),
    [Et.temporary]: g_(gn[Et.temporary]),
    ...Ri && { [Et.standby]: g_(gn[Et.standby]) }
  },
  line: {
    [Et.main]: m_(gn[Et.main]),
    [Et.temporary]: m_(gn[Et.temporary]),
    ...Ri && { [Et.standby]: m_(gn[Et.standby]) }
  },
  marker: {
    [Et.temporary]: __(),
    [Et.main]: __(),
    ...Ri && { [Et.standby]: __() }
  },
  text_marker: {
    [Et.main]: x_(),
    [Et.temporary]: x_(),
    ...Ri && { [Et.standby]: x_() }
  },
  dom_marker: {
    // not a geojson source, layers aren't required
    [Et.main]: [],
    [Et.temporary]: [],
    ...Ri && { [Et.standby]: [] }
  },
  center_marker: {
    [Et.main]: xh(gn[Et.main]),
    [Et.temporary]: xh(gn[Et.temporary]),
    ...Ri && { [Et.standby]: xh(gn[Et.standby]) }
  },
  vertex_marker: {
    [Et.main]: xh(gn[Et.main]),
    [Et.temporary]: xh(gn[Et.temporary]),
    ...Ri && { [Et.standby]: xh(gn[Et.standby]) }
  },
  edge_marker: {
    [Et.main]: y_(gn[Et.main]),
    [Et.temporary]: y_(gn[Et.temporary]),
    ...Ri && {
      [Et.standby]: y_(gn[Et.standby])
    }
  },
  snap_guide: {
    // todo: check which sources can't display snap guides (and other shapes) and remove layers
    [Et.main]: v_(),
    [Et.temporary]: v_(),
    ...Ri && { [Et.standby]: v_() }
  }
}, fk = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#0A95F0" class="bi bi-geo-alt-fill"
     viewBox="0 0 16 16">
    <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10m0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6"/>
</svg>
`, pk = `<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21">
    <circle cx="10.5" cy="10.5" r="9.213" fill="#fff" stroke="#278cda" stroke-width="2.303"/>
</svg>
`, gk = {
  settings: {
    throttlingDelay: 10,
    awaitDataUpdatesOnEvents: !0,
    useDefaultLayers: !0,
    controlsPosition: "top-left",
    controlsUiEnabledByDefault: !0,
    controlsCollapsible: !1,
    controlsStyles: {
      controlGroupClass: "maplibregl-ctrl maplibregl-ctrl-group",
      controlContainerClass: "gm-control-container",
      controlButtonClass: "gm-control-button"
    },
    idGenerator: null,
    markerIcons: {
      default: fk,
      control: pk
    }
  },
  layerStyles: dk,
  controls: {
    draw: {
      marker: {
        title: "Marker",
        icon: ds.marker,
        uiEnabled: !0,
        active: !1
      },
      circle_marker: {
        title: "Circle Marker",
        icon: ds.circle_marker,
        uiEnabled: !0,
        active: !1
      },
      text_marker: {
        title: "Text Marker",
        icon: ds.text_marker,
        uiEnabled: !0,
        active: !1
      },
      circle: {
        title: "Circle",
        icon: ds.circle,
        uiEnabled: !0,
        active: !1
      },
      ellipse: {
        title: "Ellipse",
        icon: ds.ellipse,
        uiEnabled: !0,
        active: !1
      },
      line: {
        title: "Line",
        icon: ds.line,
        uiEnabled: !0,
        active: !1
      },
      rectangle: {
        title: "Rectangle",
        icon: ds.rectangle,
        uiEnabled: !0,
        active: !1
      },
      polygon: {
        title: "Polygon",
        icon: ds.polygon,
        uiEnabled: !0,
        active: !1
      }
    },
    edit: {
      drag: {
        title: "Drag",
        icon: ds.drag,
        uiEnabled: !0,
        active: !1
      },
      change: {
        title: "Change",
        icon: ds.change,
        uiEnabled: !0,
        active: !1
      },
      rotate: {
        title: "Rotate",
        icon: ds.rotate,
        uiEnabled: !0,
        active: !1
      },
      cut: {
        title: "Cut",
        icon: ds.cut,
        uiEnabled: !0,
        active: !1
      },
      delete: {
        title: "Delete",
        icon: ds.delete,
        uiEnabled: !0,
        active: !1
      }
    },
    helper: {
      shape_markers: {
        title: "Shape markers",
        icon: null,
        uiEnabled: !1,
        active: !1
      },
      snapping: {
        title: "Snapping",
        icon: ds.snapping,
        uiEnabled: !0,
        active: !1
      },
      zoom_to_features: {
        title: "Zoom to features",
        icon: ds.zoom_to_features,
        uiEnabled: !0,
        active: !1
      }
    }
  }
};
var U1 = typeof global == "object" && global && global.Object === Object && global, mk = typeof self == "object" && self && self.Object === Object && self, Ka = U1 || mk || Function("return this")(), ya = Ka.Symbol, q1 = Object.prototype, _k = q1.hasOwnProperty, yk = q1.toString, Hd = ya ? ya.toStringTag : void 0;
function vk(a) {
  var n = _k.call(a, Hd), l = a[Hd];
  try {
    a[Hd] = void 0;
    var p = !0;
  } catch {
  }
  var x = yk.call(a);
  return p && (n ? a[Hd] = l : delete a[Hd]), x;
}
var xk = Object.prototype, bk = xk.toString;
function wk(a) {
  return bk.call(a);
}
var Ek = "[object Null]", Sk = "[object Undefined]", Ox = ya ? ya.toStringTag : void 0;
function mc(a) {
  return a == null ? a === void 0 ? Sk : Ek : Ox && Ox in Object(a) ? vk(a) : wk(a);
}
function To(a) {
  return a != null && typeof a == "object";
}
var Tk = "[object Symbol]";
function Rh(a) {
  return typeof a == "symbol" || To(a) && mc(a) == Tk;
}
function Ph(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length, x = Array(p); ++l < p; )
    x[l] = n(a[l], l, a);
  return x;
}
var _s = Array.isArray, zx = ya ? ya.prototype : void 0, Bx = zx ? zx.toString : void 0;
function $1(a) {
  if (typeof a == "string")
    return a;
  if (_s(a))
    return Ph(a, $1) + "";
  if (Rh(a))
    return Bx ? Bx.call(a) : "";
  var n = a + "";
  return n == "0" && 1 / a == -1 / 0 ? "-0" : n;
}
var kk = /\s/;
function Ik(a) {
  for (var n = a.length; n-- && kk.test(a.charAt(n)); )
    ;
  return n;
}
var Mk = /^\s+/;
function Ck(a) {
  return a && a.slice(0, Ik(a) + 1).replace(Mk, "");
}
function ys(a) {
  var n = typeof a;
  return a != null && (n == "object" || n == "function");
}
var Gx = NaN, Pk = /^[-+]0x[0-9a-f]+$/i, Ak = /^0b[01]+$/i, Lk = /^0o[0-7]+$/i, Dk = parseInt;
function jx(a) {
  if (typeof a == "number")
    return a;
  if (Rh(a))
    return Gx;
  if (ys(a)) {
    var n = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = ys(n) ? n + "" : n;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = Ck(a);
  var l = Ak.test(a);
  return l || Lk.test(a) ? Dk(a.slice(2), l ? 2 : 8) : Pk.test(a) ? Gx : +a;
}
function jg(a) {
  return a;
}
var Rk = "[object AsyncFunction]", Fk = "[object Function]", Nk = "[object GeneratorFunction]", Ok = "[object Proxy]";
function zy(a) {
  if (!ys(a))
    return !1;
  var n = mc(a);
  return n == Fk || n == Nk || n == Rk || n == Ok;
}
var b_ = Ka["__core-js_shared__"], Vx = (function() {
  var a = /[^.]+$/.exec(b_ && b_.keys && b_.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
})();
function zk(a) {
  return !!Vx && Vx in a;
}
var Bk = Function.prototype, Gk = Bk.toString;
function _c(a) {
  if (a != null) {
    try {
      return Gk.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var jk = /[\\^$.*+?()[\]{}|]/g, Vk = /^\[object .+?Constructor\]$/, Uk = Function.prototype, qk = Object.prototype, $k = Uk.toString, Zk = qk.hasOwnProperty, Hk = RegExp(
  "^" + $k.call(Zk).replace(jk, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Yk(a) {
  if (!ys(a) || zk(a))
    return !1;
  var n = zy(a) ? Hk : Vk;
  return n.test(_c(a));
}
function Wk(a, n) {
  return a?.[n];
}
function yc(a, n) {
  var l = Wk(a, n);
  return Yk(l) ? l : void 0;
}
var Y_ = yc(Ka, "WeakMap"), Ux = Object.create, Xk = /* @__PURE__ */ (function() {
  function a() {
  }
  return function(n) {
    if (!ys(n))
      return {};
    if (Ux)
      return Ux(n);
    a.prototype = n;
    var l = new a();
    return a.prototype = void 0, l;
  };
})();
function Jk(a, n, l) {
  switch (l.length) {
    case 0:
      return a.call(n);
    case 1:
      return a.call(n, l[0]);
    case 2:
      return a.call(n, l[0], l[1]);
    case 3:
      return a.call(n, l[0], l[1], l[2]);
  }
  return a.apply(n, l);
}
function Kk() {
}
function Qk(a, n) {
  var l = -1, p = a.length;
  for (n || (n = Array(p)); ++l < p; )
    n[l] = a[l];
  return n;
}
var eI = 800, tI = 16, rI = Date.now;
function nI(a) {
  var n = 0, l = 0;
  return function() {
    var p = rI(), x = tI - (p - l);
    if (l = p, x > 0) {
      if (++n >= eI)
        return arguments[0];
    } else
      n = 0;
    return a.apply(void 0, arguments);
  };
}
function iI(a) {
  return function() {
    return a;
  };
}
var wg = (function() {
  try {
    var a = yc(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
})(), sI = wg ? function(a, n) {
  return wg(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: iI(n),
    writable: !0
  });
} : jg, aI = nI(sI);
function oI(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length; ++l < p && n(a[l], l, a) !== !1; )
    ;
  return a;
}
function lI(a, n, l, p) {
  for (var x = a.length, M = l + -1; ++M < x; )
    if (n(a[M], M, a))
      return M;
  return -1;
}
function uI(a) {
  return a !== a;
}
function cI(a, n, l) {
  for (var p = l - 1, x = a.length; ++p < x; )
    if (a[p] === n)
      return p;
  return -1;
}
function hI(a, n, l) {
  return n === n ? cI(a, n, l) : lI(a, uI, l);
}
function Z1(a, n) {
  var l = a == null ? 0 : a.length;
  return !!l && hI(a, n, 0) > -1;
}
var dI = 9007199254740991, fI = /^(?:0|[1-9]\d*)$/;
function Vg(a, n) {
  var l = typeof a;
  return n = n ?? dI, !!n && (l == "number" || l != "symbol" && fI.test(a)) && a > -1 && a % 1 == 0 && a < n;
}
function Df(a, n, l) {
  n == "__proto__" && wg ? wg(a, n, {
    configurable: !0,
    enumerable: !0,
    value: l,
    writable: !0
  }) : a[n] = l;
}
function Rf(a, n) {
  return a === n || a !== a && n !== n;
}
var pI = Object.prototype, gI = pI.hasOwnProperty;
function By(a, n, l) {
  var p = a[n];
  (!(gI.call(a, n) && Rf(p, l)) || l === void 0 && !(n in a)) && Df(a, n, l);
}
function mI(a, n, l, p) {
  var x = !l;
  l || (l = {});
  for (var M = -1, S = n.length; ++M < S; ) {
    var u = n[M], R = void 0;
    R === void 0 && (R = a[u]), x ? Df(l, u, R) : By(l, u, R);
  }
  return l;
}
var qx = Math.max;
function _I(a, n, l) {
  return n = qx(n === void 0 ? a.length - 1 : n, 0), function() {
    for (var p = arguments, x = -1, M = qx(p.length - n, 0), S = Array(M); ++x < M; )
      S[x] = p[n + x];
    x = -1;
    for (var u = Array(n + 1); ++x < n; )
      u[x] = p[x];
    return u[n] = l(S), Jk(a, this, u);
  };
}
function Gy(a, n) {
  return aI(_I(a, n, jg), a + "");
}
var yI = 9007199254740991;
function jy(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= yI;
}
function qh(a) {
  return a != null && jy(a.length) && !zy(a);
}
function W_(a, n, l) {
  if (!ys(l))
    return !1;
  var p = typeof n;
  return (p == "number" ? qh(l) && Vg(n, l.length) : p == "string" && n in l) ? Rf(l[n], a) : !1;
}
function H1(a) {
  return Gy(function(n, l) {
    var p = -1, x = l.length, M = x > 1 ? l[x - 1] : void 0, S = x > 2 ? l[2] : void 0;
    for (M = a.length > 3 && typeof M == "function" ? (x--, M) : void 0, S && W_(l[0], l[1], S) && (M = x < 3 ? void 0 : M, x = 1), n = Object(n); ++p < x; ) {
      var u = l[p];
      u && a(n, u, p, M);
    }
    return n;
  });
}
var vI = Object.prototype;
function Vy(a) {
  var n = a && a.constructor, l = typeof n == "function" && n.prototype || vI;
  return a === l;
}
function xI(a, n) {
  for (var l = -1, p = Array(a); ++l < a; )
    p[l] = n(l);
  return p;
}
var bI = "[object Arguments]";
function $x(a) {
  return To(a) && mc(a) == bI;
}
var Y1 = Object.prototype, wI = Y1.hasOwnProperty, EI = Y1.propertyIsEnumerable, wf = $x(/* @__PURE__ */ (function() {
  return arguments;
})()) ? $x : function(a) {
  return To(a) && wI.call(a, "callee") && !EI.call(a, "callee");
};
function SI() {
  return !1;
}
var W1 = typeof exports == "object" && exports && !exports.nodeType && exports, Zx = W1 && typeof module == "object" && module && !module.nodeType && module, TI = Zx && Zx.exports === W1, Hx = TI ? Ka.Buffer : void 0, kI = Hx ? Hx.isBuffer : void 0, Ef = kI || SI, II = "[object Arguments]", MI = "[object Array]", CI = "[object Boolean]", PI = "[object Date]", AI = "[object Error]", LI = "[object Function]", DI = "[object Map]", RI = "[object Number]", FI = "[object Object]", NI = "[object RegExp]", OI = "[object Set]", zI = "[object String]", BI = "[object WeakMap]", GI = "[object ArrayBuffer]", jI = "[object DataView]", VI = "[object Float32Array]", UI = "[object Float64Array]", qI = "[object Int8Array]", $I = "[object Int16Array]", ZI = "[object Int32Array]", HI = "[object Uint8Array]", YI = "[object Uint8ClampedArray]", WI = "[object Uint16Array]", XI = "[object Uint32Array]", In = {};
In[VI] = In[UI] = In[qI] = In[$I] = In[ZI] = In[HI] = In[YI] = In[WI] = In[XI] = !0;
In[II] = In[MI] = In[GI] = In[CI] = In[jI] = In[PI] = In[AI] = In[LI] = In[DI] = In[RI] = In[FI] = In[NI] = In[OI] = In[zI] = In[BI] = !1;
function JI(a) {
  return To(a) && jy(a.length) && !!In[mc(a)];
}
function Ug(a) {
  return function(n) {
    return a(n);
  };
}
var X1 = typeof exports == "object" && exports && !exports.nodeType && exports, pf = X1 && typeof module == "object" && module && !module.nodeType && module, KI = pf && pf.exports === X1, w_ = KI && U1.process, Fh = (function() {
  try {
    var a = pf && pf.require && pf.require("util").types;
    return a || w_ && w_.binding && w_.binding("util");
  } catch {
  }
})(), Yx = Fh && Fh.isTypedArray, Uy = Yx ? Ug(Yx) : JI, QI = Object.prototype, eM = QI.hasOwnProperty;
function J1(a, n) {
  var l = _s(a), p = !l && wf(a), x = !l && !p && Ef(a), M = !l && !p && !x && Uy(a), S = l || p || x || M, u = S ? xI(a.length, String) : [], R = u.length;
  for (var z in a)
    (n || eM.call(a, z)) && !(S && // Safari 9 has enumerable `arguments.length` in strict mode.
    (z == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    x && (z == "offset" || z == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    M && (z == "buffer" || z == "byteLength" || z == "byteOffset") || // Skip index properties.
    Vg(z, R))) && u.push(z);
  return u;
}
function K1(a, n) {
  return function(l) {
    return a(n(l));
  };
}
var tM = K1(Object.keys, Object), rM = Object.prototype, nM = rM.hasOwnProperty;
function iM(a) {
  if (!Vy(a))
    return tM(a);
  var n = [];
  for (var l in Object(a))
    nM.call(a, l) && l != "constructor" && n.push(l);
  return n;
}
function qg(a) {
  return qh(a) ? J1(a) : iM(a);
}
function sM(a) {
  var n = [];
  if (a != null)
    for (var l in Object(a))
      n.push(l);
  return n;
}
var aM = Object.prototype, oM = aM.hasOwnProperty;
function lM(a) {
  if (!ys(a))
    return sM(a);
  var n = Vy(a), l = [];
  for (var p in a)
    p == "constructor" && (n || !oM.call(a, p)) || l.push(p);
  return l;
}
function Q1(a) {
  return qh(a) ? J1(a, !0) : lM(a);
}
var uM = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, cM = /^\w*$/;
function qy(a, n) {
  if (_s(a))
    return !1;
  var l = typeof a;
  return l == "number" || l == "symbol" || l == "boolean" || a == null || Rh(a) ? !0 : cM.test(a) || !uM.test(a) || n != null && a in Object(n);
}
var Sf = yc(Object, "create");
function hM() {
  this.__data__ = Sf ? Sf(null) : {}, this.size = 0;
}
function dM(a) {
  var n = this.has(a) && delete this.__data__[a];
  return this.size -= n ? 1 : 0, n;
}
var fM = "__lodash_hash_undefined__", pM = Object.prototype, gM = pM.hasOwnProperty;
function mM(a) {
  var n = this.__data__;
  if (Sf) {
    var l = n[a];
    return l === fM ? void 0 : l;
  }
  return gM.call(n, a) ? n[a] : void 0;
}
var _M = Object.prototype, yM = _M.hasOwnProperty;
function vM(a) {
  var n = this.__data__;
  return Sf ? n[a] !== void 0 : yM.call(n, a);
}
var xM = "__lodash_hash_undefined__";
function bM(a, n) {
  var l = this.__data__;
  return this.size += this.has(a) ? 0 : 1, l[a] = Sf && n === void 0 ? xM : n, this;
}
function lc(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.clear(); ++n < l; ) {
    var p = a[n];
    this.set(p[0], p[1]);
  }
}
lc.prototype.clear = hM;
lc.prototype.delete = dM;
lc.prototype.get = mM;
lc.prototype.has = vM;
lc.prototype.set = bM;
function wM() {
  this.__data__ = [], this.size = 0;
}
function $g(a, n) {
  for (var l = a.length; l--; )
    if (Rf(a[l][0], n))
      return l;
  return -1;
}
var EM = Array.prototype, SM = EM.splice;
function TM(a) {
  var n = this.__data__, l = $g(n, a);
  if (l < 0)
    return !1;
  var p = n.length - 1;
  return l == p ? n.pop() : SM.call(n, l, 1), --this.size, !0;
}
function kM(a) {
  var n = this.__data__, l = $g(n, a);
  return l < 0 ? void 0 : n[l][1];
}
function IM(a) {
  return $g(this.__data__, a) > -1;
}
function MM(a, n) {
  var l = this.__data__, p = $g(l, a);
  return p < 0 ? (++this.size, l.push([a, n])) : l[p][1] = n, this;
}
function fl(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.clear(); ++n < l; ) {
    var p = a[n];
    this.set(p[0], p[1]);
  }
}
fl.prototype.clear = wM;
fl.prototype.delete = TM;
fl.prototype.get = kM;
fl.prototype.has = IM;
fl.prototype.set = MM;
var Tf = yc(Ka, "Map");
function CM() {
  this.size = 0, this.__data__ = {
    hash: new lc(),
    map: new (Tf || fl)(),
    string: new lc()
  };
}
function PM(a) {
  var n = typeof a;
  return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? a !== "__proto__" : a === null;
}
function Zg(a, n) {
  var l = a.__data__;
  return PM(n) ? l[typeof n == "string" ? "string" : "hash"] : l.map;
}
function AM(a) {
  var n = Zg(this, a).delete(a);
  return this.size -= n ? 1 : 0, n;
}
function LM(a) {
  return Zg(this, a).get(a);
}
function DM(a) {
  return Zg(this, a).has(a);
}
function RM(a, n) {
  var l = Zg(this, a), p = l.size;
  return l.set(a, n), this.size += l.size == p ? 0 : 1, this;
}
function pl(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.clear(); ++n < l; ) {
    var p = a[n];
    this.set(p[0], p[1]);
  }
}
pl.prototype.clear = CM;
pl.prototype.delete = AM;
pl.prototype.get = LM;
pl.prototype.has = DM;
pl.prototype.set = RM;
var FM = "Expected a function";
function $y(a, n) {
  if (typeof a != "function" || n != null && typeof n != "function")
    throw new TypeError(FM);
  var l = function() {
    var p = arguments, x = n ? n.apply(this, p) : p[0], M = l.cache;
    if (M.has(x))
      return M.get(x);
    var S = a.apply(this, p);
    return l.cache = M.set(x, S) || M, S;
  };
  return l.cache = new ($y.Cache || pl)(), l;
}
$y.Cache = pl;
var NM = 500;
function OM(a) {
  var n = $y(a, function(p) {
    return l.size === NM && l.clear(), p;
  }), l = n.cache;
  return n;
}
var zM = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, BM = /\\(\\)?/g, GM = OM(function(a) {
  var n = [];
  return a.charCodeAt(0) === 46 && n.push(""), a.replace(zM, function(l, p, x, M) {
    n.push(x ? M.replace(BM, "$1") : p || l);
  }), n;
});
function jM(a) {
  return a == null ? "" : $1(a);
}
function Zy(a, n) {
  return _s(a) ? a : qy(a, n) ? [a] : GM(jM(a));
}
function Ff(a) {
  if (typeof a == "string" || Rh(a))
    return a;
  var n = a + "";
  return n == "0" && 1 / a == -1 / 0 ? "-0" : n;
}
function Hy(a, n) {
  n = Zy(n, a);
  for (var l = 0, p = n.length; a != null && l < p; )
    a = a[Ff(n[l++])];
  return l && l == p ? a : void 0;
}
function Nh(a, n, l) {
  var p = a == null ? void 0 : Hy(a, n);
  return p === void 0 ? l : p;
}
function ew(a, n) {
  for (var l = -1, p = n.length, x = a.length; ++l < p; )
    a[x + l] = n[l];
  return a;
}
var Wx = ya ? ya.isConcatSpreadable : void 0;
function VM(a) {
  return _s(a) || wf(a) || !!(Wx && a && a[Wx]);
}
function UM(a, n, l, p, x) {
  var M = -1, S = a.length;
  for (l || (l = VM), x || (x = []); ++M < S; ) {
    var u = a[M];
    l(u) ? ew(x, u) : x[x.length] = u;
  }
  return x;
}
var tw = K1(Object.getPrototypeOf, Object), qM = "[object Object]", $M = Function.prototype, ZM = Object.prototype, rw = $M.toString, HM = ZM.hasOwnProperty, YM = rw.call(Object);
function nw(a) {
  if (!To(a) || mc(a) != qM)
    return !1;
  var n = tw(a);
  if (n === null)
    return !0;
  var l = HM.call(n, "constructor") && n.constructor;
  return typeof l == "function" && l instanceof l && rw.call(l) == YM;
}
function WM() {
  this.__data__ = new fl(), this.size = 0;
}
function XM(a) {
  var n = this.__data__, l = n.delete(a);
  return this.size = n.size, l;
}
function JM(a) {
  return this.__data__.get(a);
}
function KM(a) {
  return this.__data__.has(a);
}
var QM = 200;
function eC(a, n) {
  var l = this.__data__;
  if (l instanceof fl) {
    var p = l.__data__;
    if (!Tf || p.length < QM - 1)
      return p.push([a, n]), this.size = ++l.size, this;
    l = this.__data__ = new pl(p);
  }
  return l.set(a, n), this.size = l.size, this;
}
function Ya(a) {
  var n = this.__data__ = new fl(a);
  this.size = n.size;
}
Ya.prototype.clear = WM;
Ya.prototype.delete = XM;
Ya.prototype.get = JM;
Ya.prototype.has = KM;
Ya.prototype.set = eC;
var iw = typeof exports == "object" && exports && !exports.nodeType && exports, Xx = iw && typeof module == "object" && module && !module.nodeType && module, tC = Xx && Xx.exports === iw, Jx = tC ? Ka.Buffer : void 0, Kx = Jx ? Jx.allocUnsafe : void 0;
function sw(a, n) {
  if (n)
    return a.slice();
  var l = a.length, p = Kx ? Kx(l) : new a.constructor(l);
  return a.copy(p), p;
}
function rC(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length, x = 0, M = []; ++l < p; ) {
    var S = a[l];
    n(S, l, a) && (M[x++] = S);
  }
  return M;
}
function nC() {
  return [];
}
var iC = Object.prototype, sC = iC.propertyIsEnumerable, Qx = Object.getOwnPropertySymbols, aC = Qx ? function(a) {
  return a == null ? [] : (a = Object(a), rC(Qx(a), function(n) {
    return sC.call(a, n);
  }));
} : nC;
function oC(a, n, l) {
  var p = n(a);
  return _s(a) ? p : ew(p, l(a));
}
function X_(a) {
  return oC(a, qg, aC);
}
var J_ = yc(Ka, "DataView"), K_ = yc(Ka, "Promise"), Ah = yc(Ka, "Set"), eb = "[object Map]", lC = "[object Object]", tb = "[object Promise]", rb = "[object Set]", nb = "[object WeakMap]", ib = "[object DataView]", uC = _c(J_), cC = _c(Tf), hC = _c(K_), dC = _c(Ah), fC = _c(Y_), Va = mc;
(J_ && Va(new J_(new ArrayBuffer(1))) != ib || Tf && Va(new Tf()) != eb || K_ && Va(K_.resolve()) != tb || Ah && Va(new Ah()) != rb || Y_ && Va(new Y_()) != nb) && (Va = function(a) {
  var n = mc(a), l = n == lC ? a.constructor : void 0, p = l ? _c(l) : "";
  if (p)
    switch (p) {
      case uC:
        return ib;
      case cC:
        return eb;
      case hC:
        return tb;
      case dC:
        return rb;
      case fC:
        return nb;
    }
  return n;
});
var pC = Object.prototype, gC = pC.hasOwnProperty;
function mC(a) {
  var n = a.length, l = new a.constructor(n);
  return n && typeof a[0] == "string" && gC.call(a, "index") && (l.index = a.index, l.input = a.input), l;
}
var Eg = Ka.Uint8Array;
function Yy(a) {
  var n = new a.constructor(a.byteLength);
  return new Eg(n).set(new Eg(a)), n;
}
function _C(a, n) {
  var l = Yy(a.buffer);
  return new a.constructor(l, a.byteOffset, a.byteLength);
}
var yC = /\w*$/;
function vC(a) {
  var n = new a.constructor(a.source, yC.exec(a));
  return n.lastIndex = a.lastIndex, n;
}
var sb = ya ? ya.prototype : void 0, ab = sb ? sb.valueOf : void 0;
function xC(a) {
  return ab ? Object(ab.call(a)) : {};
}
function aw(a, n) {
  var l = n ? Yy(a.buffer) : a.buffer;
  return new a.constructor(l, a.byteOffset, a.length);
}
var bC = "[object Boolean]", wC = "[object Date]", EC = "[object Map]", SC = "[object Number]", TC = "[object RegExp]", kC = "[object Set]", IC = "[object String]", MC = "[object Symbol]", CC = "[object ArrayBuffer]", PC = "[object DataView]", AC = "[object Float32Array]", LC = "[object Float64Array]", DC = "[object Int8Array]", RC = "[object Int16Array]", FC = "[object Int32Array]", NC = "[object Uint8Array]", OC = "[object Uint8ClampedArray]", zC = "[object Uint16Array]", BC = "[object Uint32Array]";
function GC(a, n, l) {
  var p = a.constructor;
  switch (n) {
    case CC:
      return Yy(a);
    case bC:
    case wC:
      return new p(+a);
    case PC:
      return _C(a);
    case AC:
    case LC:
    case DC:
    case RC:
    case FC:
    case NC:
    case OC:
    case zC:
    case BC:
      return aw(a, l);
    case EC:
      return new p();
    case SC:
    case IC:
      return new p(a);
    case TC:
      return vC(a);
    case kC:
      return new p();
    case MC:
      return xC(a);
  }
}
function ow(a) {
  return typeof a.constructor == "function" && !Vy(a) ? Xk(tw(a)) : {};
}
var jC = "[object Map]";
function VC(a) {
  return To(a) && Va(a) == jC;
}
var ob = Fh && Fh.isMap, UC = ob ? Ug(ob) : VC, qC = "[object Set]";
function $C(a) {
  return To(a) && Va(a) == qC;
}
var lb = Fh && Fh.isSet, ZC = lb ? Ug(lb) : $C, HC = 1, lw = "[object Arguments]", YC = "[object Array]", WC = "[object Boolean]", XC = "[object Date]", JC = "[object Error]", uw = "[object Function]", KC = "[object GeneratorFunction]", QC = "[object Map]", eP = "[object Number]", cw = "[object Object]", tP = "[object RegExp]", rP = "[object Set]", nP = "[object String]", iP = "[object Symbol]", sP = "[object WeakMap]", aP = "[object ArrayBuffer]", oP = "[object DataView]", lP = "[object Float32Array]", uP = "[object Float64Array]", cP = "[object Int8Array]", hP = "[object Int16Array]", dP = "[object Int32Array]", fP = "[object Uint8Array]", pP = "[object Uint8ClampedArray]", gP = "[object Uint16Array]", mP = "[object Uint32Array]", xn = {};
xn[lw] = xn[YC] = xn[aP] = xn[oP] = xn[WC] = xn[XC] = xn[lP] = xn[uP] = xn[cP] = xn[hP] = xn[dP] = xn[QC] = xn[eP] = xn[cw] = xn[tP] = xn[rP] = xn[nP] = xn[iP] = xn[fP] = xn[pP] = xn[gP] = xn[mP] = !0;
xn[JC] = xn[uw] = xn[sP] = !1;
function dg(a, n, l, p, x, M) {
  var S, u = n & HC;
  if (S !== void 0)
    return S;
  if (!ys(a))
    return a;
  var R = _s(a);
  if (R)
    S = mC(a);
  else {
    var z = Va(a), U = z == uw || z == KC;
    if (Ef(a))
      return sw(a, u);
    if (z == cw || z == lw || U && !x)
      S = U ? {} : ow(a);
    else {
      if (!xn[z])
        return x ? a : {};
      S = GC(a, z, u);
    }
  }
  M || (M = new Ya());
  var $ = M.get(a);
  if ($)
    return $;
  M.set(a, S), ZC(a) ? a.forEach(function(ce) {
    S.add(dg(ce, n, l, ce, a, M));
  }) : UC(a) && a.forEach(function(ce, _e) {
    S.set(_e, dg(ce, n, l, _e, a, M));
  });
  var ee = X_, le = R ? void 0 : ee(a);
  return oI(le || a, function(ce, _e) {
    le && (_e = ce, ce = a[_e]), By(S, _e, dg(ce, n, l, _e, a, M));
  }), S;
}
var _P = 1, yP = 4;
function Qs(a) {
  return dg(a, _P | yP);
}
var vP = "__lodash_hash_undefined__";
function xP(a) {
  return this.__data__.set(a, vP), this;
}
function bP(a) {
  return this.__data__.has(a);
}
function Oh(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.__data__ = new pl(); ++n < l; )
    this.add(a[n]);
}
Oh.prototype.add = Oh.prototype.push = xP;
Oh.prototype.has = bP;
function wP(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length; ++l < p; )
    if (n(a[l], l, a))
      return !0;
  return !1;
}
function Sg(a, n) {
  return a.has(n);
}
var EP = 1, SP = 2;
function hw(a, n, l, p, x, M) {
  var S = l & EP, u = a.length, R = n.length;
  if (u != R && !(S && R > u))
    return !1;
  var z = M.get(a), U = M.get(n);
  if (z && U)
    return z == n && U == a;
  var $ = -1, ee = !0, le = l & SP ? new Oh() : void 0;
  for (M.set(a, n), M.set(n, a); ++$ < u; ) {
    var ce = a[$], _e = n[$];
    if (p)
      var ne = S ? p(_e, ce, $, n, a, M) : p(ce, _e, $, a, n, M);
    if (ne !== void 0) {
      if (ne)
        continue;
      ee = !1;
      break;
    }
    if (le) {
      if (!wP(n, function(Pe, ve) {
        if (!Sg(le, ve) && (ce === Pe || x(ce, Pe, l, p, M)))
          return le.push(ve);
      })) {
        ee = !1;
        break;
      }
    } else if (!(ce === _e || x(ce, _e, l, p, M))) {
      ee = !1;
      break;
    }
  }
  return M.delete(a), M.delete(n), ee;
}
function TP(a) {
  var n = -1, l = Array(a.size);
  return a.forEach(function(p, x) {
    l[++n] = [x, p];
  }), l;
}
function Wy(a) {
  var n = -1, l = Array(a.size);
  return a.forEach(function(p) {
    l[++n] = p;
  }), l;
}
var kP = 1, IP = 2, MP = "[object Boolean]", CP = "[object Date]", PP = "[object Error]", AP = "[object Map]", LP = "[object Number]", DP = "[object RegExp]", RP = "[object Set]", FP = "[object String]", NP = "[object Symbol]", OP = "[object ArrayBuffer]", zP = "[object DataView]", ub = ya ? ya.prototype : void 0, E_ = ub ? ub.valueOf : void 0;
function BP(a, n, l, p, x, M, S) {
  switch (l) {
    case zP:
      if (a.byteLength != n.byteLength || a.byteOffset != n.byteOffset)
        return !1;
      a = a.buffer, n = n.buffer;
    case OP:
      return !(a.byteLength != n.byteLength || !M(new Eg(a), new Eg(n)));
    case MP:
    case CP:
    case LP:
      return Rf(+a, +n);
    case PP:
      return a.name == n.name && a.message == n.message;
    case DP:
    case FP:
      return a == n + "";
    case AP:
      var u = TP;
    case RP:
      var R = p & kP;
      if (u || (u = Wy), a.size != n.size && !R)
        return !1;
      var z = S.get(a);
      if (z)
        return z == n;
      p |= IP, S.set(a, n);
      var U = hw(u(a), u(n), p, x, M, S);
      return S.delete(a), U;
    case NP:
      if (E_)
        return E_.call(a) == E_.call(n);
  }
  return !1;
}
var GP = 1, jP = Object.prototype, VP = jP.hasOwnProperty;
function UP(a, n, l, p, x, M) {
  var S = l & GP, u = X_(a), R = u.length, z = X_(n), U = z.length;
  if (R != U && !S)
    return !1;
  for (var $ = R; $--; ) {
    var ee = u[$];
    if (!(S ? ee in n : VP.call(n, ee)))
      return !1;
  }
  var le = M.get(a), ce = M.get(n);
  if (le && ce)
    return le == n && ce == a;
  var _e = !0;
  M.set(a, n), M.set(n, a);
  for (var ne = S; ++$ < R; ) {
    ee = u[$];
    var Pe = a[ee], ve = n[ee];
    if (p)
      var Ue = S ? p(ve, Pe, ee, n, a, M) : p(Pe, ve, ee, a, n, M);
    if (!(Ue === void 0 ? Pe === ve || x(Pe, ve, l, p, M) : Ue)) {
      _e = !1;
      break;
    }
    ne || (ne = ee == "constructor");
  }
  if (_e && !ne) {
    var Qe = a.constructor, et = n.constructor;
    Qe != et && "constructor" in a && "constructor" in n && !(typeof Qe == "function" && Qe instanceof Qe && typeof et == "function" && et instanceof et) && (_e = !1);
  }
  return M.delete(a), M.delete(n), _e;
}
var qP = 1, cb = "[object Arguments]", hb = "[object Array]", Zp = "[object Object]", $P = Object.prototype, db = $P.hasOwnProperty;
function ZP(a, n, l, p, x, M) {
  var S = _s(a), u = _s(n), R = S ? hb : Va(a), z = u ? hb : Va(n);
  R = R == cb ? Zp : R, z = z == cb ? Zp : z;
  var U = R == Zp, $ = z == Zp, ee = R == z;
  if (ee && Ef(a)) {
    if (!Ef(n))
      return !1;
    S = !0, U = !1;
  }
  if (ee && !U)
    return M || (M = new Ya()), S || Uy(a) ? hw(a, n, l, p, x, M) : BP(a, n, R, l, p, x, M);
  if (!(l & qP)) {
    var le = U && db.call(a, "__wrapped__"), ce = $ && db.call(n, "__wrapped__");
    if (le || ce) {
      var _e = le ? a.value() : a, ne = ce ? n.value() : n;
      return M || (M = new Ya()), x(_e, ne, l, p, M);
    }
  }
  return ee ? (M || (M = new Ya()), UP(a, n, l, p, x, M)) : !1;
}
function Hg(a, n, l, p, x) {
  return a === n ? !0 : a == null || n == null || !To(a) && !To(n) ? a !== a && n !== n : ZP(a, n, l, p, Hg, x);
}
var HP = 1, YP = 2;
function WP(a, n, l, p) {
  var x = l.length, M = x;
  if (a == null)
    return !M;
  for (a = Object(a); x--; ) {
    var S = l[x];
    if (S[2] ? S[1] !== a[S[0]] : !(S[0] in a))
      return !1;
  }
  for (; ++x < M; ) {
    S = l[x];
    var u = S[0], R = a[u], z = S[1];
    if (S[2]) {
      if (R === void 0 && !(u in a))
        return !1;
    } else {
      var U = new Ya(), $;
      if (!($ === void 0 ? Hg(z, R, HP | YP, p, U) : $))
        return !1;
    }
  }
  return !0;
}
function dw(a) {
  return a === a && !ys(a);
}
function XP(a) {
  for (var n = qg(a), l = n.length; l--; ) {
    var p = n[l], x = a[p];
    n[l] = [p, x, dw(x)];
  }
  return n;
}
function fw(a, n) {
  return function(l) {
    return l == null ? !1 : l[a] === n && (n !== void 0 || a in Object(l));
  };
}
function JP(a) {
  var n = XP(a);
  return n.length == 1 && n[0][2] ? fw(n[0][0], n[0][1]) : function(l) {
    return l === a || WP(l, a, n);
  };
}
function KP(a, n) {
  return a != null && n in Object(a);
}
function QP(a, n, l) {
  n = Zy(n, a);
  for (var p = -1, x = n.length, M = !1; ++p < x; ) {
    var S = Ff(n[p]);
    if (!(M = a != null && l(a, S)))
      break;
    a = a[S];
  }
  return M || ++p != x ? M : (x = a == null ? 0 : a.length, !!x && jy(x) && Vg(S, x) && (_s(a) || wf(a)));
}
function eA(a, n) {
  return a != null && QP(a, n, KP);
}
var tA = 1, rA = 2;
function nA(a, n) {
  return qy(a) && dw(n) ? fw(Ff(a), n) : function(l) {
    var p = Nh(l, a);
    return p === void 0 && p === n ? eA(l, a) : Hg(n, p, tA | rA);
  };
}
function iA(a) {
  return function(n) {
    return n?.[a];
  };
}
function sA(a) {
  return function(n) {
    return Hy(n, a);
  };
}
function aA(a) {
  return qy(a) ? iA(Ff(a)) : sA(a);
}
function pw(a) {
  return typeof a == "function" ? a : a == null ? jg : typeof a == "object" ? _s(a) ? nA(a[0], a[1]) : JP(a) : aA(a);
}
function oA(a, n, l, p) {
  for (var x = -1, M = a == null ? 0 : a.length; ++x < M; ) {
    var S = a[x];
    n(p, S, l(S), a);
  }
  return p;
}
function lA(a) {
  return function(n, l, p) {
    for (var x = -1, M = Object(n), S = p(n), u = S.length; u--; ) {
      var R = S[++x];
      if (l(M[R], R, M) === !1)
        break;
    }
    return n;
  };
}
var gw = lA();
function uA(a, n) {
  return a && gw(a, n, qg);
}
function cA(a, n) {
  return function(l, p) {
    if (l == null)
      return l;
    if (!qh(l))
      return a(l, p);
    for (var x = l.length, M = -1, S = Object(l); ++M < x && p(S[M], M, S) !== !1; )
      ;
    return l;
  };
}
var mw = cA(uA);
function hA(a, n, l, p) {
  return mw(a, function(x, M, S) {
    n(p, x, l(x), S);
  }), p;
}
function _w(a, n) {
  return function(l, p) {
    var x = _s(l) ? oA : hA, M = {};
    return x(l, a, pw(p), M);
  };
}
var dA = Object.prototype, fA = dA.hasOwnProperty, pA = _w(function(a, n, l) {
  fA.call(a, l) ? ++a[l] : Df(a, l, 1);
}), S_ = function() {
  return Ka.Date.now();
}, gA = "Expected a function", mA = Math.max, _A = Math.min;
function yw(a, n, l) {
  var p, x, M, S, u, R, z = 0, U = !1, $ = !1, ee = !0;
  if (typeof a != "function")
    throw new TypeError(gA);
  n = jx(n) || 0, ys(l) && (U = !!l.leading, $ = "maxWait" in l, M = $ ? mA(jx(l.maxWait) || 0, n) : M, ee = "trailing" in l ? !!l.trailing : ee);
  function le(Xe) {
    var ut = p, Q = x;
    return p = x = void 0, z = Xe, S = a.apply(Q, ut), S;
  }
  function ce(Xe) {
    return z = Xe, u = setTimeout(Pe, n), U ? le(Xe) : S;
  }
  function _e(Xe) {
    var ut = Xe - R, Q = Xe - z, se = n - ut;
    return $ ? _A(se, M - Q) : se;
  }
  function ne(Xe) {
    var ut = Xe - R, Q = Xe - z;
    return R === void 0 || ut >= n || ut < 0 || $ && Q >= M;
  }
  function Pe() {
    var Xe = S_();
    if (ne(Xe))
      return ve(Xe);
    u = setTimeout(Pe, _e(Xe));
  }
  function ve(Xe) {
    return u = void 0, ee && p ? le(Xe) : (p = x = void 0, S);
  }
  function Ue() {
    u !== void 0 && clearTimeout(u), z = 0, p = R = x = u = void 0;
  }
  function Qe() {
    return u === void 0 ? S : ve(S_());
  }
  function et() {
    var Xe = S_(), ut = ne(Xe);
    if (p = arguments, x = this, R = Xe, ut) {
      if (u === void 0)
        return ce(R);
      if ($)
        return clearTimeout(u), u = setTimeout(Pe, n), le(R);
    }
    return u === void 0 && (u = setTimeout(Pe, n)), S;
  }
  return et.cancel = Ue, et.flush = Qe, et;
}
function Q_(a, n, l) {
  (l !== void 0 && !Rf(a[n], l) || l === void 0 && !(n in a)) && Df(a, n, l);
}
function vw(a) {
  return To(a) && qh(a);
}
function ey(a, n) {
  if (!(n === "constructor" && typeof a[n] == "function") && n != "__proto__")
    return a[n];
}
function yA(a) {
  return mI(a, Q1(a));
}
function vA(a, n, l, p, x, M, S) {
  var u = ey(a, l), R = ey(n, l), z = S.get(R);
  if (z) {
    Q_(a, l, z);
    return;
  }
  var U = M ? M(u, R, l + "", a, n, S) : void 0, $ = U === void 0;
  if ($) {
    var ee = _s(R), le = !ee && Ef(R), ce = !ee && !le && Uy(R);
    U = R, ee || le || ce ? _s(u) ? U = u : vw(u) ? U = Qk(u) : le ? ($ = !1, U = sw(R, !0)) : ce ? ($ = !1, U = aw(R, !0)) : U = [] : nw(R) || wf(R) ? (U = u, wf(u) ? U = yA(u) : (!ys(u) || zy(u)) && (U = ow(R))) : $ = !1;
  }
  $ && (S.set(R, U), x(U, R, p, M, S), S.delete(R)), Q_(a, l, U);
}
function Xy(a, n, l, p, x) {
  a !== n && gw(n, function(M, S) {
    if (x || (x = new Ya()), ys(M))
      vA(a, n, S, l, Xy, p, x);
    else {
      var u = p ? p(ey(a, S), M, S + "", a, n, x) : void 0;
      u === void 0 && (u = M), Q_(a, S, u);
    }
  }, Q1);
}
var xA = H1(function(a, n, l, p) {
  Xy(a, n, l, p);
});
function bA(a, n, l) {
  for (var p = -1, x = a == null ? 0 : a.length; ++p < x; )
    if (l(n, a[p]))
      return !0;
  return !1;
}
function wA(a, n) {
  var l = -1, p = qh(a) ? Array(a.length) : [];
  return mw(a, function(x, M, S) {
    p[++l] = n(x, M, S);
  }), p;
}
function EA(a, n) {
  return Ph(n, function(l) {
    return a[l];
  });
}
function SA(a) {
  return a == null ? [] : EA(a, qg(a));
}
var TA = Math.min;
function kA(a, n, l) {
  for (var p = Z1, x = a[0].length, M = a.length, S = M, u = Array(M), R = 1 / 0, z = []; S--; ) {
    var U = a[S];
    R = TA(U.length, R), u[S] = x >= 120 && U.length >= 120 ? new Oh(S && U) : void 0;
  }
  U = a[0];
  var $ = -1, ee = u[0];
  e:
    for (; ++$ < x && z.length < R; ) {
      var le = U[$], ce = le;
      if (le = le !== 0 ? le : 0, !(ee ? Sg(ee, ce) : p(z, ce))) {
        for (S = M; --S; ) {
          var _e = u[S];
          if (!(_e ? Sg(_e, ce) : p(a[S], ce)))
            continue e;
        }
        ee && ee.push(ce), z.push(le);
      }
    }
  return z;
}
function IA(a) {
  return vw(a) ? a : [];
}
var MA = Gy(function(a) {
  var n = Ph(a, IA);
  return n.length && n[0] === a[0] ? kA(n) : [];
});
function $h(a, n) {
  return Hg(a, n);
}
var CA = _w(function(a, n, l) {
  Df(a, l, n);
}), PA = H1(function(a, n, l) {
  Xy(a, n, l);
});
function AA(a, n, l, p) {
  if (!ys(a))
    return a;
  n = Zy(n, a);
  for (var x = -1, M = n.length, S = M - 1, u = a; u != null && ++x < M; ) {
    var R = Ff(n[x]), z = l;
    if (R === "__proto__" || R === "constructor" || R === "prototype")
      return a;
    if (x != S) {
      var U = u[R];
      z = void 0, z === void 0 && (z = ys(U) ? U : Vg(n[x + 1]) ? [] : {});
    }
    By(u, R, z), u = u[R];
  }
  return a;
}
function LA(a, n) {
  var l = a.length;
  for (a.sort(n); l--; )
    a[l] = a[l].value;
  return a;
}
function DA(a, n) {
  if (a !== n) {
    var l = a !== void 0, p = a === null, x = a === a, M = Rh(a), S = n !== void 0, u = n === null, R = n === n, z = Rh(n);
    if (!u && !z && !M && a > n || M && S && R && !u && !z || p && S && R || !l && R || !x)
      return 1;
    if (!p && !M && !z && a < n || z && l && x && !p && !M || u && l && x || !S && x || !R)
      return -1;
  }
  return 0;
}
function RA(a, n, l) {
  for (var p = -1, x = a.criteria, M = n.criteria, S = x.length, u = l.length; ++p < S; ) {
    var R = DA(x[p], M[p]);
    if (R) {
      if (p >= u)
        return R;
      var z = l[p];
      return R * (z == "desc" ? -1 : 1);
    }
  }
  return a.index - n.index;
}
function FA(a, n, l) {
  n.length ? n = Ph(n, function(M) {
    return _s(M) ? function(S) {
      return Hy(S, M.length === 1 ? M[0] : M);
    } : M;
  }) : n = [jg];
  var p = -1;
  n = Ph(n, Ug(pw));
  var x = wA(a, function(M, S, u) {
    var R = Ph(n, function(z) {
      return z(M);
    });
    return { criteria: R, index: ++p, value: M };
  });
  return LA(x, function(M, S) {
    return RA(M, S, l);
  });
}
function NA(a, n, l) {
  return a == null ? a : AA(a, n, l);
}
var fb = Gy(function(a, n) {
  if (a == null)
    return [];
  var l = n.length;
  return l > 1 && W_(a, n[0], n[1]) ? n = [] : l > 2 && W_(n[0], n[1], n[2]) && (n = [n[0]]), FA(a, UM(n), []);
}), OA = "Expected a function";
function xw(a, n, l) {
  var p = !0, x = !0;
  if (typeof a != "function")
    throw new TypeError(OA);
  return ys(l) && (p = "leading" in l ? !!l.leading : p, x = "trailing" in l ? !!l.trailing : x), yw(a, n, {
    leading: p,
    maxWait: n,
    trailing: x
  });
}
var zA = 1 / 0, BA = Ah && 1 / Wy(new Ah([, -0]))[1] == zA ? function(a) {
  return new Ah(a);
} : Kk, GA = 200;
function jA(a, n, l) {
  var p = -1, x = Z1, M = a.length, S = !0, u = [], R = u;
  if (l)
    S = !1, x = bA;
  else if (M >= GA) {
    var z = BA(a);
    if (z)
      return Wy(z);
    S = !1, x = Sg, R = new Oh();
  } else
    R = u;
  e:
    for (; ++p < M; ) {
      var U = a[p], $ = U;
      if (U = l || U !== 0 ? U : 0, S && $ === $) {
        for (var ee = R.length; ee--; )
          if (R[ee] === $)
            continue e;
        u.push(U);
      } else x(R, $, l) || (R !== u && R.push($), u.push(U));
    }
  return u;
}
function pb(a, n) {
  return n = typeof n == "function" ? n : void 0, a && a.length ? jA(a, void 0, n) : [];
}
function bw(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var ty = { exports: {} }, VA = ty.exports, gb;
function UA() {
  return gb || (gb = 1, (function(a) {
    (function(n, l) {
      a.exports ? a.exports = l() : n.log = l();
    })(VA, function() {
      var n = function() {
      }, l = "undefined", p = typeof window !== l && typeof window.navigator !== l && /Trident\/|MSIE /.test(window.navigator.userAgent), x = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], M = {}, S = null;
      function u(_e, ne) {
        var Pe = _e[ne];
        if (typeof Pe.bind == "function")
          return Pe.bind(_e);
        try {
          return Function.prototype.bind.call(Pe, _e);
        } catch {
          return function() {
            return Function.prototype.apply.apply(Pe, [_e, arguments]);
          };
        }
      }
      function R() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function z(_e) {
        return _e === "debug" && (_e = "log"), typeof console === l ? !1 : _e === "trace" && p ? R : console[_e] !== void 0 ? u(console, _e) : console.log !== void 0 ? u(console, "log") : n;
      }
      function U() {
        for (var _e = this.getLevel(), ne = 0; ne < x.length; ne++) {
          var Pe = x[ne];
          this[Pe] = ne < _e ? n : this.methodFactory(Pe, _e, this.name);
        }
        if (this.log = this.debug, typeof console === l && _e < this.levels.SILENT)
          return "No console available for logging";
      }
      function $(_e) {
        return function() {
          typeof console !== l && (U.call(this), this[_e].apply(this, arguments));
        };
      }
      function ee(_e, ne, Pe) {
        return z(_e) || $.apply(this, arguments);
      }
      function le(_e, ne) {
        var Pe = this, ve, Ue, Qe, et = "loglevel";
        typeof _e == "string" ? et += ":" + _e : typeof _e == "symbol" && (et = void 0);
        function Xe(Se) {
          var Ie = (x[Se] || "silent").toUpperCase();
          if (!(typeof window === l || !et)) {
            try {
              window.localStorage[et] = Ie;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(et) + "=" + Ie + ";";
            } catch {
            }
          }
        }
        function ut() {
          var Se;
          if (!(typeof window === l || !et)) {
            try {
              Se = window.localStorage[et];
            } catch {
            }
            if (typeof Se === l)
              try {
                var Ie = window.document.cookie, ze = encodeURIComponent(et), Re = Ie.indexOf(ze + "=");
                Re !== -1 && (Se = /^([^;]+)/.exec(
                  Ie.slice(Re + ze.length + 1)
                )[1]);
              } catch {
              }
            return Pe.levels[Se] === void 0 && (Se = void 0), Se;
          }
        }
        function Q() {
          if (!(typeof window === l || !et)) {
            try {
              window.localStorage.removeItem(et);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(et) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function se(Se) {
          var Ie = Se;
          if (typeof Ie == "string" && Pe.levels[Ie.toUpperCase()] !== void 0 && (Ie = Pe.levels[Ie.toUpperCase()]), typeof Ie == "number" && Ie >= 0 && Ie <= Pe.levels.SILENT)
            return Ie;
          throw new TypeError("log.setLevel() called with invalid level: " + Se);
        }
        Pe.name = _e, Pe.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, Pe.methodFactory = ne || ee, Pe.getLevel = function() {
          return Qe ?? Ue ?? ve;
        }, Pe.setLevel = function(Se, Ie) {
          return Qe = se(Se), Ie !== !1 && Xe(Qe), U.call(Pe);
        }, Pe.setDefaultLevel = function(Se) {
          Ue = se(Se), ut() || Pe.setLevel(Se, !1);
        }, Pe.resetLevel = function() {
          Qe = null, Q(), U.call(Pe);
        }, Pe.enableAll = function(Se) {
          Pe.setLevel(Pe.levels.TRACE, Se);
        }, Pe.disableAll = function(Se) {
          Pe.setLevel(Pe.levels.SILENT, Se);
        }, Pe.rebuild = function() {
          if (S !== Pe && (ve = se(S.getLevel())), U.call(Pe), S === Pe)
            for (var Se in M)
              M[Se].rebuild();
        }, ve = se(
          S ? S.getLevel() : "WARN"
        );
        var ge = ut();
        ge != null && (Qe = se(ge)), U.call(Pe);
      }
      S = new le(), S.getLogger = function(_e) {
        if (typeof _e != "symbol" && typeof _e != "string" || _e === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var ne = M[_e];
        return ne || (ne = M[_e] = new le(
          _e,
          S.methodFactory
        )), ne;
      };
      var ce = typeof window !== l ? window.log : void 0;
      return S.noConflict = function() {
        return typeof window !== l && window.log === S && (window.log = ce), S;
      }, S.getLoggers = function() {
        return M;
      }, S.default = S, S;
    });
  })(ty)), ty.exports;
}
var qA = UA();
const Ct = /* @__PURE__ */ bw(qA), $A = (a, n) => {
  let l = null;
  try {
    a.forEach((p) => {
      if (n(p))
        throw l = p, new Error("found");
    });
  } catch {
  }
  return l;
};
function ry(a, n, l = []) {
  n(a, l), Array.isArray(a) ? a.forEach((p, x) => ry(p, n, [...l, x])) : nw(a) ? Object.entries(a).forEach(
    ([p, x]) => ry(x, n, [...l, p])
  ) : a !== null && typeof a == "object" && Ct.warn(`forEachDeep: unknown collection type (${a}), path "${l.join(".")}"`);
}
const ZA = (a) => {
  const n = ["shape_markers"], l = a.settings.controlsUiEnabledByDefault;
  ry(a, (p, x) => {
    const M = x.at(2);
    if (x.length === 4 && x.at(-1) === "uiEnabled") {
      if (n.includes(M))
        return;
      NA(a, x, l);
    }
  });
}, ny = () => Qs(gk), HA = !1;
var Jy = Array.isArray, YA = Array.prototype.indexOf, Yg = Array.from, ww = Object.defineProperty, gf = Object.getOwnPropertyDescriptor, WA = Object.getOwnPropertyDescriptors, XA = Object.prototype, JA = Array.prototype, Ew = Object.getPrototypeOf, mb = Object.isExtensible;
function KA(a) {
  return typeof a == "function";
}
const Ua = () => {
};
function QA(a) {
  for (var n = 0; n < a.length; n++)
    a[n]();
}
function Sw() {
  var a, n, l = new Promise((p, x) => {
    a = p, n = x;
  });
  return { promise: l, resolve: a, reject: n };
}
function Tg(a, n) {
  if (Array.isArray(a))
    return a;
  if (!(Symbol.iterator in a))
    return Array.from(a);
  const l = [];
  for (const p of a)
    if (l.push(p), l.length === n) break;
  return l;
}
const $i = 2, Ky = 4, Qy = 8, eL = 1 << 24, Po = 16, gl = 32, vc = 64, Wg = 128, Xa = 512, is = 1024, As = 2048, ko = 4096, Ks = 8192, Yl = 16384, Xg = 32768, uc = 65536, _b = 1 << 17, Tw = 1 << 18, Zh = 1 << 19, tL = 1 << 20, al = 1 << 25, cc = 32768, iy = 1 << 21, ev = 1 << 22, Wl = 1 << 23, mf = /* @__PURE__ */ Symbol("$state"), rL = /* @__PURE__ */ Symbol(""), Ih = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function kw(a) {
  return a === this.v;
}
function Iw(a, n) {
  return a != a ? n == n : a !== n || a !== null && typeof a == "object" || typeof a == "function";
}
function Mw(a) {
  return !Iw(a, this.v);
}
function Cw(a) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function nL() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function iL(a) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function sL() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function aL(a) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function oL() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function lL() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function uL() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function cL() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function hL() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let dL = !1;
const fL = 1, pL = 2, Pw = 4, gL = 8, mL = 16, _L = 1, yL = 2, vL = 4, xL = 1, bL = 2, rs = /* @__PURE__ */ Symbol(), wL = "http://www.w3.org/1999/xhtml";
let ss = null;
function zh(a) {
  ss = a;
}
function Aw(a) {
  return (
    /** @type {T} */
    EL().get(a)
  );
}
function Hh(a, n = !1, l) {
  ss = {
    p: ss,
    i: !1,
    c: null,
    e: null,
    s: a,
    x: null,
    l: null
  };
}
function Yh(a) {
  var n = (
    /** @type {ComponentContext} */
    ss
  ), l = n.e;
  if (l !== null) {
    n.e = null;
    for (var p of l)
      Qw(p);
  }
  return n.i = !0, ss = n.p, /** @type {T} */
  {};
}
function Lw() {
  return !0;
}
function EL(a) {
  return ss === null && Cw(), ss.c ??= new Map(SL(ss) || void 0);
}
function SL(a) {
  let n = a.p;
  for (; n !== null; ) {
    const l = n.c;
    if (l !== null)
      return l;
    n = n.p;
  }
  return null;
}
let Mh = [];
function TL() {
  var a = Mh;
  Mh = [], QA(a);
}
function Nf(a) {
  if (Mh.length === 0) {
    var n = Mh;
    queueMicrotask(() => {
      n === Mh && TL();
    });
  }
  Mh.push(a);
}
function kL() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function IL() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
function nf(a) {
  if (typeof a != "object" || a === null || mf in a)
    return a;
  const n = Ew(a);
  if (n !== XA && n !== JA)
    return a;
  var l = /* @__PURE__ */ new Map(), p = Jy(a), x = /* @__PURE__ */ yo(0), M = ac, S = (u) => {
    if (ac === M)
      return u();
    var R = zr, z = ac;
    Cs(null), Eb(M);
    var U = u();
    return Cs(R), Eb(z), U;
  };
  return p && l.set("length", /* @__PURE__ */ yo(
    /** @type {any[]} */
    a.length
  )), new Proxy(
    /** @type {any} */
    a,
    {
      defineProperty(u, R, z) {
        (!("value" in z) || z.configurable === !1 || z.enumerable === !1 || z.writable === !1) && lL();
        var U = l.get(R);
        return U === void 0 ? U = S(() => {
          var $ = /* @__PURE__ */ yo(z.value);
          return l.set(R, $), $;
        }) : ms(U, z.value, !0), !0;
      },
      deleteProperty(u, R) {
        var z = l.get(R);
        if (z === void 0) {
          if (R in u) {
            const U = S(() => /* @__PURE__ */ yo(rs));
            l.set(R, U), _f(x);
          }
        } else
          ms(z, rs), _f(x);
        return !0;
      },
      get(u, R, z) {
        if (R === mf)
          return a;
        var U = l.get(R), $ = R in u;
        if (U === void 0 && (!$ || gf(u, R)?.writable) && (U = S(() => {
          var le = nf($ ? u[R] : rs), ce = /* @__PURE__ */ yo(le);
          return ce;
        }), l.set(R, U)), U !== void 0) {
          var ee = dr(U);
          return ee === rs ? void 0 : ee;
        }
        return Reflect.get(u, R, z);
      },
      getOwnPropertyDescriptor(u, R) {
        var z = Reflect.getOwnPropertyDescriptor(u, R);
        if (z && "value" in z) {
          var U = l.get(R);
          U && (z.value = dr(U));
        } else if (z === void 0) {
          var $ = l.get(R), ee = $?.v;
          if ($ !== void 0 && ee !== rs)
            return {
              enumerable: !0,
              configurable: !0,
              value: ee,
              writable: !0
            };
        }
        return z;
      },
      has(u, R) {
        if (R === mf)
          return !0;
        var z = l.get(R), U = z !== void 0 && z.v !== rs || Reflect.has(u, R);
        if (z !== void 0 || Yr !== null && (!U || gf(u, R)?.writable)) {
          z === void 0 && (z = S(() => {
            var ee = U ? nf(u[R]) : rs, le = /* @__PURE__ */ yo(ee);
            return le;
          }), l.set(R, z));
          var $ = dr(z);
          if ($ === rs)
            return !1;
        }
        return U;
      },
      set(u, R, z, U) {
        var $ = l.get(R), ee = R in u;
        if (p && R === "length")
          for (var le = z; le < /** @type {Source<number>} */
          $.v; le += 1) {
            var ce = l.get(le + "");
            ce !== void 0 ? ms(ce, rs) : le in u && (ce = S(() => /* @__PURE__ */ yo(rs)), l.set(le + "", ce));
          }
        if ($ === void 0)
          (!ee || gf(u, R)?.writable) && ($ = S(() => /* @__PURE__ */ yo(void 0)), ms($, nf(z)), l.set(R, $));
        else {
          ee = $.v !== rs;
          var _e = S(() => nf(z));
          ms($, _e);
        }
        var ne = Reflect.getOwnPropertyDescriptor(u, R);
        if (ne?.set && ne.set.call(U, z), !ee) {
          if (p && typeof R == "string") {
            var Pe = (
              /** @type {Source<number>} */
              l.get("length")
            ), ve = Number(R);
            Number.isInteger(ve) && ve >= Pe.v && ms(Pe, ve + 1);
          }
          _f(x);
        }
        return !0;
      },
      ownKeys(u) {
        dr(x);
        var R = Reflect.ownKeys(u).filter(($) => {
          var ee = l.get($);
          return ee === void 0 || ee.v !== rs;
        });
        for (var [z, U] of l)
          U.v !== rs && !(z in u) && R.push(z);
        return R;
      },
      setPrototypeOf() {
        uL();
      }
    }
  );
}
function yb(a) {
  try {
    if (a !== null && typeof a == "object" && mf in a)
      return a[mf];
  } catch {
  }
  return a;
}
function ML(a, n) {
  return Object.is(yb(a), yb(n));
}
var vb, Dw, Rw, Fw;
function CL() {
  if (vb === void 0) {
    vb = window, Dw = /Firefox/.test(navigator.userAgent);
    var a = Element.prototype, n = Node.prototype, l = Text.prototype;
    Rw = gf(n, "firstChild").get, Fw = gf(n, "nextSibling").get, mb(a) && (a.__click = void 0, a.__className = void 0, a.__attributes = null, a.__style = void 0, a.__e = void 0), mb(l) && (l.__t = void 0);
  }
}
function Xl(a = "") {
  return document.createTextNode(a);
}
// @__NO_SIDE_EFFECTS__
function Zl(a) {
  return (
    /** @type {TemplateNode | null} */
    Rw.call(a)
  );
}
// @__NO_SIDE_EFFECTS__
function Of(a) {
  return (
    /** @type {TemplateNode | null} */
    Fw.call(a)
  );
}
function $a(a, n) {
  return /* @__PURE__ */ Zl(a);
}
function Wa(a, n = !1) {
  {
    var l = /* @__PURE__ */ Zl(a);
    return l instanceof Comment && l.data === "" ? /* @__PURE__ */ Of(l) : l;
  }
}
function kf(a, n = 1, l = !1) {
  let p = a;
  for (; n--; )
    p = /** @type {TemplateNode} */
    /* @__PURE__ */ Of(p);
  return p;
}
function PL(a) {
  a.textContent = "";
}
function Nw() {
  return !1;
}
function Ow(a) {
  var n = Yr;
  if (n === null)
    return zr.f |= Wl, a;
  if ((n.f & Xg) === 0) {
    if ((n.f & Wg) === 0)
      throw a;
    n.b.error(a);
  } else
    Bh(a, n);
}
function Bh(a, n) {
  for (; n !== null; ) {
    if ((n.f & Wg) !== 0)
      try {
        n.b.error(a);
        return;
      } catch (l) {
        a = l;
      }
    n = n.parent;
  }
  throw a;
}
const Hp = /* @__PURE__ */ new Set();
let bn = null, fg = null, _a = null, vo = [], tv = null, sy = !1;
class bo {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #i = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #r = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #n = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#r > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(n) {
    vo = [], fg = null, this.apply();
    var l = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const p of n)
      this.#o(p, l);
    this.is_fork || this.#h(), this.is_deferred() ? (this.#l(l.effects), this.#l(l.render_effects)) : (fg = this, bn = null, xb(l.render_effects), xb(l.effects), fg = null, this.#n?.resolve()), _a = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(n, l) {
    n.f ^= is;
    for (var p = n.first; p !== null; ) {
      var x = p.f, M = (x & (gl | vc)) !== 0, S = M && (x & is) !== 0, u = S || (x & Ks) !== 0 || this.skipped_effects.has(p);
      if ((p.f & Wg) !== 0 && p.b?.is_pending() && (l = {
        parent: l,
        effect: p,
        effects: [],
        render_effects: []
      }), !u && p.fn !== null) {
        M ? p.f ^= is : (x & Ky) !== 0 ? l.effects.push(p) : Bf(p) && ((p.f & Po) !== 0 && this.#a.add(p), Mf(p));
        var R = p.first;
        if (R !== null) {
          p = R;
          continue;
        }
      }
      var z = p.parent;
      for (p = p.next; p === null && z !== null; )
        z === l.effect && (this.#l(l.effects), this.#l(l.render_effects), l = /** @type {EffectTarget} */
        l.parent), p = z.next, z = z.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #l(n) {
    for (const l of n)
      (l.f & As) !== 0 ? this.#a.add(l) : (l.f & ko) !== 0 && this.#s.add(l), this.#u(l.deps), as(l, is);
  }
  /**
   * @param {Value[] | null} deps
   */
  #u(n) {
    if (n !== null)
      for (const l of n)
        (l.f & $i) === 0 || (l.f & cc) === 0 || (l.f ^= cc, this.#u(
          /** @type {Derived} */
          l.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(n, l) {
    this.previous.has(n) || this.previous.set(n, l), (n.f & Wl) === 0 && (this.current.set(n, n.v), _a?.set(n, n.v));
  }
  activate() {
    bn = this, this.apply();
  }
  deactivate() {
    bn === this && (bn = null, _a = null);
  }
  flush() {
    if (this.activate(), vo.length > 0) {
      if (AL(), bn !== null && bn !== this)
        return;
    } else this.#i === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const n of this.#t) n(this);
    this.#t.clear();
  }
  #h() {
    if (this.#r === 0) {
      for (const n of this.#e) n();
      this.#e.clear();
    }
    this.#i === 0 && this.#c();
  }
  #c() {
    if (Hp.size > 1) {
      this.previous.clear();
      var n = _a, l = !0, p = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const M of Hp) {
        if (M === this) {
          l = !1;
          continue;
        }
        const S = [];
        for (const [R, z] of this.current) {
          if (M.current.has(R))
            if (l && z !== M.current.get(R))
              M.current.set(R, z);
            else
              continue;
          S.push(R);
        }
        if (S.length === 0)
          continue;
        const u = [...M.current.keys()].filter((R) => !this.current.has(R));
        if (u.length > 0) {
          var x = vo;
          vo = [];
          const R = /* @__PURE__ */ new Set(), z = /* @__PURE__ */ new Map();
          for (const U of S)
            zw(U, u, R, z);
          if (vo.length > 0) {
            bn = M, M.apply();
            for (const U of vo)
              M.#o(U, p);
            M.deactivate();
          }
          vo = x;
        }
      }
      bn = null, _a = n;
    }
    this.committed = !0, Hp.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(n) {
    this.#i += 1, n && (this.#r += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(n) {
    this.#i -= 1, n && (this.#r -= 1), this.revive();
  }
  revive() {
    for (const n of this.#a)
      this.#s.delete(n), as(n, As), hc(n);
    for (const n of this.#s)
      as(n, ko), hc(n);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(n) {
    this.#e.add(n);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(n) {
    this.#t.add(n);
  }
  settled() {
    return (this.#n ??= Sw()).promise;
  }
  static ensure() {
    if (bn === null) {
      const n = bn = new bo();
      Hp.add(bn), bo.enqueue(() => {
        bn === n && n.flush();
      });
    }
    return bn;
  }
  /** @param {() => void} task */
  static enqueue(n) {
    Nf(n);
  }
  apply() {
  }
}
function AL() {
  var a = sc;
  sy = !0;
  try {
    var n = 0;
    for (Ig(!0); vo.length > 0; ) {
      var l = bo.ensure();
      if (n++ > 1e3) {
        var p, x;
        LL();
      }
      l.process(vo), Jl.clear();
    }
  } finally {
    sy = !1, Ig(a), tv = null;
  }
}
function LL() {
  try {
    oL();
  } catch (a) {
    Bh(a, tv);
  }
}
let nl = null;
function xb(a) {
  var n = a.length;
  if (n !== 0) {
    for (var l = 0; l < n; ) {
      var p = a[l++];
      if ((p.f & (Yl | Ks)) === 0 && Bf(p) && (nl = /* @__PURE__ */ new Set(), Mf(p), p.deps === null && p.first === null && p.nodes === null && (p.teardown === null && p.ac === null ? s2(p) : p.fn = null), nl?.size > 0)) {
        Jl.clear();
        for (const x of nl) {
          if ((x.f & (Yl | Ks)) !== 0) continue;
          const M = [x];
          let S = x.parent;
          for (; S !== null; )
            nl.has(S) && (nl.delete(S), M.push(S)), S = S.parent;
          for (let u = M.length - 1; u >= 0; u--) {
            const R = M[u];
            (R.f & (Yl | Ks)) === 0 && Mf(R);
          }
        }
        nl.clear();
      }
    }
    nl = null;
  }
}
function zw(a, n, l, p) {
  if (!l.has(a) && (l.add(a), a.reactions !== null))
    for (const x of a.reactions) {
      const M = x.f;
      (M & $i) !== 0 ? zw(
        /** @type {Derived} */
        x,
        n,
        l,
        p
      ) : (M & (ev | Po)) !== 0 && (M & As) === 0 && Bw(x, n, p) && (as(x, As), hc(
        /** @type {Effect} */
        x
      ));
    }
}
function Bw(a, n, l) {
  const p = l.get(a);
  if (p !== void 0) return p;
  if (a.deps !== null)
    for (const x of a.deps) {
      if (n.includes(x))
        return !0;
      if ((x.f & $i) !== 0 && Bw(
        /** @type {Derived} */
        x,
        n,
        l
      ))
        return l.set(
          /** @type {Derived} */
          x,
          !0
        ), !0;
    }
  return l.set(a, !1), !1;
}
function hc(a) {
  for (var n = tv = a; n.parent !== null; ) {
    n = n.parent;
    var l = n.f;
    if (sy && n === Yr && (l & Po) !== 0 && (l & Tw) === 0)
      return;
    if ((l & (vc | gl)) !== 0) {
      if ((l & is) === 0) return;
      n.f ^= is;
    }
  }
  vo.push(n);
}
function DL(a) {
  let n = 0, l = dc(0), p;
  return () => {
    Cf() && (dr(l), t2(() => (n === 0 && (p = Gf(() => a(() => _f(l)))), n += 1, () => {
      Nf(() => {
        n -= 1, n === 0 && (p?.(), p = void 0, _f(l));
      });
    })));
  };
}
var RL = uc | Zh | Wg;
function FL(a, n, l) {
  new NL(a, n, l);
}
class NL {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #i = null;
  /** @type {BoundaryProps} */
  #r;
  /** @type {((anchor: Node) => void)} */
  #n;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #s = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #l = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #h = null;
  #c = 0;
  #d = 0;
  #f = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #p = null;
  #g = DL(() => (this.#p = dc(this.#c), () => {
    this.#p = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(n, l, p) {
    this.#t = n, this.#r = l, this.#n = p, this.parent = /** @type {Effect} */
    Yr.b, this.#e = !!this.#r.pending, this.#a = sv(() => {
      Yr.b = this;
      {
        var x = this.#v();
        try {
          this.#s = ja(() => p(x));
        } catch (M) {
          this.error(M);
        }
        this.#d > 0 ? this.#_() : this.#e = !1;
      }
      return () => {
        this.#h?.remove();
      };
    }, RL);
  }
  #y() {
    try {
      this.#s = ja(() => this.#n(this.#t));
    } catch (n) {
      this.error(n);
    }
    this.#e = !1;
  }
  #b() {
    const n = this.#r.pending;
    n && (this.#o = ja(() => n(this.#t)), bo.enqueue(() => {
      var l = this.#v();
      this.#s = this.#m(() => (bo.ensure(), ja(() => this.#n(l)))), this.#d > 0 ? this.#_() : (oc(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #v() {
    var n = this.#t;
    return this.#e && (this.#h = Xl(), this.#t.before(this.#h), n = this.#h), n;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#r.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(n) {
    var l = Yr, p = zr, x = ss;
    Io(this.#a), Cs(this.#a), zh(this.#a.ctx);
    try {
      return n();
    } catch (M) {
      return Ow(M), null;
    } finally {
      Io(l), Cs(p), zh(x);
    }
  }
  #_() {
    const n = (
      /** @type {(anchor: Node) => void} */
      this.#r.pending
    );
    this.#s !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#h
    ), l2(this.#s, this.#u)), this.#o === null && (this.#o = ja(() => n(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #x(n) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#x(n);
      return;
    }
    this.#d += n, this.#d === 0 && (this.#e = !1, this.#o && oc(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#t.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(n) {
    this.#x(n), this.#c += n, this.#p && Gh(this.#p, this.#c);
  }
  get_effect_pending() {
    return this.#g(), dr(
      /** @type {Source<number>} */
      this.#p
    );
  }
  /** @param {unknown} error */
  error(n) {
    var l = this.#r.onerror;
    let p = this.#r.failed;
    if (this.#f || !l && !p)
      throw n;
    this.#s && (Ps(this.#s), this.#s = null), this.#o && (Ps(this.#o), this.#o = null), this.#l && (Ps(this.#l), this.#l = null);
    var x = !1, M = !1;
    const S = () => {
      if (x) {
        IL();
        return;
      }
      x = !0, M && hL(), bo.ensure(), this.#c = 0, this.#l !== null && oc(this.#l, () => {
        this.#l = null;
      }), this.#e = this.has_pending_snippet(), this.#s = this.#m(() => (this.#f = !1, ja(() => this.#n(this.#t)))), this.#d > 0 ? this.#_() : this.#e = !1;
    };
    var u = zr;
    try {
      Cs(null), M = !0, l?.(n, S), M = !1;
    } catch (R) {
      Bh(R, this.#a && this.#a.parent);
    } finally {
      Cs(u);
    }
    p && Nf(() => {
      this.#l = this.#m(() => {
        bo.ensure(), this.#f = !0;
        try {
          return ja(() => {
            p(
              this.#t,
              () => n,
              () => S
            );
          });
        } catch (R) {
          return Bh(
            R,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#f = !1;
        }
      });
    });
  }
}
function OL(a, n, l, p) {
  const x = rv;
  if (l.length === 0 && a.length === 0) {
    p(n.map(x));
    return;
  }
  var M = bn, S = (
    /** @type {Effect} */
    Yr
  ), u = zL();
  function R() {
    Promise.all(l.map((z) => /* @__PURE__ */ BL(z))).then((z) => {
      u();
      try {
        p([...n.map(x), ...z]);
      } catch (U) {
        (S.f & Yl) === 0 && Bh(U, S);
      }
      M?.deactivate(), kg();
    }).catch((z) => {
      Bh(z, S);
    });
  }
  a.length > 0 ? Promise.all(a).then(() => {
    u();
    try {
      return R();
    } finally {
      M?.deactivate(), kg();
    }
  }) : R();
}
function zL() {
  var a = Yr, n = zr, l = ss, p = bn;
  return function(x = !0) {
    Io(a), Cs(n), zh(l), x && p?.activate();
  };
}
function kg() {
  Io(null), Cs(null), zh(null);
}
// @__NO_SIDE_EFFECTS__
function rv(a) {
  var n = $i | As, l = zr !== null && (zr.f & $i) !== 0 ? (
    /** @type {Derived} */
    zr
  ) : null;
  return Yr !== null && (Yr.f |= Zh), {
    ctx: ss,
    deps: null,
    effects: null,
    equals: kw,
    f: n,
    fn: a,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      rs
    ),
    wv: 0,
    parent: l ?? Yr,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function BL(a, n) {
  let l = (
    /** @type {Effect | null} */
    Yr
  );
  l === null && nL();
  var p = (
    /** @type {Boundary} */
    l.b
  ), x = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), M = dc(
    /** @type {V} */
    rs
  ), S = !zr, u = /* @__PURE__ */ new Map();
  return JL(() => {
    var R = Sw();
    x = R.promise;
    try {
      Promise.resolve(a()).then(R.resolve, R.reject).then(() => {
        z === bn && z.committed && z.deactivate(), kg();
      });
    } catch (ee) {
      R.reject(ee), kg();
    }
    var z = (
      /** @type {Batch} */
      bn
    );
    if (S) {
      var U = !p.is_pending();
      p.update_pending_count(1), z.increment(U), u.get(z)?.reject(Ih), u.delete(z), u.set(z, R);
    }
    const $ = (ee, le = void 0) => {
      if (z.activate(), le)
        le !== Ih && (M.f |= Wl, Gh(M, le));
      else {
        (M.f & Wl) !== 0 && (M.f ^= Wl), Gh(M, ee);
        for (const [ce, _e] of u) {
          if (u.delete(ce), ce === z) break;
          _e.reject(Ih);
        }
      }
      S && (p.update_pending_count(-1), z.decrement(U));
    };
    R.promise.then($, (ee) => $(null, ee || "unknown"));
  }), iv(() => {
    for (const R of u.values())
      R.reject(Ih);
  }), new Promise((R) => {
    function z(U) {
      function $() {
        U === x ? R(M) : z(x);
      }
      U.then($, $);
    }
    z(x);
  });
}
// @__NO_SIDE_EFFECTS__
function qa(a) {
  const n = /* @__PURE__ */ rv(a);
  return Zw(n), n;
}
// @__NO_SIDE_EFFECTS__
function GL(a) {
  const n = /* @__PURE__ */ rv(a);
  return n.equals = Mw, n;
}
function Gw(a) {
  var n = a.effects;
  if (n !== null) {
    a.effects = null;
    for (var l = 0; l < n.length; l += 1)
      Ps(
        /** @type {Effect} */
        n[l]
      );
  }
}
function jL(a) {
  for (var n = a.parent; n !== null; ) {
    if ((n.f & $i) === 0)
      return (n.f & Yl) === 0 ? (
        /** @type {Effect} */
        n
      ) : null;
    n = n.parent;
  }
  return null;
}
function nv(a) {
  var n, l = Yr;
  Io(jL(a));
  try {
    a.f &= ~cc, Gw(a), n = Xw(a);
  } finally {
    Io(l);
  }
  return n;
}
function jw(a) {
  var n = nv(a);
  if (a.equals(n) || (bn?.is_fork || (a.v = n), a.wv = Yw()), !Wh)
    if (_a !== null)
      (Cf() || bn?.is_fork) && _a.set(a, n);
    else {
      var l = (a.f & Xa) === 0 ? ko : is;
      as(a, l);
    }
}
let ay = /* @__PURE__ */ new Set();
const Jl = /* @__PURE__ */ new Map();
let Vw = !1;
function dc(a, n) {
  var l = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: a,
    reactions: null,
    equals: kw,
    rv: 0,
    wv: 0
  };
  return l;
}
// @__NO_SIDE_EFFECTS__
function yo(a, n) {
  const l = dc(a);
  return Zw(l), l;
}
// @__NO_SIDE_EFFECTS__
function Uw(a, n = !1, l = !0) {
  const p = dc(a);
  return n || (p.equals = Mw), p;
}
function ms(a, n, l = !1) {
  zr !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!wo || (zr.f & _b) !== 0) && Lw() && (zr.f & ($i | Po | ev | _b)) !== 0 && !ll?.includes(a) && cL();
  let p = l ? nf(n) : n;
  return Gh(a, p);
}
function Gh(a, n) {
  if (!a.equals(n)) {
    var l = a.v;
    Wh ? Jl.set(a, n) : Jl.set(a, l), a.v = n;
    var p = bo.ensure();
    p.capture(a, l), (a.f & $i) !== 0 && ((a.f & As) !== 0 && nv(
      /** @type {Derived} */
      a
    ), as(a, (a.f & Xa) !== 0 ? is : ko)), a.wv = Yw(), qw(a, As), Yr !== null && (Yr.f & is) !== 0 && (Yr.f & (gl | vc)) === 0 && (ga === null ? qL([a]) : ga.push(a)), !p.is_fork && ay.size > 0 && !Vw && VL();
  }
  return n;
}
function VL() {
  Vw = !1;
  var a = sc;
  Ig(!0);
  const n = Array.from(ay);
  try {
    for (const l of n)
      (l.f & is) !== 0 && as(l, ko), Bf(l) && Mf(l);
  } finally {
    Ig(a);
  }
  ay.clear();
}
function _f(a) {
  ms(a, a.v + 1);
}
function qw(a, n) {
  var l = a.reactions;
  if (l !== null)
    for (var p = l.length, x = 0; x < p; x++) {
      var M = l[x], S = M.f, u = (S & As) === 0;
      if (u && as(M, n), (S & $i) !== 0) {
        var R = (
          /** @type {Derived} */
          M
        );
        _a?.delete(R), (S & cc) === 0 && (S & Xa && (M.f |= cc), qw(R, ko));
      } else u && ((S & Po) !== 0 && nl !== null && nl.add(
        /** @type {Effect} */
        M
      ), hc(
        /** @type {Effect} */
        M
      ));
    }
}
let bb = !1;
function UL() {
  bb || (bb = !0, document.addEventListener(
    "reset",
    (a) => {
      Promise.resolve().then(() => {
        if (!a.defaultPrevented)
          for (
            const n of
            /**@type {HTMLFormElement} */
            a.target.elements
          )
            n.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
    { capture: !0 }
  ));
}
function zf(a) {
  var n = zr, l = Yr;
  Cs(null), Io(null);
  try {
    return a();
  } finally {
    Cs(n), Io(l);
  }
}
function $w(a, n, l, p = l) {
  a.addEventListener(n, () => zf(l));
  const x = a.__on_r;
  x ? a.__on_r = () => {
    x(), p(!0);
  } : a.__on_r = () => p(!0), UL();
}
let sc = !1;
function Ig(a) {
  sc = a;
}
let Wh = !1;
function wb(a) {
  Wh = a;
}
let zr = null, wo = !1;
function Cs(a) {
  zr = a;
}
let Yr = null;
function Io(a) {
  Yr = a;
}
let ll = null;
function Zw(a) {
  zr !== null && (ll === null ? ll = [a] : ll.push(a));
}
let gs = null, Ys = 0, ga = null;
function qL(a) {
  ga = a;
}
let Hw = 1, If = 0, ac = If;
function Eb(a) {
  ac = a;
}
function Yw() {
  return ++Hw;
}
function Bf(a) {
  var n = a.f;
  if ((n & As) !== 0)
    return !0;
  if (n & $i && (a.f &= ~cc), (n & ko) !== 0) {
    var l = a.deps;
    if (l !== null)
      for (var p = l.length, x = 0; x < p; x++) {
        var M = l[x];
        if (Bf(
          /** @type {Derived} */
          M
        ) && jw(
          /** @type {Derived} */
          M
        ), M.wv > a.wv)
          return !0;
      }
    (n & Xa) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    _a === null && as(a, is);
  }
  return !1;
}
function Ww(a, n, l = !0) {
  var p = a.reactions;
  if (p !== null && !ll?.includes(a))
    for (var x = 0; x < p.length; x++) {
      var M = p[x];
      (M.f & $i) !== 0 ? Ww(
        /** @type {Derived} */
        M,
        n,
        !1
      ) : n === M && (l ? as(M, As) : (M.f & is) !== 0 && as(M, ko), hc(
        /** @type {Effect} */
        M
      ));
    }
}
function Xw(a) {
  var n = gs, l = Ys, p = ga, x = zr, M = ll, S = ss, u = wo, R = ac, z = a.f;
  gs = /** @type {null | Value[]} */
  null, Ys = 0, ga = null, zr = (z & (gl | vc)) === 0 ? a : null, ll = null, zh(a.ctx), wo = !1, ac = ++If, a.ac !== null && (zf(() => {
    a.ac.abort(Ih);
  }), a.ac = null);
  try {
    a.f |= iy;
    var U = (
      /** @type {Function} */
      a.fn
    ), $ = U(), ee = a.deps;
    if (gs !== null) {
      var le;
      if (Mg(a, Ys), ee !== null && Ys > 0)
        for (ee.length = Ys + gs.length, le = 0; le < gs.length; le++)
          ee[Ys + le] = gs[le];
      else
        a.deps = ee = gs;
      if (Cf() && (a.f & Xa) !== 0)
        for (le = Ys; le < ee.length; le++)
          (ee[le].reactions ??= []).push(a);
    } else ee !== null && Ys < ee.length && (Mg(a, Ys), ee.length = Ys);
    if (Lw() && ga !== null && !wo && ee !== null && (a.f & ($i | ko | As)) === 0)
      for (le = 0; le < /** @type {Source[]} */
      ga.length; le++)
        Ww(
          ga[le],
          /** @type {Effect} */
          a
        );
    return x !== null && x !== a && (If++, ga !== null && (p === null ? p = ga : p.push(.../** @type {Source[]} */
    ga))), (a.f & Wl) !== 0 && (a.f ^= Wl), $;
  } catch (ce) {
    return Ow(ce);
  } finally {
    a.f ^= iy, gs = n, Ys = l, ga = p, zr = x, ll = M, zh(S), wo = u, ac = R;
  }
}
function $L(a, n) {
  let l = n.reactions;
  if (l !== null) {
    var p = YA.call(l, a);
    if (p !== -1) {
      var x = l.length - 1;
      x === 0 ? l = n.reactions = null : (l[p] = l[x], l.pop());
    }
  }
  l === null && (n.f & $i) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (gs === null || !gs.includes(n)) && (as(n, ko), (n.f & Xa) !== 0 && (n.f ^= Xa, n.f &= ~cc), Gw(
    /** @type {Derived} **/
    n
  ), Mg(
    /** @type {Derived} **/
    n,
    0
  ));
}
function Mg(a, n) {
  var l = a.deps;
  if (l !== null)
    for (var p = n; p < l.length; p++)
      $L(a, l[p]);
}
function Mf(a) {
  var n = a.f;
  if ((n & Yl) === 0) {
    as(a, is);
    var l = Yr, p = sc;
    Yr = a, sc = !0;
    try {
      (n & (Po | eL)) !== 0 ? KL(a) : n2(a), r2(a);
      var x = Xw(a);
      a.teardown = typeof x == "function" ? x : null, a.wv = Hw;
      var M;
      HA && dL && (a.f & As) !== 0 && a.deps;
    } finally {
      sc = p, Yr = l;
    }
  }
}
function dr(a) {
  var n = a.f, l = (n & $i) !== 0;
  if (zr !== null && !wo) {
    var p = Yr !== null && (Yr.f & Yl) !== 0;
    if (!p && !ll?.includes(a)) {
      var x = zr.deps;
      if ((zr.f & iy) !== 0)
        a.rv < If && (a.rv = If, gs === null && x !== null && x[Ys] === a ? Ys++ : gs === null ? gs = [a] : gs.includes(a) || gs.push(a));
      else {
        (zr.deps ??= []).push(a);
        var M = a.reactions;
        M === null ? a.reactions = [zr] : M.includes(zr) || M.push(zr);
      }
    }
  }
  if (Wh) {
    if (Jl.has(a))
      return Jl.get(a);
    if (l) {
      var S = (
        /** @type {Derived} */
        a
      ), u = S.v;
      return ((S.f & is) === 0 && S.reactions !== null || Kw(S)) && (u = nv(S)), Jl.set(S, u), u;
    }
  } else l && (!_a?.has(a) || bn?.is_fork && !Cf()) && (S = /** @type {Derived} */
  a, Bf(S) && jw(S), sc && Cf() && (S.f & Xa) === 0 && Jw(S));
  if (_a?.has(a))
    return _a.get(a);
  if ((a.f & Wl) !== 0)
    throw a.v;
  return a.v;
}
function Jw(a) {
  if (a.deps !== null) {
    a.f ^= Xa;
    for (const n of a.deps)
      (n.reactions ??= []).push(a), (n.f & $i) !== 0 && (n.f & Xa) === 0 && Jw(
        /** @type {Derived} */
        n
      );
  }
}
function Kw(a) {
  if (a.v === rs) return !0;
  if (a.deps === null) return !1;
  for (const n of a.deps)
    if (Jl.has(n) || (n.f & $i) !== 0 && Kw(
      /** @type {Derived} */
      n
    ))
      return !0;
  return !1;
}
function Gf(a) {
  var n = wo;
  try {
    return wo = !0, a();
  } finally {
    wo = n;
  }
}
const ZL = -7169;
function as(a, n) {
  a.f = a.f & ZL | n;
}
function HL(a) {
  Yr === null && (zr === null && aL(), sL()), Wh && iL();
}
function YL(a, n) {
  var l = n.last;
  l === null ? n.last = n.first = a : (l.next = a, a.prev = l, n.last = a);
}
function ml(a, n, l) {
  var p = Yr;
  p !== null && (p.f & Ks) !== 0 && (a |= Ks);
  var x = {
    ctx: ss,
    deps: null,
    nodes: null,
    f: a | As | Xa,
    first: null,
    fn: n,
    last: null,
    next: null,
    parent: p,
    b: p && p.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (l)
    try {
      Mf(x), x.f |= Xg;
    } catch (u) {
      throw Ps(x), u;
    }
  else n !== null && hc(x);
  var M = x;
  if (l && M.deps === null && M.teardown === null && M.nodes === null && M.first === M.last && // either `null`, or a singular child
  (M.f & Zh) === 0 && (M = M.first, (a & Po) !== 0 && (a & uc) !== 0 && M !== null && (M.f |= uc)), M !== null && (M.parent = p, p !== null && YL(M, p), zr !== null && (zr.f & $i) !== 0 && (a & vc) === 0)) {
    var S = (
      /** @type {Derived} */
      zr
    );
    (S.effects ??= []).push(M);
  }
  return x;
}
function Cf() {
  return zr !== null && !wo;
}
function iv(a) {
  const n = ml(Qy, null, !1);
  return as(n, is), n.teardown = a, n;
}
function WL(a) {
  HL();
  var n = (
    /** @type {Effect} */
    Yr.f
  ), l = !zr && (n & gl) !== 0 && (n & Xg) === 0;
  if (l) {
    var p = (
      /** @type {ComponentContext} */
      ss
    );
    (p.e ??= []).push(a);
  } else
    return Qw(a);
}
function Qw(a) {
  return ml(Ky | tL, a, !1);
}
function XL(a) {
  bo.ensure();
  const n = ml(vc | Zh, a, !0);
  return (l = {}) => new Promise((p) => {
    l.outro ? oc(n, () => {
      Ps(n), p(void 0);
    }) : (Ps(n), p(void 0));
  });
}
function e2(a) {
  return ml(Ky, a, !1);
}
function JL(a) {
  return ml(ev | Zh, a, !0);
}
function t2(a, n = 0) {
  return ml(Qy | n, a, !0);
}
function Za(a, n = [], l = [], p = []) {
  OL(p, n, l, (x) => {
    ml(Qy, () => a(...x.map(dr)), !0);
  });
}
function sv(a, n = 0) {
  var l = ml(Po | n, a, !0);
  return l;
}
function ja(a) {
  return ml(gl | Zh, a, !0);
}
function r2(a) {
  var n = a.teardown;
  if (n !== null) {
    const l = Wh, p = zr;
    wb(!0), Cs(null);
    try {
      n.call(null);
    } finally {
      wb(l), Cs(p);
    }
  }
}
function n2(a, n = !1) {
  var l = a.first;
  for (a.first = a.last = null; l !== null; ) {
    const x = l.ac;
    x !== null && zf(() => {
      x.abort(Ih);
    });
    var p = l.next;
    (l.f & vc) !== 0 ? l.parent = null : Ps(l, n), l = p;
  }
}
function KL(a) {
  for (var n = a.first; n !== null; ) {
    var l = n.next;
    (n.f & gl) === 0 && Ps(n), n = l;
  }
}
function Ps(a, n = !0) {
  var l = !1;
  (n || (a.f & Tw) !== 0) && a.nodes !== null && a.nodes.end !== null && (i2(
    a.nodes.start,
    /** @type {TemplateNode} */
    a.nodes.end
  ), l = !0), n2(a, n && !l), Mg(a, 0), as(a, Yl);
  var p = a.nodes && a.nodes.t;
  if (p !== null)
    for (const M of p)
      M.stop();
  r2(a);
  var x = a.parent;
  x !== null && x.first !== null && s2(a), a.next = a.prev = a.teardown = a.ctx = a.deps = a.fn = a.nodes = a.ac = null;
}
function i2(a, n) {
  for (; a !== null; ) {
    var l = a === n ? null : /* @__PURE__ */ Of(a);
    a.remove(), a = l;
  }
}
function s2(a) {
  var n = a.parent, l = a.prev, p = a.next;
  l !== null && (l.next = p), p !== null && (p.prev = l), n !== null && (n.first === a && (n.first = p), n.last === a && (n.last = l));
}
function oc(a, n, l = !0) {
  var p = [];
  a2(a, p, !0);
  var x = () => {
    l && Ps(a), n && n();
  }, M = p.length;
  if (M > 0) {
    var S = () => --M || x();
    for (var u of p)
      u.out(S);
  } else
    x();
}
function a2(a, n, l) {
  if ((a.f & Ks) === 0) {
    a.f ^= Ks;
    var p = a.nodes && a.nodes.t;
    if (p !== null)
      for (const u of p)
        (u.is_global || l) && n.push(u);
    for (var x = a.first; x !== null; ) {
      var M = x.next, S = (x.f & uc) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (x.f & gl) !== 0 && (a.f & Po) !== 0;
      a2(x, n, S ? l : !1), x = M;
    }
  }
}
function av(a) {
  o2(a, !0);
}
function o2(a, n) {
  if ((a.f & Ks) !== 0) {
    a.f ^= Ks, (a.f & is) === 0 && (as(a, As), hc(a));
    for (var l = a.first; l !== null; ) {
      var p = l.next, x = (l.f & uc) !== 0 || (l.f & gl) !== 0;
      o2(l, x ? n : !1), l = p;
    }
    var M = a.nodes && a.nodes.t;
    if (M !== null)
      for (const S of M)
        (S.is_global || n) && S.in();
  }
}
function l2(a, n) {
  if (a.nodes)
    for (var l = a.nodes.start, p = a.nodes.end; l !== null; ) {
      var x = l === p ? null : /* @__PURE__ */ Of(l);
      n.append(l), l = x;
    }
}
const QL = ["touchstart", "touchmove"];
function eD(a) {
  return QL.includes(a);
}
const u2 = /* @__PURE__ */ new Set(), oy = /* @__PURE__ */ new Set();
function Jg(a) {
  for (var n = 0; n < a.length; n++)
    u2.add(a[n]);
  for (var l of oy)
    l(a);
}
let Sb = null;
function Yp(a) {
  var n = this, l = (
    /** @type {Node} */
    n.ownerDocument
  ), p = a.type, x = a.composedPath?.() || [], M = (
    /** @type {null | Element} */
    x[0] || a.target
  );
  Sb = a;
  var S = 0, u = Sb === a && a.__root;
  if (u) {
    var R = x.indexOf(u);
    if (R !== -1 && (n === document || n === /** @type {any} */
    window)) {
      a.__root = n;
      return;
    }
    var z = x.indexOf(n);
    if (z === -1)
      return;
    R <= z && (S = R);
  }
  if (M = /** @type {Element} */
  x[S] || a.target, M !== n) {
    ww(a, "currentTarget", {
      configurable: !0,
      get() {
        return M || l;
      }
    });
    var U = zr, $ = Yr;
    Cs(null), Io(null);
    try {
      for (var ee, le = []; M !== null; ) {
        var ce = M.assignedSlot || M.parentNode || /** @type {any} */
        M.host || null;
        try {
          var _e = M["__" + p];
          _e != null && (!/** @type {any} */
          M.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          a.target === M) && _e.call(M, a);
        } catch (ne) {
          ee ? le.push(ne) : ee = ne;
        }
        if (a.cancelBubble || ce === n || ce === null)
          break;
        M = ce;
      }
      if (ee) {
        for (let ne of le)
          queueMicrotask(() => {
            throw ne;
          });
        throw ee;
      }
    } finally {
      a.__root = n, delete a.currentTarget, Cs(U), Io($);
    }
  }
}
function c2(a) {
  var n = document.createElement("template");
  return n.innerHTML = a.replaceAll("<!>", "<!---->"), n.content;
}
function Pf(a, n) {
  var l = (
    /** @type {Effect} */
    Yr
  );
  l.nodes === null && (l.nodes = { start: a, end: n, a: null, t: null });
}
// @__NO_SIDE_EFFECTS__
function xa(a, n) {
  var l = (n & xL) !== 0, p = (n & bL) !== 0, x, M = !a.startsWith("<!>");
  return () => {
    x === void 0 && (x = c2(M ? a : "<!>" + a), l || (x = /** @type {TemplateNode} */
    /* @__PURE__ */ Zl(x)));
    var S = (
      /** @type {TemplateNode} */
      p || Dw ? document.importNode(x, !0) : x.cloneNode(!0)
    );
    if (l) {
      var u = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Zl(S)
      ), R = (
        /** @type {TemplateNode} */
        S.lastChild
      );
      Pf(u, R);
    } else
      Pf(S, S);
    return S;
  };
}
function Tb(a = "") {
  {
    var n = Xl(a + "");
    return Pf(n, n), n;
  }
}
function ul() {
  var a = document.createDocumentFragment(), n = document.createComment(""), l = Xl();
  return a.append(n, l), Pf(n, l), a;
}
function zn(a, n) {
  a !== null && a.before(
    /** @type {Node} */
    n
  );
}
let ly = !0;
function Lh(a, n) {
  var l = n == null ? "" : typeof n == "object" ? n + "" : n;
  l !== (a.__t ??= a.nodeValue) && (a.__t = l, a.nodeValue = l + "");
}
function tD(a, n) {
  return rD(a, n);
}
const bh = /* @__PURE__ */ new Map();
function rD(a, { target: n, anchor: l, props: p = {}, events: x, context: M, intro: S = !0 }) {
  CL();
  var u = /* @__PURE__ */ new Set(), R = ($) => {
    for (var ee = 0; ee < $.length; ee++) {
      var le = $[ee];
      if (!u.has(le)) {
        u.add(le);
        var ce = eD(le);
        n.addEventListener(le, Yp, { passive: ce });
        var _e = bh.get(le);
        _e === void 0 ? (document.addEventListener(le, Yp, { passive: ce }), bh.set(le, 1)) : bh.set(le, _e + 1);
      }
    }
  };
  R(Yg(u2)), oy.add(R);
  var z = void 0, U = XL(() => {
    var $ = l ?? n.appendChild(Xl());
    return FL(
      /** @type {TemplateNode} */
      $,
      {
        pending: () => {
        }
      },
      (ee) => {
        if (M) {
          Hh({});
          var le = (
            /** @type {ComponentContext} */
            ss
          );
          le.c = M;
        }
        x && (p.$$events = x), ly = S, z = a(ee, p) || {}, ly = !0, M && Yh();
      }
    ), () => {
      for (var ee of u) {
        n.removeEventListener(ee, Yp);
        var le = (
          /** @type {number} */
          bh.get(ee)
        );
        --le === 0 ? (document.removeEventListener(ee, Yp), bh.delete(ee)) : bh.set(ee, le);
      }
      oy.delete(R), $ !== l && $.parentNode?.removeChild($);
    };
  });
  return uy.set(z, U), z;
}
let uy = /* @__PURE__ */ new WeakMap();
function nD(a, n) {
  const l = uy.get(a);
  return l ? (uy.delete(a), l(n)) : Promise.resolve();
}
class iD {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /**
   * Map of keys to effects that are currently rendered in the DOM.
   * These effects are visible and actively part of the document tree.
   * Example:
   * ```
   * {#if condition}
   * 	foo
   * {:else}
   * 	bar
   * {/if}
   * ```
   * Can result in the entries `true->Effect` and `false->Effect`
   * @type {Map<Key, Effect>}
   */
  #t = /* @__PURE__ */ new Map();
  /**
   * Similar to #onscreen with respect to the keys, but contains branches that are not yet
   * in the DOM, because their insertion is deferred.
   * @type {Map<Key, Branch>}
   */
  #i = /* @__PURE__ */ new Map();
  /**
   * Keys of effects that are currently outroing
   * @type {Set<Key>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(n, l = !0) {
    this.anchor = n, this.#n = l;
  }
  #a = () => {
    var n = (
      /** @type {Batch} */
      bn
    );
    if (this.#e.has(n)) {
      var l = (
        /** @type {Key} */
        this.#e.get(n)
      ), p = this.#t.get(l);
      if (p)
        av(p), this.#r.delete(l);
      else {
        var x = this.#i.get(l);
        x && (this.#t.set(l, x.effect), this.#i.delete(l), x.fragment.lastChild.remove(), this.anchor.before(x.fragment), p = x.effect);
      }
      for (const [M, S] of this.#e) {
        if (this.#e.delete(M), M === n)
          break;
        const u = this.#i.get(S);
        u && (Ps(u.effect), this.#i.delete(S));
      }
      for (const [M, S] of this.#t) {
        if (M === l || this.#r.has(M)) continue;
        const u = () => {
          if (Array.from(this.#e.values()).includes(M)) {
            var R = document.createDocumentFragment();
            l2(S, R), R.append(Xl()), this.#i.set(M, { effect: S, fragment: R });
          } else
            Ps(S);
          this.#r.delete(M), this.#t.delete(M);
        };
        this.#n || !p ? (this.#r.add(M), oc(S, u, !1)) : u();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #s = (n) => {
    this.#e.delete(n);
    const l = Array.from(this.#e.values());
    for (const [p, x] of this.#i)
      l.includes(p) || (Ps(x.effect), this.#i.delete(p));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(n, l) {
    var p = (
      /** @type {Batch} */
      bn
    ), x = Nw();
    l && !this.#t.has(n) && !this.#i.has(n) && this.#t.set(
      n,
      ja(() => l(this.anchor))
    ), this.#e.set(p, n), x || this.#a();
  }
}
function Xs(a, n, l = !1) {
  var p = new iD(a), x = l ? uc : 0;
  function M(S, u) {
    p.ensure(S, u);
  }
  sv(() => {
    var S = !1;
    n((u, R = !0) => {
      S = !0, M(R, u);
    }), S || M(!1, null);
  }, x);
}
function sD(a, n) {
  return n;
}
function aD(a, n, l) {
  for (var p = [], x = n.length, M, S = n.length, u = 0; u < x; u++) {
    let $ = n[u];
    oc(
      $,
      () => {
        if (M) {
          if (M.pending.delete($), M.done.add($), M.pending.size === 0) {
            var ee = (
              /** @type {Set<EachOutroGroup>} */
              a.outrogroups
            );
            cy(Yg(M.done)), ee.delete(M), ee.size === 0 && (a.outrogroups = null);
          }
        } else
          S -= 1;
      },
      !1
    );
  }
  if (S === 0) {
    var R = p.length === 0 && l !== null;
    if (R) {
      var z = (
        /** @type {Element} */
        l
      ), U = (
        /** @type {Element} */
        z.parentNode
      );
      PL(U), U.append(z), a.items.clear();
    }
    cy(n, !R);
  } else
    M = {
      pending: new Set(n),
      done: /* @__PURE__ */ new Set()
    }, (a.outrogroups ??= /* @__PURE__ */ new Set()).add(M);
}
function cy(a, n = !0) {
  for (var l = 0; l < a.length; l++)
    Ps(a[l], n);
}
var kb;
function Af(a, n, l, p, x, M = null) {
  var S = a, u = /* @__PURE__ */ new Map(), R = (n & Pw) !== 0;
  if (R) {
    var z = (
      /** @type {Element} */
      a
    );
    S = z.appendChild(Xl());
  }
  var U = null, $ = /* @__PURE__ */ GL(() => {
    var Pe = l();
    return Jy(Pe) ? Pe : Pe == null ? [] : Yg(Pe);
  }), ee, le = !0;
  function ce() {
    ne.fallback = U, oD(ne, ee, S, n, p), U !== null && (ee.length === 0 ? (U.f & al) === 0 ? av(U) : (U.f ^= al, sf(U, null, S)) : oc(U, () => {
      U = null;
    }));
  }
  var _e = sv(() => {
    ee = /** @type {V[]} */
    dr($);
    for (var Pe = ee.length, ve = /* @__PURE__ */ new Set(), Ue = (
      /** @type {Batch} */
      bn
    ), Qe = Nw(), et = 0; et < Pe; et += 1) {
      var Xe = ee[et], ut = p(Xe, et), Q = le ? null : u.get(ut);
      Q ? (Q.v && Gh(Q.v, Xe), Q.i && Gh(Q.i, et), Qe && Ue.skipped_effects.delete(Q.e)) : (Q = lD(
        u,
        le ? S : kb ??= Xl(),
        Xe,
        ut,
        et,
        x,
        n,
        l
      ), le || (Q.e.f |= al), u.set(ut, Q)), ve.add(ut);
    }
    if (Pe === 0 && M && !U && (le ? U = ja(() => M(S)) : (U = ja(() => M(kb ??= Xl())), U.f |= al)), !le)
      if (Qe) {
        for (const [se, ge] of u)
          ve.has(se) || Ue.skipped_effects.add(ge.e);
        Ue.oncommit(ce), Ue.ondiscard(() => {
        });
      } else
        ce();
    dr($);
  }), ne = { effect: _e, items: u, outrogroups: null, fallback: U };
  le = !1;
}
function oD(a, n, l, p, x) {
  var M = (p & gL) !== 0, S = n.length, u = a.items, R = a.effect.first, z, U = null, $, ee = [], le = [], ce, _e, ne, Pe;
  if (M)
    for (Pe = 0; Pe < S; Pe += 1)
      ce = n[Pe], _e = x(ce, Pe), ne = /** @type {EachItem} */
      u.get(_e).e, (ne.f & al) === 0 && (ne.nodes?.a?.measure(), ($ ??= /* @__PURE__ */ new Set()).add(ne));
  for (Pe = 0; Pe < S; Pe += 1) {
    if (ce = n[Pe], _e = x(ce, Pe), ne = /** @type {EachItem} */
    u.get(_e).e, a.outrogroups !== null)
      for (const ge of a.outrogroups)
        ge.pending.delete(ne), ge.done.delete(ne);
    if ((ne.f & al) !== 0)
      if (ne.f ^= al, ne === R)
        sf(ne, null, l);
      else {
        var ve = U ? U.next : R;
        ne === a.effect.last && (a.effect.last = ne.prev), ne.prev && (ne.prev.next = ne.next), ne.next && (ne.next.prev = ne.prev), Ul(a, U, ne), Ul(a, ne, ve), sf(ne, ve, l), U = ne, ee = [], le = [], R = U.next;
        continue;
      }
    if ((ne.f & Ks) !== 0 && (av(ne), M && (ne.nodes?.a?.unfix(), ($ ??= /* @__PURE__ */ new Set()).delete(ne))), ne !== R) {
      if (z !== void 0 && z.has(ne)) {
        if (ee.length < le.length) {
          var Ue = le[0], Qe;
          U = Ue.prev;
          var et = ee[0], Xe = ee[ee.length - 1];
          for (Qe = 0; Qe < ee.length; Qe += 1)
            sf(ee[Qe], Ue, l);
          for (Qe = 0; Qe < le.length; Qe += 1)
            z.delete(le[Qe]);
          Ul(a, et.prev, Xe.next), Ul(a, U, et), Ul(a, Xe, Ue), R = Ue, U = Xe, Pe -= 1, ee = [], le = [];
        } else
          z.delete(ne), sf(ne, R, l), Ul(a, ne.prev, ne.next), Ul(a, ne, U === null ? a.effect.first : U.next), Ul(a, U, ne), U = ne;
        continue;
      }
      for (ee = [], le = []; R !== null && R !== ne; )
        (z ??= /* @__PURE__ */ new Set()).add(R), le.push(R), R = R.next;
      if (R === null)
        continue;
    }
    (ne.f & al) === 0 && ee.push(ne), U = ne, R = ne.next;
  }
  if (a.outrogroups !== null) {
    for (const ge of a.outrogroups)
      ge.pending.size === 0 && (cy(Yg(ge.done)), a.outrogroups?.delete(ge));
    a.outrogroups.size === 0 && (a.outrogroups = null);
  }
  if (R !== null || z !== void 0) {
    var ut = [];
    if (z !== void 0)
      for (ne of z)
        (ne.f & Ks) === 0 && ut.push(ne);
    for (; R !== null; )
      (R.f & Ks) === 0 && R !== a.fallback && ut.push(R), R = R.next;
    var Q = ut.length;
    if (Q > 0) {
      var se = (p & Pw) !== 0 && S === 0 ? l : null;
      if (M) {
        for (Pe = 0; Pe < Q; Pe += 1)
          ut[Pe].nodes?.a?.measure();
        for (Pe = 0; Pe < Q; Pe += 1)
          ut[Pe].nodes?.a?.fix();
      }
      aD(a, ut, se);
    }
  }
  M && Nf(() => {
    if ($ !== void 0)
      for (ne of $)
        ne.nodes?.a?.apply();
  });
}
function lD(a, n, l, p, x, M, S, u) {
  var R = (S & fL) !== 0 ? (S & mL) === 0 ? /* @__PURE__ */ Uw(l, !1, !1) : dc(l) : null, z = (S & pL) !== 0 ? dc(x) : null;
  return {
    v: R,
    i: z,
    e: ja(() => (M(n, R ?? l, z ?? x, u), () => {
      a.delete(p);
    }))
  };
}
function sf(a, n, l) {
  if (a.nodes)
    for (var p = a.nodes.start, x = a.nodes.end, M = n && (n.f & al) === 0 ? (
      /** @type {EffectNodes} */
      n.nodes.start
    ) : l; p !== null; ) {
      var S = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Of(p)
      );
      if (M.before(p), p === x)
        return;
      p = S;
    }
}
function Ul(a, n, l) {
  n === null ? a.effect.first = l : n.next = l, l === null ? a.effect.last = n : l.prev = n;
}
function h2(a, n, l = !1, p = !1, x = !1) {
  var M = a, S = "";
  Za(() => {
    var u = (
      /** @type {Effect} */
      Yr
    );
    if (S !== (S = n() ?? "") && (u.nodes !== null && (i2(
      u.nodes.start,
      /** @type {TemplateNode} */
      u.nodes.end
    ), u.nodes = null), S !== "")) {
      var R = S + "";
      l ? R = `<svg>${R}</svg>` : p && (R = `<math>${R}</math>`);
      var z = c2(R);
      if ((l || p) && (z = /** @type {Element} */
      /* @__PURE__ */ Zl(z)), Pf(
        /** @type {TemplateNode} */
        /* @__PURE__ */ Zl(z),
        /** @type {TemplateNode} */
        z.lastChild
      ), l || p)
        for (; /* @__PURE__ */ Zl(z); )
          M.before(
            /** @type {TemplateNode} */
            /* @__PURE__ */ Zl(z)
          );
      else
        M.before(z);
    }
  });
}
const uD = () => performance.now(), sl = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    ((a) => requestAnimationFrame(a))
  ),
  now: () => uD(),
  tasks: /* @__PURE__ */ new Set()
};
function d2() {
  const a = sl.now();
  sl.tasks.forEach((n) => {
    n.c(a) || (sl.tasks.delete(n), n.f());
  }), sl.tasks.size !== 0 && sl.tick(d2);
}
function cD(a) {
  let n;
  return sl.tasks.size === 0 && sl.tick(d2), {
    promise: new Promise((l) => {
      sl.tasks.add(n = { c: a, f: l });
    }),
    abort() {
      sl.tasks.delete(n);
    }
  };
}
function Wp(a, n) {
  zf(() => {
    a.dispatchEvent(new CustomEvent(n));
  });
}
function hD(a) {
  if (a === "float") return "cssFloat";
  if (a === "offset") return "cssOffset";
  if (a.startsWith("--")) return a;
  const n = a.split("-");
  return n.length === 1 ? n[0] : n[0] + n.slice(1).map(
    /** @param {any} word */
    (l) => l[0].toUpperCase() + l.slice(1)
  ).join("");
}
function Ib(a) {
  const n = {}, l = a.split(";");
  for (const p of l) {
    const [x, M] = p.split(":");
    if (!x || M === void 0) break;
    const S = hD(x.trim());
    n[S] = M.trim();
  }
  return n;
}
const dD = (a) => a;
function Mb(a, n, l, p) {
  var x = (a & _L) !== 0, M = (a & yL) !== 0, S = x && M, u = (a & vL) !== 0, R = S ? "both" : x ? "in" : "out", z, U = n.inert, $ = n.style.overflow, ee, le;
  function ce() {
    return zf(() => z ??= l()(n, p?.() ?? /** @type {P} */
    {}, {
      direction: R
    }));
  }
  var _e = {
    is_global: u,
    in() {
      if (n.inert = U, !x) {
        le?.abort(), le?.reset?.();
        return;
      }
      M || ee?.abort(), Wp(n, "introstart"), ee = hy(n, ce(), le, 1, () => {
        Wp(n, "introend"), ee?.abort(), ee = z = void 0, n.style.overflow = $;
      });
    },
    out(Ue) {
      if (!M) {
        Ue?.(), z = void 0;
        return;
      }
      n.inert = !0, Wp(n, "outrostart"), le = hy(n, ce(), ee, 0, () => {
        Wp(n, "outroend"), Ue?.();
      });
    },
    stop: () => {
      ee?.abort(), le?.abort();
    }
  }, ne = (
    /** @type {Effect & { nodes: EffectNodes }} */
    Yr
  );
  if ((ne.nodes.t ??= []).push(_e), x && ly) {
    var Pe = u;
    if (!Pe) {
      for (var ve = (
        /** @type {Effect | null} */
        ne.parent
      ); ve && (ve.f & uc) !== 0; )
        for (; (ve = ve.parent) && (ve.f & Po) === 0; )
          ;
      Pe = !ve || (ve.f & Xg) !== 0;
    }
    Pe && e2(() => {
      Gf(() => _e.in());
    });
  }
}
function hy(a, n, l, p, x) {
  var M = p === 1;
  if (KA(n)) {
    var S, u = !1;
    return Nf(() => {
      if (!u) {
        var ne = n({ direction: M ? "in" : "out" });
        S = hy(a, ne, l, p, x);
      }
    }), {
      abort: () => {
        u = !0, S?.abort();
      },
      deactivate: () => S.deactivate(),
      reset: () => S.reset(),
      t: () => S.t()
    };
  }
  if (l?.deactivate(), !n?.duration)
    return x(), {
      abort: Ua,
      deactivate: Ua,
      reset: Ua,
      t: () => p
    };
  const { delay: R = 0, css: z, tick: U, easing: $ = dD } = n;
  var ee = [];
  if (M && l === void 0 && (U && U(0, 1), z)) {
    var le = Ib(z(0, 1));
    ee.push(le, le);
  }
  var ce = () => 1 - p, _e = a.animate(ee, { duration: R, fill: "forwards" });
  return _e.onfinish = () => {
    _e.cancel();
    var ne = l?.t() ?? 1 - p;
    l?.abort();
    var Pe = p - ne, ve = (
      /** @type {number} */
      n.duration * Math.abs(Pe)
    ), Ue = [];
    if (ve > 0) {
      var Qe = !1;
      if (z)
        for (var et = Math.ceil(ve / 16.666666666666668), Xe = 0; Xe <= et; Xe += 1) {
          var ut = ne + Pe * $(Xe / et), Q = Ib(z(ut, 1 - ut));
          Ue.push(Q), Qe ||= Q.overflow === "hidden";
        }
      Qe && (a.style.overflow = "hidden"), ce = () => {
        var se = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          _e.currentTime
        );
        return ne + Pe * $(se / ve);
      }, U && cD(() => {
        if (_e.playState !== "running") return !1;
        var se = ce();
        return U(se, 1 - se), !0;
      });
    }
    _e = a.animate(Ue, { duration: ve, fill: "forwards" }), _e.onfinish = () => {
      ce = () => p, U?.(p, 1 - p), x();
    };
  }, {
    abort: () => {
      _e && (_e.cancel(), _e.effect = null, _e.onfinish = Ua);
    },
    deactivate: () => {
      x = Ua;
    },
    reset: () => {
      p === 0 && U?.(1, 0);
    },
    t: () => ce()
  };
}
function f2(a) {
  var n, l, p = "";
  if (typeof a == "string" || typeof a == "number") p += a;
  else if (typeof a == "object") if (Array.isArray(a)) {
    var x = a.length;
    for (n = 0; n < x; n++) a[n] && (l = f2(a[n])) && (p && (p += " "), p += l);
  } else for (l in a) a[l] && (p && (p += " "), p += l);
  return p;
}
function fD() {
  for (var a, n, l = 0, p = "", x = arguments.length; l < x; l++) (a = arguments[l]) && (n = f2(a)) && (p && (p += " "), p += n);
  return p;
}
function pD(a) {
  return typeof a == "object" ? fD(a) : a ?? "";
}
const Cb = [...` 	
\r\f\v\uFEFF`];
function gD(a, n, l) {
  var p = a == null ? "" : "" + a;
  if (n && (p = p ? p + " " + n : n), l) {
    for (var x in l)
      if (l[x])
        p = p ? p + " " + x : x;
      else if (p.length)
        for (var M = x.length, S = 0; (S = p.indexOf(x, S)) >= 0; ) {
          var u = S + M;
          (S === 0 || Cb.includes(p[S - 1])) && (u === p.length || Cb.includes(p[u])) ? p = (S === 0 ? "" : p.substring(0, S)) + p.substring(u + 1) : S = u;
        }
  }
  return p === "" ? null : p;
}
function yf(a, n, l, p, x, M) {
  var S = a.__className;
  if (S !== l || S === void 0) {
    var u = gD(l, p, M);
    u == null ? a.removeAttribute("class") : a.className = u, a.__className = l;
  } else if (M && x !== M)
    for (var R in M) {
      var z = !!M[R];
      (x == null || z !== !!x[R]) && a.classList.toggle(R, z);
    }
  return M;
}
function p2(a, n, l = !1) {
  if (a.multiple) {
    if (n == null)
      return;
    if (!Jy(n))
      return kL();
    for (var p of a.options)
      p.selected = n.includes(vf(p));
    return;
  }
  for (p of a.options) {
    var x = vf(p);
    if (ML(x, n)) {
      p.selected = !0;
      return;
    }
  }
  (!l || n !== void 0) && (a.selectedIndex = -1);
}
function mD(a) {
  var n = new MutationObserver(() => {
    p2(a, a.__value);
  });
  n.observe(a, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), iv(() => {
    n.disconnect();
  });
}
function _D(a, n, l = n) {
  var p = /* @__PURE__ */ new WeakSet(), x = !0;
  $w(a, "change", (M) => {
    var S = M ? "[selected]" : ":checked", u;
    if (a.multiple)
      u = [].map.call(a.querySelectorAll(S), vf);
    else {
      var R = a.querySelector(S) ?? // will fall back to first non-disabled option if no option is selected
      a.querySelector("option:not([disabled])");
      u = R && vf(R);
    }
    l(u), bn !== null && p.add(bn);
  }), e2(() => {
    var M = n();
    if (a === document.activeElement) {
      var S = (
        /** @type {Batch} */
        fg ?? bn
      );
      if (p.has(S))
        return;
    }
    if (p2(a, M, x), x && M === void 0) {
      var u = a.querySelector(":checked");
      u !== null && (M = vf(u), l(M));
    }
    a.__value = M, x = !1;
  }), mD(a);
}
function vf(a) {
  return "__value" in a ? a.__value : a.value;
}
const yD = /* @__PURE__ */ Symbol("is custom element"), vD = /* @__PURE__ */ Symbol("is html");
function Hl(a, n, l, p) {
  var x = xD(a);
  x[n] !== (x[n] = l) && (n === "loading" && (a[rL] = l), l == null ? a.removeAttribute(n) : typeof l != "string" && bD(a).includes(n) ? a[n] = l : a.setAttribute(n, l));
}
function xD(a) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    a.__attributes ??= {
      [yD]: a.nodeName.includes("-"),
      [vD]: a.namespaceURI === wL
    }
  );
}
var Pb = /* @__PURE__ */ new Map();
function bD(a) {
  var n = a.getAttribute("is") || a.nodeName, l = Pb.get(n);
  if (l) return l;
  Pb.set(n, l = []);
  for (var p, x = a, M = Element.prototype; M !== x; ) {
    p = WA(x);
    for (var S in p)
      p[S].set && l.push(S);
    x = Ew(x);
  }
  return l;
}
function wD(a, n, l = n) {
  $w(a, "change", (p) => {
    var x = p ? a.defaultChecked : a.checked;
    l(x);
  }), // If we are hydrating and the value has since changed,
  // then use the update value from the input instead.
  // If defaultChecked is set, then checked == defaultChecked
  Gf(n) == null && l(a.checked), t2(() => {
    var p = n();
    a.checked = !!p;
  });
}
let dy = /* @__PURE__ */ Symbol();
function g2(a, n, l) {
  const p = l[n] ??= {
    store: null,
    source: /* @__PURE__ */ Uw(void 0),
    unsubscribe: Ua
  };
  if (p.store !== a && !(dy in l))
    if (p.unsubscribe(), p.store = a ?? null, a == null)
      p.source.v = void 0, p.unsubscribe = Ua;
    else {
      var x = !0;
      p.unsubscribe = _2(a, (M) => {
        x ? p.source.v = M : ms(p.source, M);
      }), x = !1;
    }
  return a && dy in l ? TD(a) : dr(p.source);
}
function m2() {
  const a = {};
  function n() {
    iv(() => {
      for (var l in a)
        a[l].unsubscribe();
      ww(a, dy, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [a, n];
}
function ED(a) {
  ss === null && Cw(), WL(() => {
    const n = Gf(a);
    if (typeof n == "function") return (
      /** @type {() => void} */
      n
    );
  });
}
function _2(a, n, l) {
  if (a == null)
    return n(void 0), Ua;
  const p = Gf(
    () => a.subscribe(
      n,
      // @ts-expect-error
      l
    )
  );
  return p.unsubscribe ? () => p.unsubscribe() : p;
}
const wh = [];
function SD(a, n = Ua) {
  let l = null;
  const p = /* @__PURE__ */ new Set();
  function x(u) {
    if (Iw(a, u) && (a = u, l)) {
      const R = !wh.length;
      for (const z of p)
        z[1](), wh.push(z, a);
      if (R) {
        for (let z = 0; z < wh.length; z += 2)
          wh[z][0](wh[z + 1]);
        wh.length = 0;
      }
    }
  }
  function M(u) {
    x(u(
      /** @type {T} */
      a
    ));
  }
  function S(u, R = Ua) {
    const z = [u, R];
    return p.add(z), p.size === 1 && (l = n(x, M) || Ua), u(
      /** @type {T} */
      a
    ), () => {
      p.delete(z), p.size === 0 && l && (l(), l = null);
    };
  }
  return { set: x, update: M, subscribe: S };
}
function TD(a) {
  let n;
  return _2(a, (l) => n = l)(), n;
}
const kD = {
  controls: Qs(j1),
  options: ny().controls,
  settings: ny().settings
}, ov = SD(kD), ID = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(ID);
const MD = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.474 17.988h49.045L31.996 46.012zm-3.85 3.37 24.522 28.019a5.113 5.113 0 0 0 7.7 0l24.523-28.02c2.894-3.308.542-8.482-3.85-8.482H7.474a5.113 5.113 0 0 0-3.85 8.482"/>
</svg>
`, CD = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.474 46.012h49.045L31.996 17.988Zm-3.85-3.37 24.522-28.019a5.113 5.113 0 0 1 7.7 0l24.523 28.02c2.894 3.308.542 8.482-3.85 8.482H7.474a5.113 5.113 0 0 1-3.85-8.482"/>
</svg>
`;
var PD = /* @__PURE__ */ xa("<option> </option>"), AD = /* @__PURE__ */ xa('<label class="svelte-18zciyf"> </label> <select class="svelte-18zciyf"></select>', 1), LD = /* @__PURE__ */ xa('<label class="svelte-18zciyf"><input type="checkbox" class="svelte-18zciyf"/> </label>'), DD = /* @__PURE__ */ xa('<div class="action-option svelte-18zciyf"><!></div>');
function RD(a, n) {
  Hh(n, !0);
  let l = /* @__PURE__ */ yo("");
  ED(() => {
    n.actionOption && (n.actionOption.type === "select" ? ms(l, n.actionOption.value.value, !0) : n.actionOption.type === "toggle" && ms(l, n.actionOption.value, !0));
  });
  const p = (u) => {
    if (!n.actionInstance || !n.actionOption) {
      Ct.error("Can't apply option value", n.actionInstance, n.actionOption);
      return;
    }
    if (n.actionOption?.type === "toggle") {
      const R = u.target;
      ms(l, R.checked, !0);
    } else if (n.actionOption?.type === "select") {
      const R = u.target;
      ms(l, R.value, !0);
    }
    n.actionInstance.applyOptionValue(n.name, dr(l));
  };
  var x = ul(), M = Wa(x);
  {
    var S = (u) => {
      var R = DD(), z = $a(R);
      {
        var U = (ee) => {
          var le = AD(), ce = Wa(le), _e = $a(ce), ne = kf(ce, 2);
          ne.__change = p, Af(ne, 21, () => n.actionOption.choices, sD, (Pe, ve) => {
            var Ue = PD(), Qe = $a(Ue), et = {};
            Za(() => {
              Lh(Qe, dr(ve).title), et !== (et = dr(ve).value) && (Ue.value = (Ue.__value = dr(ve).value) ?? "");
            }), zn(Pe, Ue);
          }), Za(() => {
            Hl(ce, "for", n.name), Lh(_e, n.actionOption.label), Hl(ne, "id", n.name);
          }), _D(ne, () => dr(l), (Pe) => ms(l, Pe)), zn(ee, le);
        }, $ = (ee) => {
          var le = ul(), ce = Wa(le);
          {
            var _e = (ne) => {
              var Pe = LD(), ve = $a(Pe);
              ve.__change = p;
              var Ue = kf(ve);
              Za(
                (Qe) => {
                  Hl(Pe, "for", n.name), Hl(ve, "id", Qe), Lh(Ue, ` ${n.actionOption.label ?? ""}`);
                },
                [() => String(n.name)]
              ), wD(ve, () => dr(l), (Qe) => ms(l, Qe)), zn(ne, Pe);
            };
            Xs(
              ce,
              (ne) => {
                n.actionOption.type === "toggle" && typeof dr(l) == "boolean" && ne(_e);
              },
              !0
            );
          }
          zn(ee, le);
        };
        Xs(z, (ee) => {
          n.actionOption.type === "select" ? ee(U) : ee($, !1);
        });
      }
      zn(u, R);
    };
    Xs(M, (u) => {
      n.actionOption && u(S);
    });
  }
  zn(a, x), Yh();
}
Jg(["change"]);
var FD = /* @__PURE__ */ xa('<button type="submit" class="sub-action svelte-1xmw7n6"> </button>');
function ND(a, n) {
  Hh(n, !0);
  const l = (S) => {
    if (S.preventDefault(), !n.actionInstance || !n.subAction) {
      Ct.error("Can't run a SubAction", n.actionInstance, n.subAction);
      return;
    }
    n.subAction.method();
  };
  var p = ul(), x = Wa(p);
  {
    var M = (S) => {
      var u = FD();
      u.__click = l;
      var R = $a(u);
      Za(() => {
        Hl(u, "id", `subaction-${n.name}`), Hl(u, "title", n.subAction.label), Lh(R, n.subAction.label);
      }), zn(S, u);
    };
    Xs(x, (S) => {
      n.subAction && S(M);
    });
  }
  zn(a, p), Yh();
}
Jg(["click"]);
var OD = /* @__PURE__ */ xa("<!> <!>", 1);
function zD(a, n) {
  Hh(n, !0);
  const l = Aw("gm"), p = /* @__PURE__ */ qa(() => n.control.type), x = /* @__PURE__ */ qa(() => n.control.targetMode), M = /* @__PURE__ */ qa(() => dr(p) && dr(x) && l.actionInstances[`${dr(p)}__${dr(x)}`] || null);
  var S = ul(), u = Wa(S);
  {
    var R = (z) => {
      var U = OD(), $ = Wa(U);
      Af($, 17, () => Object.entries(dr(M).options), ([le, ce]) => le, (le, ce) => {
        var _e = /* @__PURE__ */ qa(() => Tg(dr(ce), 2));
        let ne = () => dr(_e)[0], Pe = () => dr(_e)[1];
        RD(le, {
          get name() {
            return ne();
          },
          get actionInstance() {
            return dr(M);
          },
          get actionOption() {
            return Pe();
          }
        });
      });
      var ee = kf($, 2);
      Af(ee, 17, () => Object.entries(dr(M).actions), ([le, ce]) => le, (le, ce) => {
        var _e = /* @__PURE__ */ qa(() => Tg(dr(ce), 2));
        let ne = () => dr(_e)[0], Pe = () => dr(_e)[1];
        ND(le, {
          get name() {
            return ne();
          },
          get actionInstance() {
            return dr(M);
          },
          get subAction() {
            return Pe();
          }
        });
      }), zn(z, U);
    };
    Xs(u, (z) => {
      dr(M) && z(R);
    });
  }
  zn(a, S), Yh();
}
const {
  entries: y2,
  setPrototypeOf: Ab,
  isFrozen: BD,
  getPrototypeOf: GD,
  getOwnPropertyDescriptor: jD
} = Object;
let {
  freeze: vs,
  seal: va,
  create: fy
} = Object, {
  apply: py,
  construct: gy
} = typeof Reflect < "u" && Reflect;
vs || (vs = function(a) {
  return a;
});
va || (va = function(a) {
  return a;
});
py || (py = function(a, n) {
  for (var l = arguments.length, p = new Array(l > 2 ? l - 2 : 0), x = 2; x < l; x++)
    p[x - 2] = arguments[x];
  return a.apply(n, p);
});
gy || (gy = function(a) {
  for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), p = 1; p < n; p++)
    l[p - 1] = arguments[p];
  return new a(...l);
});
const Xp = xs(Array.prototype.forEach), VD = xs(Array.prototype.lastIndexOf), Lb = xs(Array.prototype.pop), Yd = xs(Array.prototype.push), UD = xs(Array.prototype.splice), pg = xs(String.prototype.toLowerCase), T_ = xs(String.prototype.toString), k_ = xs(String.prototype.match), Wd = xs(String.prototype.replace), qD = xs(String.prototype.indexOf), $D = xs(String.prototype.trim), Ga = xs(Object.prototype.hasOwnProperty), fs = xs(RegExp.prototype.test), Xd = ZD(TypeError);
function xs(a) {
  return function(n) {
    n instanceof RegExp && (n.lastIndex = 0);
    for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), x = 1; x < l; x++)
      p[x - 1] = arguments[x];
    return py(a, n, p);
  };
}
function ZD(a) {
  return function() {
    for (var n = arguments.length, l = new Array(n), p = 0; p < n; p++)
      l[p] = arguments[p];
    return gy(a, l);
  };
}
function kr(a, n) {
  let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : pg;
  Ab && Ab(a, null);
  let p = n.length;
  for (; p--; ) {
    let x = n[p];
    if (typeof x == "string") {
      const M = l(x);
      M !== x && (BD(n) || (n[p] = M), x = M);
    }
    a[x] = !0;
  }
  return a;
}
function HD(a) {
  for (let n = 0; n < a.length; n++)
    Ga(a, n) || (a[n] = null);
  return a;
}
function _o(a) {
  const n = fy(null);
  for (const [l, p] of y2(a))
    Ga(a, l) && (Array.isArray(p) ? n[l] = HD(p) : p && typeof p == "object" && p.constructor === Object ? n[l] = _o(p) : n[l] = p);
  return n;
}
function Jd(a, n) {
  for (; a !== null; ) {
    const p = jD(a, n);
    if (p) {
      if (p.get)
        return xs(p.get);
      if (typeof p.value == "function")
        return xs(p.value);
    }
    a = GD(a);
  }
  function l() {
    return null;
  }
  return l;
}
const Db = vs(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), I_ = vs(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), M_ = vs(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), YD = vs(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), C_ = vs(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), WD = vs(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Rb = vs(["#text"]), Fb = vs(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), P_ = vs(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Nb = vs(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Jp = vs(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), XD = va(/\{\{[\w\W]*|[\w\W]*\}\}/gm), JD = va(/<%[\w\W]*|[\w\W]*%>/gm), KD = va(/\$\{[\w\W]*/gm), QD = va(/^data-[\-\w.\u00B7-\uFFFF]+$/), eR = va(/^aria-[\-\w]+$/), v2 = va(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), tR = va(/^(?:\w+script|data):/i), rR = va(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), x2 = va(/^html$/i), nR = va(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Ob = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: eR,
  ATTR_WHITESPACE: rR,
  CUSTOM_ELEMENT: nR,
  DATA_ATTR: QD,
  DOCTYPE_NAME: x2,
  ERB_EXPR: JD,
  IS_ALLOWED_URI: v2,
  IS_SCRIPT_OR_DATA: tR,
  MUSTACHE_EXPR: XD,
  TMPLIT_EXPR: KD
});
const Kd = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, iR = function() {
  return typeof window > "u" ? null : window;
}, sR = function(a, n) {
  if (typeof a != "object" || typeof a.createPolicy != "function")
    return null;
  let l = null;
  const p = "data-tt-policy-suffix";
  n && n.hasAttribute(p) && (l = n.getAttribute(p));
  const x = "dompurify" + (l ? "#" + l : "");
  try {
    return a.createPolicy(x, {
      createHTML(M) {
        return M;
      },
      createScriptURL(M) {
        return M;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + x + " could not be created."), null;
  }
}, zb = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function b2() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iR();
  const n = (we) => b2(we);
  if (n.version = "3.3.1", n.removed = [], !a || !a.document || a.document.nodeType !== Kd.document || !a.Element)
    return n.isSupported = !1, n;
  let {
    document: l
  } = a;
  const p = l, x = p.currentScript, {
    DocumentFragment: M,
    HTMLTemplateElement: S,
    Node: u,
    Element: R,
    NodeFilter: z,
    NamedNodeMap: U = a.NamedNodeMap || a.MozNamedAttrMap,
    HTMLFormElement: $,
    DOMParser: ee,
    trustedTypes: le
  } = a, ce = R.prototype, _e = Jd(ce, "cloneNode"), ne = Jd(ce, "remove"), Pe = Jd(ce, "nextSibling"), ve = Jd(ce, "childNodes"), Ue = Jd(ce, "parentNode");
  if (typeof S == "function") {
    const we = l.createElement("template");
    we.content && we.content.ownerDocument && (l = we.content.ownerDocument);
  }
  let Qe, et = "";
  const {
    implementation: Xe,
    createNodeIterator: ut,
    createDocumentFragment: Q,
    getElementsByTagName: se
  } = l, {
    importNode: ge
  } = p;
  let Se = zb();
  n.isSupported = typeof y2 == "function" && typeof Ue == "function" && Xe && Xe.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Ie,
    ERB_EXPR: ze,
    TMPLIT_EXPR: Re,
    DATA_ATTR: De,
    ARIA_ATTR: Ne,
    IS_SCRIPT_OR_DATA: Ge,
    ATTR_WHITESPACE: qe,
    CUSTOM_ELEMENT: Je
  } = Ob;
  let {
    IS_ALLOWED_URI: ft
  } = Ob, Tt = null;
  const Zt = kr({}, [...Db, ...I_, ...M_, ...C_, ...Rb]);
  let zt = null;
  const At = kr({}, [...Fb, ...P_, ...Nb, ...Jp]);
  let Dt = Object.seal(fy(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Yt = null, mr = null;
  const He = Object.seal(fy(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let yi = !0, fr = !0, Bt = !1, Me = !0, br = !1, ur = !0, rr = !1, ni = !1, Dr = !1, ii = !1, Mt = !1, Zi = !1, Ti = !0, jn = !1;
  const Ls = "user-content-";
  let tr = !0, ln = !1, Vn = {}, Un = null;
  const Jt = kr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let os = null;
  const Fe = kr({}, ["audio", "video", "img", "source", "image", "track"]);
  let H = null;
  const K = kr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), re = "http://www.w3.org/1998/Math/MathML", Te = "http://www.w3.org/2000/svg", me = "http://www.w3.org/1999/xhtml";
  let Ye = me, We = !1, Ve = null;
  const $e = kr({}, [re, Te, me], T_);
  let gt = kr({}, ["mi", "mo", "mn", "ms", "mtext"]), st = kr({}, ["annotation-xml"]);
  const vt = kr({}, ["title", "style", "font", "a", "script"]);
  let Be = null;
  const Qt = ["application/xhtml+xml", "text/html"], Cr = "text/html";
  let kt = null, lt = null;
  const nr = l.createElement("form"), Fr = function(we) {
    return we instanceof RegExp || we instanceof Function;
  }, wr = function() {
    let we = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(lt && lt === we)) {
      if ((!we || typeof we != "object") && (we = {}), we = _o(we), Be = // eslint-disable-next-line unicorn/prefer-includes
      Qt.indexOf(we.PARSER_MEDIA_TYPE) === -1 ? Cr : we.PARSER_MEDIA_TYPE, kt = Be === "application/xhtml+xml" ? T_ : pg, Tt = Ga(we, "ALLOWED_TAGS") ? kr({}, we.ALLOWED_TAGS, kt) : Zt, zt = Ga(we, "ALLOWED_ATTR") ? kr({}, we.ALLOWED_ATTR, kt) : At, Ve = Ga(we, "ALLOWED_NAMESPACES") ? kr({}, we.ALLOWED_NAMESPACES, T_) : $e, H = Ga(we, "ADD_URI_SAFE_ATTR") ? kr(_o(K), we.ADD_URI_SAFE_ATTR, kt) : K, os = Ga(we, "ADD_DATA_URI_TAGS") ? kr(_o(Fe), we.ADD_DATA_URI_TAGS, kt) : Fe, Un = Ga(we, "FORBID_CONTENTS") ? kr({}, we.FORBID_CONTENTS, kt) : Jt, Yt = Ga(we, "FORBID_TAGS") ? kr({}, we.FORBID_TAGS, kt) : _o({}), mr = Ga(we, "FORBID_ATTR") ? kr({}, we.FORBID_ATTR, kt) : _o({}), Vn = Ga(we, "USE_PROFILES") ? we.USE_PROFILES : !1, yi = we.ALLOW_ARIA_ATTR !== !1, fr = we.ALLOW_DATA_ATTR !== !1, Bt = we.ALLOW_UNKNOWN_PROTOCOLS || !1, Me = we.ALLOW_SELF_CLOSE_IN_ATTR !== !1, br = we.SAFE_FOR_TEMPLATES || !1, ur = we.SAFE_FOR_XML !== !1, rr = we.WHOLE_DOCUMENT || !1, ii = we.RETURN_DOM || !1, Mt = we.RETURN_DOM_FRAGMENT || !1, Zi = we.RETURN_TRUSTED_TYPE || !1, Dr = we.FORCE_BODY || !1, Ti = we.SANITIZE_DOM !== !1, jn = we.SANITIZE_NAMED_PROPS || !1, tr = we.KEEP_CONTENT !== !1, ln = we.IN_PLACE || !1, ft = we.ALLOWED_URI_REGEXP || v2, Ye = we.NAMESPACE || me, gt = we.MATHML_TEXT_INTEGRATION_POINTS || gt, st = we.HTML_INTEGRATION_POINTS || st, Dt = we.CUSTOM_ELEMENT_HANDLING || {}, we.CUSTOM_ELEMENT_HANDLING && Fr(we.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Dt.tagNameCheck = we.CUSTOM_ELEMENT_HANDLING.tagNameCheck), we.CUSTOM_ELEMENT_HANDLING && Fr(we.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Dt.attributeNameCheck = we.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), we.CUSTOM_ELEMENT_HANDLING && typeof we.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Dt.allowCustomizedBuiltInElements = we.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), br && (fr = !1), Mt && (ii = !0), Vn && (Tt = kr({}, Rb), zt = [], Vn.html === !0 && (kr(Tt, Db), kr(zt, Fb)), Vn.svg === !0 && (kr(Tt, I_), kr(zt, P_), kr(zt, Jp)), Vn.svgFilters === !0 && (kr(Tt, M_), kr(zt, P_), kr(zt, Jp)), Vn.mathMl === !0 && (kr(Tt, C_), kr(zt, Nb), kr(zt, Jp))), we.ADD_TAGS && (typeof we.ADD_TAGS == "function" ? He.tagCheck = we.ADD_TAGS : (Tt === Zt && (Tt = _o(Tt)), kr(Tt, we.ADD_TAGS, kt))), we.ADD_ATTR && (typeof we.ADD_ATTR == "function" ? He.attributeCheck = we.ADD_ATTR : (zt === At && (zt = _o(zt)), kr(zt, we.ADD_ATTR, kt))), we.ADD_URI_SAFE_ATTR && kr(H, we.ADD_URI_SAFE_ATTR, kt), we.FORBID_CONTENTS && (Un === Jt && (Un = _o(Un)), kr(Un, we.FORBID_CONTENTS, kt)), we.ADD_FORBID_CONTENTS && (Un === Jt && (Un = _o(Un)), kr(Un, we.ADD_FORBID_CONTENTS, kt)), tr && (Tt["#text"] = !0), rr && kr(Tt, ["html", "head", "body"]), Tt.table && (kr(Tt, ["tbody"]), delete Yt.tbody), we.TRUSTED_TYPES_POLICY) {
        if (typeof we.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Xd('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof we.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Xd('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        Qe = we.TRUSTED_TYPES_POLICY, et = Qe.createHTML("");
      } else
        Qe === void 0 && (Qe = sR(le, x)), Qe !== null && typeof et == "string" && (et = Qe.createHTML(""));
      vs && vs(we), lt = we;
    }
  }, un = kr({}, [...I_, ...M_, ...YD]), Qr = kr({}, [...C_, ...WD]), Ur = function(we) {
    let Gt = Ue(we);
    (!Gt || !Gt.tagName) && (Gt = {
      namespaceURI: Ye,
      tagName: "template"
    });
    const wt = pg(we.tagName), Sr = pg(Gt.tagName);
    return Ve[we.namespaceURI] ? we.namespaceURI === Te ? Gt.namespaceURI === me ? wt === "svg" : Gt.namespaceURI === re ? wt === "svg" && (Sr === "annotation-xml" || gt[Sr]) : !!un[wt] : we.namespaceURI === re ? Gt.namespaceURI === me ? wt === "math" : Gt.namespaceURI === Te ? wt === "math" && st[Sr] : !!Qr[wt] : we.namespaceURI === me ? Gt.namespaceURI === Te && !st[Sr] || Gt.namespaceURI === re && !gt[Sr] ? !1 : !Qr[wt] && (vt[wt] || !un[wt]) : !!(Be === "application/xhtml+xml" && Ve[we.namespaceURI]) : !1;
  }, Ir = function(we) {
    Yd(n.removed, {
      element: we
    });
    try {
      Ue(we).removeChild(we);
    } catch {
      ne(we);
    }
  }, pt = function(we, Gt) {
    try {
      Yd(n.removed, {
        attribute: Gt.getAttributeNode(we),
        from: Gt
      });
    } catch {
      Yd(n.removed, {
        attribute: null,
        from: Gt
      });
    }
    if (Gt.removeAttribute(we), we === "is")
      if (ii || Mt)
        try {
          Ir(Gt);
        } catch {
        }
      else
        try {
          Gt.setAttribute(we, "");
        } catch {
        }
  }, jr = function(we) {
    let Gt = null, wt = null;
    if (Dr)
      we = "<remove></remove>" + we;
    else {
      const Mr = k_(we, /^[\r\n\t ]+/);
      wt = Mr && Mr[0];
    }
    Be === "application/xhtml+xml" && Ye === me && (we = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + we + "</body></html>");
    const Sr = Qe ? Qe.createHTML(we) : we;
    if (Ye === me)
      try {
        Gt = new ee().parseFromString(Sr, Be);
      } catch {
      }
    if (!Gt || !Gt.documentElement) {
      Gt = Xe.createDocument(Ye, "template", null);
      try {
        Gt.documentElement.innerHTML = We ? et : Sr;
      } catch {
      }
    }
    const en = Gt.body || Gt.documentElement;
    return we && wt && en.insertBefore(l.createTextNode(wt), en.childNodes[0] || null), Ye === me ? se.call(Gt, rr ? "html" : "body")[0] : rr ? Gt.documentElement : en;
  }, Wn = function(we) {
    return ut.call(
      we.ownerDocument || we,
      we,
      // eslint-disable-next-line no-bitwise
      z.SHOW_ELEMENT | z.SHOW_COMMENT | z.SHOW_TEXT | z.SHOW_PROCESSING_INSTRUCTION | z.SHOW_CDATA_SECTION,
      null
    );
  }, Hi = function(we) {
    return we instanceof $ && (typeof we.nodeName != "string" || typeof we.textContent != "string" || typeof we.removeChild != "function" || !(we.attributes instanceof U) || typeof we.removeAttribute != "function" || typeof we.setAttribute != "function" || typeof we.namespaceURI != "string" || typeof we.insertBefore != "function" || typeof we.hasChildNodes != "function");
  }, Wr = function(we) {
    return typeof u == "function" && we instanceof u;
  };
  function yt(we, Gt, wt) {
    Xp(we, (Sr) => {
      Sr.call(n, Gt, wt, lt);
    });
  }
  const er = function(we) {
    let Gt = null;
    if (yt(Se.beforeSanitizeElements, we, null), Hi(we))
      return Ir(we), !0;
    const wt = kt(we.nodeName);
    if (yt(Se.uponSanitizeElement, we, {
      tagName: wt,
      allowedTags: Tt
    }), ur && we.hasChildNodes() && !Wr(we.firstElementChild) && fs(/<[/\w!]/g, we.innerHTML) && fs(/<[/\w!]/g, we.textContent) || we.nodeType === Kd.progressingInstruction || ur && we.nodeType === Kd.comment && fs(/<[/\w]/g, we.data))
      return Ir(we), !0;
    if (!(He.tagCheck instanceof Function && He.tagCheck(wt)) && (!Tt[wt] || Yt[wt])) {
      if (!Yt[wt] && mn(wt) && (Dt.tagNameCheck instanceof RegExp && fs(Dt.tagNameCheck, wt) || Dt.tagNameCheck instanceof Function && Dt.tagNameCheck(wt)))
        return !1;
      if (tr && !Un[wt]) {
        const Sr = Ue(we) || we.parentNode, en = ve(we) || we.childNodes;
        if (en && Sr) {
          const Mr = en.length;
          for (let Mn = Mr - 1; Mn >= 0; --Mn) {
            const Dn = _e(en[Mn], !0);
            Dn.__removalCount = (we.__removalCount || 0) + 1, Sr.insertBefore(Dn, Pe(we));
          }
        }
      }
      return Ir(we), !0;
    }
    return we instanceof R && !Ur(we) || (wt === "noscript" || wt === "noembed" || wt === "noframes") && fs(/<\/no(script|embed|frames)/i, we.innerHTML) ? (Ir(we), !0) : (br && we.nodeType === Kd.text && (Gt = we.textContent, Xp([Ie, ze, Re], (Sr) => {
      Gt = Wd(Gt, Sr, " ");
    }), we.textContent !== Gt && (Yd(n.removed, {
      element: we.cloneNode()
    }), we.textContent = Gt)), yt(Se.afterSanitizeElements, we, null), !1);
  }, ir = function(we, Gt, wt) {
    if (Ti && (Gt === "id" || Gt === "name") && (wt in l || wt in nr))
      return !1;
    if (!(fr && !mr[Gt] && fs(De, Gt)) && !(yi && fs(Ne, Gt)) && !(He.attributeCheck instanceof Function && He.attributeCheck(Gt, we))) {
      if (!zt[Gt] || mr[Gt]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          !(mn(we) && (Dt.tagNameCheck instanceof RegExp && fs(Dt.tagNameCheck, we) || Dt.tagNameCheck instanceof Function && Dt.tagNameCheck(we)) && (Dt.attributeNameCheck instanceof RegExp && fs(Dt.attributeNameCheck, Gt) || Dt.attributeNameCheck instanceof Function && Dt.attributeNameCheck(Gt, we)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          Gt === "is" && Dt.allowCustomizedBuiltInElements && (Dt.tagNameCheck instanceof RegExp && fs(Dt.tagNameCheck, wt) || Dt.tagNameCheck instanceof Function && Dt.tagNameCheck(wt)))
        ) return !1;
      } else if (!H[Gt] && !fs(ft, Wd(wt, qe, "")) && !((Gt === "src" || Gt === "xlink:href" || Gt === "href") && we !== "script" && qD(wt, "data:") === 0 && os[we]) && !(Bt && !fs(Ge, Wd(wt, qe, ""))) && wt)
        return !1;
    }
    return !0;
  }, mn = function(we) {
    return we !== "annotation-xml" && k_(we, Je);
  }, Bi = function(we) {
    yt(Se.beforeSanitizeAttributes, we, null);
    const {
      attributes: Gt
    } = we;
    if (!Gt || Hi(we))
      return;
    const wt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: zt,
      forceKeepAttr: void 0
    };
    let Sr = Gt.length;
    for (; Sr--; ) {
      const en = Gt[Sr], {
        name: Mr,
        namespaceURI: Mn,
        value: Dn
      } = en, Nr = kt(Mr), Er = Dn;
      let _n = Mr === "value" ? Er : $D(Er);
      if (wt.attrName = Nr, wt.attrValue = _n, wt.keepAttr = !0, wt.forceKeepAttr = void 0, yt(Se.uponSanitizeAttribute, we, wt), _n = wt.attrValue, jn && (Nr === "id" || Nr === "name") && (pt(Mr, we), _n = Ls + _n), ur && fs(/((--!?|])>)|<\/(style|title|textarea)/i, _n)) {
        pt(Mr, we);
        continue;
      }
      if (Nr === "attributename" && k_(_n, "href")) {
        pt(Mr, we);
        continue;
      }
      if (wt.forceKeepAttr)
        continue;
      if (!wt.keepAttr) {
        pt(Mr, we);
        continue;
      }
      if (!Me && fs(/\/>/i, _n)) {
        pt(Mr, we);
        continue;
      }
      br && Xp([Ie, ze, Re], (Yi) => {
        _n = Wd(_n, Yi, " ");
      });
      const Rn = kt(we.nodeName);
      if (!ir(Rn, Nr, _n)) {
        pt(Mr, we);
        continue;
      }
      if (Qe && typeof le == "object" && typeof le.getAttributeType == "function" && !Mn)
        switch (le.getAttributeType(Rn, Nr)) {
          case "TrustedHTML": {
            _n = Qe.createHTML(_n);
            break;
          }
          case "TrustedScriptURL": {
            _n = Qe.createScriptURL(_n);
            break;
          }
        }
      if (_n !== Er)
        try {
          Mn ? we.setAttributeNS(Mn, Mr, _n) : we.setAttribute(Mr, _n), Hi(we) ? Ir(we) : Lb(n.removed);
        } catch {
          pt(Mr, we);
        }
    }
    yt(Se.afterSanitizeAttributes, we, null);
  }, Gi = function we(Gt) {
    let wt = null;
    const Sr = Wn(Gt);
    for (yt(Se.beforeSanitizeShadowDOM, Gt, null); wt = Sr.nextNode(); )
      yt(Se.uponSanitizeShadowNode, wt, null), er(wt), Bi(wt), wt.content instanceof M && we(wt.content);
    yt(Se.afterSanitizeShadowDOM, Gt, null);
  };
  return n.sanitize = function(we) {
    let Gt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, wt = null, Sr = null, en = null, Mr = null;
    if (We = !we, We && (we = "<!-->"), typeof we != "string" && !Wr(we))
      if (typeof we.toString == "function") {
        if (we = we.toString(), typeof we != "string")
          throw Xd("dirty is not a string, aborting");
      } else
        throw Xd("toString is not a function");
    if (!n.isSupported)
      return we;
    if (ni || wr(Gt), n.removed = [], typeof we == "string" && (ln = !1), ln) {
      if (we.nodeName) {
        const Nr = kt(we.nodeName);
        if (!Tt[Nr] || Yt[Nr])
          throw Xd("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (we instanceof u)
      wt = jr("<!---->"), Sr = wt.ownerDocument.importNode(we, !0), Sr.nodeType === Kd.element && Sr.nodeName === "BODY" || Sr.nodeName === "HTML" ? wt = Sr : wt.appendChild(Sr);
    else {
      if (!ii && !br && !rr && // eslint-disable-next-line unicorn/prefer-includes
      we.indexOf("<") === -1)
        return Qe && Zi ? Qe.createHTML(we) : we;
      if (wt = jr(we), !wt)
        return ii ? null : Zi ? et : "";
    }
    wt && Dr && Ir(wt.firstChild);
    const Mn = Wn(ln ? we : wt);
    for (; en = Mn.nextNode(); )
      er(en), Bi(en), en.content instanceof M && Gi(en.content);
    if (ln)
      return we;
    if (ii) {
      if (Mt)
        for (Mr = Q.call(wt.ownerDocument); wt.firstChild; )
          Mr.appendChild(wt.firstChild);
      else
        Mr = wt;
      return (zt.shadowroot || zt.shadowrootmode) && (Mr = ge.call(p, Mr, !0)), Mr;
    }
    let Dn = rr ? wt.outerHTML : wt.innerHTML;
    return rr && Tt["!doctype"] && wt.ownerDocument && wt.ownerDocument.doctype && wt.ownerDocument.doctype.name && fs(x2, wt.ownerDocument.doctype.name) && (Dn = "<!DOCTYPE " + wt.ownerDocument.doctype.name + `>
` + Dn), br && Xp([Ie, ze, Re], (Nr) => {
      Dn = Wd(Dn, Nr, " ");
    }), Qe && Zi ? Qe.createHTML(Dn) : Dn;
  }, n.setConfig = function() {
    let we = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    wr(we), ni = !0;
  }, n.clearConfig = function() {
    lt = null, ni = !1;
  }, n.isValidAttribute = function(we, Gt, wt) {
    lt || wr({});
    const Sr = kt(we), en = kt(Gt);
    return ir(Sr, en, wt);
  }, n.addHook = function(we, Gt) {
    typeof Gt == "function" && Yd(Se[we], Gt);
  }, n.removeHook = function(we, Gt) {
    if (Gt !== void 0) {
      const wt = VD(Se[we], Gt);
      return wt === -1 ? void 0 : UD(Se[we], wt, 1)[0];
    }
    return Lb(Se[we]);
  }, n.removeHooks = function(we) {
    Se[we] = [];
  }, n.removeAllHooks = function() {
    Se = zb();
  }, n;
}
var w2 = b2(), aR = /* @__PURE__ */ xa("<div><!></div>"), oR = /* @__PURE__ */ xa('<div><button type="button"><!></button> <!></div>');
function lR(a, n) {
  Hh(n, !0);
  const l = () => g2(ov, "$controlsStore", p), [p, x] = m2(), M = /* @__PURE__ */ qa(() => n.controlOptions?.icon ? w2.sanitize(n.controlOptions.icon.trim()) : null), S = Aw("gm"), u = S.control.getDefaultPosition(), R = () => {
    n.control && n.controlOptions ? S.options.toggleMode(n.control.type, n.control.targetMode) : Ct.error("Control or controlOptions not defined", n.control, n.controlOptions);
  };
  var z = ul(), U = Wa(z);
  {
    var $ = (ee) => {
      var le = oR(), ce = $a(le);
      let _e;
      ce.__click = R;
      var ne = $a(ce);
      {
        var Pe = (et) => {
          var Xe = ul(), ut = Wa(Xe);
          h2(ut, () => dr(M)), zn(et, Xe);
        }, ve = (et) => {
          var Xe = ul(), ut = Wa(Xe);
          {
            var Q = (ge) => {
              var Se = Tb();
              Za((Ie) => Lh(Se, Ie), [() => n.controlOptions.title.slice(0, 2)]), zn(ge, Se);
            }, se = (ge) => {
              var Se = Tb();
              Za(() => Lh(Se, n.control.targetMode)), zn(ge, Se);
            };
            Xs(
              ut,
              (ge) => {
                n.controlOptions.title ? ge(Q) : ge(se, !1);
              },
              !0
            );
          }
          zn(et, Xe);
        };
        Xs(ne, (et) => {
          n.controlOptions.icon ? et(Pe) : et(ve, !1);
        });
      }
      var Ue = kf(ce, 2);
      {
        var Qe = (et) => {
          var Xe = aR();
          let ut;
          var Q = $a(Xe);
          zD(Q, {
            get control() {
              return n.control;
            }
          }), Za((se) => ut = yf(Xe, 1, "control-menu svelte-1q85gr9", null, ut, se), [
            () => ({
              "menu-right": u.endsWith("left"),
              "menu-left": u.endsWith("right")
            })
          ]), zn(et, Xe);
        };
        Xs(Ue, (et) => {
          n.controlOptions.active && et(Qe);
        });
      }
      Za(() => {
        yf(le, 1, pD(l().settings.controlsStyles.controlContainerClass), "svelte-1q85gr9"), Hl(ce, "id", `id_${n.control.type}_${n.control.targetMode}`), _e = yf(ce, 1, `${l().settings.controlsStyles.controlButtonClass} ${n.control.type}-${n.control.targetMode}`, "svelte-1q85gr9", _e, { active: n.controlOptions.active }), Hl(ce, "title", n.controlOptions.title);
      }), zn(ee, le);
    };
    Xs(U, (ee) => {
      n.control && n.controlOptions && n.controlOptions.uiEnabled && ee($);
    });
  }
  zn(a, z), Yh(), x();
}
Jg(["click"]);
function uR(a) {
  const n = a - 1;
  return n * n * n + 1;
}
function Bb(a, { delay: n = 0, duration: l = 400, easing: p = uR, axis: x = "y" } = {}) {
  const M = getComputedStyle(a), S = +M.opacity, u = x === "y" ? "height" : "width", R = parseFloat(M[u]), z = x === "y" ? ["top", "bottom"] : ["left", "right"], U = z.map(
    (Pe) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${Pe[0].toUpperCase()}${Pe.slice(1)}`
    )
  ), $ = parseFloat(M[`padding${U[0]}`]), ee = parseFloat(M[`padding${U[1]}`]), le = parseFloat(M[`margin${U[0]}`]), ce = parseFloat(M[`margin${U[1]}`]), _e = parseFloat(
    M[`border${U[0]}Width`]
  ), ne = parseFloat(
    M[`border${U[1]}Width`]
  );
  return {
    delay: n,
    duration: l,
    easing: p,
    css: (Pe) => `overflow: hidden;opacity: ${Math.min(Pe * 20, 1) * S};${u}: ${Pe * R}px;padding-${z[0]}: ${Pe * $}px;padding-${z[1]}: ${Pe * ee}px;margin-${z[0]}: ${Pe * le}px;margin-${z[1]}: ${Pe * ce}px;border-${z[0]}-width: ${Pe * _e}px;border-${z[1]}-width: ${Pe * ne}px;min-${u}: 0`
  };
}
var cR = /* @__PURE__ */ xa('<div><button class="gm-control-button"><!></button></div>'), hR = /* @__PURE__ */ xa("<div></div>"), dR = /* @__PURE__ */ xa("<div></div>"), fR = /* @__PURE__ */ xa('<div class="gm-reactive-controls"><!> <!></div>');
function pR(a, n) {
  Hh(n, !0);
  const l = () => g2(ov, "$controlsStore", p), [p, x] = m2();
  let M = /* @__PURE__ */ yo(!0), S = /* @__PURE__ */ qa(() => l().settings.controlsCollapsible), u = /* @__PURE__ */ qa(() => l().settings.controlsStyles);
  const R = (Pe, ve) => l().controls?.[Pe]?.[ve] || null, z = (Pe, ve) => Object.entries(ve).some(([Ue, Qe]) => R(Pe, Ue) && Qe && Qe.uiEnabled), U = () => {
    ms(M, !dr(M));
  }, $ = () => w2.sanitize(dr(M) ? MD : CD);
  var ee = fR(), le = $a(ee);
  {
    var ce = (Pe) => {
      var ve = cR(), Ue = $a(ve);
      Ue.__click = U;
      var Qe = $a(Ue);
      h2(Qe, $), Za(() => yf(ve, 1, `${dr(u).controlGroupClass} group-settings`)), zn(Pe, ve);
    };
    Xs(le, (Pe) => {
      dr(S) && Pe(ce);
    });
  }
  var _e = kf(le, 2);
  {
    var ne = (Pe) => {
      var ve = dR();
      Af(ve, 5, () => Object.entries(l().options), ([Ue, Qe]) => Ue, (Ue, Qe) => {
        var et = /* @__PURE__ */ qa(() => Tg(dr(Qe), 2));
        let Xe = () => dr(et)[0], ut = () => dr(et)[1];
        var Q = ul(), se = Wa(Q);
        {
          var ge = (Se) => {
            var Ie = hR();
            Af(Ie, 21, () => Object.entries(ut()), ([ze, Re]) => ze, (ze, Re) => {
              var De = /* @__PURE__ */ qa(() => Tg(dr(Re), 2));
              let Ne = () => dr(De)[0], Ge = () => dr(De)[1];
              const qe = /* @__PURE__ */ qa(() => R(Xe(), Ne()));
              var Je = ul(), ft = Wa(Je);
              {
                var Tt = (Zt) => {
                  lR(Zt, {
                    get control() {
                      return dr(qe);
                    },
                    get controlOptions() {
                      return Ge();
                    }
                  });
                };
                Xs(ft, (Zt) => {
                  dr(qe) && Zt(Tt);
                });
              }
              zn(ze, Je);
            }), Za(() => yf(Ie, 1, `${dr(u).controlGroupClass} group-${Xe()}`)), zn(Se, Ie);
          };
          Xs(se, (Se) => {
            z(Xe(), ut()) && Se(ge);
          });
        }
        zn(Ue, Q);
      }), Mb(1, ve, () => Bb, () => ({ duration: 180 })), Mb(2, ve, () => Bb, () => ({ duration: 140 })), zn(Pe, ve);
    };
    Xs(_e, (Pe) => {
      dr(M) && Pe(ne);
    });
  }
  zn(a, ee), Yh(), x();
}
Jg(["click"]);
class gR {
  gm;
  constructor(n) {
    this.gm = n;
  }
}
const ti = (a) => Object.keys(a), my = (a) => Object.values(a), Kl = (a, n) => n.includes(a);
class mR extends gR {
  controls = Qs(j1);
  reactiveControls = null;
  container = void 0;
  eventHandlers = {
    [`${Ot}:draw`]: this.handleModeEvent.bind(this),
    [`${Ot}:edit`]: this.handleModeEvent.bind(this),
    [`${Ot}:helper`]: this.handleModeEvent.bind(this)
  };
  onAdd() {
    if (this.createControls(), this.gm.events.bus.attachEvents(this.eventHandlers), !this.container)
      throw new Error("Controls container is not initialized");
    return this.container;
  }
  createControls(n = void 0) {
    if (this.controlsAdded()) {
      Ct.warn("Can't add controls: controls already added");
      return;
    }
    this.container = n || this.createHtmlContainer(), this.createReactivePanel();
  }
  onRemove() {
    this.gm.events.bus.detachEvents(this.eventHandlers), this.reactiveControls && (nD(this.reactiveControls), this.reactiveControls = null), this.container && this.container.parentNode && this.container.parentNode.removeChild(this.container), this.container = void 0;
  }
  handleModeEvent(n) {
    return Ev(n) ? (["mode_started", "mode_ended"].includes(n.action) && this.updateReactivePanel(), { next: !0 }) : { next: !0 };
  }
  controlsAdded() {
    return !!this.reactiveControls;
  }
  createReactivePanel() {
    if (!this.container) {
      Ct.error("Can't create reactive panel: container is not initialized");
      return;
    }
    this.syncModeStates();
    const n = /* @__PURE__ */ new Map();
    n.set("gm", this.gm), this.reactiveControls = tD(pR, {
      target: this.container,
      context: n
    }), this.updateReactivePanel();
  }
  updateReactivePanel() {
    ov.update(() => ({
      controls: this.controls,
      options: this.gm.options.controls,
      settings: this.gm.options.settings
    }));
  }
  createHtmlContainer() {
    const n = document.createElement("div");
    return n.classList.add("geoman-controls"), n;
  }
  syncModeStates() {
    this.eachControlWithOptions(({ control: n }) => {
      this.gm.options.syncModeState(n.type, n.targetMode);
    });
  }
  eachControlWithOptions(n) {
    return ti(this.controls).forEach((l) => {
      const p = this.controls[l];
      return Object.keys(p).forEach((x) => {
        const M = x, S = this.getControl({ modeType: l, modeName: M }), u = this.gm.options.getControlOptions({
          modeType: l,
          modeName: M
        });
        S && u && n({ control: S, controlOptions: u });
      });
    });
  }
  getControl({
    modeType: n,
    modeName: l
  }) {
    return n && l && this.controls[n][l] || null;
  }
  getDefaultPosition() {
    return this.gm.options.settings.controlsPosition;
  }
}
class _R {
  gm;
  globalEventsListener = null;
  constructor(n) {
    this.gm = n;
  }
  get map() {
    return this.gm.mapAdapter.getMapInstance();
  }
  async processEvent(n, l) {
    await this.fireToMap({
      type: "system",
      eventName: n.split(":")[1],
      payload: {
        ...l,
        level: "user"
      }
    }), l.action === "mode_start" || l.action === "mode_end" ? await this.forwardModeToggledEvent(l) : l.action === "feature_created" ? await this.forwardFeatureCreated(l) : l.action === "feature_removed" ? await this.forwardFeatureRemoved(l) : l.action === "feature_updated" ? await this.forwardFeatureUpdated(l) : l.action === "feature_edit_start" ? await this.forwardFeatureEditStart(l) : l.action === "feature_edit_end" ? await this.forwardFeatureEditEnd(l) : (l.action === "loaded" || l.action === "unloaded") && await this.forwardGeomanLoaded(l);
  }
  async forwardModeToggledEvent(n) {
    const l = n.action === "mode_start";
    if (n.actionType === "draw") {
      const p = "globaldrawmodetoggled", x = {
        name: `${Ni}:${p}`,
        actionType: n.actionType,
        action: n.action,
        enabled: l,
        shape: n.mode,
        map: this.map
      };
      await this.fireToMap({ type: "converted", eventName: p, payload: x });
      const M = l ? "drawstart" : "drawend", S = {
        name: `${Ni}:${M}`,
        actionType: n.actionType,
        action: n.action,
        shape: n.mode,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: M,
        payload: S
      });
    } else if (n.actionType === "edit") {
      const p = `global${this.getConvertedEditModeName(n.mode)}modetoggled`, x = {
        name: `${Ni}:${p}`,
        actionType: n.actionType,
        action: n.action,
        enabled: l,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: p,
        payload: x
      });
    } else if (n.actionType === "helper") {
      const p = `global${n.mode}modetoggled`, x = {
        name: `${Ni}:${p}`,
        actionType: n.actionType,
        action: n.action,
        enabled: l,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: p,
        payload: x
      });
    }
  }
  async forwardFeatureCreated(n) {
    const l = {
      name: `${Ni}:create`,
      actionType: n.actionType,
      action: n.action,
      shape: n.mode,
      feature: n.featureData,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: "create", payload: l });
  }
  async forwardFeatureRemoved(n) {
    const l = {
      name: `${Ni}:remove`,
      actionType: n.actionType,
      action: n.action,
      shape: n.mode,
      feature: n.featureData,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: "remove", payload: l });
  }
  async forwardFeatureUpdated(n) {
    const l = this.getConvertedEditModeName(n.mode), p = ["lasso"], x = {
      name: `${Ni}:${l}`,
      actionType: n.actionType,
      action: n.action,
      map: this.map
    };
    n.sourceFeatures.length === 1 && !p.includes(n.mode) ? x.originalFeature = n.sourceFeatures[0] : x.originalFeatures = n.sourceFeatures, n.targetFeatures.length === 1 && !p.includes(n.mode) ? (x.feature = n.targetFeatures[0], x.shape = x.feature.shape) : x.features = n.targetFeatures, await this.fireToMap({ type: "converted", eventName: `${l}`, payload: x });
  }
  async forwardFeatureEditStart(n) {
    const l = this.getConvertedEditModeName(n.mode), p = {
      name: `${Ni}:${l}start`,
      actionType: n.actionType,
      action: n.action,
      shape: n.feature.shape,
      feature: n.feature,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: `${l}start`, payload: p });
  }
  async forwardFeatureEditEnd(n) {
    const l = this.getConvertedEditModeName(n.mode), p = {
      name: `${Ni}:${l}end`,
      actionType: n.actionType,
      action: n.action,
      shape: n.feature.shape,
      feature: n.feature,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: `${l}end`, payload: p });
  }
  async forwardGeomanLoaded(n) {
    const l = {
      name: `${Ni}:${n.action}`,
      actionType: n.actionType,
      action: n.action,
      map: this.map,
      [Ni]: this.gm
    };
    await this.fireToMap({
      type: "converted",
      eventName: `${l.action}`,
      payload: l
    });
  }
  async fireToMap({
    type: n,
    eventName: l,
    payload: p
  }) {
    const x = `${n === "system" ? Ot : Ni}:${l}`;
    if (this.gm.options.settings.awaitDataUpdatesOnEvents && "feature" in p && p.feature?.source) {
      const M = p.feature.source.id;
      await this.gm.features.updateManager.waitForPendingUpdates(M);
    }
    this.globalEventsListener?.(p), this.gm.mapAdapter.fire(x, p);
  }
  getConvertedEditModeName(n) {
    return n === "change" ? "edit" : n;
  }
}
const E2 = (a) => hl(a) && a.name === `${Ot}:control:switch`, hl = (a) => !!(a && typeof a == "object" && ["level", "name", "actionType", "action"].every((n) => n in a)), yR = (a) => !!(a && typeof a == "object" && ["type", "originalEvent", "target"].every((n) => n in a));
class vR {
  gm;
  forwarder;
  mapEventHandlers = {};
  gmEventHandlers = {};
  constructor(n) {
    this.gm = n, this.forwarder = new _R(n);
  }
  // Track pending event forwarding to maintain event ordering
  // Events are processed sequentially to ensure dragstart fires before drag, etc.
  pendingForward = Promise.resolve();
  fireEvent(n, l) {
    const p = this.gmEventHandlers[n];
    if (!p)
      return;
    const { controlHandler: x } = p;
    x(l), this.pendingForward = this.pendingForward.then(
      () => this.forwarder.processEvent(n, l)
    );
  }
  attachEvents(n) {
    ti(n).forEach((l) => {
      const p = n[l];
      p && this.on(l, p);
    });
  }
  detachEvents(n) {
    ti(n).forEach((l) => {
      const p = n[l];
      p && this.off(l, p);
    });
  }
  detachAllEvents() {
    ti(this.gmEventHandlers).forEach((n) => {
      Array.from(this.gmEventHandlers[n]?.handlers || []).forEach((l) => {
        this.off(n, l);
      });
    }), ti(this.mapEventHandlers).forEach((n) => {
      Array.from(this.mapEventHandlers[n]?.handlers || []).forEach((l) => {
        this.off(n, l);
      });
    });
  }
  on(n, l) {
    n.startsWith(Ot) ? this.onGmEvent(n, l) : this.onMapEvent(n, l);
  }
  onGmEvent(n, l) {
    this.gmEventHandlers[n] || (this.gmEventHandlers[n] = this.createEventSection(n)), this.gmEventHandlers[n]?.handlers.unshift(l);
  }
  onMapEvent(n, l) {
    if (!this.mapEventHandlers[n]) {
      const p = this.createEventSection(n);
      this.gm.mapAdapter.on(n, p.controlHandler), this.mapEventHandlers[n] = p;
    }
    this.mapEventHandlers[n]?.handlers.unshift(l);
  }
  off(n, l) {
    n.startsWith(`${Ot}`) ? this.offGmEvent(n, l) : this.offMapEvent(n, l);
  }
  offGmEvent(n, l) {
    const p = this.gmEventHandlers[n]?.handlers || [], x = p.findIndex((M) => l === M);
    x === -1 ? Ct.warn("MapEvents: handler not found", n, l) : (p.splice(x, 1), p.length === 0 && delete this.gmEventHandlers[n]);
  }
  offMapEvent(n, l) {
    const p = this.mapEventHandlers[n]?.handlers || [], x = p.findIndex((M) => l === M);
    if (x === -1)
      Ct.warn("MapEvents: handler not found", n, l);
    else if (p.splice(x, 1), p.length === 0) {
      const M = this.mapEventHandlers[n]?.controlHandler;
      M && this.gm.mapAdapter.off(n, M), delete this.mapEventHandlers[n];
    }
  }
  createEventSection(n) {
    return {
      handlers: [],
      controlHandler: (l) => {
        let p;
        if (hl(l) && n.startsWith(`${Ot}`) ? p = this.gmEventHandlers[n] : p = this.mapEventHandlers[n], !p) {
          Ct.debug(`No handlers for eventName: "${n}"`);
          return;
        }
        p.handlers.some((x) => {
          let M;
          return hl(l) || yR(l) ? M = x(l) : Ct.error("EventsBus: unknown event type", l), M && typeof M == "object" && "next" in M ? !M.next : (Ct.error('EventsBus: handler should return an object with a "next" property'), !1);
        });
      }
    };
  }
}
class Kg {
  gm;
  constructor(n) {
    this.gm = n;
  }
  trackExclusiveModes(n) {
    if (n.action !== "mode_start")
      return;
    const { sectionName: l, modeName: p } = this.getControlIds(n) || {};
    this.getControl(n)?.settings.exclusive && this.gm.control.eachControlWithOptions((x) => {
      const M = x.control.type, S = x.control.targetMode;
      M === l && S === p || x.controlOptions.active && x.control.settings.exclusive && this.gm.options.disableMode(M, S);
    });
  }
  trackRelatedModes(n) {
    Ev(n) && this.gm.control.eachControlWithOptions((l) => {
      const p = l.control, { type: x, targetMode: M } = p;
      p.settings.enabledBy?.includes(n.mode) && (n.action === "mode_start" ? (this.gm.options.isModeEnabled(x, M) && this.gm.options.disableMode(x, M), this.gm.options.enableMode(x, M)) : n.action === "mode_end" ? this.gm.options.disableMode(x, M) : Ct.error("Unknown mode action", n.action));
    });
  }
  getControl(n) {
    const { modeName: l, sectionName: p } = this.getControlIds(n) || {};
    return l && p ? this.gm.control.getControl({ modeType: p, modeName: l }) : null;
  }
  getControlOptions(n) {
    const { modeName: l, sectionName: p } = this.getControlIds(n) || {};
    return l && p ? this.gm.options.getControlOptions({ modeType: p, modeName: l }) : null;
  }
  getControlIds(n) {
    let l = null, p = null;
    return n.action === "mode_start" ? (l = n.actionType, p = n.mode) : E2(n) && (l = n.section, p = n.mode), l && p ? { sectionName: l, modeName: p } : null;
  }
}
class xR extends Kg {
  eventHandlers = {
    [`${Ot}:control`]: this.handleControlEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleControlEvent(n) {
    return E2(n) ? (this.getControl(n) || Ct.error("Control not found, event payload", n), { next: !0 }) : { next: !0 };
  }
}
const bR = ["draw", "edit", "helper"], ol = [
  // shapes
  "marker",
  "circle",
  "circle_marker",
  "ellipse",
  "text_marker",
  "line",
  "rectangle",
  "polygon"
], wR = [
  "dom_marker",
  "vertex_marker",
  "center_marker",
  "edge_marker",
  "snap_guide"
], S2 = [...ol, ...wR], ER = ["freehand", "custom_shape"], T2 = [...ol, ...ER], k2 = [
  "shape_markers",
  "pin",
  "snapping",
  "snap_guides",
  "measurements",
  "auto_trace",
  "geofencing",
  "zoom_to_features",
  "click_to_edit"
], I2 = [
  "drag",
  "change",
  "rotate",
  "scale",
  "copy",
  "cut",
  "split",
  "union",
  "difference",
  "line_simplification",
  "lasso",
  "delete"
], SR = (a) => Array.isArray(a) && a.length === 2 && typeof a[0] == "number" && typeof a[1] == "number", A_ = {
  id: (a) => typeof a == "string" || typeof a == "number",
  shape: (a) => typeof a == "string" && Kl(a, S2),
  center: (a) => SR(a),
  xSemiAxis: (a) => typeof a == "number",
  ySemiAxis: (a) => typeof a == "number",
  angle: (a) => typeof a == "number",
  text: (a) => typeof a == "string",
  disableEdit: (a) => typeof a == "boolean"
};
class lv {
  isMarkerInstanceAvailable() {
    return this.markerInstance ? !0 : (Ct.error("Marker instance is not available"), !1);
  }
}
var Fi = 63710088e-1, M2 = {
  centimeters: Fi * 100,
  centimetres: Fi * 100,
  degrees: 360 / (2 * Math.PI),
  feet: Fi * 3.28084,
  inches: Fi * 39.37,
  kilometers: Fi / 1e3,
  kilometres: Fi / 1e3,
  meters: Fi,
  metres: Fi,
  miles: Fi / 1609.344,
  millimeters: Fi * 1e3,
  millimetres: Fi * 1e3,
  nauticalmiles: Fi / 1852,
  radians: 1,
  yards: Fi * 1.0936
};
function Ja(a, n, l = {}) {
  const p = { type: "Feature" };
  return (l.id === 0 || l.id) && (p.id = l.id), l.bbox && (p.bbox = l.bbox), p.properties = n || {}, p.geometry = a, p;
}
function Ha(a, n, l = {}) {
  if (!a)
    throw new Error("coordinates is required");
  if (!Array.isArray(a))
    throw new Error("coordinates must be an Array");
  if (a.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Cg(a[0]) || !Cg(a[1]))
    throw new Error("coordinates must contain numbers");
  return Ja({
    type: "Point",
    coordinates: a
  }, n, l);
}
function Ql(a, n, l = {}) {
  for (const p of a) {
    if (p.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (p[p.length - 1].length !== p[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let x = 0; x < p[p.length - 1].length; x++)
      if (p[p.length - 1][x] !== p[0][x])
        throw new Error("First and last Position are not equivalent.");
  }
  return Ja({
    type: "Polygon",
    coordinates: a
  }, n, l);
}
function eu(a, n, l = {}) {
  if (a.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return Ja({
    type: "LineString",
    coordinates: a
  }, n, l);
}
function _i(a, n = {}) {
  const l = { type: "FeatureCollection" };
  return n.id && (l.id = n.id), n.bbox && (l.bbox = n.bbox), l.features = a, l;
}
function TR(a, n, l = {}) {
  return Ja({
    type: "MultiLineString",
    coordinates: a
  }, n, l);
}
function C2(a, n, l = {}) {
  return Ja({
    type: "MultiPolygon",
    coordinates: a
  }, n, l);
}
function uv(a, n = "kilometers") {
  const l = M2[n];
  if (!l)
    throw new Error(n + " units is invalid");
  return a * l;
}
function cv(a, n = "kilometers") {
  const l = M2[n];
  if (!l)
    throw new Error(n + " units is invalid");
  return a / l;
}
function fc(a) {
  return a % (2 * Math.PI) * 180 / Math.PI;
}
function Oi(a) {
  return a % 360 * Math.PI / 180;
}
function P2(a, n = "kilometers", l = "kilometers") {
  if (!(a >= 0))
    throw new Error("length must be a positive number");
  return uv(cv(a, n), l);
}
function Cg(a) {
  return !isNaN(a) && a !== null && !Array.isArray(a);
}
function Qg(a) {
  return a !== null && typeof a == "object" && !Array.isArray(a);
}
function ru(a, n, l) {
  if (a !== null)
    for (var p, x, M, S, u, R, z, U = 0, $ = 0, ee, le = a.type, ce = le === "FeatureCollection", _e = le === "Feature", ne = ce ? a.features.length : 1, Pe = 0; Pe < ne; Pe++) {
      z = ce ? a.features[Pe].geometry : _e ? a.geometry : a, ee = z ? z.type === "GeometryCollection" : !1, u = ee ? z.geometries.length : 1;
      for (var ve = 0; ve < u; ve++) {
        var Ue = 0, Qe = 0;
        if (S = ee ? z.geometries[ve] : z, S !== null) {
          R = S.coordinates;
          var et = S.type;
          switch (U = l && (et === "Polygon" || et === "MultiPolygon") ? 1 : 0, et) {
            case null:
              break;
            case "Point":
              if (n(
                R,
                $,
                Pe,
                Ue,
                Qe
              ) === !1)
                return !1;
              $++, Ue++;
              break;
            case "LineString":
            case "MultiPoint":
              for (p = 0; p < R.length; p++) {
                if (n(
                  R[p],
                  $,
                  Pe,
                  Ue,
                  Qe
                ) === !1)
                  return !1;
                $++, et === "MultiPoint" && Ue++;
              }
              et === "LineString" && Ue++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (p = 0; p < R.length; p++) {
                for (x = 0; x < R[p].length - U; x++) {
                  if (n(
                    R[p][x],
                    $,
                    Pe,
                    Ue,
                    Qe
                  ) === !1)
                    return !1;
                  $++;
                }
                et === "MultiLineString" && Ue++, et === "Polygon" && Qe++;
              }
              et === "Polygon" && Ue++;
              break;
            case "MultiPolygon":
              for (p = 0; p < R.length; p++) {
                for (Qe = 0, x = 0; x < R[p].length; x++) {
                  for (M = 0; M < R[p][x].length - U; M++) {
                    if (n(
                      R[p][x][M],
                      $,
                      Pe,
                      Ue,
                      Qe
                    ) === !1)
                      return !1;
                    $++;
                  }
                  Qe++;
                }
                Ue++;
              }
              break;
            case "GeometryCollection":
              for (p = 0; p < S.geometries.length; p++)
                if (ru(S.geometries[p], n, l) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Mo(a, n) {
  if (a.type === "Feature")
    n(a, 0);
  else if (a.type === "FeatureCollection")
    for (var l = 0; l < a.features.length && n(a.features[l], l) !== !1; l++)
      ;
}
function kR(a, n, l) {
  var p = l;
  return Mo(a, function(x, M) {
    M === 0 && l === void 0 ? p = x : p = n(p, x, M);
  }), p;
}
function xc(a, n) {
  var l, p, x, M, S, u, R, z, U, $, ee = 0, le = a.type === "FeatureCollection", ce = a.type === "Feature", _e = le ? a.features.length : 1;
  for (l = 0; l < _e; l++) {
    for (u = le ? a.features[l].geometry : ce ? a.geometry : a, z = le ? a.features[l].properties : ce ? a.properties : {}, U = le ? a.features[l].bbox : ce ? a.bbox : void 0, $ = le ? a.features[l].id : ce ? a.id : void 0, R = u ? u.type === "GeometryCollection" : !1, S = R ? u.geometries.length : 1, x = 0; x < S; x++) {
      if (M = R ? u.geometries[x] : u, M === null) {
        if (n(
          null,
          ee,
          z,
          U,
          $
        ) === !1)
          return !1;
        continue;
      }
      switch (M.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (n(
            M,
            ee,
            z,
            U,
            $
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (p = 0; p < M.geometries.length; p++)
            if (n(
              M.geometries[p],
              ee,
              z,
              U,
              $
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    ee++;
  }
}
function IR(a, n, l) {
  var p = l;
  return xc(
    a,
    function(x, M, S, u, R) {
      p = n(
        p,
        x,
        M,
        S,
        u,
        R
      );
    }
  ), p;
}
function tu(a, n) {
  xc(a, function(l, p, x, M, S) {
    var u = l === null ? null : l.type;
    switch (u) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return n(
          Ja(l, x, { bbox: M, id: S }),
          p,
          0
        ) === !1 ? !1 : void 0;
    }
    var R;
    switch (u) {
      case "MultiPoint":
        R = "Point";
        break;
      case "MultiLineString":
        R = "LineString";
        break;
      case "MultiPolygon":
        R = "Polygon";
        break;
    }
    for (var z = 0; z < l.coordinates.length; z++) {
      var U = l.coordinates[z], $ = {
        type: R,
        coordinates: U
      };
      if (n(Ja($, x), p, z) === !1)
        return !1;
    }
  });
}
function il(a, n = {}) {
  if (a.bbox != null && n.recompute !== !0)
    return a.bbox;
  const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return ru(a, (p) => {
    l[0] > p[0] && (l[0] = p[0]), l[1] > p[1] && (l[1] = p[1]), l[2] < p[0] && (l[2] = p[0]), l[3] < p[1] && (l[3] = p[1]);
  }), l;
}
var A2 = il;
function ri(a) {
  if (!a)
    throw new Error("coord is required");
  if (!Array.isArray(a)) {
    if (a.type === "Feature" && a.geometry !== null && a.geometry.type === "Point")
      return [...a.geometry.coordinates];
    if (a.type === "Point")
      return [...a.coordinates];
  }
  if (Array.isArray(a) && a.length >= 2 && !Array.isArray(a[0]) && !Array.isArray(a[1]))
    return [...a];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Js(a) {
  if (Array.isArray(a))
    return a;
  if (a.type === "Feature") {
    if (a.geometry !== null)
      return a.geometry.coordinates;
  } else if (a.coordinates)
    return a.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function jf(a) {
  return a.type === "Feature" ? a.geometry : a;
}
function Gb(a, n) {
  return a.type === "FeatureCollection" ? "FeatureCollection" : a.type === "GeometryCollection" ? "GeometryCollection" : a.type === "Feature" && a.geometry !== null ? a.geometry.type : a.type;
}
function L2(a, n, l, p = {}) {
  const x = ri(a), M = Oi(x[0]), S = Oi(x[1]), u = Oi(l), R = cv(n, p.units), z = Math.asin(
    Math.sin(S) * Math.cos(R) + Math.cos(S) * Math.sin(R) * Math.cos(u)
  ), U = M + Math.atan2(
    Math.sin(u) * Math.sin(R) * Math.cos(S),
    Math.cos(R) - Math.sin(S) * Math.sin(z)
  ), $ = fc(U), ee = fc(z);
  return x[2] !== void 0 ? Ha([$, ee, x[2]], p.properties) : Ha([$, ee], p.properties);
}
function MR(a, n, l = {}) {
  const p = l.steps || 64, x = l.properties ? l.properties : !Array.isArray(a) && a.type === "Feature" && a.properties ? a.properties : {}, M = [];
  for (let S = 0; S < p; S++)
    M.push(
      L2(a, n, S * -360 / p, l).geometry.coordinates
    );
  return M.push(M[0]), Ql([M], x);
}
var CR = MR;
function D2(a, n = {}) {
  let l = 0, p = 0, x = 0;
  return ru(
    a,
    function(M) {
      l += M[0], p += M[1], x++;
    },
    !0
  ), Ha([l / x, p / x], n.properties);
}
var _y = D2;
function PR(a, n, l = {}) {
  let p;
  return l.final ? p = jb(ri(n), ri(a)) : p = jb(ri(a), ri(n)), p > 180 ? -(360 - p) : p;
}
function jb(a, n) {
  const l = Oi(a[1]), p = Oi(n[1]);
  let x = Oi(n[0] - a[0]);
  x > Math.PI && (x -= 2 * Math.PI), x < -Math.PI && (x += 2 * Math.PI);
  const M = Math.log(
    Math.tan(p / 2 + Math.PI / 4) / Math.tan(l / 2 + Math.PI / 4)
  ), S = Math.atan2(x, M);
  return (fc(S) + 360) % 360;
}
function AR(a, n, l = {}) {
  const p = ri(a), x = ri(n);
  x[0] += x[0] - p[0] > 180 ? -360 : p[0] - x[0] > 180 ? 360 : 0;
  const M = LR(p, x);
  return P2(M, "meters", l.units);
}
function LR(a, n, l) {
  l = l === void 0 ? Fi : Number(l);
  const p = l, x = a[1] * Math.PI / 180, M = n[1] * Math.PI / 180, S = M - x;
  let u = Math.abs(n[0] - a[0]) * Math.PI / 180;
  u > Math.PI && (u -= 2 * Math.PI);
  const R = Math.log(
    Math.tan(M / 2 + Math.PI / 4) / Math.tan(x / 2 + Math.PI / 4)
  ), z = Math.abs(R) > 1e-11 ? S / R : Math.cos(x);
  return Math.sqrt(
    S * S + z * z * u * u
  ) * p;
}
function DR(a, n, l, p = {}) {
  const x = n < 0;
  let M = P2(
    Math.abs(n),
    p.units,
    "meters"
  );
  x && (M = -Math.abs(M));
  const S = ri(a), u = RR(
    S,
    M,
    l
  );
  return u[0] += u[0] - S[0] > 180 ? -360 : S[0] - u[0] > 180 ? 360 : 0, Ha(u, p.properties);
}
function RR(a, n, l, p) {
  p = p === void 0 ? Fi : Number(p);
  const x = n / p, M = a[0] * Math.PI / 180, S = Oi(a[1]), u = Oi(l), R = x * Math.cos(u);
  let z = S + R;
  Math.abs(z) > Math.PI / 2 && (z = z > 0 ? Math.PI - z : -Math.PI - z);
  const U = Math.log(
    Math.tan(z / 2 + Math.PI / 4) / Math.tan(S / 2 + Math.PI / 4)
  ), $ = Math.abs(U) > 1e-11 ? R / U : Math.cos(S), ee = x * Math.sin(u) / $;
  return [
    ((M + ee) * 180 / Math.PI + 540) % 360 - 180,
    z * 180 / Math.PI
  ];
}
function em(a) {
  if (!a)
    throw new Error("geojson is required");
  switch (a.type) {
    case "Feature":
      return R2(a);
    case "FeatureCollection":
      return FR(a);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return hv(a);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function R2(a) {
  const n = { type: "Feature" };
  return Object.keys(a).forEach((l) => {
    switch (l) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        n[l] = a[l];
    }
  }), n.properties = F2(a.properties), a.geometry == null ? n.geometry = null : n.geometry = hv(a.geometry), n;
}
function F2(a) {
  const n = {};
  return a && Object.keys(a).forEach((l) => {
    const p = a[l];
    typeof p == "object" ? p === null ? n[l] = null : Array.isArray(p) ? n[l] = p.map((x) => x) : n[l] = F2(p) : n[l] = p;
  }), n;
}
function FR(a) {
  const n = { type: "FeatureCollection" };
  return Object.keys(a).forEach((l) => {
    switch (l) {
      case "type":
      case "features":
        return;
      default:
        n[l] = a[l];
    }
  }), n.features = a.features.map((l) => R2(l)), n;
}
function hv(a) {
  const n = { type: a.type };
  return a.bbox && (n.bbox = a.bbox), a.type === "GeometryCollection" ? (n.geometries = a.geometries.map((l) => hv(l)), n) : (n.coordinates = N2(a.coordinates), n);
}
function N2(a) {
  const n = a;
  return typeof n[0] != "object" ? n.slice() : n.map((l) => N2(l));
}
var NR = em;
function O2(a, n, l) {
  if (l = l || {}, !Qg(l)) throw new Error("options is invalid");
  const p = l.pivot, x = l.mutate;
  if (!a) throw new Error("geojson is required");
  if (n == null || isNaN(n))
    throw new Error("angle is required");
  if (n === 0) return a;
  const M = p ?? D2(a);
  return (x === !1 || x === void 0) && (a = em(a)), ru(a, function(S) {
    const u = PR(M, S) + n, R = AR(M, S), z = Js(
      DR(M, R, u)
    );
    S[0] = z[0], S[1] = z[1];
  }), a;
}
var OR = O2;
function Vb(a, n, l, p) {
  p = p || {};
  let x = p.steps || 64;
  const M = p.units || "kilometers";
  let S = p.angle || 0;
  const u = p.pivot || a, R = p.properties || {};
  if (!a) throw new Error("center is required");
  if (!n) throw new Error("xSemiAxis is required");
  if (!l) throw new Error("ySemiAxis is required");
  if (!Qg(p)) throw new Error("options must be an object");
  if (!Cg(x)) throw new Error("steps must be a number");
  if (!Cg(S)) throw new Error("angle must be a number");
  const z = ri(O2(Ha(ri(a)), S, { pivot: u }));
  S = -90 + S, x = Math.ceil(x / 4);
  const U = [], $ = [], ee = n, le = l, ce = le, _e = (ee - le) / (Math.PI / 2), ne = (ee + le) * Math.PI / 4, Pe = 0.5, ve = x;
  let Ue = 0, Qe = 0;
  for (let Xe = 0; Xe < x; Xe++)
    Qe += Ue, _e === 0 ? Ue = ne / ve / ce : Ue = (-(_e * Qe + ce) + Math.sqrt(Math.pow(_e * Qe + ce, 2) - 4 * (Pe * _e) * -(ne / ve))) / (2 * (Pe * _e)), Qe != 0 && U.push(Qe);
  $.push(0);
  for (let Xe = 0; Xe < U.length; Xe++)
    $.push(U[Xe]);
  $.push(Math.PI / 2);
  for (let Xe = 0; Xe < U.length; Xe++)
    $.push(Math.PI - U[U.length - Xe - 1]);
  $.push(Math.PI);
  for (let Xe = 0; Xe < U.length; Xe++)
    $.push(Math.PI + U[Xe]);
  $.push(3 * Math.PI / 2);
  for (let Xe = 0; Xe < U.length; Xe++)
    $.push(2 * Math.PI - U[U.length - Xe - 1]);
  $.push(0);
  const et = [];
  for (const Xe of $) {
    const ut = Math.atan2(le * Math.sin(Xe), ee * Math.cos(Xe)), Q = Math.sqrt(
      Math.pow(ee, 2) * Math.pow(le, 2) / (Math.pow(ee * Math.sin(ut), 2) + Math.pow(le * Math.cos(ut), 2))
    );
    et.push(
      L2(z, Q, S + fc(ut), {
        units: M
      }).geometry.coordinates
    );
  }
  return Ql([et], R);
}
function z2(a, n, l = {}) {
  if (l.final === !0)
    return zR(a, n);
  const p = ri(a), x = ri(n), M = Oi(p[0]), S = Oi(x[0]), u = Oi(p[1]), R = Oi(x[1]), z = Math.sin(S - M) * Math.cos(R), U = Math.cos(u) * Math.sin(R) - Math.sin(u) * Math.cos(R) * Math.cos(S - M);
  return fc(Math.atan2(z, U));
}
function zR(a, n) {
  let l = z2(n, a);
  return l = (l + 180) % 360, l;
}
var Pg = z2;
function Dh(a, n, l = {}) {
  var p = ri(a), x = ri(n), M = Oi(x[1] - p[1]), S = Oi(x[0] - p[0]), u = Oi(p[1]), R = Oi(x[1]), z = Math.pow(Math.sin(M / 2), 2) + Math.pow(Math.sin(S / 2), 2) * Math.cos(u) * Math.cos(R);
  return uv(
    2 * Math.atan2(Math.sqrt(z), Math.sqrt(1 - z)),
    l.units
  );
}
var B2 = Dh;
function yy(a, n = {}) {
  const l = jf(a);
  switch (!n.properties && a.type === "Feature" && (n.properties = a.properties), l.type) {
    case "Polygon":
      return BR(l, n);
    case "MultiPolygon":
      return GR(l, n);
    default:
      throw new Error("invalid poly");
  }
}
function BR(a, n = {}) {
  const l = jf(a).coordinates, p = n.properties ? n.properties : a.type === "Feature" ? a.properties : {};
  return G2(l, p);
}
function GR(a, n = {}) {
  const l = jf(a).coordinates, p = n.properties ? n.properties : a.type === "Feature" ? a.properties : {}, x = [];
  return l.forEach((M) => {
    x.push(G2(M, p));
  }), _i(x);
}
function G2(a, n) {
  return a.length > 1 ? TR(a, n) : eu(a[0], n);
}
const Ub = (a, n) => a[0] === n[0] && a[1] === n[1], j2 = (a) => a.type === "Feature" && a.geometry.type === "LineString", V2 = (a) => a.type === "Feature" && a.geometry.type === "Polygon", U2 = (a) => a.type === "Feature" && a.geometry.type === "MultiPolygon", L_ = (a, n) => ({
  lng: n[0] - a[0],
  lat: n[1] - a[1]
}), Ag = (a) => Array.isArray(a) && a.length >= 2 && a.length <= 3 && a.every((n) => typeof n == "number"), Vf = (a, n, l = !1) => {
  let p = 0;
  const x = ["features", "geometries", "geometry", "coordinates"], M = (S, u, R = !1) => {
    Ag(S) ? (n({ coordinate: S, path: u }, p), p += 1) : Array.isArray(S) ? S.forEach((z, U) => {
      R && l && U === S.length - 1 && Ag(z) || M(z, [...u, U], R);
    }) : typeof S == "object" && S !== null && ti(S).forEach((z) => {
      const U = S[z];
      if (x.includes(z) && U) {
        const $ = "type" in S && S.type, ee = $ === "Polygon" || $ === "MultiPolygon";
        M(U, [...u, z], ee);
      }
    });
  };
  M(a, []);
}, jR = (a, n) => {
  let l = { coordinate: [0, 0], path: [] }, p = -1;
  try {
    Vf(a, (x, M) => {
      if (n[0] === x.coordinate[0] && n[1] === x.coordinate[1])
        throw p = M, l = x, new Error("stop");
    });
  } catch {
    if (l)
      return {
        index: p,
        coordinate: l.coordinate,
        path: l.path
      };
  }
  return null;
}, q2 = (a, n) => {
  let l = 0;
  const p = ["features", "geometries", "geometry", "coordinates"], x = (M, S, u, R) => {
    Ag(M) && Ag(S) ? (n(
      {
        start: { coordinate: [...M], path: u },
        end: { coordinate: [...S], path: R }
      },
      l
    ), l += 1) : Array.isArray(M) ? M.forEach((z, U) => {
      x(
        z,
        M[U + 1],
        [...u, U],
        [...u, U + 1]
      );
    }) : typeof M == "object" && M !== null && ti(M).forEach((z) => {
      const U = M[z];
      p.includes(z) && U && x(U, void 0, [...u, z], []);
    });
  };
  x(a, void 0, [], []);
}, tm = (a, n) => {
  let l = {
    absCoordIndex: -1,
    featureIndex: -1,
    multiFeatureIndex: -1,
    geometryIndex: -1
  };
  try {
    ru(
      a,
      (p, x, M, S, u) => {
        if (p[0] === n[0] && p[1] === n[1])
          throw l = { absCoordIndex: x, featureIndex: M, multiFeatureIndex: S, geometryIndex: u }, new Error("found");
      }
    );
  } catch {
  }
  return l;
}, Th = (a, n) => {
  const [l, p] = a, [x, M] = n, S = Math.min(l, x), u = Math.min(p, M), R = Math.max(l, x), z = Math.max(p, M);
  return [S, u, R, z];
}, vy = (a, n) => {
  const l = Th(a, n), p = [l[0], l[1]], x = [l[2], l[3]], M = p[0], S = p[1], u = x[0], R = x[1];
  return {
    type: "Feature",
    properties: {
      shape: "rectangle"
    },
    geometry: {
      type: "Polygon",
      coordinates: [
        [
          [M, S],
          [u, S],
          [u, R],
          [M, R],
          [M, S]
        ]
      ]
    }
  };
}, xy = (a) => [a.geometry.coordinates[0], a.geometry.coordinates[1]], dv = (a) => {
  const n = A2(a);
  return [
    [n[0], n[1]],
    // South-West (min-x, min-y)
    [n[2], n[3]]
    // North-East (max-x, max-y)
  ];
}, D_ = (a) => {
  let n = 0;
  return ru(
    a,
    () => {
      n += 1;
    },
    !0
  ), n;
}, VR = (a) => {
  const n = [];
  return ru(
    a,
    (l) => {
      n.push([l[0], l[1]]);
    },
    !0
  ), n;
}, fv = (a) => {
  const n = VR(a);
  return n.some((l) => !$h(n[0], l));
}, $2 = (a) => {
  let n = null;
  try {
    Vf(a, (l) => {
      throw n = l.coordinate, new Error("found");
    });
  } catch {
    return n;
  }
  return null;
}, gg = (a, n) => Math.sqrt((a[0] - n[0]) ** 2 + (a[1] - n[1]) ** 2), UR = (a, n, l) => {
  const [p, x] = [a[0], a[1]], [M, S] = [n[0], n[1]], [u, R] = [l[0], l[1]], z = M - p, U = S - x, $ = u - p, ee = R - x, le = $ * z + ee * U, ce = z * z + U * U;
  let _e = le / ce;
  return _e = Math.max(0, Math.min(1, _e)), [p + _e * z, x + _e * U];
}, qR = (a, n) => {
  const { absCoordIndex: l } = tm(a, n);
  return l !== -1 ? (a.geometry.coordinates.splice(l, 1), !0) : !1;
}, $R = (a, n) => {
  const l = tm(a, n);
  if (l.absCoordIndex !== -1) {
    const p = [l.geometryIndex], x = Nh(
      a.geometry.coordinates,
      p
    ), M = x.findIndex((S) => $h(S, n));
    return x.length <= 4 ? (a.geometry.coordinates.splice(l.geometryIndex, 1), !0) : (x.splice(M, 1), M === 0 && (x[x.length - 1] = [...x[0]]), !0);
  }
  return !1;
}, ZR = (a, n) => {
  const l = tm(a, n);
  if (l.absCoordIndex !== -1) {
    const p = [
      l.multiFeatureIndex,
      l.geometryIndex
    ], x = Nh(
      a.geometry.coordinates,
      p
    ), M = x.findIndex((S) => $h(S, n));
    if (x.length <= 4) {
      p.pop();
      const S = Nh(
        a.geometry.coordinates,
        l.multiFeatureIndex
      );
      return S.splice(l.geometryIndex, 1), S.length === 0 && a.geometry.coordinates.splice(l.multiFeatureIndex, 1), !0;
    }
    return x.splice(M, 1), M === 0 && (x[x.length - 1] = [...x[0]]), !0;
  }
  return !1;
}, HR = (a, n) => j2(a) ? qR(a, n) : V2(a) ? $R(a, n) : U2(a) ? ZR(a, n) : !1, YR = (a, n = "marker") => ({
  type: "Feature",
  properties: {
    shape: n
  },
  geometry: {
    type: "Point",
    coordinates: a
  }
}), pv = ({
  center: a,
  radius: n,
  steps: l = 80
}) => {
  const p = CR(a, n, {
    steps: l,
    units: "meters"
  });
  return p.geometry.coordinates[0][0] = [...p.geometry.coordinates[0][0]], p;
}, qb = ({
  center: a,
  xSemiAxisLngLat: n,
  rimLngLat: l
}) => {
  let p = Dh(a, n, { units: "meters" });
  p === 0 && (p = 1);
  const x = Pg(a, n) - 90;
  let M = 0;
  if (l) {
    const S = -x * Math.PI / 180, u = -(Pg(a, l) - 90) * Math.PI / 180, R = Dh(a, l, { units: "meters" }), z = R * Math.cos(u), U = R * Math.sin(u), $ = z * Math.cos(S) + U * Math.sin(S), ee = z * -Math.sin(S) + U * Math.cos(S), le = $ * $ / (p * p);
    M = Math.abs(ee) / Math.sqrt(1 - le), isNaN(M) && (M = 0);
  }
  return {
    xSemiAxis: p,
    ySemiAxis: M,
    angle: x
  };
}, Z2 = 80, rm = ({
  center: a,
  xSemiAxis: n,
  ySemiAxis: l,
  angle: p,
  properties: x = {}
}) => {
  const M = {
    steps: Z2,
    angle: p,
    units: "meters"
  };
  if (l === void 0 || l === 0) {
    const u = Vb(a, n, 1, M);
    return eu(u.geometry.coordinates[0].slice(0, 41), {
      shape: "line"
    });
  }
  const S = Vb(a, n, l, {
    ...M,
    properties: {
      ...x,
      [`${ns}shape`]: "ellipse",
      [`${ns}center`]: a,
      [`${ns}xSemiAxis`]: n,
      [`${ns}ySemiAxis`]: l,
      [`${ns}angle`]: p
    }
  });
  return S.geometry.coordinates[0][0] = [...S.geometry.coordinates[0][0]], S;
}, WR = [
  "circle",
  "ellipse",
  "rectangle"
];
class xf {
  gm;
  id = "no-id";
  parent = null;
  markers;
  source;
  _geoJson = null;
  constructor(n) {
    this.gm = n.gm, this.id = n.id, this.source = n.source, this.parent = n.parent, this.markers = /* @__PURE__ */ new Map();
    const l = {
      ...n.geoJsonShapeFeature,
      properties: {
        ...this.parseExtraProperties(n.geoJsonShapeFeature),
        ...this.parseGmShapeProperties(n.geoJsonShapeFeature)
      }
    };
    if (n.skipSourceUpdate) {
      if (this._geoJson = {
        ...l,
        id: this.id
      }, this.shape === "circle") {
        const p = xy(_y(this._geoJson));
        this._geoJson.properties[`${ns}center`] = p;
      }
    } else
      this.addGeoJson(l);
  }
  get shape() {
    const n = this.getShapeProperty("shape");
    if (typeof n == "string" && Kl(n, S2))
      return n;
    throw new Error(`Wrong shape type: "${n}"`);
  }
  set shape(n) {
    this.setShapeProperty("shape", n);
  }
  get temporary() {
    return this.source.id === Et.temporary;
  }
  get sourceName() {
    return this.source.id;
  }
  getShapeProperty(n, l) {
    const p = l?.properties || this._geoJson?.properties || {}, x = A_[n], M = p[`${ns}${n}`] ?? p[n];
    if (x && x(M))
      return M;
  }
  setShapeProperty(n, l) {
    if (!this._geoJson) {
      Ct.error("FeatureData.setShapeProperty(): geojson is not set");
      return;
    }
    this._geoJson.properties[`${ns}${n}`] = l, this._updateAllProperties(this._geoJson.properties);
  }
  deleteShapeProperty(n) {
    if (!this._geoJson) {
      Ct.error("FeatureData.deleteShapeProperty(): geojson is not set");
      return;
    }
    delete this._geoJson.properties[`${ns}${n}`], this._updateAllProperties(this._geoJson.properties);
  }
  parseGmShapeProperties(n) {
    const l = this.getShapeProperty("shape", n) || this.gm.features.getFeatureShapeByGeoJson(n);
    l || Ct.error(`FeatureData.importGmShapeProperties(): unknown shape: ${l}`);
    const p = {
      ...Object.fromEntries(
        ti(A_).map((x) => [x, this.getShapeProperty(x, n)])
      ),
      id: this.id,
      shape: l || void 0
    };
    return Object.fromEntries(
      ti(p).filter((x) => p[x] !== void 0).map((x) => [`${ns}${x}`, p[x]])
    );
  }
  parseExtraProperties(n) {
    const l = Qs(n.properties) || {};
    return ti(A_).forEach((p) => {
      delete l[p], delete l[`${ns}${p}`];
    }), l;
  }
  getGeoJson() {
    if (this._geoJson)
      return this._geoJson;
    throw new Error(`Missing GeoJSON for feature: "${this.shape}:${this.id}"`);
  }
  addGeoJson(n) {
    if (this._geoJson = {
      ...n,
      id: this.id
    }, this.shape === "circle") {
      const l = xy(_y(this._geoJson));
      this._geoJson.properties[`${ns}center`] = l;
    }
    this.gm.features.updateManager.updateSource({
      diff: { add: [this._geoJson] },
      sourceName: this.sourceName
    });
  }
  removeGeoJson() {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    this.gm.features.updateManager.updateSource({
      diff: { remove: [this.id] },
      sourceName: this.sourceName
    });
  }
  removeMarkers() {
    this.markers.forEach((n) => {
      n.instance instanceof lv ? n.instance.remove() : this.gm.features.delete(n.instance);
    }), this.markers = /* @__PURE__ */ new Map();
  }
  /**
   * Updates the geometry of this feature.
   *
   * @param geometry - The new geometry for the feature
   *
   * @example
   * // Update a marker's position
   * feature.updateGeometry({ type: 'Point', coordinates: [10, 52] });
   *
   * // Update a polygon's coordinates
   * feature.updateGeometry({
   *   type: 'Polygon',
   *   coordinates: [[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]]
   * });
   */
  updateGeometry(n) {
    const l = this.getGeoJson();
    if (!l)
      throw new Error(`Feature not found: "${this.id}"`);
    this._geoJson = { ...l, geometry: n };
    const p = {
      update: [this._geoJson]
    };
    this.gm.features.updateManager.updateSource({
      diff: p,
      sourceName: this.sourceName
    });
  }
  /**
   * @deprecated Use `updateGeometry()` instead.
   */
  updateGeoJsonGeometry(n) {
    this.updateGeometry(n);
  }
  /**
   * Updates custom properties on this feature. Properties are merged with existing ones.
   * Set a property value to `undefined` to delete it.
   *
   * Internal Geoman properties (prefixed with `gm_`) cannot be modified through this method
   * and will be preserved.
   *
   * @param properties - Object containing properties to update or delete (set to undefined)
   *
   * @example
   * // Add or update properties
   * feature.updateProperties({ color: 'red', size: 10 });
   *
   * // Delete a property
   * feature.updateProperties({ color: undefined });
   *
   * // Mix of updates and deletions
   * feature.updateProperties({ color: 'blue', oldProp: undefined });
   */
  updateProperties(n) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    const l = this.parseGmShapeProperties(this._geoJson), p = new Set(Object.keys(l)), x = {};
    for (const [u, R] of Object.entries(this._geoJson.properties))
      u in n || (x[u] = R);
    for (const [u, R] of Object.entries(n))
      p.has(u) || R !== void 0 && (x[u] = R);
    Object.assign(x, l), this._geoJson.properties = x;
    const M = { ...x };
    for (const [u, R] of Object.entries(n))
      p.has(u) || R === void 0 && (M[u] = void 0);
    const S = { update: [{ ...this._geoJson, properties: M }] };
    this.gm.features.updateManager.updateSource({
      diff: S,
      sourceName: this.sourceName
    });
  }
  /**
   * Replaces all custom properties on this feature. Existing custom properties are removed
   * and replaced with the provided ones.
   *
   * Internal Geoman properties (prefixed with `gm_`) cannot be modified and will be preserved.
   *
   * @param properties - Object containing the new properties (replaces all existing custom properties)
   *
   * @example
   * // Replace all custom properties
   * feature.setProperties({ name: 'New Feature', category: 'poi' });
   */
  setProperties(n) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    const l = this.parseGmShapeProperties(this._geoJson), p = {};
    for (const [M, S] of Object.entries(n))
      S !== void 0 && !(M in l) && (p[M] = S);
    this._geoJson.properties = {
      ...p,
      ...l
    };
    const x = { update: [this._geoJson] };
    this.gm.features.updateManager.updateSource({
      diff: x,
      sourceName: this.sourceName
    });
  }
  /**
   * Internal method to update all properties including Geoman system properties.
   * This should only be used by internal Geoman code (edit modes, draw modes, etc.).
   *
   * @internal
   * @param properties - Properties to merge with existing ones
   */
  _updateAllProperties(n) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    this._geoJson.properties = { ...this._geoJson.properties, ...n };
    const l = { update: [this._geoJson] };
    this.gm.features.updateManager.updateSource({
      diff: l,
      sourceName: this.sourceName
    });
  }
  /**
   * @deprecated Use `updateProperties()` instead. Set property value to `undefined` to delete it.
   */
  updateGeoJsonProperties(n) {
    this._updateAllProperties(n);
  }
  /**
   * @deprecated Use `setProperties()` instead.
   */
  setGeoJsonCustomProperties(n) {
    this.setProperties(n || {});
  }
  /**
   * @deprecated Use `updateProperties()` instead.
   */
  updateGeoJsonCustomProperties(n) {
    this.updateProperties(n || {});
  }
  /**
   * @deprecated Use `updateProperties({ propName: undefined })` instead.
   */
  deleteGeoJsonCustomProperties(n) {
    const l = {};
    for (const p of n)
      l[p] = void 0;
    this.updateProperties(l);
  }
  convertToPolygon() {
    return this.isConvertableToPolygon() ? (this.shape = "polygon", this.deleteShapeProperty("center"), this.deleteShapeProperty("angle"), this.deleteShapeProperty("xSemiAxis"), this.deleteShapeProperty("ySemiAxis"), !0) : !1;
  }
  isConvertableToPolygon() {
    return WR.includes(this.shape);
  }
  // changeSource({ sourceName, atomic }: { sourceName: FeatureSourceName; atomic: boolean }) {
  //   if (atomic) {
  //     this.gm.features.updateManager.withAtomicSourcesUpdate(() =>
  //       this.actualChangeSource({ sourceName, atomic }),
  //     );
  //   } else {
  //     this.actualChangeSource({ sourceName, atomic });
  //   }
  // }
  changeSource({ sourceName: n, atomic: l }) {
    if (this.source.id === n) {
      Ct.error(
        `FeatureData.changeSource: feature "${this.id}" already has the source "${n}"`
      );
      return;
    }
    const p = this.gm.features.sources[n];
    if (!p) {
      Ct.error(`FeatureData.changeSource: missing source "${n}"`);
      return;
    }
    const x = this.getGeoJson();
    if (!x) {
      Ct.error("FeatureData.changeSource: missing shape GeoJSON");
      return;
    }
    this.removeGeoJson(), this.source = p, this.addGeoJson(x), this.markers.forEach((M) => {
      M.instance instanceof xf && M.instance.changeSource({ sourceName: n, atomic: l });
    });
  }
  fireFeatureUpdatedEvent({ mode: n }) {
    const l = {
      name: `${Ot}:edit:feature_updated`,
      level: "system",
      actionType: "edit",
      action: "feature_updated",
      mode: n,
      sourceFeatures: [this],
      targetFeatures: [this],
      markerData: null
    };
    this.gm.events.fire(`${Ot}:edit`, l);
  }
  delete() {
    this.removeGeoJson(), this.removeMarkers();
  }
}
const gv = (a) => hl(a) && a.actionType === "helper", XR = (a) => hl(a) && a.name === `${Ot}:helper:geofencing_violation`;
class mv {
  gm;
  options = {};
  settings = {};
  actions = {};
  flags = {
    featureCreateAllowed: !0,
    featureUpdateAllowed: !0,
    actionInProgress: !1
  };
  internalEventHandlers = {
    [`${Ot}:helper`]: this.handleHelperEvent.bind(this)
  };
  constructor(n) {
    this.gm = n;
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  startAction() {
    this.gm.events.bus.attachEvents(this.internalEventHandlers), this.gm.events.bus.attachEvents(this.eventHandlers), this.onStartAction();
  }
  endAction() {
    this.onEndAction(), this.gm.events.bus.detachEvents(this.eventHandlers), this.gm.events.bus.detachEvents(this.internalEventHandlers);
  }
  getOptionValue(n) {
    const l = this.options[n];
    if (!l)
      throw new Error(`Option ${n} not found`);
    if (["toggle", "hidden"].includes(l.type))
      return l.value;
    if (l.type === "select")
      return l.value.value;
    throw new Error(`Unknown option type: ${JSON.stringify(l)}`);
  }
  getSettingValue(n) {
    if (n in this.settings)
      return this.settings[n];
  }
  applyOptionValue(n, l) {
    const p = this.options[n];
    if (!p) {
      Ct.error("Option not found", n, l);
      return;
    }
    if (p.type === "toggle" && typeof l == "boolean")
      p.value = l;
    else if (p.type === "select") {
      const x = p.choices.find((M) => M.value === l);
      x && (p.value = x);
    } else p.type === "hidden" ? p.value = l : Ct.error("Can't apply option value", n, l, p);
  }
  handleHelperEvent(n) {
    return XR(n) ? this.handleGeofencingViolationEvent(n) : { next: !0 };
  }
  handleGeofencingViolationEvent(n) {
    return n.actionType === "draw" ? this.flags.featureCreateAllowed = !1 : n.actionType === "edit" && (this.flags.featureUpdateAllowed = !1), { next: !0 };
  }
}
const _v = (a) => hl(a) && a.actionType === "draw", JR = (a) => hl(a) && (a.name === `${Ot}:draw:shape` || a.name === `${Ot}:draw:shape_with_data`), H2 = (a) => JR(a) && a.variant === "line_drawer";
class _l extends mv {
  actionType = "draw";
  shape = null;
  featureData = null;
  saveFeature() {
    if (this.featureData) {
      const n = this.featureData.getGeoJson();
      this.removeTmpFeature(), this.gm.features.createFeature({
        sourceName: Et.main,
        shapeGeoJson: n
      });
    } else
      Ct.error("BaseDraw.saveFeature: no featureData to save");
  }
  removeTmpFeature() {
    this.featureData && (this.featureData.temporary || Ct.error("Not a temporary feature to remove", this.featureData), this.gm.features.delete(this.featureData), this.featureData = null);
  }
  fireBeforeFeatureCreate({
    geoJsonFeatures: n,
    forceMode: l = void 0
  }) {
    this.flags.featureCreateAllowed = !0;
    const p = {
      name: `${Ot}:feature:before_create`,
      level: "system",
      actionType: "draw",
      mode: l || this.mode,
      action: "before_create",
      geoJsonFeatures: n
    };
    this.gm.events.fire(`${Ot}:${this.actionType}`, p);
  }
  fireMarkerPointerStartEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const n = this.gm.markerPointer.marker, l = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "start",
      markerData: {
        type: "dom",
        instance: n,
        position: {
          coordinate: n.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${Ot}:draw`, l);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const n = this.gm.markerPointer.marker, l = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "update",
      markerData: {
        type: "dom",
        instance: n,
        position: {
          coordinate: n.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${Ot}:draw`, l);
  }
  fireMarkerPointerFinishEvent() {
    if (!this.shape)
      return;
    const n = {
      name: `${Ot}:draw:shape`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "finish"
    };
    this.gm.events.fire(`${Ot}:draw`, n);
  }
  forwardLineDrawerEvent(n) {
    if (!H2(n) || !this.shape)
      return { next: !0 };
    if (n.action === "start" || n.action === "update") {
      const l = {
        name: `${Ot}:draw:shape_with_data`,
        level: "system",
        actionType: "draw",
        mode: this.shape,
        variant: null,
        action: n.action,
        featureData: n.featureData,
        markerData: n.markerData
      };
      this.gm.events.fire(`${Ot}:draw`, l);
    } else if (n.action === "finish" || n.action === "cancel") {
      const l = {
        name: `${Ot}:draw:shape`,
        level: "system",
        actionType: "draw",
        mode: this.shape,
        variant: null,
        action: n.action
      };
      this.gm.events.fire(`${Ot}:draw`, l);
    }
    return { next: !0 };
  }
  fireStartEvent(n, l = null) {
    if (!this.shape)
      return;
    const p = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:draw`, p);
  }
  fireUpdateEvent(n, l = null) {
    if (!this.shape)
      return;
    const p = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:draw`, p);
  }
  fireFinishEvent() {
    if (!this.shape)
      return;
    const n = {
      name: `${Ot}:draw:shape`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${Ot}:draw`, n);
  }
}
class yv extends _l {
  mode = "circle";
  shape = "circle";
  eventHandlers = {
    mousemove: this.onMouseMove.bind(this),
    click: this.onMouseClick.bind(this)
  };
  circleCenterPoint = null;
  circleCenterLngLat = null;
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: n
      }
    };
  }
  getControlMarkerData() {
    const n = this.gm.markerPointer.marker;
    return n ? {
      type: "dom",
      instance: n,
      position: {
        coordinate: n.getLngLat(),
        path: [-1]
      }
    } : null;
  }
  createFeature() {
    const n = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(this.circleCenterLngLat || [0, 0]),
      sourceName: Et.temporary
    });
    return n && this.circleCenterLngLat && n.setShapeProperty("center", this.circleCenterLngLat), n;
  }
  createMarker() {
    const n = document.createElement("div");
    n.innerHTML = V1;
    const l = n.firstChild;
    return l.style.color = "#278cda", l.style.width = "28px", l.style.height = "28px", l.style.pointerEvents = "none", this.gm.mapAdapter.createDomMarker(
      {
        draggable: !1,
        anchor: "center",
        element: l
      },
      [0, 0]
    );
  }
}
class KR extends yv {
  mode = "circle_marker";
  shape = "circle_marker";
  onStartAction() {
    this.gm.markerPointer.enable({
      customMarker: this.createMarker()
    });
  }
  onEndAction() {
    this.fireMarkerPointerFinishEvent(), super.onEndAction();
  }
  onMouseMove() {
    return this.fireMarkerPointerUpdateEvent(), { next: !0 };
  }
  onMouseClick(n) {
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(), this.circleCenterLngLat = l, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.updateFeaturePosition(this.circleCenterLngLat), this.saveFeature()), { next: !1 };
  }
  updateFeaturePosition(n) {
    if (!this.featureData)
      return;
    const l = this.getFeatureGeoJson(n);
    this.featureData.updateGeoJsonGeometry(l.geometry);
  }
}
const QR = () => window.PointerEvent && "maxTouchPoints" in navigator ? navigator.maxTouchPoints > 0 ? !window.matchMedia("(hover: hover)").matches : !1 : matchMedia("(hover: none)").matches || "ontouchstart" in window ? !0 : "msMaxTouchPoints" in navigator && typeof navigator.msMaxTouchPoints == "number" && navigator.msMaxTouchPoints > 0, bc = (a, n, l = 10) => {
  const p = { ...a };
  return ti(a).forEach((x) => {
    const M = a[x];
    typeof M == "function" ? p[x] = xw(M.bind(n), l, {
      leading: !0,
      trailing: !1
    }) : Ct.error("convertToThrottled: item is not a function", a[x]);
  }), p;
}, eF = (a, n, l = 10) => {
  const p = { ...a };
  return ti(a).forEach((x) => {
    const M = a[x];
    typeof M == "function" ? p[x] = yw(M.bind(n), l, {
      leading: !1,
      trailing: !0
    }) : Ct.error("convertToDebounced: item is not a function", a[x]);
  }), p;
}, $b = async (a, n) => {
  const l = "Promise race timeout";
  await Promise.race([
    a,
    new Promise((p, x) => {
      setTimeout(
        () => x(
          new Error(
            `Timeout ${Nx / 1e3} seconds: ${n || l}`
          )
        ),
        Nx
      );
    })
  ]);
}, tF = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchmove",
  "touchcancel"
], rF = (a) => !!(a && typeof a == "object" && "once" in a && typeof a.once == "function"), Yn = (a, n = { warning: !1 }) => {
  if (!a)
    return n.warning && Ct.warn("Empty event", a), !1;
  const l = typeof a == "object" && "lngLat" in a && "point" in a && "type" in a && "originalEvent" in a && typeof a.type == "string" && tF.includes(a.type);
  return !l && n.warning && Ct.warn("Not a pointer event", a), l;
}, nF = (a) => a.originalEvent.ctrlKey || a.originalEvent.shiftKey || a.originalEvent.altKey || a.originalEvent.metaKey, iF = (a) => {
  const n = ["symbol", "fill", "line", "circle"];
  return !!a && typeof a == "object" && "type" in a && n.includes(a.type);
};
class sF extends yv {
  mode = "circle";
  shape = "circle";
  throttledMethods = bc(
    {
      updateFeatureGeoJson: this.updateFeatureGeoJson
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  onMouseClick(n) {
    if (!Yn(n))
      return { next: !0 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.circleCenterPoint && this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, l)]
      }), this.flags.featureCreateAllowed && (this.saveCircleFeature(l), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.fireFinishEvent());
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = l, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const p = this.getControlMarkerData();
      this.featureData && p && this.fireStartEvent(this.featureData, p);
    }
    return { next: !1 };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const n = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, n)]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(n);
    }
    return this.circleCenterPoint || this.fireMarkerPointerUpdateEvent(), { next: !1 };
  }
  updateFeatureGeoJson(n) {
    if (this.featureData && this.circleCenterLngLat) {
      const l = this.getCircleGeoJson(this.circleCenterLngLat, n);
      this.featureData.updateGeoJsonGeometry(l.geometry);
      const p = this.getControlMarkerData();
      p && this.fireUpdateEvent(this.featureData, p);
    }
  }
  saveCircleFeature(n) {
    if (this.circleCenterLngLat && this.featureData) {
      const l = this.gm.markerPointer.marker?.getLngLat() || n;
      this.updateFeatureGeoJson(l), this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? fv(this.featureData.getGeoJson()) : !1;
  }
  getCircleGeoJson(n, l) {
    const p = this.gm.mapAdapter.getDistance(n, l);
    return {
      ...pv({ center: n, radius: p }),
      properties: {
        shape: this.shape
      }
    };
  }
}
class nu extends mv {
  actionType = "helper";
}
const Y2 = (a) => !!a && typeof a == "object" && a instanceof nu && "removeSnapGuides" in a && "updateSnapGuides" in a && a.mode === "snap_guides" && typeof a.removeSnapGuides == "function" && typeof a.updateSnapGuides == "function", aF = (a) => !!a && typeof a == "object" && a instanceof nu && "getShortestPath" in a && a.mode === "auto_trace" && typeof a.getShortestPath == "function", oF = (a) => !!a && typeof a == "object" && a instanceof nu && "getSharedMarkers" in a && a.mode === "pin" && typeof a.getSharedMarkers == "function";
function lF(a, n = {}) {
  var l, p, x, M = n.properties, S = (l = n.autoComplete) != null ? l : !0, u = (p = n.orderCoords) != null ? p : !0, R = (x = n.mutate) != null ? x : !1;
  if ((R || (a = em(a)), a.type) === "FeatureCollection") {
    var z = [];
    return a.features.forEach(function(U) {
      z.push(
        Js(Zb(U, {}, S, u))
      );
    }), C2(z, M);
  } else
    return Zb(a, M, S, u);
}
function Zb(a, n, l, p) {
  n = n || (a.type === "Feature" ? a.properties : {});
  var x = jf(a), M = x.coordinates, S = x.type;
  if (!M.length) throw new Error("line must contain coordinates");
  switch (S) {
    case "LineString":
      return l && (M = Hb(M)), Ql([M], n);
    case "MultiLineString":
      var u = [], R = 0;
      return M.forEach(function(z) {
        if (l && (z = Hb(z)), p) {
          var U = uF(il(eu(z)));
          U > R ? (u.unshift(z), R = U) : u.push(z);
        } else
          u.push(z);
      }), Ql(u, n);
    default:
      throw new Error("geometry type " + S + " is not supported");
  }
}
function Hb(a) {
  var n = a[0], l = n[0], p = n[1], x = a[a.length - 1], M = x[0], S = x[1];
  return (l !== M || p !== S) && a.push(n), a;
}
function uF(a) {
  var n = a[0], l = a[1], p = a[2], x = a[3];
  return Math.abs(n - p) * Math.abs(l - x);
}
var vv = lF;
class xv extends _l {
  mode = "line";
  snappingKey = "line_drawer";
  drawOptions;
  shapeLngLats = [];
  throttledMethods = bc(
    {
      onMouseMove: this.onMouseMove
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  eventHandlers = {
    [`${Ot}:helper`]: this.handleGmHelperEvent.bind(this),
    click: this.onMouseClick.bind(this),
    mousemove: this.throttledMethods.onMouseMove.bind(this)
  };
  drawerEventHandlers = {
    firstMarkerClick: null,
    lastMarkerClick: null,
    nMarkerClick: null
  };
  constructor(n, l = {
    snappingMarkers: "none",
    targetShape: "line"
  }) {
    super(n), this.drawOptions = l;
  }
  get snapGuidesInstance() {
    const n = this.gm.actionInstances.helper__snap_guides;
    return Y2(n) ? n : null;
  }
  get autoTraceEnabled() {
    return this.gm.options.controls.helper.auto_trace?.active || !1;
  }
  get autoTraceHelperInstance() {
    return this.autoTraceEnabled && Object.values(this.gm.actionInstances).find(aF) || null;
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.endShape(), this.snapGuidesInstance?.removeSnapGuides(), this.clearDrawerHandlers();
  }
  clearDrawerHandlers() {
    this.drawerEventHandlers.firstMarkerClick = null, this.drawerEventHandlers.lastMarkerClick = null, this.drawerEventHandlers.nMarkerClick = null;
  }
  handleGmHelperEvent(n) {
    return gv(n) ? (n.mode === "snap_guides" && n.action === "mode_start" && this.updateSnapGuides(), { next: !0 }) : (Ct.error("LineDrawer.handleGmHelperEvent: invalid event", n), { next: !0 });
  }
  updateSnapGuides() {
    if (this.snapGuidesInstance) {
      const n = this.featureData?.getGeoJson();
      n && n.geometry.coordinates.pop(), this.snapGuidesInstance.updateSnapGuides(
        n || null,
        this.shapeLngLats.at(-1) || null,
        !0
      );
    }
  }
  on(n, l) {
    this.drawerEventHandlers[n] = l;
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !0 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.featureData) {
      const p = this.getClickedMarkerInfo(n);
      this.handleNextVertex(l, p);
    } else this.isFeatureAllowed(YR(l)) && this.startShape(l);
    return this.updateSnapGuides(), { next: !0 };
  }
  handleNextVertex(n, l) {
    if (!this.featureData) {
      Ct.error("LineDrawer.handleNextVertex: no featureData");
      return;
    }
    const p = this.featureData.markers.size, x = this.getMarkerClickEventData(l.index);
    l.index < p - 1 && this.addPoint(n, l), l.index !== -1 && (l.index === 0 ? this.drawerEventHandlers.firstMarkerClick?.(x) : l.index > 0 && l.index === p - 1 && this.drawerEventHandlers.lastMarkerClick?.(x), l.index >= 0 && this.drawerEventHandlers.nMarkerClick?.(x));
  }
  getMarkerClickEventData(n) {
    const l = this.getFeatureGeoJson({ withControlMarker: !1 });
    return {
      markerIndex: n,
      shapeCoordinates: this.getShapeCoordinates({ withControlMarker: !1 }),
      geoJson: l,
      bounds: dv(l)
    };
  }
  onMouseMove(n) {
    return Yn(n, { warning: !0 }) ? (this.featureData && this.shapeLngLats.length && this.updateFeatureSource(), { next: !0 }) : { next: !0 };
  }
  startShape(n) {
    this.shapeLngLats = [n], this.featureData = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson({ withControlMarker: !0 }),
      sourceName: Et.temporary
    });
    const l = {
      type: "dom",
      instance: this.createMarker(n),
      position: {
        coordinate: n,
        path: ["geometry", "coordinates", 0]
      }
    };
    this.featureData && (this.featureData.markers.set(l.position.path.join("."), l), this.setSnapping(), this.fireStartEvent(this.featureData, l)), this.gm.mapAdapter.disableMapInteractions(["doubleClickZoom"]);
  }
  endShape() {
    const n = this.getFeatureGeoJson({ withControlMarker: !1 });
    this.removeSnapping(), this.removeTmpFeature(), this.shapeLngLats = [], this.gm.mapAdapter.enableMapInteractions(["doubleClickZoom"]), this.fireStopEvent(n);
  }
  setSnapping() {
    if (!this.snappingHelper)
      return;
    const n = this.drawOptions.snappingMarkers;
    n === "none" ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, []) : n === "all" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, this.shapeLngLats) : n === "first" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [this.shapeLngLats[0]]) : n === "last" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [
      this.shapeLngLats[this.shapeLngLats.length - 1]
    ]) : Ct.error("LineDrawer.setSnapping: invalid data", n, this.shapeLngLats);
  }
  removeSnapping() {
    this.snappingHelper && this.snappingHelper.clearCustomSnappingCoordinates(this.snappingKey);
  }
  getClickedMarkerInfo(n) {
    if (!this.featureData)
      return { index: -1, path: null };
    let l = 0, p = null;
    try {
      this.featureData.markers.forEach((x, M) => {
        if (x.instance instanceof lv) {
          const S = x.instance.getElement() || null, u = n.originalEvent.target, R = u instanceof Element ? u : null;
          if (S && S.contains(R))
            throw p = M, new Error("stop");
        }
        l += 1;
      });
    } catch {
      if (p)
        return { index: l, path: p };
    }
    return { index: -1, path: null };
  }
  addPoint(n, l) {
    const p = this.featureData;
    if (!p) {
      Ct.error("LineDrawer.addPoint: no featureData");
      return;
    }
    const x = this.getAddedLngLats(n, l), M = this.getFeatureGeoJsonWithType({
      withControlMarker: !0,
      coordinates: this.shapeLngLats.concat(x)
    });
    this.isFeatureAllowed(M) && (x.forEach((S) => {
      this.shapeLngLats.push(S);
      const u = this.addMarker(S, p);
      this.fireUpdateEvent(p, u);
    }), this.updateFeatureSource());
  }
  isFeatureAllowed(n) {
    return this.gm.getActiveDrawModes().length ? (this.fireBeforeFeatureCreate({ geoJsonFeatures: [n] }), this.flags.featureCreateAllowed) : !0;
  }
  getAddedLngLats(n, l) {
    if (!this.featureData)
      return Ct.error("LineDrawer.getCurrentLngLats: no featureData"), [];
    const p = this.getMarkerInfoLngLat(l) || n;
    return [...this.getAutoTracePath(p)?.slice(1, -1) || [], p];
  }
  getAutoTracePath(n) {
    const l = this.shapeLngLats.at(-1);
    return this.autoTraceEnabled && this.autoTraceHelperInstance && l && this.autoTraceHelperInstance.getShortestPath(l, n) || null;
  }
  getMarkerInfoLngLat(n) {
    if (this.featureData && n.path) {
      const l = this.featureData.markers.get(n.path);
      if (l && l.type === "dom")
        return l.instance.getLngLat();
      Ct.error("LineDrawer.addPoint: no markerData", n);
    }
    return null;
  }
  addMarker(n, l) {
    const p = {
      type: "dom",
      instance: this.createMarker(n),
      position: {
        coordinate: n,
        path: ["geometry", "coordinates", this.shapeLngLats.length]
      }
    };
    return l.markers.set(p.position.path.join("."), {
      type: "dom",
      instance: p.instance,
      position: {
        coordinate: n,
        path: []
      }
    }), p;
  }
  createMarker(n) {
    return this.gm.mapAdapter.createDomMarker(
      {
        element: this.gm.createSvgMarkerElement("control", {
          pointerEvents: "auto",
          cursor: "pointer"
        }),
        anchor: "center"
      },
      n
    );
  }
  updateFeatureSource() {
    if (this.featureData && (this.featureData.updateGeoJsonGeometry(
      this.getFeatureGeoJson({ withControlMarker: !0 }).geometry
    ), this.gm.markerPointer.marker)) {
      const n = {
        type: "dom",
        instance: this.gm.markerPointer.marker,
        position: {
          coordinate: this.gm.markerPointer.marker.getLngLat(),
          path: ["geometry", "coordinates", this.shapeLngLats.length]
        }
      };
      this.fireUpdateEvent(this.featureData, n);
    }
  }
  getFeatureGeoJson({
    withControlMarker: n,
    coordinates: l = void 0
  }) {
    return {
      type: "Feature",
      properties: {
        shape: "line"
      },
      geometry: {
        type: "LineString",
        coordinates: l || this.getShapeCoordinates({ withControlMarker: n })
      }
    };
  }
  getFeatureGeoJsonWithType({
    withControlMarker: n,
    coordinates: l = void 0
  }) {
    const p = this.getFeatureGeoJson({ withControlMarker: n, coordinates: l });
    return this.drawOptions.targetShape === "polygon" && p.geometry.coordinates.length > 3 ? vv(p, {
      properties: p.properties
    }) : p;
  }
  getShapeCoordinates({ withControlMarker: n }) {
    const l = [...this.shapeLngLats];
    return n && this.gm.markerPointer.marker && l.push(this.gm.markerPointer.marker.getLngLat()), l;
  }
  fireStartEvent(n, l) {
    const p = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      variant: "line_drawer",
      action: "start",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:draw`, p);
  }
  fireUpdateEvent(n, l) {
    const p = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      variant: "line_drawer",
      action: "update",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:draw`, p);
  }
  fireStopEvent(n) {
    const l = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      action: "finish",
      variant: "line_drawer",
      geoJsonFeature: n,
      markerData: null,
      featureData: null
    };
    this.gm.events.fire(`${Ot}:draw`, l);
  }
}
class cF extends _l {
  mode = "line";
  shape = "line";
  lineDrawer = new xv(this.gm, { snappingMarkers: "first", targetShape: "line" });
  eventHandlers = {
    [`${Ot}:draw`]: this.forwardLineDrawerEvent.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("nMarkerClick", this.lineFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(n) {
    return Yn(n) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  lineFinished(n) {
    this.lineDrawer.endShape();
    let l = n.shapeCoordinates;
    return n.markerIndex > 0 && (l = l.slice(0, n.markerIndex + 1)), l.length < 2 ? null : this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(l),
      sourceName: Et.main
    });
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "LineString",
        coordinates: n
      }
    };
  }
}
class hF extends _l {
  mode = "marker";
  shape = "marker";
  eventHandlers = {
    click: this.onMouseClick.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    const n = this.createMarker();
    this.gm.markerPointer.enable({ customMarker: n }), this.fireMarkerPointerStartEvent();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseClick(n) {
    return Yn(n) && (this.featureData = this.createFeature(n), this.featureData && this.saveFeature()), { next: !1 };
  }
  onMouseMove(n) {
    return !Yn(n) || !this.gm.markerPointer.marker ? { next: !0 } : (this.fireMarkerPointerUpdateEvent(), { next: !0 });
  }
  createFeature(n) {
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray(), p = this.getFeatureGeoJson(l);
    return p && (this.fireBeforeFeatureCreate({ geoJsonFeatures: [p] }), this.flags.featureCreateAllowed) ? this.gm.features.createFeature({
      shapeGeoJson: p,
      sourceName: Et.temporary
    }) : null;
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: n
      }
    };
  }
  createMarker(n = Et.temporary) {
    const l = this.gm.options.layerStyles.marker[n]?.find((R) => R.type === "symbol"), p = l?.paint && "icon-opacity" in l.paint ? l.paint["icon-opacity"] : void 0, x = l?.layout && "icon-size" in l.layout ? l.layout["icon-size"] : void 0, M = 36, S = `${x !== void 0 ? Math.round(M * (x / 0.18)) : M}px`, u = this.gm.createSvgMarkerElement("default", {
      width: S,
      height: S,
      pointerEvents: "none",
      ...p !== void 0 && { opacity: String(p) }
    });
    return this.gm.mapAdapter.createDomMarker(
      {
        draggable: !1,
        anchor: "bottom",
        element: u
      },
      [0, 0]
    );
  }
}
function dF(a) {
  var n = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  return Mo(a, (l) => {
    var p;
    switch ((p = l.geometry) == null ? void 0 : p.type) {
      case "Point":
        n.MultiPoint.coordinates.push(l.geometry.coordinates), n.MultiPoint.properties.push(l.properties);
        break;
      case "MultiPoint":
        n.MultiPoint.coordinates.push(...l.geometry.coordinates), n.MultiPoint.properties.push(l.properties);
        break;
      case "LineString":
        n.MultiLineString.coordinates.push(l.geometry.coordinates), n.MultiLineString.properties.push(l.properties);
        break;
      case "MultiLineString":
        n.MultiLineString.coordinates.push(
          ...l.geometry.coordinates
        ), n.MultiLineString.properties.push(l.properties);
        break;
      case "Polygon":
        n.MultiPolygon.coordinates.push(l.geometry.coordinates), n.MultiPolygon.properties.push(l.properties);
        break;
      case "MultiPolygon":
        n.MultiPolygon.coordinates.push(...l.geometry.coordinates), n.MultiPolygon.properties.push(l.properties);
        break;
    }
  }), _i(
    Object.keys(n).filter(function(l) {
      return n[l].coordinates.length;
    }).sort().map(function(l) {
      var p = { type: l, coordinates: n[l].coordinates }, x = { collectedProperties: n[l].properties };
      return Ja(p, x);
    })
  );
}
var fF = dF;
function pF(a, n, l, p, x) {
  W2(a, n, l || 0, p || a.length - 1, x || gF);
}
function W2(a, n, l, p, x) {
  for (; p > l; ) {
    if (p - l > 600) {
      var M = p - l + 1, S = n - l + 1, u = Math.log(M), R = 0.5 * Math.exp(2 * u / 3), z = 0.5 * Math.sqrt(u * R * (M - R) / M) * (S - M / 2 < 0 ? -1 : 1), U = Math.max(l, Math.floor(n - S * R / M + z)), $ = Math.min(p, Math.floor(n + (M - S) * R / M + z));
      W2(a, n, U, $, x);
    }
    var ee = a[n], le = l, ce = p;
    for (Qd(a, l, n), x(a[p], ee) > 0 && Qd(a, l, p); le < ce; ) {
      for (Qd(a, le, ce), le++, ce--; x(a[le], ee) < 0; ) le++;
      for (; x(a[ce], ee) > 0; ) ce--;
    }
    x(a[l], ee) === 0 ? Qd(a, l, ce) : (ce++, Qd(a, ce, p)), ce <= n && (l = ce + 1), n <= ce && (p = ce - 1);
  }
}
function Qd(a, n, l) {
  var p = a[n];
  a[n] = a[l], a[l] = p;
}
function gF(a, n) {
  return a < n ? -1 : a > n ? 1 : 0;
}
class pa {
  constructor(n = 9) {
    this._maxEntries = Math.max(4, n), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(n) {
    let l = this.data;
    const p = [];
    if (!Qp(n, l)) return p;
    const x = this.toBBox, M = [];
    for (; l; ) {
      for (let S = 0; S < l.children.length; S++) {
        const u = l.children[S], R = l.leaf ? x(u) : u;
        Qp(n, R) && (l.leaf ? p.push(u) : F_(n, R) ? this._all(u, p) : M.push(u));
      }
      l = M.pop();
    }
    return p;
  }
  collides(n) {
    let l = this.data;
    if (!Qp(n, l)) return !1;
    const p = [];
    for (; l; ) {
      for (let x = 0; x < l.children.length; x++) {
        const M = l.children[x], S = l.leaf ? this.toBBox(M) : M;
        if (Qp(n, S)) {
          if (l.leaf || F_(n, S)) return !0;
          p.push(M);
        }
      }
      l = p.pop();
    }
    return !1;
  }
  load(n) {
    if (!(n && n.length)) return this;
    if (n.length < this._minEntries) {
      for (let p = 0; p < n.length; p++)
        this.insert(n[p]);
      return this;
    }
    let l = this._build(n.slice(), 0, n.length - 1, 0);
    if (!this.data.children.length)
      this.data = l;
    else if (this.data.height === l.height)
      this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const p = this.data;
        this.data = l, l = p;
      }
      this._insert(l, this.data.height - l.height - 1, !0);
    }
    return this;
  }
  insert(n) {
    return n && this._insert(n, this.data.height - 1), this;
  }
  clear() {
    return this.data = kh([]), this;
  }
  remove(n, l) {
    if (!n) return this;
    let p = this.data;
    const x = this.toBBox(n), M = [], S = [];
    let u, R, z;
    for (; p || M.length; ) {
      if (p || (p = M.pop(), R = M[M.length - 1], u = S.pop(), z = !0), p.leaf) {
        const U = mF(n, p.children, l);
        if (U !== -1)
          return p.children.splice(U, 1), M.push(p), this._condense(M), this;
      }
      !z && !p.leaf && F_(p, x) ? (M.push(p), S.push(u), u = 0, R = p, p = p.children[0]) : R ? (u++, p = R.children[u], z = !1) : p = null;
    }
    return this;
  }
  toBBox(n) {
    return n;
  }
  compareMinX(n, l) {
    return n.minX - l.minX;
  }
  compareMinY(n, l) {
    return n.minY - l.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(n) {
    return this.data = n, this;
  }
  _all(n, l) {
    const p = [];
    for (; n; )
      n.leaf ? l.push(...n.children) : p.push(...n.children), n = p.pop();
    return l;
  }
  _build(n, l, p, x) {
    const M = p - l + 1;
    let S = this._maxEntries, u;
    if (M <= S)
      return u = kh(n.slice(l, p + 1)), Eh(u, this.toBBox), u;
    x || (x = Math.ceil(Math.log(M) / Math.log(S)), S = Math.ceil(M / Math.pow(S, x - 1))), u = kh([]), u.leaf = !1, u.height = x;
    const R = Math.ceil(M / S), z = R * Math.ceil(Math.sqrt(S));
    Yb(n, l, p, z, this.compareMinX);
    for (let U = l; U <= p; U += z) {
      const $ = Math.min(U + z - 1, p);
      Yb(n, U, $, R, this.compareMinY);
      for (let ee = U; ee <= $; ee += R) {
        const le = Math.min(ee + R - 1, $);
        u.children.push(this._build(n, ee, le, x - 1));
      }
    }
    return Eh(u, this.toBBox), u;
  }
  _chooseSubtree(n, l, p, x) {
    for (; x.push(l), !(l.leaf || x.length - 1 === p); ) {
      let M = 1 / 0, S = 1 / 0, u;
      for (let R = 0; R < l.children.length; R++) {
        const z = l.children[R], U = R_(z), $ = vF(n, z) - U;
        $ < S ? (S = $, M = U < M ? U : M, u = z) : $ === S && U < M && (M = U, u = z);
      }
      l = u || l.children[0];
    }
    return l;
  }
  _insert(n, l, p) {
    const x = p ? n : this.toBBox(n), M = [], S = this._chooseSubtree(x, this.data, l, M);
    for (S.children.push(n), of(S, x); l >= 0 && M[l].children.length > this._maxEntries; )
      this._split(M, l), l--;
    this._adjustParentBBoxes(x, M, l);
  }
  // split overflowed node into two
  _split(n, l) {
    const p = n[l], x = p.children.length, M = this._minEntries;
    this._chooseSplitAxis(p, M, x);
    const S = this._chooseSplitIndex(p, M, x), u = kh(p.children.splice(S, p.children.length - S));
    u.height = p.height, u.leaf = p.leaf, Eh(p, this.toBBox), Eh(u, this.toBBox), l ? n[l - 1].children.push(u) : this._splitRoot(p, u);
  }
  _splitRoot(n, l) {
    this.data = kh([n, l]), this.data.height = n.height + 1, this.data.leaf = !1, Eh(this.data, this.toBBox);
  }
  _chooseSplitIndex(n, l, p) {
    let x, M = 1 / 0, S = 1 / 0;
    for (let u = l; u <= p - l; u++) {
      const R = af(n, 0, u, this.toBBox), z = af(n, u, p, this.toBBox), U = xF(R, z), $ = R_(R) + R_(z);
      U < M ? (M = U, x = u, S = $ < S ? $ : S) : U === M && $ < S && (S = $, x = u);
    }
    return x || p - l;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(n, l, p) {
    const x = n.leaf ? this.compareMinX : _F, M = n.leaf ? this.compareMinY : yF, S = this._allDistMargin(n, l, p, x), u = this._allDistMargin(n, l, p, M);
    S < u && n.children.sort(x);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(n, l, p, x) {
    n.children.sort(x);
    const M = this.toBBox, S = af(n, 0, l, M), u = af(n, p - l, p, M);
    let R = Kp(S) + Kp(u);
    for (let z = l; z < p - l; z++) {
      const U = n.children[z];
      of(S, n.leaf ? M(U) : U), R += Kp(S);
    }
    for (let z = p - l - 1; z >= l; z--) {
      const U = n.children[z];
      of(u, n.leaf ? M(U) : U), R += Kp(u);
    }
    return R;
  }
  _adjustParentBBoxes(n, l, p) {
    for (let x = p; x >= 0; x--)
      of(l[x], n);
  }
  _condense(n) {
    for (let l = n.length - 1, p; l >= 0; l--)
      n[l].children.length === 0 ? l > 0 ? (p = n[l - 1].children, p.splice(p.indexOf(n[l]), 1)) : this.clear() : Eh(n[l], this.toBBox);
  }
}
function mF(a, n, l) {
  if (!l) return n.indexOf(a);
  for (let p = 0; p < n.length; p++)
    if (l(a, n[p])) return p;
  return -1;
}
function Eh(a, n) {
  af(a, 0, a.children.length, n, a);
}
function af(a, n, l, p, x) {
  x || (x = kh(null)), x.minX = 1 / 0, x.minY = 1 / 0, x.maxX = -1 / 0, x.maxY = -1 / 0;
  for (let M = n; M < l; M++) {
    const S = a.children[M];
    of(x, a.leaf ? p(S) : S);
  }
  return x;
}
function of(a, n) {
  return a.minX = Math.min(a.minX, n.minX), a.minY = Math.min(a.minY, n.minY), a.maxX = Math.max(a.maxX, n.maxX), a.maxY = Math.max(a.maxY, n.maxY), a;
}
function _F(a, n) {
  return a.minX - n.minX;
}
function yF(a, n) {
  return a.minY - n.minY;
}
function R_(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function Kp(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function vF(a, n) {
  return (Math.max(n.maxX, a.maxX) - Math.min(n.minX, a.minX)) * (Math.max(n.maxY, a.maxY) - Math.min(n.minY, a.minY));
}
function xF(a, n) {
  const l = Math.max(a.minX, n.minX), p = Math.max(a.minY, n.minY), x = Math.min(a.maxX, n.maxX), M = Math.min(a.maxY, n.maxY);
  return Math.max(0, x - l) * Math.max(0, M - p);
}
function F_(a, n) {
  return a.minX <= n.minX && a.minY <= n.minY && n.maxX <= a.maxX && n.maxY <= a.maxY;
}
function Qp(a, n) {
  return n.minX <= a.maxX && n.minY <= a.maxY && n.maxX >= a.minX && n.maxY >= a.minY;
}
function kh(a) {
  return {
    children: a,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Yb(a, n, l, p, x) {
  const M = [n, l];
  for (; M.length; ) {
    if (l = M.pop(), n = M.pop(), l - n <= p) continue;
    const S = n + Math.ceil((l - n) / p / 2) * p;
    pF(a, S, n, l, x), M.push(n, S, S, l);
  }
}
function bF(a) {
  return IR(
    a,
    (n, l) => n + wF(l),
    0
  );
}
function wF(a) {
  let n = 0, l;
  switch (a.type) {
    case "Polygon":
      return Wb(a.coordinates);
    case "MultiPolygon":
      for (l = 0; l < a.coordinates.length; l++)
        n += Wb(a.coordinates[l]);
      return n;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function Wb(a) {
  let n = 0;
  if (a && a.length > 0) {
    n += Math.abs(Xb(a[0]));
    for (let l = 1; l < a.length; l++)
      n -= Math.abs(Xb(a[l]));
  }
  return n;
}
var EF = Fi * Fi / 2, N_ = Math.PI / 180;
function Xb(a) {
  const n = a.length - 1;
  if (n <= 2) return 0;
  let l = 0, p = 0;
  for (; p < n; ) {
    const x = a[p], M = a[p + 1 === n ? 0 : p + 1], S = a[p + 2 >= n ? (p + 2) % n : p + 2], u = x[0] * N_, R = M[1] * N_, z = S[0] * N_;
    l += (z - u) * Math.sin(R), p++;
  }
  return l * EF;
}
const cl = 11102230246251565e-32, ts = 134217729, SF = (3 + 8 * cl) * cl;
function O_(a, n, l, p, x) {
  let M, S, u, R, z = n[0], U = p[0], $ = 0, ee = 0;
  U > z == U > -z ? (M = z, z = n[++$]) : (M = U, U = p[++ee]);
  let le = 0;
  if ($ < a && ee < l)
    for (U > z == U > -z ? (S = z + M, u = M - (S - z), z = n[++$]) : (S = U + M, u = M - (S - U), U = p[++ee]), M = S, u !== 0 && (x[le++] = u); $ < a && ee < l; )
      U > z == U > -z ? (S = M + z, R = S - M, u = M - (S - R) + (z - R), z = n[++$]) : (S = M + U, R = S - M, u = M - (S - R) + (U - R), U = p[++ee]), M = S, u !== 0 && (x[le++] = u);
  for (; $ < a; )
    S = M + z, R = S - M, u = M - (S - R) + (z - R), z = n[++$], M = S, u !== 0 && (x[le++] = u);
  for (; ee < l; )
    S = M + U, R = S - M, u = M - (S - R) + (U - R), U = p[++ee], M = S, u !== 0 && (x[le++] = u);
  return (M !== 0 || le === 0) && (x[le++] = M), le;
}
function TF(a, n) {
  let l = n[0];
  for (let p = 1; p < a; p++) l += n[p];
  return l;
}
function Uf(a) {
  return new Float64Array(a);
}
const kF = (3 + 16 * cl) * cl, IF = (2 + 12 * cl) * cl, MF = (9 + 64 * cl) * cl * cl, Sh = Uf(4), Jb = Uf(8), Kb = Uf(12), Qb = Uf(16), ps = Uf(4);
function CF(a, n, l, p, x, M, S) {
  let u, R, z, U, $, ee, le, ce, _e, ne, Pe, ve, Ue, Qe, et, Xe, ut, Q;
  const se = a - x, ge = l - x, Se = n - M, Ie = p - M;
  Qe = se * Ie, ee = ts * se, le = ee - (ee - se), ce = se - le, ee = ts * Ie, _e = ee - (ee - Ie), ne = Ie - _e, et = ce * ne - (Qe - le * _e - ce * _e - le * ne), Xe = Se * ge, ee = ts * Se, le = ee - (ee - Se), ce = Se - le, ee = ts * ge, _e = ee - (ee - ge), ne = ge - _e, ut = ce * ne - (Xe - le * _e - ce * _e - le * ne), Pe = et - ut, $ = et - Pe, Sh[0] = et - (Pe + $) + ($ - ut), ve = Qe + Pe, $ = ve - Qe, Ue = Qe - (ve - $) + (Pe - $), Pe = Ue - Xe, $ = Ue - Pe, Sh[1] = Ue - (Pe + $) + ($ - Xe), Q = ve + Pe, $ = Q - ve, Sh[2] = ve - (Q - $) + (Pe - $), Sh[3] = Q;
  let ze = TF(4, Sh), Re = IF * S;
  if (ze >= Re || -ze >= Re || ($ = a - se, u = a - (se + $) + ($ - x), $ = l - ge, z = l - (ge + $) + ($ - x), $ = n - Se, R = n - (Se + $) + ($ - M), $ = p - Ie, U = p - (Ie + $) + ($ - M), u === 0 && R === 0 && z === 0 && U === 0) || (Re = MF * S + SF * Math.abs(ze), ze += se * U + Ie * u - (Se * z + ge * R), ze >= Re || -ze >= Re)) return ze;
  Qe = u * Ie, ee = ts * u, le = ee - (ee - u), ce = u - le, ee = ts * Ie, _e = ee - (ee - Ie), ne = Ie - _e, et = ce * ne - (Qe - le * _e - ce * _e - le * ne), Xe = R * ge, ee = ts * R, le = ee - (ee - R), ce = R - le, ee = ts * ge, _e = ee - (ee - ge), ne = ge - _e, ut = ce * ne - (Xe - le * _e - ce * _e - le * ne), Pe = et - ut, $ = et - Pe, ps[0] = et - (Pe + $) + ($ - ut), ve = Qe + Pe, $ = ve - Qe, Ue = Qe - (ve - $) + (Pe - $), Pe = Ue - Xe, $ = Ue - Pe, ps[1] = Ue - (Pe + $) + ($ - Xe), Q = ve + Pe, $ = Q - ve, ps[2] = ve - (Q - $) + (Pe - $), ps[3] = Q;
  const De = O_(4, Sh, 4, ps, Jb);
  Qe = se * U, ee = ts * se, le = ee - (ee - se), ce = se - le, ee = ts * U, _e = ee - (ee - U), ne = U - _e, et = ce * ne - (Qe - le * _e - ce * _e - le * ne), Xe = Se * z, ee = ts * Se, le = ee - (ee - Se), ce = Se - le, ee = ts * z, _e = ee - (ee - z), ne = z - _e, ut = ce * ne - (Xe - le * _e - ce * _e - le * ne), Pe = et - ut, $ = et - Pe, ps[0] = et - (Pe + $) + ($ - ut), ve = Qe + Pe, $ = ve - Qe, Ue = Qe - (ve - $) + (Pe - $), Pe = Ue - Xe, $ = Ue - Pe, ps[1] = Ue - (Pe + $) + ($ - Xe), Q = ve + Pe, $ = Q - ve, ps[2] = ve - (Q - $) + (Pe - $), ps[3] = Q;
  const Ne = O_(De, Jb, 4, ps, Kb);
  Qe = u * U, ee = ts * u, le = ee - (ee - u), ce = u - le, ee = ts * U, _e = ee - (ee - U), ne = U - _e, et = ce * ne - (Qe - le * _e - ce * _e - le * ne), Xe = R * z, ee = ts * R, le = ee - (ee - R), ce = R - le, ee = ts * z, _e = ee - (ee - z), ne = z - _e, ut = ce * ne - (Xe - le * _e - ce * _e - le * ne), Pe = et - ut, $ = et - Pe, ps[0] = et - (Pe + $) + ($ - ut), ve = Qe + Pe, $ = ve - Qe, Ue = Qe - (ve - $) + (Pe - $), Pe = Ue - Xe, $ = Ue - Pe, ps[1] = Ue - (Pe + $) + ($ - Xe), Q = ve + Pe, $ = Q - ve, ps[2] = ve - (Q - $) + (Pe - $), ps[3] = Q;
  const Ge = O_(Ne, Kb, 4, ps, Qb);
  return Qb[Ge - 1];
}
function PF(a, n, l, p, x, M) {
  const S = (n - M) * (l - x), u = (a - x) * (p - M), R = S - u, z = Math.abs(S + u);
  return Math.abs(R) >= kF * z ? R : -CF(a, n, l, p, x, M, z);
}
function AF(a, n) {
  var l, p, x = 0, M, S, u, R, z, U, $, ee = a[0], le = a[1], ce = n.length;
  for (l = 0; l < ce; l++) {
    p = 0;
    var _e = n[l], ne = _e.length - 1;
    if (U = _e[0], U[0] !== _e[ne][0] && U[1] !== _e[ne][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (S = U[0] - ee, u = U[1] - le, p; p < ne; p++) {
      if ($ = _e[p + 1], R = $[0] - ee, z = $[1] - le, u === 0 && z === 0) {
        if (R <= 0 && S >= 0 || S <= 0 && R >= 0)
          return 0;
      } else if (z >= 0 && u <= 0 || z <= 0 && u >= 0) {
        if (M = PF(S, R, u, z, 0, 0), M === 0)
          return 0;
        (M > 0 && z > 0 && u <= 0 || M < 0 && z <= 0 && u > 0) && x++;
      }
      U = $, u = z, S = R;
    }
  }
  return x % 2 !== 0;
}
function pc(a, n, l = {}) {
  if (!a)
    throw new Error("point is required");
  if (!n)
    throw new Error("polygon is required");
  const p = ri(a), x = jf(n), M = x.type, S = n.bbox;
  let u = x.coordinates;
  if (S && LF(p, S) === !1)
    return !1;
  M === "Polygon" && (u = [u]);
  let R = !1;
  for (var z = 0; z < u.length; ++z) {
    const U = AF(p, u[z]);
    if (U === 0) return !l.ignoreBoundary;
    U && (R = !0);
  }
  return R;
}
function LF(a, n) {
  return n[0] <= a[0] && n[1] <= a[1] && n[2] >= a[0] && n[3] >= a[1];
}
function DF(a, n, l) {
  if (a.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  l === void 0 && (l = 1);
  var p = a.geometry.coordinates, x = [], M = {};
  if (l) {
    for (var S = [], u = 0; u < p.length; u++)
      for (var R = 0; R < p[u].length - 1; R++)
        S.push(ne(u, R));
    var z = new pa();
    z.load(S);
  }
  for (var U = 0; U < p.length; U++)
    for (var $ = 0; $ < p[U].length - 1; $++)
      if (l) {
        var ee = z.search(ne(U, $));
        ee.forEach(function(Pe) {
          var ve = Pe.ring, Ue = Pe.edge;
          _e(U, $, ve, Ue);
        });
      } else
        for (var le = 0; le < p.length; le++)
          for (var ce = 0; ce < p[le].length - 1; ce++)
            _e(U, $, le, ce);
  return n || (x = {
    type: "Feature",
    geometry: { type: "MultiPoint", coordinates: x }
  }), x;
  function _e(Pe, ve, Ue, Qe) {
    var et = p[Pe][ve], Xe = p[Pe][ve + 1], ut = p[Ue][Qe], Q = p[Ue][Qe + 1], se = RF(et, Xe, ut, Q);
    if (se !== null) {
      var ge, Se;
      if (Xe[0] !== et[0] ? ge = (se[0] - et[0]) / (Xe[0] - et[0]) : ge = (se[1] - et[1]) / (Xe[1] - et[1]), Q[0] !== ut[0] ? Se = (se[0] - ut[0]) / (Q[0] - ut[0]) : Se = (se[1] - ut[1]) / (Q[1] - ut[1]), !(ge >= 1 || ge <= 0 || Se >= 1 || Se <= 0)) {
        var Ie = se, ze = !M[Ie];
        ze && (M[Ie] = !0), n ? x.push(
          n(
            se,
            Pe,
            ve,
            et,
            Xe,
            ge,
            Ue,
            Qe,
            ut,
            Q,
            Se,
            ze
          )
        ) : x.push(se);
      }
    }
  }
  function ne(Pe, ve) {
    var Ue = p[Pe][ve], Qe = p[Pe][ve + 1], et, Xe, ut, Q;
    return Ue[0] < Qe[0] ? (et = Ue[0], Xe = Qe[0]) : (et = Qe[0], Xe = Ue[0]), Ue[1] < Qe[1] ? (ut = Ue[1], Q = Qe[1]) : (ut = Qe[1], Q = Ue[1]), {
      minX: et,
      minY: ut,
      maxX: Xe,
      maxY: Q,
      ring: Pe,
      edge: ve
    };
  }
}
function RF(a, n, l, p) {
  if (lf(a, l) || lf(a, p) || lf(n, l) || lf(p, l))
    return null;
  var x = a[0], M = a[1], S = n[0], u = n[1], R = l[0], z = l[1], U = p[0], $ = p[1], ee = (x - S) * (z - $) - (M - u) * (R - U);
  if (ee === 0) return null;
  var le = ((x * u - M * S) * (R - U) - (x - S) * (R * $ - z * U)) / ee, ce = ((x * u - M * S) * (z - $) - (M - u) * (R * $ - z * U)) / ee;
  return [le, ce];
}
function lf(a, n) {
  if (!a || !n || a.length !== n.length) return !1;
  for (var l = 0, p = a.length; l < p; l++)
    if (a[l] instanceof Array && n[l] instanceof Array) {
      if (!lf(a[l], n[l])) return !1;
    } else if (a[l] !== n[l])
      return !1;
  return !0;
}
function FF(a) {
  if (a.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (a.geometry === void 0 || a.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (a.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  for (var n = a.geometry.coordinates.length, l = [], p = 0; p < n; p++) {
    var x = a.geometry.coordinates[p];
    uf(x[0], x[x.length - 1]) || x.push(x[0]);
    for (var M = 0; M < x.length - 1; M++)
      l.push(x[M]);
  }
  if (!OF(l))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var S = l.length, u = DF(
    a,
    function(zt, At, Dt, Yt, mr, He, yi, fr, Bt, Me, br, ur) {
      return [
        zt,
        At,
        Dt,
        Yt,
        mr,
        He,
        yi,
        fr,
        Bt,
        Me,
        br,
        ur
      ];
    }
  ), R = u.length;
  if (R == 0) {
    for (var z = [], p = 0; p < n; p++)
      z.push(
        Ql([a.geometry.coordinates[p]], {
          parent: -1,
          winding: NF(a.geometry.coordinates[p])
        })
      );
    var Je = _i(z);
    return ft(), Tt(), Je;
  }
  for (var U = [], $ = [], p = 0; p < n; p++) {
    U.push([]);
    for (var M = 0; M < a.geometry.coordinates[p].length - 1; M++)
      U[p].push([
        new e1(
          a.geometry.coordinates[p][Ch(M + 1, a.geometry.coordinates[p].length - 1)],
          1,
          [p, M],
          [p, Ch(M + 1, a.geometry.coordinates[p].length - 1)],
          void 0
        )
      ]), $.push(
        new t1(
          a.geometry.coordinates[p][M],
          [p, Ch(M - 1, a.geometry.coordinates[p].length - 1)],
          [p, M],
          void 0,
          void 0,
          !1,
          !0
        )
      );
  }
  for (var p = 0; p < R; p++)
    U[u[p][1]][u[p][2]].push(
      new e1(
        u[p][0],
        u[p][5],
        [u[p][1], u[p][2]],
        [u[p][6], u[p][7]],
        void 0
      )
    ), u[p][11] && $.push(
      new t1(
        u[p][0],
        [u[p][1], u[p][2]],
        [u[p][6], u[p][7]],
        void 0,
        void 0,
        !0,
        !0
      )
    );
  for (var ee = $.length, p = 0; p < U.length; p++)
    for (var M = 0; M < U[p].length; M++)
      U[p][M].sort(function(Dt, Yt) {
        return Dt.param < Yt.param ? -1 : 1;
      });
  for (var le = [], p = 0; p < ee; p++)
    le.push({
      minX: $[p].coord[0],
      minY: $[p].coord[1],
      maxX: $[p].coord[0],
      maxY: $[p].coord[1],
      index: p
    });
  var ce = new pa();
  ce.load(le);
  for (var p = 0; p < U.length; p++)
    for (var M = 0; M < U[p].length; M++)
      for (var _e = 0; _e < U[p][M].length; _e++) {
        var ne;
        _e == U[p][M].length - 1 ? ne = U[p][Ch(M + 1, a.geometry.coordinates[p].length - 1)][0].coord : ne = U[p][M][_e + 1].coord;
        var Pe = ce.search({
          minX: ne[0],
          minY: ne[1],
          maxX: ne[0],
          maxY: ne[1]
        })[0];
        U[p][M][_e].nxtIsectAlongEdgeIn = Pe.index;
      }
  for (var p = 0; p < U.length; p++)
    for (var M = 0; M < U[p].length; M++)
      for (var _e = 0; _e < U[p][M].length; _e++) {
        var ne = U[p][M][_e].coord, Pe = ce.search({
          minX: ne[0],
          minY: ne[1],
          maxX: ne[0],
          maxY: ne[1]
        })[0], ve = Pe.index;
        ve < S ? $[ve].nxtIsectAlongRingAndEdge2 = U[p][M][_e].nxtIsectAlongEdgeIn : uf(
          $[ve].ringAndEdge1,
          U[p][M][_e].ringAndEdgeIn
        ) ? $[ve].nxtIsectAlongRingAndEdge1 = U[p][M][_e].nxtIsectAlongEdgeIn : $[ve].nxtIsectAlongRingAndEdge2 = U[p][M][_e].nxtIsectAlongEdgeIn;
      }
  for (var Ue = [], p = 0, M = 0; M < n; M++) {
    for (var Qe = p, _e = 0; _e < a.geometry.coordinates[M].length - 1; _e++)
      $[p].coord[0] < $[Qe].coord[0] && (Qe = p), p++;
    for (var et = $[Qe].nxtIsectAlongRingAndEdge2, _e = 0; _e < $.length; _e++)
      if ($[_e].nxtIsectAlongRingAndEdge1 == Qe || $[_e].nxtIsectAlongRingAndEdge2 == Qe) {
        var Xe = _e;
        break;
      }
    var ut = mg(
      [
        $[Xe].coord,
        $[Qe].coord,
        $[et].coord
      ],
      !0
    ) ? 1 : -1;
    Ue.push({ isect: Qe, parent: -1, winding: ut });
  }
  Ue.sort(function(zt, At) {
    return $[zt.isect].coord > $[At.isect].coord ? -1 : 1;
  });
  for (var z = []; Ue.length > 0; ) {
    var Q = Ue.pop(), se = Q.isect, ge = Q.parent, Se = Q.winding, Ie = z.length, ze = [$[se].coord], Re = se;
    if ($[se].ringAndEdge1Walkable)
      var De = $[se].ringAndEdge1, Ne = $[se].nxtIsectAlongRingAndEdge1;
    else
      var De = $[se].ringAndEdge2, Ne = $[se].nxtIsectAlongRingAndEdge2;
    for (; !uf($[se].coord, $[Ne].coord); ) {
      ze.push($[Ne].coord);
      for (var Ge = void 0, p = 0; p < Ue.length; p++)
        if (Ue[p].isect == Ne) {
          Ge = p;
          break;
        }
      if (Ge != null && Ue.splice(Ge, 1), uf(De, $[Ne].ringAndEdge1)) {
        if (De = $[Ne].ringAndEdge2, $[Ne].ringAndEdge2Walkable = !1, $[Ne].ringAndEdge1Walkable) {
          var qe = { isect: Ne };
          mg(
            [
              $[Re].coord,
              $[Ne].coord,
              $[$[Ne].nxtIsectAlongRingAndEdge2].coord
            ],
            Se == 1
          ) ? (qe.parent = ge, qe.winding = -Se) : (qe.parent = Ie, qe.winding = Se), Ue.push(qe);
        }
        Re = Ne, Ne = $[Ne].nxtIsectAlongRingAndEdge2;
      } else {
        if (De = $[Ne].ringAndEdge1, $[Ne].ringAndEdge1Walkable = !1, $[Ne].ringAndEdge2Walkable) {
          var qe = { isect: Ne };
          mg(
            [
              $[Re].coord,
              $[Ne].coord,
              $[$[Ne].nxtIsectAlongRingAndEdge1].coord
            ],
            Se == 1
          ) ? (qe.parent = ge, qe.winding = -Se) : (qe.parent = Ie, qe.winding = Se), Ue.push(qe);
        }
        Re = Ne, Ne = $[Ne].nxtIsectAlongRingAndEdge1;
      }
    }
    ze.push($[Ne].coord), z.push(
      Ql([ze], {
        index: Ie,
        parent: ge,
        winding: Se,
        netWinding: void 0
      })
    );
  }
  var Je = _i(z);
  ft(), Tt();
  function ft() {
    for (var zt = [], At = 0; At < Je.features.length; At++)
      Je.features[At].properties.parent == -1 && zt.push(At);
    if (zt.length > 1)
      for (var At = 0; At < zt.length; At++) {
        for (var Dt = -1, Yt = 1 / 0, mr = 0; mr < Je.features.length; mr++)
          zt[At] != mr && pc(
            Je.features[zt[At]].geometry.coordinates[0][0],
            Je.features[mr],
            { ignoreBoundary: !0 }
          ) && bF(Je.features[mr]) < Yt && (Dt = mr);
        Je.features[zt[At]].properties.parent = Dt;
      }
  }
  function Tt() {
    for (var zt = 0; zt < Je.features.length; zt++)
      if (Je.features[zt].properties.parent == -1) {
        var At = Je.features[zt].properties.winding;
        Je.features[zt].properties.netWinding = At, Zt(zt, At);
      }
  }
  function Zt(zt, At) {
    for (var Dt = 0; Dt < Je.features.length; Dt++)
      if (Je.features[Dt].properties.parent == zt) {
        var Yt = At + Je.features[Dt].properties.winding;
        Je.features[Dt].properties.netWinding = Yt, Zt(Dt, Yt);
      }
  }
  return Je;
}
var e1 = function(a, n, l, p, x) {
  this.coord = a, this.param = n, this.ringAndEdgeIn = l, this.ringAndEdgeOut = p, this.nxtIsectAlongEdgeIn = x;
}, t1 = function(a, n, l, p, x, M, S) {
  this.coord = a, this.ringAndEdge1 = n, this.ringAndEdge2 = l, this.nxtIsectAlongRingAndEdge1 = p, this.nxtIsectAlongRingAndEdge2 = x, this.ringAndEdge1Walkable = M, this.ringAndEdge2Walkable = S;
};
function mg(a, n) {
  if (typeof n > "u" && (n = !0), a.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var l = (a[1][0] - a[0][0]) * (a[2][1] - a[0][1]) - (a[1][1] - a[0][1]) * (a[2][0] - a[0][0]);
  return l >= 0 == n;
}
function NF(a) {
  for (var n = 0, l = 0; l < a.length - 1; l++)
    a[l][0] < a[n][0] && (n = l);
  if (mg(
    [
      a[Ch(n - 1, a.length - 1)],
      a[n],
      a[Ch(n + 1, a.length - 1)]
    ],
    !0
  ))
    var p = 1;
  else
    var p = -1;
  return p;
}
function uf(a, n) {
  if (!a || !n || a.length != n.length) return !1;
  for (var l = 0, p = a.length; l < p; l++)
    if (a[l] instanceof Array && n[l] instanceof Array) {
      if (!uf(a[l], n[l])) return !1;
    } else if (a[l] != n[l])
      return !1;
  return !0;
}
function Ch(a, n) {
  return (a % n + n) % n;
}
function OF(a) {
  for (var n = {}, l = 1, p = 0, x = a.length; p < x; ++p) {
    if (Object.prototype.hasOwnProperty.call(n, a[p])) {
      l = 0;
      break;
    }
    n[a[p]] = 1;
  }
  return l;
}
function zF(a) {
  var n = [];
  return tu(a, function(l) {
    l.geometry.type === "Polygon" && Mo(FF(l), function(p) {
      n.push(Ql(p.geometry.coordinates, l.properties));
    });
  }), _i(n);
}
var BF = zF;
class GF extends _l {
  mode = "polygon";
  shape = "polygon";
  lineDrawer = new xv(this.gm, { snappingMarkers: "first", targetShape: "polygon" });
  eventHandlers = {
    [`${Ot}:draw`]: this.forwardLineDrawerEvent.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("firstMarkerClick", this.polygonFinished.bind(this));
  }
  onMouseMove(n) {
    return Yn(n) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  polygonFinished(n) {
    if (this.lineDrawer.endShape(), n.shapeCoordinates.length < 3)
      return;
    const l = this.fixShapeGeoJson(vv(n.geoJson));
    l && this.gm.features.createFeature({
      shapeGeoJson: {
        ...l,
        properties: {
          // we don't need to have collected properties for a new polygon
          // ...geoJsonPolygon.properties,
          shape: this.shape
        }
      },
      sourceName: Et.main
    });
  }
  fixShapeGeoJson(n) {
    try {
      return NR(fF(BF(n))).features[0];
    } catch {
      return null;
    }
  }
}
class jF extends _l {
  mode = "rectangle";
  shape = "rectangle";
  startLngLat = null;
  eventHandlers = {
    mousemove: this.onMouseMove.bind(this),
    click: this.onMouseClick.bind(this)
  };
  throttledMethods = bc(
    {
      updateFeaturePosition: this.updateFeaturePosition
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.startLngLat = null, this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !1 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.startLngLat) {
      const p = this.getFeatureGeoJson(Th(this.startLngLat, l));
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [p] }), this.flags.featureCreateAllowed && this.finishShape(l);
    } else {
      const p = this.getFeatureGeoJson(Th(l, l));
      if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [p] }), this.flags.featureCreateAllowed) {
        const x = this.startShape(l);
        if (x) {
          const M = this.getControlMarkerData(["geometry", "coordinates", 4]);
          this.fireStartEvent(x, M);
        }
      }
    }
    return { next: !1 };
  }
  onMouseMove(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !1 };
    if (!this.startLngLat)
      return this.fireMarkerPointerUpdateEvent(), { next: !1 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray(), p = Th(this.startLngLat, l), x = this.getFeatureGeoJson(p);
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [x] }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeaturePosition(p), { next: !1 };
  }
  startShape(n) {
    this.startLngLat = n;
    const l = Th(this.startLngLat, this.startLngLat);
    return this.featureData = this.createFeature(l), this.featureData;
  }
  finishShape(n) {
    if (this.startLngLat) {
      const l = Th(this.startLngLat, n);
      this.throttledMethods.updateFeaturePosition(l);
    }
    this.featureData && (this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature()), this.startLngLat = null, this.fireFinishEvent();
  }
  createFeature(n) {
    return this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(n),
      sourceName: Et.temporary
    });
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? fv(this.featureData.getGeoJson()) : !1;
  }
  getFeatureGeoJson(n) {
    return {
      ...vy(
        [n[0], n[1]],
        [n[2], n[3]]
      ),
      properties: {
        shape: this.shape
      }
    };
  }
  updateFeaturePosition(n) {
    if (!this.featureData)
      return;
    const l = vy(
      [n[0], n[1]],
      [n[2], n[3]]
    );
    this.featureData.updateGeoJsonGeometry(l.geometry);
    const p = this.getControlMarkerData(["geometry", "coordinates", 4]);
    this.fireUpdateEvent(this.featureData, p);
  }
  getControlMarkerData(n) {
    const l = this.gm.markerPointer.marker;
    return l ? {
      type: "dom",
      instance: l,
      position: {
        coordinate: l.getLngLat(),
        path: n
      }
    } : null;
  }
  fireStartEvent(n, l) {
    const p = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:draw`, p);
  }
  fireUpdateEvent(n, l) {
    const p = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:draw`, p);
  }
  fireFinishEvent() {
    const n = {
      name: `${Ot}:draw:shape`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${Ot}:draw`, n);
  }
}
class VF extends _l {
  mode = "text_marker";
  shape = "text_marker";
  textarea = null;
  eventHandlers = {
    click: this.onMouseClick.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: !0 });
  }
  onEndAction() {
    this.removeTextarea(), this.removeTmpFeature(), this.featureData = null, this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseMove(n) {
    return Yn(n, { warning: !0 }) ? (this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !0 };
    if (this.textarea)
      this.endShape(), this.gm.markerPointer.enable({ invisibleMarker: !0, lngLat: n.lngLat.toArray() }), this.fireMarkerPointerUpdateEvent();
    else {
      const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(l), this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent());
    }
    return { next: !1 };
  }
  createFeature(n) {
    const l = this.gm.mapAdapter.project(n);
    return this.createTextarea(l), this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(n),
      sourceName: Et.temporary
    });
  }
  endShape() {
    const n = this.textarea?.value || "";
    this.removeTextarea(), n.trim() ? (this.updateFeatureSource(n), this.saveFeature()) : this.removeTmpFeature();
  }
  createTextarea(n) {
    this.textarea = document.createElement("textarea"), this.textarea.style.position = "absolute", this.textarea.style.left = `${n[0]}px`, this.textarea.style.top = `${n[1]}px`, this.textarea.style.opacity = "0.7", this.gm.mapAdapter.getContainer().appendChild(this.textarea), this.textarea.focus();
  }
  removeTextarea() {
    this.textarea?.remove(), this.textarea = null;
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape,
        text: ""
      },
      geometry: {
        type: "Point",
        coordinates: n
      }
    };
  }
  updateFeatureSource(n) {
    this.featureData && this.featureData._updateAllProperties({ shape: this.shape, text: n });
  }
}
class UF extends yv {
  mode = "ellipse";
  shape = "ellipse";
  xSemiAxisPoint = null;
  xSemiAxisLngLat = null;
  throttledMethods = bc(
    {
      updateFeatureGeoJson: this.updateFeatureGeoJson
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  onMouseClick(n) {
    if (!Yn(n))
      return { next: !0 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.circleCenterLngLat && this.xSemiAxisLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [
          this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, l)
        ]
      }), this.flags.featureCreateAllowed && (this.saveEllipseFeature(l), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.xSemiAxisPoint = null, this.xSemiAxisLngLat = null, this.fireFinishEvent());
    else if (this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getEllipseGeoJson(this.circleCenterLngLat, l)]
      }), this.flags.featureCreateAllowed && (this.xSemiAxisLngLat = l, this.xSemiAxisPoint = this.gm.mapAdapter.project(this.circleCenterLngLat));
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = l, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const p = this.getControlMarkerData();
      this.featureData && p && this.fireStartEvent(this.featureData, p);
    }
    return { next: !1 };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const n = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [
          this.xSemiAxisLngLat ? this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, n) : this.getEllipseGeoJson(this.circleCenterLngLat, n)
        ]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(n);
    }
    return this.circleCenterLngLat || this.fireMarkerPointerUpdateEvent(), { next: !1 };
  }
  updateFeatureGeoJson(n) {
    if (!this.featureData || !this.circleCenterLngLat)
      return;
    const l = this.xSemiAxisLngLat ? this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, n) : this.getEllipseGeoJson(this.circleCenterLngLat, n);
    this.featureData.updateGeoJsonGeometry(l.geometry), this.featureData._updateAllProperties({
      shape: l.properties.shape
    });
    const p = this.getControlMarkerData();
    p && this.fireUpdateEvent(this.featureData, p);
  }
  saveEllipseFeature(n) {
    if (!(!this.circleCenterLngLat || !this.xSemiAxisLngLat) && this.featureData) {
      const l = this.gm.markerPointer.marker?.getLngLat() || n;
      this.updateFeatureGeoJson(l);
      const { xSemiAxis: p, ySemiAxis: x, angle: M } = qb({
        center: this.circleCenterLngLat,
        xSemiAxisLngLat: this.xSemiAxisLngLat,
        rimLngLat: l
      });
      this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.featureData.setShapeProperty("xSemiAxis", p), this.featureData.setShapeProperty("ySemiAxis", x), this.featureData.setShapeProperty("angle", M), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? fv(this.featureData.getGeoJson()) : !1;
  }
  getEllipseGeoJson(n, l, p) {
    const { xSemiAxis: x, ySemiAxis: M, angle: S } = qb({
      center: n,
      xSemiAxisLngLat: l,
      rimLngLat: p
    });
    return rm({ center: n, xSemiAxis: x, ySemiAxis: M, angle: S });
  }
}
const by = {
  marker: hF,
  ellipse: UF,
  circle: sF,
  circle_marker: KR,
  text_marker: VF,
  line: cF,
  rectangle: jF,
  polygon: GF,
  freehand: null,
  custom_shape: null
}, qF = (a, n) => by[n] ? new by[n](a) : (Ct.error(`Draw "${n}" is not available`), null), Xh = (a) => hl(a) && a.actionType === "edit", $F = (a) => bR.includes(a), ZF = (a) => T2.includes(a), HF = (a) => I2.includes(a), YF = (a) => k2.includes(a), WF = (a) => ZF(a) || HF(a) || YF(a);
class XF extends Kg {
  eventHandlers = {
    [`${Ot}:draw`]: this.handleDrawEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleDrawEvent(n) {
    if (!_v(n))
      return { next: !0 };
    const l = `${n.actionType}__${n.mode}`;
    return n.action === "mode_start" ? (this.trackExclusiveModes(n), this.start(l, n), this.trackRelatedModes(n)) : n.action === "mode_end" && (this.trackRelatedModes(n), this.end(l)), { next: !0 };
  }
  start(n, l) {
    const p = qF(this.gm, l.mode);
    p && (n in this.gm.actionInstances && Ct.error(`Action instance "${n}" already exists`), this.gm.actionInstances[n] = p, p.startAction());
  }
  end(n) {
    const l = this.gm.actionInstances[n];
    l instanceof _l ? (l.endAction(), delete this.gm.actionInstances[n]) : console.error(`Wrong action instance for draw event "${n}":`, l);
  }
}
class qf extends mv {
  actionType = "edit";
  featureData = null;
  cursorExcludedLayerIds = ["rectangle-line", "polygon-line", "circle-line"];
  layerEventHandlersData = [];
  startAction() {
    this.setEventsForLayers("mouseenter", this.setCursorToPointer.bind(this)), this.setEventsForLayers("mouseleave", this.setCursorToEmpty.bind(this)), super.startAction();
  }
  endAction() {
    this.clearEventsForLayers(), super.endAction();
  }
  setCursorToPointer() {
    this.flags.actionInProgress || this.gm.mapAdapter.setCursor("pointer");
  }
  setCursorToEmpty() {
    this.flags.actionInProgress || this.gm.mapAdapter.setCursor("");
  }
  getFeatureByMouseEvent({
    event: n,
    sourceNames: l
  }) {
    const p = this.gm.features.getFeatureByMouseEvent({
      event: n,
      sourceNames: l
    });
    return !p || p.getShapeProperty("disableEdit") === !0 ? null : p;
  }
  setEventsForLayers(n, l) {
    this.gm.features.layers.map((p) => p.id).filter(
      (p) => !this.cursorExcludedLayerIds.some((x) => p.includes(x))
    ).forEach((p) => {
      this.gm.mapAdapter.on(n, p, l), this.layerEventHandlersData.push({ eventName: n, layerId: p, callback: l });
    });
  }
  clearEventsForLayers() {
    this.layerEventHandlersData.forEach(({ eventName: n, layerId: l, callback: p }) => {
      this.gm.mapAdapter.off(n, l, p);
    }), this.layerEventHandlersData = [];
  }
  updateFeatureGeoJson({
    featureData: n,
    featureGeoJson: l,
    forceMode: p = void 0
  }) {
    return this.flags.featureUpdateAllowed ? (n.updateGeoJsonGeometry(l.geometry), $h(n.getGeoJson().properties, l.properties) || n._updateAllProperties(l.properties), this.fireFeatureUpdatedEvent({
      sourceFeatures: [n],
      targetFeatures: [n],
      forceMode: p
    }), !0) : !1;
  }
  fireBeforeFeatureUpdate({
    features: n,
    geoJsonFeatures: l,
    forceMode: p = void 0
  }) {
    this.flags.featureUpdateAllowed = !0;
    const x = {
      name: `${Ot}:feature:before_update`,
      level: "system",
      actionType: "edit",
      mode: p || this.mode,
      action: "before_update",
      features: n,
      geoJsonFeatures: l
    };
    this.gm.events.fire(`${Ot}:${this.actionType}`, x);
  }
  fireFeatureUpdatedEvent({
    sourceFeatures: n,
    targetFeatures: l,
    markerData: p = void 0,
    forceMode: x = void 0
  }) {
    const M = {
      name: `${Ot}:edit:feature_updated`,
      level: "system",
      actionType: "edit",
      action: "feature_updated",
      mode: x || this.mode,
      sourceFeatures: n,
      targetFeatures: l,
      markerData: p || null
    };
    this.gm.events.fire(`${Ot}:edit`, M);
  }
  fireFeatureEditStartEvent({
    feature: n,
    forceMode: l = void 0
  }) {
    const p = {
      name: `${Ot}:edit:feature_edit_start`,
      level: "system",
      actionType: "edit",
      action: "feature_edit_start",
      mode: l || this.mode,
      feature: n
    };
    this.gm.events.fire(`${Ot}:edit`, p);
  }
  fireFeatureEditEndEvent({
    feature: n,
    forceMode: l = void 0
  }) {
    const p = {
      name: `${Ot}:edit:feature_edit_end`,
      level: "system",
      actionType: "edit",
      action: "feature_edit_end",
      mode: l || this.mode,
      feature: n
    };
    this.gm.events.fire(`${Ot}:edit`, p);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker)
      return;
    const n = this.gm.markerPointer.marker, l = {
      name: `${Ot}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.getLineDrawerMode(),
      action: "update",
      markerData: {
        type: "dom",
        instance: n,
        position: {
          coordinate: n.getLngLat(),
          path: [-1]
        }
      },
      featureData: null
    };
    this.gm.events.fire(`${Ot}:draw`, l);
  }
  forwardLineDrawerEvent(n) {
    if (!H2(n) || !["cut", "split"].includes(this.mode))
      return { next: !0 };
    if (n.action === "start" || n.action === "update") {
      const l = {
        name: `${Ot}:draw:shape_with_data`,
        level: "system",
        actionType: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: n.action,
        featureData: n.featureData,
        markerData: n.markerData
      };
      this.gm.events.fire(`${Ot}:draw`, l);
    } else if (n.action === "finish" || n.action === "cancel") {
      const l = {
        name: `${Ot}:draw:shape`,
        level: "system",
        actionType: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: n.action
      };
      this.gm.events.fire(`${Ot}:draw`, l);
    }
    return { next: !0 };
  }
  fireFeatureRemovedEvent(n) {
    if (Kl(n.shape, ol)) {
      const l = {
        name: `${Ot}:edit:feature_removed`,
        level: "system",
        actionType: "edit",
        mode: n.shape,
        action: "feature_removed",
        featureData: n
      };
      this.gm.events.fire(`${Ot}:edit`, l);
    }
  }
  getLineDrawerMode() {
    return this.mode === "cut" ? "polygon" : (this.mode, "line");
  }
}
function JF(a, n = {}) {
  const l = il(a), p = (l[0] + l[2]) / 2, x = (l[1] + l[3]) / 2;
  return Ha([p, x], n.properties, n);
}
var wy = { exports: {} }, KF = wy.exports, r1;
function QF() {
  return r1 || (r1 = 1, (function(a, n) {
    (function(l, p) {
      a.exports = p();
    })(KF, (function() {
      function l(y, o) {
        (o == null || o > y.length) && (o = y.length);
        for (var h = 0, _ = Array(o); h < o; h++) _[h] = y[h];
        return _;
      }
      function p(y, o, h) {
        return o = U(o), (function(_, I) {
          if (I && (typeof I == "object" || typeof I == "function")) return I;
          if (I !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return (function(D) {
            if (D === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return D;
          })(_);
        })(y, ee() ? Reflect.construct(o, h || [], U(y).constructor) : o.apply(y, h));
      }
      function x(y, o) {
        if (!(y instanceof o)) throw new TypeError("Cannot call a class as a function");
      }
      function M(y, o, h) {
        if (ee()) return Reflect.construct.apply(null, arguments);
        var _ = [null];
        _.push.apply(_, o);
        var I = new (y.bind.apply(y, _))();
        return h && le(I, h.prototype), I;
      }
      function S(y, o) {
        for (var h = 0; h < o.length; h++) {
          var _ = o[h];
          _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(y, ne(_.key), _);
        }
      }
      function u(y, o, h) {
        return o && S(y.prototype, o), h && S(y, h), Object.defineProperty(y, "prototype", { writable: !1 }), y;
      }
      function R(y, o) {
        var h = typeof Symbol < "u" && y[Symbol.iterator] || y["@@iterator"];
        if (!h) {
          if (Array.isArray(y) || (h = Pe(y)) || o) {
            h && (y = h);
            var _ = 0, I = function() {
            };
            return { s: I, n: function() {
              return _ >= y.length ? { done: !0 } : { done: !1, value: y[_++] };
            }, e: function(oe) {
              throw oe;
            }, f: I };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var D, B = !0, W = !1;
        return { s: function() {
          h = h.call(y);
        }, n: function() {
          var oe = h.next();
          return B = oe.done, oe;
        }, e: function(oe) {
          W = !0, D = oe;
        }, f: function() {
          try {
            B || h.return == null || h.return();
          } finally {
            if (W) throw D;
          }
        } };
      }
      function z() {
        return z = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(y, o, h) {
          var _ = (function(D, B) {
            for (; !{}.hasOwnProperty.call(D, B) && (D = U(D)) !== null; ) ;
            return D;
          })(y, o);
          if (_) {
            var I = Object.getOwnPropertyDescriptor(_, o);
            return I.get ? I.get.call(arguments.length < 3 ? y : h) : I.value;
          }
        }, z.apply(null, arguments);
      }
      function U(y) {
        return U = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        }, U(y);
      }
      function $(y, o) {
        if (typeof o != "function" && o !== null) throw new TypeError("Super expression must either be null or a function");
        y.prototype = Object.create(o && o.prototype, { constructor: { value: y, writable: !0, configurable: !0 } }), Object.defineProperty(y, "prototype", { writable: !1 }), o && le(y, o);
      }
      function ee() {
        try {
          var y = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
          })));
        } catch {
        }
        return (ee = function() {
          return !!y;
        })();
      }
      function le(y, o) {
        return le = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, _) {
          return h.__proto__ = _, h;
        }, le(y, o);
      }
      function ce(y, o, h, _) {
        var I = z(U(1 & _ ? y.prototype : y), o, h);
        return 2 & _ && typeof I == "function" ? function(D) {
          return I.apply(h, D);
        } : I;
      }
      function _e(y) {
        return (function(o) {
          if (Array.isArray(o)) return l(o);
        })(y) || (function(o) {
          if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o);
        })(y) || Pe(y) || (function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        })();
      }
      function ne(y) {
        var o = (function(h, _) {
          if (typeof h != "object" || !h) return h;
          var I = h[Symbol.toPrimitive];
          if (I !== void 0) {
            var D = I.call(h, _);
            if (typeof D != "object") return D;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(h);
        })(y, "string");
        return typeof o == "symbol" ? o : o + "";
      }
      function Pe(y, o) {
        if (y) {
          if (typeof y == "string") return l(y, o);
          var h = {}.toString.call(y).slice(8, -1);
          return h === "Object" && y.constructor && (h = y.constructor.name), h === "Map" || h === "Set" ? Array.from(y) : h === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h) ? l(y, o) : void 0;
        }
      }
      function ve(y) {
        var o = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
        return ve = function(h) {
          if (h === null || !(function(I) {
            try {
              return Function.toString.call(I).indexOf("[native code]") !== -1;
            } catch {
              return typeof I == "function";
            }
          })(h)) return h;
          if (typeof h != "function") throw new TypeError("Super expression must either be null or a function");
          if (o !== void 0) {
            if (o.has(h)) return o.get(h);
            o.set(h, _);
          }
          function _() {
            return M(h, arguments, U(this).constructor);
          }
          return _.prototype = Object.create(h.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), le(_, h);
        }, ve(y);
      }
      var Ue = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getEndCapStyle", value: function() {
          return this._endCapStyle;
        } }, { key: "isSingleSided", value: function() {
          return this._isSingleSided;
        } }, { key: "setQuadrantSegments", value: function(o) {
          this._quadrantSegments = o, this._quadrantSegments === 0 && (this._joinStyle = y.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = y.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), o <= 0 && (this._quadrantSegments = 1), this._joinStyle !== y.JOIN_ROUND && (this._quadrantSegments = y.DEFAULT_QUADRANT_SEGMENTS);
        } }, { key: "getJoinStyle", value: function() {
          return this._joinStyle;
        } }, { key: "setJoinStyle", value: function(o) {
          this._joinStyle = o;
        } }, { key: "setSimplifyFactor", value: function(o) {
          this._simplifyFactor = o < 0 ? 0 : o;
        } }, { key: "getSimplifyFactor", value: function() {
          return this._simplifyFactor;
        } }, { key: "getQuadrantSegments", value: function() {
          return this._quadrantSegments;
        } }, { key: "setEndCapStyle", value: function(o) {
          this._endCapStyle = o;
        } }, { key: "getMitreLimit", value: function() {
          return this._mitreLimit;
        } }, { key: "setMitreLimit", value: function(o) {
          this._mitreLimit = o;
        } }, { key: "setSingleSided", value: function(o) {
          this._isSingleSided = o;
        } }], [{ key: "constructor_", value: function() {
          if (this._quadrantSegments = y.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = y.CAP_ROUND, this._joinStyle = y.JOIN_ROUND, this._mitreLimit = y.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = y.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
            if (arguments.length === 1) {
              var o = arguments[0];
              this.setQuadrantSegments(o);
            } else if (arguments.length === 2) {
              var h = arguments[0], _ = arguments[1];
              this.setQuadrantSegments(h), this.setEndCapStyle(_);
            } else if (arguments.length === 4) {
              var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3];
              this.setQuadrantSegments(I), this.setEndCapStyle(D), this.setJoinStyle(B), this.setMitreLimit(W);
            }
          }
        } }, { key: "bufferDistanceError", value: function(o) {
          var h = Math.PI / 2 / o;
          return 1 - Math.cos(h / 2);
        } }]);
      })();
      Ue.CAP_ROUND = 1, Ue.CAP_FLAT = 2, Ue.CAP_SQUARE = 3, Ue.JOIN_ROUND = 1, Ue.JOIN_MITRE = 2, Ue.JOIN_BEVEL = 3, Ue.DEFAULT_QUADRANT_SEGMENTS = 8, Ue.DEFAULT_MITRE_LIMIT = 5, Ue.DEFAULT_SIMPLIFY_FACTOR = 0.01;
      var Qe = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ Exception: o })[0], _;
        }
        return $(o, y), u(o, [{ key: "toString", value: function() {
          return this.message;
        } }]);
      })(ve(Error)), et = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ IllegalArgumentException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), Xe = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y) {
        } }]);
      })();
      function ut() {
      }
      function Q() {
      }
      function se() {
      }
      var ge, Se, Ie, ze, Re, De, Ne, Ge, qe = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "equalsWithTolerance", value: function(y, o, h) {
          return Math.abs(y - o) <= h;
        } }]);
      })(), Je = (function() {
        return u((function y(o, h) {
          x(this, y), this.low = h || 0, this.high = o || 0;
        }), null, [{ key: "toBinaryString", value: function(y) {
          var o, h = "";
          for (o = 2147483648; o > 0; o >>>= 1) h += (y.high & o) === o ? "1" : "0";
          for (o = 2147483648; o > 0; o >>>= 1) h += (y.low & o) === o ? "1" : "0";
          return h;
        } }]);
      })();
      function ft() {
      }
      function Tt() {
      }
      ft.NaN = NaN, ft.isNaN = function(y) {
        return Number.isNaN(y);
      }, ft.isInfinite = function(y) {
        return !Number.isFinite(y);
      }, ft.MAX_VALUE = Number.MAX_VALUE, ft.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, ft.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, typeof Float64Array == "function" && typeof Int32Array == "function" ? (De = 2146435072, Ne = new Float64Array(1), Ge = new Int32Array(Ne.buffer), ft.doubleToLongBits = function(y) {
        Ne[0] = y;
        var o = 0 | Ge[0], h = 0 | Ge[1];
        return (h & De) === De && 1048575 & h && o !== 0 && (o = 0, h = 2146959360), new Je(h, o);
      }, ft.longBitsToDouble = function(y) {
        return Ge[0] = y.low, Ge[1] = y.high, Ne[0];
      }) : (ge = 1023, Se = Math.log2, Ie = Math.floor, ze = Math.pow, Re = (function() {
        for (var y = 53; y > 0; y--) {
          var o = ze(2, y) - 1;
          if (Ie(Se(o)) + 1 === y) return o;
        }
        return 0;
      })(), ft.doubleToLongBits = function(y) {
        var o, h, _, I, D, B, W, oe, de;
        if (y < 0 || 1 / y === Number.NEGATIVE_INFINITY ? (B = 1 << 31, y = -y) : B = 0, y === 0) return new Je(oe = B, de = 0);
        if (y === 1 / 0) return new Je(oe = 2146435072 | B, de = 0);
        if (y != y) return new Je(oe = 2146959360, de = 0);
        if (I = 0, de = 0, (o = Ie(y)) > 1) if (o <= Re) (I = Ie(Se(o))) <= 20 ? (de = 0, oe = o << 20 - I & 1048575) : (de = o % (h = ze(2, _ = I - 20)) << 32 - _, oe = o / h & 1048575);
        else for (_ = o, de = 0; (_ = Ie(h = _ / 2)) !== 0; ) I++, de >>>= 1, de |= (1 & oe) << 31, oe >>>= 1, h !== _ && (oe |= 524288);
        if (W = I + ge, D = o === 0, o = y - o, I < 52 && o !== 0) for (_ = 0; ; ) {
          if ((h = 2 * o) >= 1 ? (o = h - 1, D ? (W--, D = !1) : (_ <<= 1, _ |= 1, I++)) : (o = h, D ? --W == 0 && (I++, D = !1) : (_ <<= 1, I++)), I === 20) oe |= _, _ = 0;
          else if (I === 52) {
            de |= _;
            break;
          }
          if (h === 1) {
            I < 20 ? oe |= _ << 20 - I : I < 52 && (de |= _ << 52 - I);
            break;
          }
        }
        return oe |= W << 20, new Je(oe |= B, de);
      }, ft.longBitsToDouble = function(y) {
        var o, h, _, I, D = y.high, B = y.low, W = D & 1 << 31 ? -1 : 1;
        for (_ = ((2146435072 & D) >> 20) - ge, I = 0, h = 1 << 19, o = 1; o <= 20; o++) D & h && (I += ze(2, -o)), h >>>= 1;
        for (h = 1 << 31, o = 21; o <= 52; o++) B & h && (I += ze(2, -o)), h >>>= 1;
        if (_ === -1023) {
          if (I === 0) return 0 * W;
          _ = -1022;
        } else {
          if (_ === 1024) return I === 0 ? W / 0 : NaN;
          I += 1;
        }
        return W * I * ze(2, _);
      });
      var Zt = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ RuntimeException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), zt = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, null, [{ key: "constructor_", value: function() {
          if (arguments.length === 0) Zt.constructor_.call(this);
          else if (arguments.length === 1) {
            var h = arguments[0];
            Zt.constructor_.call(this, h);
          }
        } }]);
      })(Zt), At = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "shouldNeverReachHere", value: function() {
          if (arguments.length === 0) y.shouldNeverReachHere(null);
          else if (arguments.length === 1) {
            var o = arguments[0];
            throw new zt("Should never reach here" + (o !== null ? ": " + o : ""));
          }
        } }, { key: "isTrue", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            y.isTrue(o, null);
          } else if (arguments.length === 2) {
            var h = arguments[1];
            if (!arguments[0]) throw h === null ? new zt() : new zt(h);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            y.equals(o, h, null);
          } else if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2];
            if (!I.equals(_)) throw new zt("Expected " + _ + " but encountered " + I + (D !== null ? ": " + D : ""));
          }
        } }]);
      })(), Dt = new ArrayBuffer(8), Yt = new Float64Array(Dt), mr = new Int32Array(Dt), He = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getM", value: function() {
          return ft.NaN;
        } }, { key: "setOrdinate", value: function(o, h) {
          switch (o) {
            case y.X:
              this.x = h;
              break;
            case y.Y:
              this.y = h;
              break;
            case y.Z:
              this.setZ(h);
              break;
            default:
              throw new et("Invalid ordinate index: " + o);
          }
        } }, { key: "equals2D", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.x === o.x && this.y === o.y;
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return !!qe.equalsWithTolerance(this.x, h.x, _) && !!qe.equalsWithTolerance(this.y, h.y, _);
          }
        } }, { key: "setM", value: function(o) {
          throw new et("Invalid ordinate index: " + y.M);
        } }, { key: "getZ", value: function() {
          return this.z;
        } }, { key: "getOrdinate", value: function(o) {
          switch (o) {
            case y.X:
              return this.x;
            case y.Y:
              return this.y;
            case y.Z:
              return this.getZ();
          }
          throw new et("Invalid ordinate index: " + o);
        } }, { key: "equals3D", value: function(o) {
          return this.x === o.x && this.y === o.y && (this.getZ() === o.getZ() || ft.isNaN(this.getZ()) && ft.isNaN(o.getZ()));
        } }, { key: "equals", value: function(o) {
          return o instanceof y && this.equals2D(o);
        } }, { key: "equalInZ", value: function(o, h) {
          return qe.equalsWithTolerance(this.getZ(), o.getZ(), h);
        } }, { key: "setX", value: function(o) {
          this.x = o;
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this.x < h.x ? -1 : this.x > h.x ? 1 : this.y < h.y ? -1 : this.y > h.y ? 1 : 0;
        } }, { key: "getX", value: function() {
          return this.x;
        } }, { key: "setZ", value: function(o) {
          this.z = o;
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (o) {
            if (o instanceof CloneNotSupportedException) return At.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw o;
          }
        } }, { key: "copy", value: function() {
          return new y(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
        } }, { key: "distance3D", value: function(o) {
          var h = this.x - o.x, _ = this.y - o.y, I = this.getZ() - o.getZ();
          return Math.sqrt(h * h + _ * _ + I * I);
        } }, { key: "getY", value: function() {
          return this.y;
        } }, { key: "setY", value: function(o) {
          this.y = o;
        } }, { key: "distance", value: function(o) {
          var h = this.x - o.x, _ = this.y - o.y;
          return Math.sqrt(h * h + _ * _);
        } }, { key: "hashCode", value: function() {
          var o = 17;
          return o = 37 * (o = 37 * o + y.hashCode(this.x)) + y.hashCode(this.y);
        } }, { key: "setCoordinate", value: function(o) {
          this.x = o.x, this.y = o.y, this.z = o.getZ();
        } }, { key: "interfaces_", get: function() {
          return [ut, Q, se];
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.z = null, arguments.length === 0) y.constructor_.call(this, 0, 0);
          else if (arguments.length === 1) {
            var o = arguments[0];
            y.constructor_.call(this, o.x, o.y, o.getZ());
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            y.constructor_.call(this, h, _, y.NULL_ORDINATE);
          } else if (arguments.length === 3) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            this.x = I, this.y = D, this.z = B;
          }
        } }, { key: "hashCode", value: function(o) {
          return Yt[0] = o, mr[0] ^ mr[1];
        } }]);
      })(), yi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "compare", value: function(o, h) {
          var _ = y.compare(o.x, h.x);
          if (_ !== 0) return _;
          var I = y.compare(o.y, h.y);
          return I !== 0 ? I : this._dimensionsToTest <= 2 ? 0 : y.compare(o.getZ(), h.getZ());
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimensionsToTest = 2, arguments.length === 0) y.constructor_.call(this, 2);
          else if (arguments.length === 1) {
            var o = arguments[0];
            if (o !== 2 && o !== 3) throw new et("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = o;
          }
        } }, { key: "compare", value: function(o, h) {
          return o < h ? -1 : o > h ? 1 : ft.isNaN(o) ? ft.isNaN(h) ? 0 : -1 : ft.isNaN(h) ? 1 : 0;
        } }]);
      })();
      He.DimensionalComparator = yi, He.NULL_ORDINATE = ft.NaN, He.X = 0, He.Y = 1, He.Z = 2, He.M = 3;
      var fr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getArea", value: function() {
          return this.getWidth() * this.getHeight();
        } }, { key: "equals", value: function(o) {
          if (!(o instanceof y)) return !1;
          var h = o;
          return this.isNull() ? h.isNull() : this._maxx === h.getMaxX() && this._maxy === h.getMaxY() && this._minx === h.getMinX() && this._miny === h.getMinY();
        } }, { key: "intersection", value: function(o) {
          if (this.isNull() || o.isNull() || !this.intersects(o)) return new y();
          var h = this._minx > o._minx ? this._minx : o._minx, _ = this._miny > o._miny ? this._miny : o._miny;
          return new y(h, this._maxx < o._maxx ? this._maxx : o._maxx, _, this._maxy < o._maxy ? this._maxy : o._maxy);
        } }, { key: "isNull", value: function() {
          return this._maxx < this._minx;
        } }, { key: "getMaxX", value: function() {
          return this._maxx;
        } }, { key: "covers", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof He) {
              var o = arguments[0];
              return this.covers(o.x, o.y);
            }
            if (arguments[0] instanceof y) {
              var h = arguments[0];
              return !this.isNull() && !h.isNull() && h.getMinX() >= this._minx && h.getMaxX() <= this._maxx && h.getMinY() >= this._miny && h.getMaxY() <= this._maxy;
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            return !this.isNull() && _ >= this._minx && _ <= this._maxx && I >= this._miny && I <= this._maxy;
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return !this.isNull() && !o.isNull() && !(o._minx > this._maxx || o._maxx < this._minx || o._miny > this._maxy || o._maxy < this._miny);
            }
            if (arguments[0] instanceof He) {
              var h = arguments[0];
              return this.intersects(h.x, h.y);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof He && arguments[1] instanceof He) {
              var _ = arguments[0], I = arguments[1];
              return !this.isNull() && !((_.x < I.x ? _.x : I.x) > this._maxx) && !((_.x > I.x ? _.x : I.x) < this._minx) && !((_.y < I.y ? _.y : I.y) > this._maxy) && !((_.y > I.y ? _.y : I.y) < this._miny);
            }
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var D = arguments[0], B = arguments[1];
              return !this.isNull() && !(D > this._maxx || D < this._minx || B > this._maxy || B < this._miny);
            }
          }
        } }, { key: "getMinY", value: function() {
          return this._miny;
        } }, { key: "getDiameter", value: function() {
          if (this.isNull()) return 0;
          var o = this.getWidth(), h = this.getHeight();
          return Math.sqrt(o * o + h * h);
        } }, { key: "getMinX", value: function() {
          return this._minx;
        } }, { key: "expandToInclude", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof He) {
              var o = arguments[0];
              this.expandToInclude(o.x, o.y);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              if (h.isNull()) return null;
              this.isNull() ? (this._minx = h.getMinX(), this._maxx = h.getMaxX(), this._miny = h.getMinY(), this._maxy = h.getMaxY()) : (h._minx < this._minx && (this._minx = h._minx), h._maxx > this._maxx && (this._maxx = h._maxx), h._miny < this._miny && (this._miny = h._miny), h._maxy > this._maxy && (this._maxy = h._maxy));
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.isNull() ? (this._minx = _, this._maxx = _, this._miny = I, this._maxy = I) : (_ < this._minx && (this._minx = _), _ > this._maxx && (this._maxx = _), I < this._miny && (this._miny = I), I > this._maxy && (this._maxy = I));
          }
        } }, { key: "minExtent", value: function() {
          if (this.isNull()) return 0;
          var o = this.getWidth(), h = this.getHeight();
          return o < h ? o : h;
        } }, { key: "getWidth", value: function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this.isNull() ? h.isNull() ? 0 : -1 : h.isNull() ? 1 : this._minx < h._minx ? -1 : this._minx > h._minx ? 1 : this._miny < h._miny ? -1 : this._miny > h._miny ? 1 : this._maxx < h._maxx ? -1 : this._maxx > h._maxx ? 1 : this._maxy < h._maxy ? -1 : this._maxy > h._maxy ? 1 : 0;
        } }, { key: "translate", value: function(o, h) {
          if (this.isNull()) return null;
          this.init(this.getMinX() + o, this.getMaxX() + o, this.getMinY() + h, this.getMaxY() + h);
        } }, { key: "copy", value: function() {
          return new y(this);
        } }, { key: "toString", value: function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        } }, { key: "setToNull", value: function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        } }, { key: "disjoint", value: function(o) {
          return !(!this.isNull() && !o.isNull()) || o._minx > this._maxx || o._maxx < this._minx || o._miny > this._maxy || o._maxy < this._miny;
        } }, { key: "getHeight", value: function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        } }, { key: "maxExtent", value: function() {
          if (this.isNull()) return 0;
          var o = this.getWidth(), h = this.getHeight();
          return o > h ? o : h;
        } }, { key: "expandBy", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.expandBy(o, o);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            if (this.isNull()) return null;
            this._minx -= h, this._maxx += h, this._miny -= _, this._maxy += _, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        } }, { key: "contains", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.covers(o);
            }
            if (arguments[0] instanceof He) {
              var h = arguments[0];
              return this.covers(h);
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            return this.covers(_, I);
          }
        } }, { key: "centre", value: function() {
          return this.isNull() ? null : new He((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        } }, { key: "init", value: function() {
          if (arguments.length === 0) this.setToNull();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof He) {
              var o = arguments[0];
              this.init(o.x, o.x, o.y, o.y);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this._minx = h._minx, this._maxx = h._maxx, this._miny = h._miny, this._maxy = h._maxy;
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.init(_.x, I.x, _.y, I.y);
          } else if (arguments.length === 4) {
            var D = arguments[0], B = arguments[1], W = arguments[2], oe = arguments[3];
            D < B ? (this._minx = D, this._maxx = B) : (this._minx = B, this._maxx = D), W < oe ? (this._miny = W, this._maxy = oe) : (this._miny = oe, this._maxy = W);
          }
        } }, { key: "getMaxY", value: function() {
          return this._maxy;
        } }, { key: "distance", value: function(o) {
          if (this.intersects(o)) return 0;
          var h = 0;
          this._maxx < o._minx ? h = o._minx - this._maxx : this._minx > o._maxx && (h = this._minx - o._maxx);
          var _ = 0;
          return this._maxy < o._miny ? _ = o._miny - this._maxy : this._miny > o._maxy && (_ = this._miny - o._maxy), h === 0 ? _ : _ === 0 ? h : Math.sqrt(h * h + _ * _);
        } }, { key: "hashCode", value: function() {
          var o = 17;
          return o = 37 * (o = 37 * (o = 37 * (o = 37 * o + He.hashCode(this._minx)) + He.hashCode(this._maxx)) + He.hashCode(this._miny)) + He.hashCode(this._maxy);
        } }, { key: "interfaces_", get: function() {
          return [ut, se];
        } }], [{ key: "constructor_", value: function() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof He) {
              var o = arguments[0];
              this.init(o.x, o.x, o.y, o.y);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this.init(h);
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.init(_.x, I.x, _.y, I.y);
          } else if (arguments.length === 4) {
            var D = arguments[0], B = arguments[1], W = arguments[2], oe = arguments[3];
            this.init(D, B, W, oe);
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 3) {
            var o = arguments[0], h = arguments[1], _ = arguments[2];
            return _.x >= (o.x < h.x ? o.x : h.x) && _.x <= (o.x > h.x ? o.x : h.x) && _.y >= (o.y < h.y ? o.y : h.y) && _.y <= (o.y > h.y ? o.y : h.y);
          }
          if (arguments.length === 4) {
            var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3], oe = Math.min(B.x, W.x), de = Math.max(B.x, W.x), Ze = Math.min(I.x, D.x), rt = Math.max(I.x, D.x);
            return !(Ze > de) && !(rt < oe) && (oe = Math.min(B.y, W.y), de = Math.max(B.y, W.y), Ze = Math.min(I.y, D.y), rt = Math.max(I.y, D.y), !(Ze > de) && !(rt < oe));
          }
        } }]);
      })(), Bt = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isGeometryCollection", value: function() {
          return this.getTypeCode() === y.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getFactory", value: function() {
          return this._factory;
        } }, { key: "getGeometryN", value: function(o) {
          return this;
        } }, { key: "getArea", value: function() {
          return 0;
        } }, { key: "isRectangle", value: function() {
          return !1;
        } }, { key: "equalsExact", value: function(o) {
          return this === o || this.equalsExact(o, 0);
        } }, { key: "geometryChanged", value: function() {
          this.apply(y.geometryChangedFilter);
        } }, { key: "geometryChangedAction", value: function() {
          this._envelope = null;
        } }, { key: "equalsNorm", value: function(o) {
          return o !== null && this.norm().equalsExact(o.norm());
        } }, { key: "getLength", value: function() {
          return 0;
        } }, { key: "getNumGeometries", value: function() {
          return 1;
        } }, { key: "compareTo", value: function() {
          var o;
          if (arguments.length === 1) {
            var h = arguments[0];
            return o = h, this.getTypeCode() !== o.getTypeCode() ? this.getTypeCode() - o.getTypeCode() : this.isEmpty() && o.isEmpty() ? 0 : this.isEmpty() ? -1 : o.isEmpty() ? 1 : this.compareToSameClass(h);
          }
          if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            return o = _, this.getTypeCode() !== o.getTypeCode() ? this.getTypeCode() - o.getTypeCode() : this.isEmpty() && o.isEmpty() ? 0 : this.isEmpty() ? -1 : o.isEmpty() ? 1 : this.compareToSameClass(_, I);
          }
        } }, { key: "getUserData", value: function() {
          return this._userData;
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "getEnvelope", value: function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        } }, { key: "checkNotGeometryCollection", value: function(o) {
          if (o.getTypeCode() === y.TYPECODE_GEOMETRYCOLLECTION) throw new et("This method does not support GeometryCollection arguments");
        } }, { key: "equal", value: function(o, h, _) {
          return _ === 0 ? o.equals(h) : o.distance(h) <= _;
        } }, { key: "norm", value: function() {
          var o = this.copy();
          return o.normalize(), o;
        } }, { key: "reverse", value: function() {
          var o = this.reverseInternal();
          return this.envelope != null && (o.envelope = this.envelope.copy()), o.setSRID(this.getSRID()), o;
        } }, { key: "copy", value: function() {
          var o = this.copyInternal();
          return o.envelope = this._envelope == null ? null : this._envelope.copy(), o._SRID = this._SRID, o._userData = this._userData, o;
        } }, { key: "getPrecisionModel", value: function() {
          return this._factory.getPrecisionModel();
        } }, { key: "getEnvelopeInternal", value: function() {
          return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new fr(this._envelope);
        } }, { key: "setSRID", value: function(o) {
          this._SRID = o;
        } }, { key: "setUserData", value: function(o) {
          this._userData = o;
        } }, { key: "compare", value: function(o, h) {
          for (var _ = o.iterator(), I = h.iterator(); _.hasNext() && I.hasNext(); ) {
            var D = _.next(), B = I.next(), W = D.compareTo(B);
            if (W !== 0) return W;
          }
          return _.hasNext() ? 1 : I.hasNext() ? -1 : 0;
        } }, { key: "hashCode", value: function() {
          return this.getEnvelopeInternal().hashCode();
        } }, { key: "isEquivalentClass", value: function(o) {
          return this.getClass() === o.getClass();
        } }, { key: "isGeometryCollectionOrDerived", value: function() {
          return this.getTypeCode() === y.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === y.TYPECODE_MULTIPOINT || this.getTypeCode() === y.TYPECODE_MULTILINESTRING || this.getTypeCode() === y.TYPECODE_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [Q, ut, se];
        } }, { key: "getClass", value: function() {
          return y;
        } }], [{ key: "hasNonEmptyElements", value: function(o) {
          for (var h = 0; h < o.length; h++) if (!o[h].isEmpty()) return !0;
          return !1;
        } }, { key: "hasNullElements", value: function(o) {
          for (var h = 0; h < o.length; h++) if (o[h] === null) return !0;
          return !1;
        } }]);
      })();
      Bt.constructor_ = function(y) {
        y && (this._envelope = null, this._userData = null, this._factory = y, this._SRID = y.getSRID());
      }, Bt.TYPECODE_POINT = 0, Bt.TYPECODE_MULTIPOINT = 1, Bt.TYPECODE_LINESTRING = 2, Bt.TYPECODE_LINEARRING = 3, Bt.TYPECODE_MULTILINESTRING = 4, Bt.TYPECODE_POLYGON = 5, Bt.TYPECODE_MULTIPOLYGON = 6, Bt.TYPECODE_GEOMETRYCOLLECTION = 7, Bt.TYPENAME_POINT = "Point", Bt.TYPENAME_MULTIPOINT = "MultiPoint", Bt.TYPENAME_LINESTRING = "LineString", Bt.TYPENAME_LINEARRING = "LinearRing", Bt.TYPENAME_MULTILINESTRING = "MultiLineString", Bt.TYPENAME_POLYGON = "Polygon", Bt.TYPENAME_MULTIPOLYGON = "MultiPolygon", Bt.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", Bt.geometryChangedFilter = { get interfaces_() {
        return [Xe];
      }, filter: function(y) {
        y.geometryChangedAction();
      } };
      var Me = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "toLocationSymbol", value: function(o) {
          switch (o) {
            case y.EXTERIOR:
              return "e";
            case y.BOUNDARY:
              return "b";
            case y.INTERIOR:
              return "i";
            case y.NONE:
              return "-";
          }
          throw new et("Unknown location value: " + o);
        } }]);
      })();
      Me.INTERIOR = 0, Me.BOUNDARY = 1, Me.EXTERIOR = 2, Me.NONE = -1;
      var br = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "add", value: function() {
        } }, { key: "addAll", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }, { key: "iterator", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "toArray", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      })(), ur = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ NoSuchElementException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), rr = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ UnsupportedOperationException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), ni = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o, [{ key: "contains", value: function() {
        } }]);
      })(br), Dr = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o)).map = /* @__PURE__ */ new Map(), h instanceof br && _.addAll(h), _;
        }
        return $(o, y), u(o, [{ key: "contains", value: function(h) {
          var _ = h.hashCode ? h.hashCode() : h;
          return !!this.map.has(_);
        } }, { key: "add", value: function(h) {
          var _ = h.hashCode ? h.hashCode() : h;
          return !this.map.has(_) && !!this.map.set(_, h);
        } }, { key: "addAll", value: function(h) {
          var _, I = R(h);
          try {
            for (I.s(); !(_ = I.n()).done; ) {
              var D = _.value;
              this.add(D);
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return !0;
        } }, { key: "remove", value: function() {
          throw new rr();
        } }, { key: "size", value: function() {
          return this.map.size;
        } }, { key: "isEmpty", value: function() {
          return this.map.size === 0;
        } }, { key: "toArray", value: function() {
          return Array.from(this.map.values());
        } }, { key: "iterator", value: function() {
          return new ii(this.map);
        } }, { key: Symbol.iterator, value: function() {
          return this.map;
        } }]);
      })(ni), ii = (function() {
        return u((function y(o) {
          x(this, y), this.iterator = o.values();
          var h = this.iterator.next(), _ = h.done, I = h.value;
          this.done = _, this.value = I;
        }), [{ key: "next", value: function() {
          if (this.done) throw new ur();
          var y = this.value, o = this.iterator.next(), h = o.done, _ = o.value;
          return this.done = h, this.value = _, y;
        } }, { key: "hasNext", value: function() {
          return !this.done;
        } }, { key: "remove", value: function() {
          throw new rr();
        } }]);
      })(), Mt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "opposite", value: function(o) {
          return o === y.LEFT ? y.RIGHT : o === y.RIGHT ? y.LEFT : o;
        } }]);
      })();
      Mt.ON = 0, Mt.LEFT = 1, Mt.RIGHT = 2;
      var Zi = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ EmptyStackException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), Ti = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ IndexOutOfBoundsException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), jn = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o, [{ key: "get", value: function() {
        } }, { key: "set", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }]);
      })(br), Ls = (function(y) {
        function o() {
          var h;
          return x(this, o), (h = p(this, o)).array = [], h;
        }
        return $(o, y), u(o, [{ key: "add", value: function(h) {
          return this.array.push(h), !0;
        } }, { key: "get", value: function(h) {
          if (h < 0 || h >= this.size()) throw new Ti();
          return this.array[h];
        } }, { key: "push", value: function(h) {
          return this.array.push(h), h;
        } }, { key: "pop", value: function() {
          if (this.array.length === 0) throw new Zi();
          return this.array.pop();
        } }, { key: "peek", value: function() {
          if (this.array.length === 0) throw new Zi();
          return this.array[this.array.length - 1];
        } }, { key: "empty", value: function() {
          return this.array.length === 0;
        } }, { key: "isEmpty", value: function() {
          return this.empty();
        } }, { key: "search", value: function(h) {
          return this.array.indexOf(h);
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }]);
      })(jn);
      function tr(y, o) {
        return y.interfaces_ && y.interfaces_.indexOf(o) > -1;
      }
      var ln = (function() {
        return u((function y(o) {
          x(this, y), this.str = o;
        }), [{ key: "append", value: function(y) {
          this.str += y;
        } }, { key: "setCharAt", value: function(y, o) {
          this.str = this.str.substr(0, y) + o + this.str.substr(y + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      })(), Vn = (function() {
        function y(o) {
          x(this, y), this.value = o;
        }
        return u(y, [{ key: "intValue", value: function() {
          return this.value;
        } }, { key: "compareTo", value: function(o) {
          return this.value < o ? -1 : this.value > o ? 1 : 0;
        } }], [{ key: "compare", value: function(o, h) {
          return o < h ? -1 : o > h ? 1 : 0;
        } }, { key: "isNan", value: function(o) {
          return Number.isNaN(o);
        } }, { key: "valueOf", value: function(o) {
          return new y(o);
        } }]);
      })(), Un = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "isWhitespace", value: function(y) {
          return y <= 32 && y >= 0 || y === 127;
        } }, { key: "toUpperCase", value: function(y) {
          return y.toUpperCase();
        } }]);
      })(), Jt = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "le", value: function(o) {
          return this._hi < o._hi || this._hi === o._hi && this._lo <= o._lo;
        } }, { key: "extractSignificantDigits", value: function(o, h) {
          var _ = this.abs(), I = y.magnitude(_._hi), D = y.TEN.pow(I);
          (_ = _.divide(D)).gt(y.TEN) ? (_ = _.divide(y.TEN), I += 1) : _.lt(y.ONE) && (_ = _.multiply(y.TEN), I -= 1);
          for (var B = I + 1, W = new ln(), oe = y.MAX_PRINT_DIGITS - 1, de = 0; de <= oe; de++) {
            o && de === B && W.append(".");
            var Ze = Math.trunc(_._hi);
            if (Ze < 0) break;
            var rt = !1, xt = 0;
            Ze > 9 ? (rt = !0, xt = "9") : xt = "0" + Ze, W.append(xt), _ = _.subtract(y.valueOf(Ze)).multiply(y.TEN), rt && _.selfAdd(y.TEN);
            var jt = !0, qt = y.magnitude(_._hi);
            if (qt < 0 && Math.abs(qt) >= oe - de && (jt = !1), !jt) break;
          }
          return h[0] = I, W.toString();
        } }, { key: "sqr", value: function() {
          return this.multiply(this);
        } }, { key: "doubleValue", value: function() {
          return this._hi + this._lo;
        } }, { key: "subtract", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return this.add(o.negate());
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return this.add(-h);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 1 && arguments[0] instanceof y) {
            var o = arguments[0];
            return this._hi === o._hi && this._lo === o._lo;
          }
        } }, { key: "isZero", value: function() {
          return this._hi === 0 && this._lo === 0;
        } }, { key: "selfSubtract", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-o._hi, -o._lo);
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-h, 0);
          }
        } }, { key: "getSpecialNumberString", value: function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        } }, { key: "min", value: function(o) {
          return this.le(o) ? this : o;
        } }, { key: "selfDivide", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.selfDivide(o._hi, o._lo);
            }
            if (typeof arguments[0] == "number") {
              var h = arguments[0];
              return this.selfDivide(h, 0);
            }
          } else if (arguments.length === 2) {
            var _, I, D, B, W = arguments[0], oe = arguments[1], de = null, Ze = null, rt = null, xt = null;
            return D = this._hi / W, xt = (de = (rt = y.SPLIT * D) - (de = rt - D)) * (Ze = (xt = y.SPLIT * W) - (Ze = xt - W)) - (B = D * W) + de * (I = W - Ze) + (_ = D - de) * Ze + _ * I, xt = D + (rt = (this._hi - B - xt + this._lo - D * oe) / W), this._hi = xt, this._lo = D - xt + rt, this;
          }
        } }, { key: "dump", value: function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        } }, { key: "divide", value: function() {
          if (arguments[0] instanceof y) {
            var o, h, _, I, D = arguments[0], B = null, W = null, oe = null, de = null;
            return o = (_ = this._hi / D._hi) - (B = (oe = y.SPLIT * _) - (B = oe - _)), de = B * (W = (de = y.SPLIT * D._hi) - (W = de - D._hi)) - (I = _ * D._hi) + B * (h = D._hi - W) + o * W + o * h, new y(de = _ + (oe = (this._hi - I - de + this._lo - _ * D._lo) / D._hi), _ - de + oe);
          }
          if (typeof arguments[0] == "number") {
            var Ze = arguments[0];
            return ft.isNaN(Ze) ? y.createNaN() : y.copy(this).selfDivide(Ze, 0);
          }
        } }, { key: "ge", value: function(o) {
          return this._hi > o._hi || this._hi === o._hi && this._lo >= o._lo;
        } }, { key: "pow", value: function(o) {
          if (o === 0) return y.valueOf(1);
          var h = new y(this), _ = y.valueOf(1), I = Math.abs(o);
          if (I > 1) for (; I > 0; ) I % 2 == 1 && _.selfMultiply(h), (I /= 2) > 0 && (h = h.sqr());
          else _ = h;
          return o < 0 ? _.reciprocal() : _;
        } }, { key: "ceil", value: function() {
          if (this.isNaN()) return y.NaN;
          var o = Math.ceil(this._hi), h = 0;
          return o === this._hi && (h = Math.ceil(this._lo)), new y(o, h);
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this._hi < h._hi ? -1 : this._hi > h._hi ? 1 : this._lo < h._lo ? -1 : this._lo > h._lo ? 1 : 0;
        } }, { key: "rint", value: function() {
          return this.isNaN() ? this : this.add(0.5).floor();
        } }, { key: "setValue", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return this.init(o), this;
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return this.init(h), this;
          }
        } }, { key: "max", value: function(o) {
          return this.ge(o) ? this : o;
        } }, { key: "sqrt", value: function() {
          if (this.isZero()) return y.valueOf(0);
          if (this.isNegative()) return y.NaN;
          var o = 1 / Math.sqrt(this._hi), h = this._hi * o, _ = y.valueOf(h), I = this.subtract(_.sqr())._hi * (0.5 * o);
          return _.add(I);
        } }, { key: "selfAdd", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.selfAdd(o._hi, o._lo);
            }
            if (typeof arguments[0] == "number") {
              var h, _, I, D, B, W = arguments[0], oe = null;
              return oe = (I = this._hi + W) - (D = I - this._hi), _ = (B = (oe = W - D + (this._hi - oe)) + this._lo) + (I - (h = I + B)), this._hi = h + _, this._lo = _ + (h - this._hi), this;
            }
          } else if (arguments.length === 2) {
            var de, Ze, rt, xt, jt = arguments[0], qt = arguments[1], Wt = null, _r = null, lr = null;
            rt = this._hi + jt, Ze = this._lo + qt, _r = rt - (lr = rt - this._hi), Wt = Ze - (xt = Ze - this._lo);
            var Br = (de = rt + (lr = (_r = jt - lr + (this._hi - _r)) + Ze)) + (lr = (Wt = qt - xt + (this._lo - Wt)) + (lr + (rt - de))), qn = lr + (de - Br);
            return this._hi = Br, this._lo = qn, this;
          }
        } }, { key: "selfMultiply", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.selfMultiply(o._hi, o._lo);
            }
            if (typeof arguments[0] == "number") {
              var h = arguments[0];
              return this.selfMultiply(h, 0);
            }
          } else if (arguments.length === 2) {
            var _, I, D = arguments[0], B = arguments[1], W = null, oe = null, de = null, Ze = null;
            W = (de = y.SPLIT * this._hi) - this._hi, Ze = y.SPLIT * D, W = de - W, _ = this._hi - W, oe = Ze - D;
            var rt = (de = this._hi * D) + (Ze = W * (oe = Ze - oe) - de + W * (I = D - oe) + _ * oe + _ * I + (this._hi * B + this._lo * D)), xt = Ze + (W = de - rt);
            return this._hi = rt, this._lo = xt, this;
          }
        } }, { key: "selfSqr", value: function() {
          return this.selfMultiply(this);
        } }, { key: "floor", value: function() {
          if (this.isNaN()) return y.NaN;
          var o = Math.floor(this._hi), h = 0;
          return o === this._hi && (h = Math.floor(this._lo)), new y(o, h);
        } }, { key: "negate", value: function() {
          return this.isNaN() ? this : new y(-this._hi, -this._lo);
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (o) {
            if (o instanceof CloneNotSupportedException) return null;
            throw o;
          }
        } }, { key: "multiply", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return o.isNaN() ? y.createNaN() : y.copy(this).selfMultiply(o);
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return ft.isNaN(h) ? y.createNaN() : y.copy(this).selfMultiply(h, 0);
          }
        } }, { key: "isNaN", value: function() {
          return ft.isNaN(this._hi);
        } }, { key: "intValue", value: function() {
          return Math.trunc(this._hi);
        } }, { key: "toString", value: function() {
          var o = y.magnitude(this._hi);
          return o >= -3 && o <= 20 ? this.toStandardNotation() : this.toSciNotation();
        } }, { key: "toStandardNotation", value: function() {
          var o = this.getSpecialNumberString();
          if (o !== null) return o;
          var h = new Array(1).fill(null), _ = this.extractSignificantDigits(!0, h), I = h[0] + 1, D = _;
          if (_.charAt(0) === ".") D = "0" + _;
          else if (I < 0) D = "0." + y.stringOfChar("0", -I) + _;
          else if (_.indexOf(".") === -1) {
            var B = I - _.length;
            D = _ + y.stringOfChar("0", B) + ".0";
          }
          return this.isNegative() ? "-" + D : D;
        } }, { key: "reciprocal", value: function() {
          var o, h, _, I, D = null, B = null, W = null, oe = null;
          o = (_ = 1 / this._hi) - (D = (W = y.SPLIT * _) - (D = W - _)), B = (oe = y.SPLIT * this._hi) - this._hi;
          var de = _ + (W = (1 - (I = _ * this._hi) - (oe = D * (B = oe - B) - I + D * (h = this._hi - B) + o * B + o * h) - _ * this._lo) / this._hi);
          return new y(de, _ - de + W);
        } }, { key: "toSciNotation", value: function() {
          if (this.isZero()) return y.SCI_NOT_ZERO;
          var o = this.getSpecialNumberString();
          if (o !== null) return o;
          var h = new Array(1).fill(null), _ = this.extractSignificantDigits(!1, h), I = y.SCI_NOT_EXPONENT_CHAR + h[0];
          if (_.charAt(0) === "0") throw new IllegalStateException("Found leading zero: " + _);
          var D = "";
          _.length > 1 && (D = _.substring(1));
          var B = _.charAt(0) + "." + D;
          return this.isNegative() ? "-" + B + I : B + I;
        } }, { key: "abs", value: function() {
          return this.isNaN() ? y.NaN : this.isNegative() ? this.negate() : new y(this);
        } }, { key: "isPositive", value: function() {
          return this._hi > 0 || this._hi === 0 && this._lo > 0;
        } }, { key: "lt", value: function(o) {
          return this._hi < o._hi || this._hi === o._hi && this._lo < o._lo;
        } }, { key: "add", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return y.copy(this).selfAdd(o);
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return y.copy(this).selfAdd(h);
          }
        } }, { key: "init", value: function() {
          if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var o = arguments[0];
              this._hi = o, this._lo = 0;
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this._hi = h._hi, this._lo = h._lo;
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this._hi = _, this._lo = I;
          }
        } }, { key: "gt", value: function(o) {
          return this._hi > o._hi || this._hi === o._hi && this._lo > o._lo;
        } }, { key: "isNegative", value: function() {
          return this._hi < 0 || this._hi === 0 && this._lo < 0;
        } }, { key: "trunc", value: function() {
          return this.isNaN() ? y.NaN : this.isPositive() ? this.floor() : this.ceil();
        } }, { key: "signum", value: function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [se, ut, Q];
        } }], [{ key: "constructor_", value: function() {
          if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var o = arguments[0];
              this.init(o);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this.init(h);
            } else if (typeof arguments[0] == "string") {
              var _ = arguments[0];
              y.constructor_.call(this, y.parse(_));
            }
          } else if (arguments.length === 2) {
            var I = arguments[0], D = arguments[1];
            this.init(I, D);
          }
        } }, { key: "determinant", value: function() {
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1], _ = arguments[2], I = arguments[3];
            return y.determinant(y.valueOf(o), y.valueOf(h), y.valueOf(_), y.valueOf(I));
          }
          if (arguments[3] instanceof y && arguments[2] instanceof y && arguments[0] instanceof y && arguments[1] instanceof y) {
            var D = arguments[1], B = arguments[2], W = arguments[3];
            return arguments[0].multiply(W).selfSubtract(D.multiply(B));
          }
        } }, { key: "sqr", value: function(o) {
          return y.valueOf(o).selfMultiply(o);
        } }, { key: "valueOf", value: function() {
          if (typeof arguments[0] == "string") {
            var o = arguments[0];
            return y.parse(o);
          }
          if (typeof arguments[0] == "number") return new y(arguments[0]);
        } }, { key: "sqrt", value: function(o) {
          return y.valueOf(o).sqrt();
        } }, { key: "parse", value: function(o) {
          for (var h = 0, _ = o.length; Un.isWhitespace(o.charAt(h)); ) h++;
          var I = !1;
          if (h < _) {
            var D = o.charAt(h);
            D !== "-" && D !== "+" || (h++, D === "-" && (I = !0));
          }
          for (var B = new y(), W = 0, oe = 0, de = 0, Ze = !1; !(h >= _); ) {
            var rt = o.charAt(h);
            if (h++, Un.isDigit(rt)) {
              var xt = rt - "0";
              B.selfMultiply(y.TEN), B.selfAdd(xt), W++;
            } else {
              if (rt !== ".") {
                if (rt === "e" || rt === "E") {
                  var jt = o.substring(h);
                  try {
                    de = Vn.parseInt(jt);
                  } catch (Br) {
                    throw Br instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + jt + " in string " + o) : Br;
                  }
                  break;
                }
                throw new NumberFormatException("Unexpected character '" + rt + "' at position " + h + " in string " + o);
              }
              oe = W, Ze = !0;
            }
          }
          var qt = B;
          Ze || (oe = W);
          var Wt = W - oe - de;
          if (Wt === 0) qt = B;
          else if (Wt > 0) {
            var _r = y.TEN.pow(Wt);
            qt = B.divide(_r);
          } else if (Wt < 0) {
            var lr = y.TEN.pow(-Wt);
            qt = B.multiply(lr);
          }
          return I ? qt.negate() : qt;
        } }, { key: "createNaN", value: function() {
          return new y(ft.NaN, ft.NaN);
        } }, { key: "copy", value: function(o) {
          return new y(o);
        } }, { key: "magnitude", value: function(o) {
          var h = Math.abs(o), _ = Math.log(h) / Math.log(10), I = Math.trunc(Math.floor(_));
          return 10 * Math.pow(10, I) <= h && (I += 1), I;
        } }, { key: "stringOfChar", value: function(o, h) {
          for (var _ = new ln(), I = 0; I < h; I++) _.append(o);
          return _.toString();
        } }]);
      })();
      Jt.PI = new Jt(3.141592653589793, 12246467991473532e-32), Jt.TWO_PI = new Jt(6.283185307179586, 24492935982947064e-32), Jt.PI_2 = new Jt(1.5707963267948966, 6123233995736766e-32), Jt.E = new Jt(2.718281828459045, 14456468917292502e-32), Jt.NaN = new Jt(ft.NaN, ft.NaN), Jt.EPS = 123259516440783e-46, Jt.SPLIT = 134217729, Jt.MAX_PRINT_DIGITS = 32, Jt.TEN = Jt.valueOf(10), Jt.ONE = Jt.valueOf(1), Jt.SCI_NOT_EXPONENT_CHAR = "E", Jt.SCI_NOT_ZERO = "0.0E0";
      var os = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "orientationIndex", value: function(o, h, _) {
          var I = y.orientationIndexFilter(o, h, _);
          if (I <= 1) return I;
          var D = Jt.valueOf(h.x).selfAdd(-o.x), B = Jt.valueOf(h.y).selfAdd(-o.y), W = Jt.valueOf(_.x).selfAdd(-h.x), oe = Jt.valueOf(_.y).selfAdd(-h.y);
          return D.selfMultiply(oe).selfSubtract(B.selfMultiply(W)).signum();
        } }, { key: "signOfDet2x2", value: function() {
          if (arguments[3] instanceof Jt && arguments[2] instanceof Jt && arguments[0] instanceof Jt && arguments[1] instanceof Jt) {
            var o = arguments[1], h = arguments[2], _ = arguments[3];
            return arguments[0].multiply(_).selfSubtract(o.multiply(h)).signum();
          }
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3], oe = Jt.valueOf(I), de = Jt.valueOf(D), Ze = Jt.valueOf(B), rt = Jt.valueOf(W);
            return oe.multiply(rt).selfSubtract(de.multiply(Ze)).signum();
          }
        } }, { key: "intersection", value: function(o, h, _, I) {
          var D = new Jt(o.y).selfSubtract(h.y), B = new Jt(h.x).selfSubtract(o.x), W = new Jt(o.x).selfMultiply(h.y).selfSubtract(new Jt(h.x).selfMultiply(o.y)), oe = new Jt(_.y).selfSubtract(I.y), de = new Jt(I.x).selfSubtract(_.x), Ze = new Jt(_.x).selfMultiply(I.y).selfSubtract(new Jt(I.x).selfMultiply(_.y)), rt = B.multiply(Ze).selfSubtract(de.multiply(W)), xt = oe.multiply(W).selfSubtract(D.multiply(Ze)), jt = D.multiply(de).selfSubtract(oe.multiply(B)), qt = rt.selfDivide(jt).doubleValue(), Wt = xt.selfDivide(jt).doubleValue();
          return ft.isNaN(qt) || ft.isInfinite(qt) || ft.isNaN(Wt) || ft.isInfinite(Wt) ? null : new He(qt, Wt);
        } }, { key: "orientationIndexFilter", value: function(o, h, _) {
          var I = null, D = (o.x - _.x) * (h.y - _.y), B = (o.y - _.y) * (h.x - _.x), W = D - B;
          if (D > 0) {
            if (B <= 0) return y.signum(W);
            I = D + B;
          } else {
            if (!(D < 0) || B >= 0) return y.signum(W);
            I = -D - B;
          }
          var oe = y.DP_SAFE_EPSILON * I;
          return W >= oe || -W >= oe ? y.signum(W) : 2;
        } }, { key: "signum", value: function(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        } }]);
      })();
      os.DP_SAFE_EPSILON = 1e-15;
      var Fe = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "getM", value: function(y) {
          if (this.hasM()) {
            var o = this.getDimension() - this.getMeasures();
            return this.getOrdinate(y, o);
          }
          return ft.NaN;
        } }, { key: "setOrdinate", value: function(y, o, h) {
        } }, { key: "getZ", value: function(y) {
          return this.hasZ() ? this.getOrdinate(y, 2) : ft.NaN;
        } }, { key: "size", value: function() {
        } }, { key: "getOrdinate", value: function(y, o) {
        } }, { key: "getCoordinate", value: function() {
        } }, { key: "getCoordinateCopy", value: function(y) {
        } }, { key: "createCoordinate", value: function() {
        } }, { key: "getDimension", value: function() {
        } }, { key: "hasM", value: function() {
          return this.getMeasures() > 0;
        } }, { key: "getX", value: function(y) {
        } }, { key: "hasZ", value: function() {
          return this.getDimension() - this.getMeasures() > 2;
        } }, { key: "getMeasures", value: function() {
          return 0;
        } }, { key: "expandEnvelope", value: function(y) {
        } }, { key: "copy", value: function() {
        } }, { key: "getY", value: function(y) {
        } }, { key: "toCoordinateArray", value: function() {
        } }, { key: "interfaces_", get: function() {
          return [Q];
        } }]);
      })();
      Fe.X = 0, Fe.Y = 1, Fe.Z = 2, Fe.M = 3;
      var H = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "index", value: function(o, h, _) {
          return os.orientationIndex(o, h, _);
        } }, { key: "isCCW", value: function() {
          if (arguments[0] instanceof Array) {
            var o = arguments[0], h = o.length - 1;
            if (h < 3) throw new et("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var _ = o[0], I = 0, D = 1; D <= h; D++) {
              var B = o[D];
              B.y > _.y && (_ = B, I = D);
            }
            var W = I;
            do
              (W -= 1) < 0 && (W = h);
            while (o[W].equals2D(_) && W !== I);
            var oe = I;
            do
              oe = (oe + 1) % h;
            while (o[oe].equals2D(_) && oe !== I);
            var de = o[W], Ze = o[oe];
            if (de.equals2D(_) || Ze.equals2D(_) || de.equals2D(Ze)) return !1;
            var rt = y.index(de, _, Ze);
            return rt === 0 ? de.x > Ze.x : rt > 0;
          }
          if (tr(arguments[0], Fe)) {
            var xt = arguments[0], jt = xt.size() - 1;
            if (jt < 3) throw new et("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var qt = xt.getCoordinate(0), Wt = 0, _r = 1; _r <= jt; _r++) {
              var lr = xt.getCoordinate(_r);
              lr.y > qt.y && (qt = lr, Wt = _r);
            }
            var Br = null, qn = Wt;
            do
              (qn -= 1) < 0 && (qn = jt), Br = xt.getCoordinate(qn);
            while (Br.equals2D(qt) && qn !== Wt);
            var $n = null, Vi = Wt;
            do
              Vi = (Vi + 1) % jt, $n = xt.getCoordinate(Vi);
            while ($n.equals2D(qt) && Vi !== Wt);
            if (Br.equals2D(qt) || $n.equals2D(qt) || Br.equals2D($n)) return !1;
            var aa = y.index(Br, qt, $n);
            return aa === 0 ? Br.x > $n.x : aa > 0;
          }
        } }]);
      })();
      H.CLOCKWISE = -1, H.RIGHT = H.CLOCKWISE, H.COUNTERCLOCKWISE = 1, H.LEFT = H.COUNTERCLOCKWISE, H.COLLINEAR = 0, H.STRAIGHT = H.COLLINEAR;
      var K = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinate", value: function() {
          return this._minCoord;
        } }, { key: "getRightmostSide", value: function(y, o) {
          var h = this.getRightmostSideOfSegment(y, o);
          return h < 0 && (h = this.getRightmostSideOfSegment(y, o - 1)), h < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(y)), h;
        } }, { key: "findRightmostEdgeAtVertex", value: function() {
          var y = this._minDe.getEdge().getCoordinates();
          At.isTrue(this._minIndex > 0 && this._minIndex < y.length, "rightmost point expected to be interior vertex of edge");
          var o = y[this._minIndex - 1], h = y[this._minIndex + 1], _ = H.index(this._minCoord, h, o), I = !1;
          (o.y < this._minCoord.y && h.y < this._minCoord.y && _ === H.COUNTERCLOCKWISE || o.y > this._minCoord.y && h.y > this._minCoord.y && _ === H.CLOCKWISE) && (I = !0), I && (this._minIndex = this._minIndex - 1);
        } }, { key: "getRightmostSideOfSegment", value: function(y, o) {
          var h = y.getEdge().getCoordinates();
          if (o < 0 || o + 1 >= h.length || h[o].y === h[o + 1].y) return -1;
          var _ = Mt.LEFT;
          return h[o].y < h[o + 1].y && (_ = Mt.RIGHT), _;
        } }, { key: "getEdge", value: function() {
          return this._orientedDe;
        } }, { key: "checkForRightmostCoordinate", value: function(y) {
          for (var o = y.getEdge().getCoordinates(), h = 0; h < o.length - 1; h++) (this._minCoord === null || o[h].x > this._minCoord.x) && (this._minDe = y, this._minIndex = h, this._minCoord = o[h]);
        } }, { key: "findRightmostEdgeAtNode", value: function() {
          var y = this._minDe.getNode().getEdges();
          this._minDe = y.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        } }, { key: "findEdge", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next();
            h.isForward() && this.checkForRightmostCoordinate(h);
          }
          At.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === Mt.LEFT && (this._orientedDe = this._minDe.getSym());
        } }], [{ key: "constructor_", value: function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        } }]);
      })(), re = (function(y) {
        function o(h, _) {
          var I;
          return x(this, o), (I = p(this, o, [_ ? h + " [ " + _ + " ]" : h])).pt = _ ? new He(_) : void 0, I.name = Object.keys({ TopologyException: o })[0], I;
        }
        return $(o, y), u(o, [{ key: "getCoordinate", value: function() {
          return this.pt;
        } }]);
      })(Zt), Te = (function() {
        return u((function y() {
          x(this, y), this.array = [];
        }), [{ key: "addLast", value: function(y) {
          this.array.push(y);
        } }, { key: "removeFirst", value: function() {
          return this.array.shift();
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }]);
      })(), me = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o)).array = [], h instanceof br && _.addAll(h), _;
        }
        return $(o, y), u(o, [{ key: "interfaces_", get: function() {
          return [jn, br];
        } }, { key: "ensureCapacity", value: function() {
        } }, { key: "add", value: function(h) {
          return arguments.length === 1 ? this.array.push(h) : this.array.splice(arguments[0], 0, arguments[1]), !0;
        } }, { key: "clear", value: function() {
          this.array = [];
        } }, { key: "addAll", value: function(h) {
          var _, I = R(h);
          try {
            for (I.s(); !(_ = I.n()).done; ) {
              var D = _.value;
              this.array.push(D);
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
        } }, { key: "set", value: function(h, _) {
          var I = this.array[h];
          return this.array[h] = _, I;
        } }, { key: "iterator", value: function() {
          return new Ye(this);
        } }, { key: "get", value: function(h) {
          if (h < 0 || h >= this.size()) throw new Ti();
          return this.array[h];
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "sort", value: function(h) {
          h ? this.array.sort((function(_, I) {
            return h.compare(_, I);
          })) : this.array.sort();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "remove", value: function(h) {
          for (var _ = 0, I = this.array.length; _ < I; _++) if (this.array[_] === h) return !!this.array.splice(_, 1);
          return !1;
        } }, { key: Symbol.iterator, value: function() {
          return this.array.values();
        } }]);
      })(jn), Ye = (function() {
        return u((function y(o) {
          x(this, y), this.arrayList = o, this.position = 0;
        }), [{ key: "next", value: function() {
          if (this.position === this.arrayList.size()) throw new ur();
          return this.arrayList.get(this.position++);
        } }, { key: "hasNext", value: function() {
          return this.position < this.arrayList.size();
        } }, { key: "set", value: function(y) {
          return this.arrayList.set(this.position - 1, y);
        } }, { key: "remove", value: function() {
          this.arrayList.remove(this.arrayList.get(this.position));
        } }]);
      })(), We = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "clearVisitedEdges", value: function() {
          for (var y = this._dirEdgeList.iterator(); y.hasNext(); )
            y.next().setVisited(!1);
        } }, { key: "getRightmostCoordinate", value: function() {
          return this._rightMostCoord;
        } }, { key: "computeNodeDepth", value: function(y) {
          for (var o = null, h = y.getEdges().iterator(); h.hasNext(); ) {
            var _ = h.next();
            if (_.isVisited() || _.getSym().isVisited()) {
              o = _;
              break;
            }
          }
          if (o === null) throw new re("unable to find edge to compute depths at " + y.getCoordinate());
          y.getEdges().computeDepths(o);
          for (var I = y.getEdges().iterator(); I.hasNext(); ) {
            var D = I.next();
            D.setVisited(!0), this.copySymDepths(D);
          }
        } }, { key: "computeDepth", value: function(y) {
          this.clearVisitedEdges();
          var o = this._finder.getEdge();
          o.getNode(), o.getLabel(), o.setEdgeDepths(Mt.RIGHT, y), this.copySymDepths(o), this.computeDepths(o);
        } }, { key: "create", value: function(y) {
          this.addReachable(y), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        } }, { key: "findResultEdges", value: function() {
          for (var y = this._dirEdgeList.iterator(); y.hasNext(); ) {
            var o = y.next();
            o.getDepth(Mt.RIGHT) >= 1 && o.getDepth(Mt.LEFT) <= 0 && !o.isInteriorAreaEdge() && o.setInResult(!0);
          }
        } }, { key: "computeDepths", value: function(y) {
          var o = new Dr(), h = new Te(), _ = y.getNode();
          for (h.addLast(_), o.add(_), y.setVisited(!0); !h.isEmpty(); ) {
            var I = h.removeFirst();
            o.add(I), this.computeNodeDepth(I);
            for (var D = I.getEdges().iterator(); D.hasNext(); ) {
              var B = D.next().getSym();
              if (!B.isVisited()) {
                var W = B.getNode();
                o.contains(W) || (h.addLast(W), o.add(W));
              }
            }
          }
        } }, { key: "compareTo", value: function(y) {
          var o = y;
          return this._rightMostCoord.x < o._rightMostCoord.x ? -1 : this._rightMostCoord.x > o._rightMostCoord.x ? 1 : 0;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            for (var y = new fr(), o = this._dirEdgeList.iterator(); o.hasNext(); ) for (var h = o.next().getEdge().getCoordinates(), _ = 0; _ < h.length - 1; _++) y.expandToInclude(h[_]);
            this._env = y;
          }
          return this._env;
        } }, { key: "addReachable", value: function(y) {
          var o = new Ls();
          for (o.add(y); !o.empty(); ) {
            var h = o.pop();
            this.add(h, o);
          }
        } }, { key: "copySymDepths", value: function(y) {
          var o = y.getSym();
          o.setDepth(Mt.LEFT, y.getDepth(Mt.RIGHT)), o.setDepth(Mt.RIGHT, y.getDepth(Mt.LEFT));
        } }, { key: "add", value: function(y, o) {
          y.setVisited(!0), this._nodes.add(y);
          for (var h = y.getEdges().iterator(); h.hasNext(); ) {
            var _ = h.next();
            this._dirEdgeList.add(_);
            var I = _.getSym().getNode();
            I.isVisited() || o.push(I);
          }
        } }, { key: "getNodes", value: function() {
          return this._nodes;
        } }, { key: "getDirectedEdges", value: function() {
          return this._dirEdgeList;
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          this._finder = null, this._dirEdgeList = new me(), this._nodes = new me(), this._rightMostCoord = null, this._env = null, this._finder = new K();
        } }]);
      })(), Ve = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "intersection", value: function(y, o, h, _) {
          var I = y.x < o.x ? y.x : o.x, D = y.y < o.y ? y.y : o.y, B = y.x > o.x ? y.x : o.x, W = y.y > o.y ? y.y : o.y, oe = h.x < _.x ? h.x : _.x, de = h.y < _.y ? h.y : _.y, Ze = h.x > _.x ? h.x : _.x, rt = h.y > _.y ? h.y : _.y, xt = ((I > oe ? I : oe) + (B < Ze ? B : Ze)) / 2, jt = ((D > de ? D : de) + (W < rt ? W : rt)) / 2, qt = y.x - xt, Wt = y.y - jt, _r = o.x - xt, lr = o.y - jt, Br = h.x - xt, qn = h.y - jt, $n = _.x - xt, Vi = _.y - jt, aa = Wt - lr, Go = _r - qt, so = qt * lr - _r * Wt, jo = qn - Vi, Su = $n - Br, Pa = Br * Vi - $n * qn, Aa = aa * Su - jo * Go, Cl = (Go * Pa - Su * so) / Aa, Vo = (jo * so - aa * Pa) / Aa;
          return ft.isNaN(Cl) || ft.isInfinite(Cl) || ft.isNaN(Vo) || ft.isInfinite(Vo) ? null : new He(Cl + xt, Vo + jt);
        } }]);
      })(), $e = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "arraycopy", value: function(y, o, h, _, I) {
          for (var D = 0, B = o; B < o + I; B++) h[_ + D] = y[B], D++;
        } }, { key: "getProperty", value: function(y) {
          return { "line.separator": `
` }[y];
        } }]);
      })(), gt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "log10", value: function(o) {
          var h = Math.log(o);
          return ft.isInfinite(h) || ft.isNaN(h) ? h : h / y.LOG_10;
        } }, { key: "min", value: function(o, h, _, I) {
          var D = o;
          return h < D && (D = h), _ < D && (D = _), I < D && (D = I), D;
        } }, { key: "clamp", value: function() {
          if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1], _ = arguments[2];
            return o < h ? h : o > _ ? _ : o;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            return I < D ? D : I > B ? B : I;
          }
        } }, { key: "wrap", value: function(o, h) {
          return o < 0 ? h - -o % h : o % h;
        } }, { key: "max", value: function() {
          if (arguments.length === 3) {
            var o = arguments[1], h = arguments[2], _ = arguments[0];
            return o > _ && (_ = o), h > _ && (_ = h), _;
          }
          if (arguments.length === 4) {
            var I = arguments[1], D = arguments[2], B = arguments[3], W = arguments[0];
            return I > W && (W = I), D > W && (W = D), B > W && (W = B), W;
          }
        } }, { key: "average", value: function(o, h) {
          return (o + h) / 2;
        } }]);
      })();
      gt.LOG_10 = Math.log(10);
      var st = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "segmentToSegment", value: function(o, h, _, I) {
          if (o.equals(h)) return y.pointToSegment(o, _, I);
          if (_.equals(I)) return y.pointToSegment(I, o, h);
          var D = !1;
          if (fr.intersects(o, h, _, I)) {
            var B = (h.x - o.x) * (I.y - _.y) - (h.y - o.y) * (I.x - _.x);
            if (B === 0) D = !0;
            else {
              var W = (o.y - _.y) * (I.x - _.x) - (o.x - _.x) * (I.y - _.y), oe = ((o.y - _.y) * (h.x - o.x) - (o.x - _.x) * (h.y - o.y)) / B, de = W / B;
              (de < 0 || de > 1 || oe < 0 || oe > 1) && (D = !0);
            }
          } else D = !0;
          return D ? gt.min(y.pointToSegment(o, _, I), y.pointToSegment(h, _, I), y.pointToSegment(_, o, h), y.pointToSegment(I, o, h)) : 0;
        } }, { key: "pointToSegment", value: function(o, h, _) {
          if (h.x === _.x && h.y === _.y) return o.distance(h);
          var I = (_.x - h.x) * (_.x - h.x) + (_.y - h.y) * (_.y - h.y), D = ((o.x - h.x) * (_.x - h.x) + (o.y - h.y) * (_.y - h.y)) / I;
          if (D <= 0) return o.distance(h);
          if (D >= 1) return o.distance(_);
          var B = ((h.y - o.y) * (_.x - h.x) - (h.x - o.x) * (_.y - h.y)) / I;
          return Math.abs(B) * Math.sqrt(I);
        } }, { key: "pointToLinePerpendicular", value: function(o, h, _) {
          var I = (_.x - h.x) * (_.x - h.x) + (_.y - h.y) * (_.y - h.y), D = ((h.y - o.y) * (_.x - h.x) - (h.x - o.x) * (_.y - h.y)) / I;
          return Math.abs(D) * Math.sqrt(I);
        } }, { key: "pointToSegmentString", value: function(o, h) {
          if (h.length === 0) throw new et("Line array must contain at least one vertex");
          for (var _ = o.distance(h[0]), I = 0; I < h.length - 1; I++) {
            var D = y.pointToSegment(o, h[I], h[I + 1]);
            D < _ && (_ = D);
          }
          return _;
        } }]);
      })(), vt = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "create", value: function() {
          if (arguments.length === 1) arguments[0] instanceof Array || tr(arguments[0], Fe);
          else if (arguments.length !== 2 && arguments.length === 3) {
            var y = arguments[0], o = arguments[1];
            return this.create(y, o);
          }
        } }]);
      })(), Be = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y) {
        } }]);
      })(), Qt = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "ofLine", value: function(y) {
          var o = y.size();
          if (o <= 1) return 0;
          var h = 0, _ = new He();
          y.getCoordinate(0, _);
          for (var I = _.x, D = _.y, B = 1; B < o; B++) {
            y.getCoordinate(B, _);
            var W = _.x, oe = _.y, de = W - I, Ze = oe - D;
            h += Math.sqrt(de * de + Ze * Ze), I = W, D = oe;
          }
          return h;
        } }]);
      })(), Cr = u((function y() {
        x(this, y);
      })), kt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "copyCoord", value: function(o, h, _, I) {
          for (var D = Math.min(o.getDimension(), _.getDimension()), B = 0; B < D; B++) _.setOrdinate(I, B, o.getOrdinate(h, B));
        } }, { key: "isRing", value: function(o) {
          var h = o.size();
          return h === 0 || !(h <= 3) && o.getOrdinate(0, Fe.X) === o.getOrdinate(h - 1, Fe.X) && o.getOrdinate(0, Fe.Y) === o.getOrdinate(h - 1, Fe.Y);
        } }, { key: "scroll", value: function() {
          if (arguments.length === 2) {
            if (tr(arguments[0], Fe) && Number.isInteger(arguments[1])) {
              var o = arguments[0], h = arguments[1];
              y.scroll(o, h, y.isRing(o));
            } else if (tr(arguments[0], Fe) && arguments[1] instanceof He) {
              var _ = arguments[0], I = arguments[1], D = y.indexOf(I, _);
              if (D <= 0) return null;
              y.scroll(_, D);
            }
          } else if (arguments.length === 3) {
            var B = arguments[0], W = arguments[1], oe = arguments[2];
            if (W <= 0) return null;
            for (var de = B.copy(), Ze = oe ? B.size() - 1 : B.size(), rt = 0; rt < Ze; rt++) for (var xt = 0; xt < B.getDimension(); xt++) B.setOrdinate(rt, xt, de.getOrdinate((W + rt) % Ze, xt));
            if (oe) for (var jt = 0; jt < B.getDimension(); jt++) B.setOrdinate(Ze, jt, B.getOrdinate(0, jt));
          }
        } }, { key: "isEqual", value: function(o, h) {
          var _ = o.size();
          if (_ !== h.size()) return !1;
          for (var I = Math.min(o.getDimension(), h.getDimension()), D = 0; D < _; D++) for (var B = 0; B < I; B++) {
            var W = o.getOrdinate(D, B), oe = h.getOrdinate(D, B);
            if (o.getOrdinate(D, B) !== h.getOrdinate(D, B) && (!ft.isNaN(W) || !ft.isNaN(oe))) return !1;
          }
          return !0;
        } }, { key: "minCoordinateIndex", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return y.minCoordinateIndex(o, 0, o.size() - 1);
          }
          if (arguments.length === 3) {
            for (var h = arguments[0], _ = arguments[2], I = -1, D = null, B = arguments[1]; B <= _; B++) {
              var W = h.getCoordinate(B);
              (D === null || D.compareTo(W) > 0) && (D = W, I = B);
            }
            return I;
          }
        } }, { key: "extend", value: function(o, h, _) {
          var I = o.create(_, h.getDimension()), D = h.size();
          if (y.copy(h, 0, I, 0, D), D > 0) for (var B = D; B < _; B++) y.copy(h, D - 1, I, B, 1);
          return I;
        } }, { key: "reverse", value: function(o) {
          for (var h = o.size() - 1, _ = Math.trunc(h / 2), I = 0; I <= _; I++) y.swap(o, I, h - I);
        } }, { key: "swap", value: function(o, h, _) {
          if (h === _) return null;
          for (var I = 0; I < o.getDimension(); I++) {
            var D = o.getOrdinate(h, I);
            o.setOrdinate(h, I, o.getOrdinate(_, I)), o.setOrdinate(_, I, D);
          }
        } }, { key: "copy", value: function(o, h, _, I, D) {
          for (var B = 0; B < D; B++) y.copyCoord(o, h + B, _, I + B);
        } }, { key: "ensureValidRing", value: function(o, h) {
          var _ = h.size();
          return _ === 0 ? h : _ <= 3 ? y.createClosedRing(o, h, 4) : h.getOrdinate(0, Fe.X) === h.getOrdinate(_ - 1, Fe.X) && h.getOrdinate(0, Fe.Y) === h.getOrdinate(_ - 1, Fe.Y) ? h : y.createClosedRing(o, h, _ + 1);
        } }, { key: "indexOf", value: function(o, h) {
          for (var _ = 0; _ < h.size(); _++) if (o.x === h.getOrdinate(_, Fe.X) && o.y === h.getOrdinate(_, Fe.Y)) return _;
          return -1;
        } }, { key: "createClosedRing", value: function(o, h, _) {
          var I = o.create(_, h.getDimension()), D = h.size();
          y.copy(h, 0, I, 0, D);
          for (var B = D; B < _; B++) y.copy(h, 0, I, B, 1);
          return I;
        } }, { key: "minCoordinate", value: function(o) {
          for (var h = null, _ = 0; _ < o.size(); _++) {
            var I = o.getCoordinate(_);
            (h === null || h.compareTo(I) > 0) && (h = I);
          }
          return h;
        } }]);
      })(), lt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "toDimensionSymbol", value: function(o) {
          switch (o) {
            case y.FALSE:
              return y.SYM_FALSE;
            case y.TRUE:
              return y.SYM_TRUE;
            case y.DONTCARE:
              return y.SYM_DONTCARE;
            case y.P:
              return y.SYM_P;
            case y.L:
              return y.SYM_L;
            case y.A:
              return y.SYM_A;
          }
          throw new et("Unknown dimension value: " + o);
        } }, { key: "toDimensionValue", value: function(o) {
          switch (Un.toUpperCase(o)) {
            case y.SYM_FALSE:
              return y.FALSE;
            case y.SYM_TRUE:
              return y.TRUE;
            case y.SYM_DONTCARE:
              return y.DONTCARE;
            case y.SYM_P:
              return y.P;
            case y.SYM_L:
              return y.L;
            case y.SYM_A:
              return y.A;
          }
          throw new et("Unknown dimension symbol: " + o);
        } }]);
      })();
      lt.P = 0, lt.L = 1, lt.A = 2, lt.FALSE = -1, lt.TRUE = -2, lt.DONTCARE = -3, lt.SYM_FALSE = "F", lt.SYM_TRUE = "T", lt.SYM_DONTCARE = "*", lt.SYM_P = "0", lt.SYM_L = "1", lt.SYM_A = "2";
      var nr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y) {
        } }]);
      })(), Fr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y, o) {
        } }, { key: "isDone", value: function() {
        } }, { key: "isGeometryChanged", value: function() {
        } }]);
      })(), wr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          return this.isEmpty() ? new fr() : this._points.expandEnvelope(new fr());
        } }, { key: "isRing", value: function() {
          return this.isClosed() && this.isSimple();
        } }, { key: "getCoordinates", value: function() {
          return this._points.toCoordinateArray();
        } }, { key: "copyInternal", value: function() {
          return new o(this._points.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            if (!this.isEquivalentClass(h)) return !1;
            var I = h;
            if (this._points.size() !== I._points.size()) return !1;
            for (var D = 0; D < this._points.size(); D++) if (!this.equal(this._points.getCoordinate(D), I._points.getCoordinate(D), _)) return !1;
            return !0;
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var h = 0; h < Math.trunc(this._points.size() / 2); h++) {
            var _ = this._points.size() - 1 - h;
            if (!this._points.getCoordinate(h).equals(this._points.getCoordinate(_))) {
              if (this._points.getCoordinate(h).compareTo(this._points.getCoordinate(_)) > 0) {
                var I = this._points.copy();
                kt.reverse(I), this._points = I;
              }
              return null;
            }
          }
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? lt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        } }, { key: "reverseInternal", value: function() {
          var h = this._points.copy();
          return kt.reverse(h), this.getFactory().createLineString(h);
        } }, { key: "getEndPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_LINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getLength", value: function() {
          return Qt.ofLine(this._points);
        } }, { key: "getNumPoints", value: function() {
          return this._points.size();
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            for (var h = arguments[0], _ = 0, I = 0; _ < this._points.size() && I < h._points.size(); ) {
              var D = this._points.getCoordinate(_).compareTo(h._points.getCoordinate(I));
              if (D !== 0) return D;
              _++, I++;
            }
            return _ < this._points.size() ? 1 : I < h._points.size() ? -1 : 0;
          }
          if (arguments.length === 2) {
            var B = arguments[0];
            return arguments[1].compare(this._points, B._points);
          }
        } }, { key: "apply", value: function() {
          if (tr(arguments[0], Be)) for (var h = arguments[0], _ = 0; _ < this._points.size(); _++) h.filter(this._points.getCoordinate(_));
          else if (tr(arguments[0], Fr)) {
            var I = arguments[0];
            if (this._points.size() === 0) return null;
            for (var D = 0; D < this._points.size() && (I.filter(this._points, D), !I.isDone()); D++) ;
            I.isGeometryChanged() && this.geometryChanged();
          } else tr(arguments[0], nr) ? arguments[0].filter(this) : tr(arguments[0], Xe) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          throw new rr();
        } }, { key: "isEquivalentClass", value: function(h) {
          return h instanceof o;
        } }, { key: "getCoordinateN", value: function(h) {
          return this._points.getCoordinate(h);
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_LINESTRING;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._points;
        } }, { key: "isEmpty", value: function() {
          return this._points.size() === 0;
        } }, { key: "init", value: function(h) {
          if (h === null && (h = this.getFactory().getCoordinateSequenceFactory().create([])), h.size() === 1) throw new et("Invalid number of points in LineString (found " + h.size() + " - must be 0 or >= 2)");
          this._points = h;
        } }, { key: "isCoordinate", value: function(h) {
          for (var _ = 0; _ < this._points.size(); _++) if (this._points.getCoordinate(_).equals(h)) return !0;
          return !1;
        } }, { key: "getStartPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(0);
        } }, { key: "getPointN", value: function(h) {
          return this.getFactory().createPoint(this._points.getCoordinate(h));
        } }, { key: "interfaces_", get: function() {
          return [Cr];
        } }], [{ key: "constructor_", value: function() {
          if (this._points = null, arguments.length !== 0 && arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            Bt.constructor_.call(this, _), this.init(h);
          }
        } }]);
      })(Bt), un = u((function y() {
        x(this, y);
      })), Qr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          if (this.isEmpty()) return new fr();
          var h = new fr();
          return h.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), h;
        } }, { key: "getCoordinates", value: function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        } }, { key: "copyInternal", value: function() {
          return new o(this._coordinates.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && (!(!this.isEmpty() || !h.isEmpty()) || this.isEmpty() === h.isEmpty() && this.equal(h.getCoordinate(), this.getCoordinate(), _));
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
        } }, { key: "getCoordinate", value: function() {
          return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
        } }, { key: "getBoundaryDimension", value: function() {
          return lt.FALSE;
        } }, { key: "reverseInternal", value: function() {
          return this.getFactory().createPoint(this._coordinates.copy());
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_POINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getNumPoints", value: function() {
          return this.isEmpty() ? 0 : 1;
        } }, { key: "getX", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getX called on empty Point");
          return this.getCoordinate().x;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.getCoordinate().compareTo(h.getCoordinate());
          }
          if (arguments.length === 2) {
            var _ = arguments[0];
            return arguments[1].compare(this._coordinates, _._coordinates);
          }
        } }, { key: "apply", value: function() {
          if (tr(arguments[0], Be)) {
            var h = arguments[0];
            if (this.isEmpty()) return null;
            h.filter(this.getCoordinate());
          } else if (tr(arguments[0], Fr)) {
            var _ = arguments[0];
            if (this.isEmpty()) return null;
            _.filter(this._coordinates, 0), _.isGeometryChanged() && this.geometryChanged();
          } else tr(arguments[0], nr) ? arguments[0].filter(this) : tr(arguments[0], Xe) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_POINT;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._coordinates;
        } }, { key: "getY", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getY called on empty Point");
          return this.getCoordinate().y;
        } }, { key: "isEmpty", value: function() {
          return this._coordinates.size() === 0;
        } }, { key: "init", value: function(h) {
          h === null && (h = this.getFactory().getCoordinateSequenceFactory().create([])), At.isTrue(h.size() <= 1), this._coordinates = h;
        } }, { key: "isSimple", value: function() {
          return !0;
        } }, { key: "interfaces_", get: function() {
          return [un];
        } }], [{ key: "constructor_", value: function() {
          this._coordinates = null;
          var h = arguments[0], _ = arguments[1];
          Bt.constructor_.call(this, _), this.init(h);
        } }]);
      })(Bt), Ur = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "ofRing", value: function() {
          if (arguments[0] instanceof Array) {
            var o = arguments[0];
            return Math.abs(y.ofRingSigned(o));
          }
          if (tr(arguments[0], Fe)) {
            var h = arguments[0];
            return Math.abs(y.ofRingSigned(h));
          }
        } }, { key: "ofRingSigned", value: function() {
          if (arguments[0] instanceof Array) {
            var o = arguments[0];
            if (o.length < 3) return 0;
            for (var h = 0, _ = o[0].x, I = 1; I < o.length - 1; I++) {
              var D = o[I].x - _, B = o[I + 1].y;
              h += D * (o[I - 1].y - B);
            }
            return h / 2;
          }
          if (tr(arguments[0], Fe)) {
            var W = arguments[0], oe = W.size();
            if (oe < 3) return 0;
            var de = new He(), Ze = new He(), rt = new He();
            W.getCoordinate(0, Ze), W.getCoordinate(1, rt);
            var xt = Ze.x;
            rt.x -= xt;
            for (var jt = 0, qt = 1; qt < oe - 1; qt++) de.y = Ze.y, Ze.x = rt.x, Ze.y = rt.y, W.getCoordinate(qt + 1, rt), rt.x -= xt, jt += Ze.x * (de.y - rt.y);
            return jt / 2;
          }
        } }]);
      })(), Ir = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "sort", value: function() {
          var y = arguments, o = arguments[0];
          if (arguments.length === 1) o.sort((function(xt, jt) {
            return xt.compareTo(jt);
          }));
          else if (arguments.length === 2) o.sort((function(xt, jt) {
            return y[1].compare(xt, jt);
          }));
          else if (arguments.length === 3) {
            var h = o.slice(arguments[1], arguments[2]);
            h.sort();
            var _ = o.slice(0, arguments[1]).concat(h, o.slice(arguments[2], o.length));
            o.splice(0, o.length);
            var I, D = R(_);
            try {
              for (D.s(); !(I = D.n()).done; ) {
                var B = I.value;
                o.push(B);
              }
            } catch (xt) {
              D.e(xt);
            } finally {
              D.f();
            }
          } else if (arguments.length === 4) {
            var W = o.slice(arguments[1], arguments[2]);
            W.sort((function(xt, jt) {
              return y[3].compare(xt, jt);
            }));
            var oe = o.slice(0, arguments[1]).concat(W, o.slice(arguments[2], o.length));
            o.splice(0, o.length);
            var de, Ze = R(oe);
            try {
              for (Ze.s(); !(de = Ze.n()).done; ) {
                var rt = de.value;
                o.push(rt);
              }
            } catch (xt) {
              Ze.e(xt);
            } finally {
              Ze.f();
            }
          }
        } }, { key: "asList", value: function(y) {
          var o, h = new me(), _ = R(y);
          try {
            for (_.s(); !(o = _.n()).done; ) {
              var I = o.value;
              h.add(I);
            }
          } catch (D) {
            _.e(D);
          } finally {
            _.f();
          }
          return h;
        } }, { key: "copyOf", value: function(y, o) {
          return y.slice(0, o);
        } }]);
      })(), pt = u((function y() {
        x(this, y);
      })), jr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          return this._shell.getEnvelopeInternal();
        } }, { key: "getCoordinates", value: function() {
          if (this.isEmpty()) return [];
          for (var h = new Array(this.getNumPoints()).fill(null), _ = -1, I = this._shell.getCoordinates(), D = 0; D < I.length; D++) h[++_] = I[D];
          for (var B = 0; B < this._holes.length; B++) for (var W = this._holes[B].getCoordinates(), oe = 0; oe < W.length; oe++) h[++_] = W[oe];
          return h;
        } }, { key: "getArea", value: function() {
          var h = 0;
          h += Ur.ofRing(this._shell.getCoordinateSequence());
          for (var _ = 0; _ < this._holes.length; _++) h -= Ur.ofRing(this._holes[_].getCoordinateSequence());
          return h;
        } }, { key: "copyInternal", value: function() {
          for (var h = this._shell.copy(), _ = new Array(this._holes.length).fill(null), I = 0; I < this._holes.length; I++) _[I] = this._holes[I].copy();
          return new o(h, _, this._factory);
        } }, { key: "isRectangle", value: function() {
          if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return !1;
          for (var h = this._shell.getCoordinateSequence(), _ = this.getEnvelopeInternal(), I = 0; I < 5; I++) {
            var D = h.getX(I);
            if (D !== _.getMinX() && D !== _.getMaxX()) return !1;
            var B = h.getY(I);
            if (B !== _.getMinY() && B !== _.getMaxY()) return !1;
          }
          for (var W = h.getX(0), oe = h.getY(0), de = 1; de <= 4; de++) {
            var Ze = h.getX(de), rt = h.getY(de);
            if (Ze !== W == (rt !== oe)) return !1;
            W = Ze, oe = rt;
          }
          return !0;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            if (!this.isEquivalentClass(h)) return !1;
            var I = h, D = this._shell, B = I._shell;
            if (!D.equalsExact(B, _) || this._holes.length !== I._holes.length) return !1;
            for (var W = 0; W < this._holes.length; W++) if (!this._holes[W].equalsExact(I._holes[W], _)) return !1;
            return !0;
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, !0);
            for (var h = 0; h < this._holes.length; h++) this._holes[h] = this.normalized(this._holes[h], !1);
            Ir.sort(this._holes);
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            if (_.isEmpty()) return null;
            var D = _.getCoordinateSequence(), B = kt.minCoordinateIndex(D, 0, D.size() - 2);
            kt.scroll(D, B, !0), H.isCCW(D) === I && kt.reverse(D);
          }
        } }, { key: "getCoordinate", value: function() {
          return this._shell.getCoordinate();
        } }, { key: "getNumInteriorRing", value: function() {
          return this._holes.length;
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "reverseInternal", value: function() {
          for (var h = this.getExteriorRing().reverse(), _ = new Array(this.getNumInteriorRing()).fill(null), I = 0; I < _.length; I++) _[I] = this.getInteriorRingN(I).reverse();
          return this.getFactory().createPolygon(h, _);
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_POLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getLength", value: function() {
          var h = 0;
          h += this._shell.getLength();
          for (var _ = 0; _ < this._holes.length; _++) h += this._holes[_].getLength();
          return h;
        } }, { key: "getNumPoints", value: function() {
          for (var h = this._shell.getNumPoints(), _ = 0; _ < this._holes.length; _++) h += this._holes[_].getNumPoints();
          return h;
        } }, { key: "convexHull", value: function() {
          return this.getExteriorRing().convexHull();
        } }, { key: "normalized", value: function(h, _) {
          var I = h.copy();
          return this.normalize(I, _), I;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], _ = this._shell, I = h._shell;
            return _.compareToSameClass(I);
          }
          if (arguments.length === 2) {
            var D = arguments[1], B = arguments[0], W = this._shell, oe = B._shell, de = W.compareToSameClass(oe, D);
            if (de !== 0) return de;
            for (var Ze = this.getNumInteriorRing(), rt = B.getNumInteriorRing(), xt = 0; xt < Ze && xt < rt; ) {
              var jt = this.getInteriorRingN(xt), qt = B.getInteriorRingN(xt), Wt = jt.compareToSameClass(qt, D);
              if (Wt !== 0) return Wt;
              xt++;
            }
            return xt < Ze ? 1 : xt < rt ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (tr(arguments[0], Be)) {
            var h = arguments[0];
            this._shell.apply(h);
            for (var _ = 0; _ < this._holes.length; _++) this._holes[_].apply(h);
          } else if (tr(arguments[0], Fr)) {
            var I = arguments[0];
            if (this._shell.apply(I), !I.isDone()) for (var D = 0; D < this._holes.length && (this._holes[D].apply(I), !I.isDone()); D++) ;
            I.isGeometryChanged() && this.geometryChanged();
          } else if (tr(arguments[0], nr))
            arguments[0].filter(this);
          else if (tr(arguments[0], Xe)) {
            var B = arguments[0];
            B.filter(this), this._shell.apply(B);
            for (var W = 0; W < this._holes.length; W++) this._holes[W].apply(B);
          }
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          var h = new Array(this._holes.length + 1).fill(null);
          h[0] = this._shell;
          for (var _ = 0; _ < this._holes.length; _++) h[_ + 1] = this._holes[_];
          return h.length <= 1 ? this.getFactory().createLinearRing(h[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(h);
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_POLYGON;
        } }, { key: "getExteriorRing", value: function() {
          return this._shell;
        } }, { key: "isEmpty", value: function() {
          return this._shell.isEmpty();
        } }, { key: "getInteriorRingN", value: function(h) {
          return this._holes[h];
        } }, { key: "interfaces_", get: function() {
          return [pt];
        } }], [{ key: "constructor_", value: function() {
          this._shell = null, this._holes = null;
          var h = arguments[0], _ = arguments[1], I = arguments[2];
          if (Bt.constructor_.call(this, I), h === null && (h = this.getFactory().createLinearRing()), _ === null && (_ = []), Bt.hasNullElements(_)) throw new et("holes must not contain null elements");
          if (h.isEmpty() && Bt.hasNonEmptyElements(_)) throw new et("shell is empty but holes are not");
          this._shell = h, this._holes = _;
        } }]);
      })(Bt), Wn = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o);
      })(ni), Hi = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o)).array = [], h instanceof br && _.addAll(h), _;
        }
        return $(o, y), u(o, [{ key: "contains", value: function(h) {
          var _, I = R(this.array);
          try {
            for (I.s(); !(_ = I.n()).done; )
              if (_.value.compareTo(h) === 0) return !0;
          } catch (D) {
            I.e(D);
          } finally {
            I.f();
          }
          return !1;
        } }, { key: "add", value: function(h) {
          if (this.contains(h)) return !1;
          for (var _ = 0, I = this.array.length; _ < I; _++)
            if (this.array[_].compareTo(h) === 1) return !!this.array.splice(_, 0, h);
          return this.array.push(h), !0;
        } }, { key: "addAll", value: function(h) {
          var _, I = R(h);
          try {
            for (I.s(); !(_ = I.n()).done; ) {
              var D = _.value;
              this.add(D);
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return !0;
        } }, { key: "remove", value: function() {
          throw new rr();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "iterator", value: function() {
          return new Wr(this.array);
        } }]);
      })(Wn), Wr = (function() {
        return u((function y(o) {
          x(this, y), this.array = o, this.position = 0;
        }), [{ key: "next", value: function() {
          if (this.position === this.array.length) throw new ur();
          return this.array[this.position++];
        } }, { key: "hasNext", value: function() {
          return this.position < this.array.length;
        } }, { key: "remove", value: function() {
          throw new rr();
        } }]);
      })(), yt = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          for (var h = new fr(), _ = 0; _ < this._geometries.length; _++) h.expandToInclude(this._geometries[_].getEnvelopeInternal());
          return h;
        } }, { key: "getGeometryN", value: function(h) {
          return this._geometries[h];
        } }, { key: "getCoordinates", value: function() {
          for (var h = new Array(this.getNumPoints()).fill(null), _ = -1, I = 0; I < this._geometries.length; I++) for (var D = this._geometries[I].getCoordinates(), B = 0; B < D.length; B++) h[++_] = D[B];
          return h;
        } }, { key: "getArea", value: function() {
          for (var h = 0, _ = 0; _ < this._geometries.length; _++) h += this._geometries[_].getArea();
          return h;
        } }, { key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            if (!this.isEquivalentClass(h)) return !1;
            var I = h;
            if (this._geometries.length !== I._geometries.length) return !1;
            for (var D = 0; D < this._geometries.length; D++) if (!this._geometries[D].equalsExact(I._geometries[D], _)) return !1;
            return !0;
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var h = 0; h < this._geometries.length; h++) this._geometries[h].normalize();
          Ir.sort(this._geometries);
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        } }, { key: "getBoundaryDimension", value: function() {
          for (var h = lt.FALSE, _ = 0; _ < this._geometries.length; _++) h = Math.max(h, this._geometries[_].getBoundaryDimension());
          return h;
        } }, { key: "reverseInternal", value: function() {
          for (var h = this._geometries.length, _ = new me(h), I = 0; I < h; I++) _.add(this._geometries[I].reverse());
          return this.getFactory().buildGeometry(_);
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getDimension", value: function() {
          for (var h = lt.FALSE, _ = 0; _ < this._geometries.length; _++) h = Math.max(h, this._geometries[_].getDimension());
          return h;
        } }, { key: "getLength", value: function() {
          for (var h = 0, _ = 0; _ < this._geometries.length; _++) h += this._geometries[_].getLength();
          return h;
        } }, { key: "getNumPoints", value: function() {
          for (var h = 0, _ = 0; _ < this._geometries.length; _++) h += this._geometries[_].getNumPoints();
          return h;
        } }, { key: "getNumGeometries", value: function() {
          return this._geometries.length;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], _ = new Hi(Ir.asList(this._geometries)), I = new Hi(Ir.asList(h._geometries));
            return this.compare(_, I);
          }
          if (arguments.length === 2) {
            for (var D = arguments[1], B = arguments[0], W = this.getNumGeometries(), oe = B.getNumGeometries(), de = 0; de < W && de < oe; ) {
              var Ze = this.getGeometryN(de), rt = B.getGeometryN(de), xt = Ze.compareToSameClass(rt, D);
              if (xt !== 0) return xt;
              de++;
            }
            return de < W ? 1 : de < oe ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (tr(arguments[0], Be)) for (var h = arguments[0], _ = 0; _ < this._geometries.length; _++) this._geometries[_].apply(h);
          else if (tr(arguments[0], Fr)) {
            var I = arguments[0];
            if (this._geometries.length === 0) return null;
            for (var D = 0; D < this._geometries.length && (this._geometries[D].apply(I), !I.isDone()); D++) ;
            I.isGeometryChanged() && this.geometryChanged();
          } else if (tr(arguments[0], nr)) {
            var B = arguments[0];
            B.filter(this);
            for (var W = 0; W < this._geometries.length; W++) this._geometries[W].apply(B);
          } else if (tr(arguments[0], Xe)) {
            var oe = arguments[0];
            oe.filter(this);
            for (var de = 0; de < this._geometries.length; de++) this._geometries[de].apply(oe);
          }
        } }, { key: "getBoundary", value: function() {
          return Bt.checkNotGeometryCollection(this), At.shouldNeverReachHere(), null;
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_GEOMETRYCOLLECTION;
        } }, { key: "isEmpty", value: function() {
          for (var h = 0; h < this._geometries.length; h++) if (!this._geometries[h].isEmpty()) return !1;
          return !0;
        } }], [{ key: "constructor_", value: function() {
          if (this._geometries = null, arguments.length !== 0 && arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            if (Bt.constructor_.call(this, _), h === null && (h = []), Bt.hasNullElements(h)) throw new et("geometries must not contain null elements");
            this._geometries = h;
          }
        } }]);
      })(Bt), er = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "isValid", value: function() {
          return !0;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && ce(o, "equalsExact", this, 1).call(this, h, _);
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            var h = arguments[0];
            return this._geometries[h].getCoordinate();
          }
          return ce(o, "getCoordinate", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return lt.FALSE;
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_MULTIPOINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_MULTIPOINT;
        } }, { key: "interfaces_", get: function() {
          return [un];
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          yt.constructor_.call(this, h, _);
        } }]);
      })(yt), ir = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          return new o(this._points.copy(), this._factory);
        } }, { key: "getBoundaryDimension", value: function() {
          return lt.FALSE;
        } }, { key: "isClosed", value: function() {
          return !!this.isEmpty() || ce(o, "isClosed", this, 1).call(this);
        } }, { key: "reverseInternal", value: function() {
          var h = this._points.copy();
          return kt.reverse(h), this.getFactory().createLinearRing(h);
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_LINEARRING;
        } }, { key: "validateConstruction", value: function() {
          if (!this.isEmpty() && !ce(o, "isClosed", this, 1).call(this)) throw new et("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < o.MINIMUM_VALID_SIZE) throw new et("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_LINEARRING;
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          wr.constructor_.call(this, h, _), this.validateConstruction();
        } }]);
      })(wr);
      ir.MINIMUM_VALID_SIZE = 4;
      var mn = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "setOrdinate", value: function(h, _) {
          switch (h) {
            case o.X:
              this.x = _;
              break;
            case o.Y:
              this.y = _;
              break;
            default:
              throw new et("Invalid ordinate index: " + h);
          }
        } }, { key: "getZ", value: function() {
          return He.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case o.X:
              return this.x;
            case o.Y:
              return this.y;
          }
          throw new et("Invalid ordinate index: " + h);
        } }, { key: "setZ", value: function(h) {
          throw new et("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ")";
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ();
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) He.constructor_.call(this);
          else if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var h = arguments[0];
              He.constructor_.call(this, h.x, h.y);
            } else if (arguments[0] instanceof He) {
              var _ = arguments[0];
              He.constructor_.call(this, _.x, _.y);
            }
          } else if (arguments.length === 2) {
            var I = arguments[0], D = arguments[1];
            He.constructor_.call(this, I, D, He.NULL_ORDINATE);
          }
        } }]);
      })(He);
      mn.X = 0, mn.Y = 1, mn.Z = -1, mn.M = -1;
      var Bi = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(h, _) {
          switch (h) {
            case o.X:
              this.x = _;
              break;
            case o.Y:
              this.y = _;
              break;
            case o.M:
              this._m = _;
              break;
            default:
              throw new et("Invalid ordinate index: " + h);
          }
        } }, { key: "setM", value: function(h) {
          this._m = h;
        } }, { key: "getZ", value: function() {
          return He.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case o.X:
              return this.x;
            case o.Y:
              return this.y;
            case o.M:
              return this._m;
          }
          throw new et("Invalid ordinate index: " + h);
        } }, { key: "setZ", value: function(h) {
          throw new et("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ(), this._m = h.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) He.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var h = arguments[0];
              He.constructor_.call(this, h.x, h.y), this._m = h._m;
            } else if (arguments[0] instanceof He) {
              var _ = arguments[0];
              He.constructor_.call(this, _.x, _.y), this._m = this.getM();
            }
          } else if (arguments.length === 3) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            He.constructor_.call(this, I, D, He.NULL_ORDINATE), this._m = B;
          }
        } }]);
      })(He);
      Bi.X = 0, Bi.Y = 1, Bi.Z = -1, Bi.M = 2;
      var Gi = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(h, _) {
          switch (h) {
            case He.X:
              this.x = _;
              break;
            case He.Y:
              this.y = _;
              break;
            case He.Z:
              this.z = _;
              break;
            case He.M:
              this._m = _;
              break;
            default:
              throw new et("Invalid ordinate index: " + h);
          }
        } }, { key: "setM", value: function(h) {
          this._m = h;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case He.X:
              return this.x;
            case He.Y:
              return this.y;
            case He.Z:
              return this.getZ();
            case He.M:
              return this.getM();
          }
          throw new et("Invalid ordinate index: " + h);
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ(), this._m = h.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) He.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var h = arguments[0];
              He.constructor_.call(this, h), this._m = h._m;
            } else if (arguments[0] instanceof He) {
              var _ = arguments[0];
              He.constructor_.call(this, _), this._m = this.getM();
            }
          } else if (arguments.length === 4) {
            var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3];
            He.constructor_.call(this, I, D, B), this._m = W;
          }
        } }]);
      })(He), we = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "measures", value: function(o) {
          return o instanceof mn ? 0 : o instanceof Bi || o instanceof Gi ? 1 : 0;
        } }, { key: "dimension", value: function(o) {
          return o instanceof mn ? 2 : o instanceof Bi ? 3 : o instanceof Gi ? 4 : 3;
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return y.create(o, 0);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return h === 2 ? new mn() : h === 3 && _ === 0 ? new He() : h === 3 && _ === 1 ? new Bi() : h === 4 && _ === 1 ? new Gi() : new He();
          }
        } }]);
      })(), Gt = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getCoordinate", value: function(h) {
          return this.get(h);
        } }, { key: "addAll", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "boolean" && tr(arguments[0], br)) {
            for (var h = arguments[1], _ = !1, I = arguments[0].iterator(); I.hasNext(); ) this.add(I.next(), h), _ = !0;
            return _;
          }
          return ce(o, "addAll", this, 1).apply(this, arguments);
        } }, { key: "clone", value: function() {
          for (var h = ce(o, "clone", this, 1).call(this), _ = 0; _ < this.size(); _++) h.add(_, this.get(_).clone());
          return h;
        } }, { key: "toCoordinateArray", value: function() {
          if (arguments.length === 0) return this.toArray(o.coordArrayType);
          if (arguments.length === 1) {
            if (arguments[0]) return this.toArray(o.coordArrayType);
            for (var h = this.size(), _ = new Array(h).fill(null), I = 0; I < h; I++) _[I] = this.get(h - I - 1);
            return _;
          }
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return ce(o, "add", this, 1).call(this, h);
          }
          if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var _ = arguments[0], I = arguments[1];
              return this.add(_, I, !0), !0;
            }
            if (arguments[0] instanceof He && typeof arguments[1] == "boolean") {
              var D = arguments[0];
              if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(D)) return null;
              ce(o, "add", this, 1).call(this, D);
            } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
              var B = arguments[0], W = arguments[1];
              return this.add(B, W), !0;
            }
          } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var oe = arguments[0], de = arguments[1];
              if (arguments[2]) for (var Ze = 0; Ze < oe.length; Ze++) this.add(oe[Ze], de);
              else for (var rt = oe.length - 1; rt >= 0; rt--) this.add(oe[rt], de);
              return !0;
            }
            if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof He) {
              var xt = arguments[0], jt = arguments[1];
              if (!arguments[2]) {
                var qt = this.size();
                if (qt > 0 && (xt > 0 && this.get(xt - 1).equals2D(jt) || xt < qt && this.get(xt).equals2D(jt)))
                  return null;
              }
              ce(o, "add", this, 1).call(this, xt, jt);
            }
          } else if (arguments.length === 4) {
            var Wt = arguments[0], _r = arguments[1], lr = arguments[2], Br = arguments[3], qn = 1;
            lr > Br && (qn = -1);
            for (var $n = lr; $n !== Br; $n += qn) this.add(Wt[$n], _r);
            return !0;
          }
        } }, { key: "closeRing", value: function() {
          if (this.size() > 0) {
            var h = this.get(0).copy();
            this.add(h, !1);
          }
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length !== 0) {
            if (arguments.length === 1) {
              var h = arguments[0];
              this.ensureCapacity(h.length), this.add(h, !0);
            } else if (arguments.length === 2) {
              var _ = arguments[0], I = arguments[1];
              this.ensureCapacity(_.length), this.add(_, I);
            }
          }
        } }]);
      })(me);
      Gt.coordArrayType = new Array(0).fill(null);
      var wt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "isRing", value: function(o) {
          return !(o.length < 4) && !!o[0].equals2D(o[o.length - 1]);
        } }, { key: "ptNotInList", value: function(o, h) {
          for (var _ = 0; _ < o.length; _++) {
            var I = o[_];
            if (y.indexOf(I, h) < 0) return I;
          }
          return null;
        } }, { key: "scroll", value: function(o, h) {
          var _ = y.indexOf(h, o);
          if (_ < 0) return null;
          var I = new Array(o.length).fill(null);
          $e.arraycopy(o, _, I, 0, o.length - _), $e.arraycopy(o, 0, I, o.length - _, _), $e.arraycopy(I, 0, o, 0, o.length);
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            if (o === h) return !0;
            if (o === null || h === null || o.length !== h.length) return !1;
            for (var _ = 0; _ < o.length; _++) if (!o[_].equals(h[_])) return !1;
            return !0;
          }
          if (arguments.length === 3) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            if (I === D) return !0;
            if (I === null || D === null || I.length !== D.length) return !1;
            for (var W = 0; W < I.length; W++) if (B.compare(I[W], D[W]) !== 0) return !1;
            return !0;
          }
        } }, { key: "intersection", value: function(o, h) {
          for (var _ = new Gt(), I = 0; I < o.length; I++) h.intersects(o[I]) && _.add(o[I], !0);
          return _.toCoordinateArray();
        } }, { key: "measures", value: function(o) {
          if (o === null || o.length === 0) return 0;
          var h, _ = 0, I = R(o);
          try {
            for (I.s(); !(h = I.n()).done; ) {
              var D = h.value;
              _ = Math.max(_, we.measures(D));
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return _;
        } }, { key: "hasRepeatedPoints", value: function(o) {
          for (var h = 1; h < o.length; h++) if (o[h - 1].equals(o[h])) return !0;
          return !1;
        } }, { key: "removeRepeatedPoints", value: function(o) {
          return y.hasRepeatedPoints(o) ? new Gt(o, !1).toCoordinateArray() : o;
        } }, { key: "reverse", value: function(o) {
          for (var h = o.length - 1, _ = Math.trunc(h / 2), I = 0; I <= _; I++) {
            var D = o[I];
            o[I] = o[h - I], o[h - I] = D;
          }
        } }, { key: "removeNull", value: function(o) {
          for (var h = 0, _ = 0; _ < o.length; _++) o[_] !== null && h++;
          var I = new Array(h).fill(null);
          if (h === 0) return I;
          for (var D = 0, B = 0; B < o.length; B++) o[B] !== null && (I[D++] = o[B]);
          return I;
        } }, { key: "copyDeep", value: function() {
          if (arguments.length === 1) {
            for (var o = arguments[0], h = new Array(o.length).fill(null), _ = 0; _ < o.length; _++) h[_] = o[_].copy();
            return h;
          }
          if (arguments.length === 5) for (var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3], oe = arguments[4], de = 0; de < oe; de++) B[W + de] = I[D + de].copy();
        } }, { key: "isEqualReversed", value: function(o, h) {
          for (var _ = 0; _ < o.length; _++) {
            var I = o[_], D = h[o.length - _ - 1];
            if (I.compareTo(D) !== 0) return !1;
          }
          return !0;
        } }, { key: "envelope", value: function(o) {
          for (var h = new fr(), _ = 0; _ < o.length; _++) h.expandToInclude(o[_]);
          return h;
        } }, { key: "toCoordinateArray", value: function(o) {
          return o.toArray(y.coordArrayType);
        } }, { key: "dimension", value: function(o) {
          if (o === null || o.length === 0) return 3;
          var h, _ = 0, I = R(o);
          try {
            for (I.s(); !(h = I.n()).done; ) {
              var D = h.value;
              _ = Math.max(_, we.dimension(D));
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return _;
        } }, { key: "atLeastNCoordinatesOrNothing", value: function(o, h) {
          return h.length >= o ? h : [];
        } }, { key: "indexOf", value: function(o, h) {
          for (var _ = 0; _ < h.length; _++) if (o.equals(h[_])) return _;
          return -1;
        } }, { key: "increasingDirection", value: function(o) {
          for (var h = 0; h < Math.trunc(o.length / 2); h++) {
            var _ = o.length - 1 - h, I = o[h].compareTo(o[_]);
            if (I !== 0) return I;
          }
          return 1;
        } }, { key: "compare", value: function(o, h) {
          for (var _ = 0; _ < o.length && _ < h.length; ) {
            var I = o[_].compareTo(h[_]);
            if (I !== 0) return I;
            _++;
          }
          return _ < h.length ? -1 : _ < o.length ? 1 : 0;
        } }, { key: "minCoordinate", value: function(o) {
          for (var h = null, _ = 0; _ < o.length; _++) (h === null || h.compareTo(o[_]) > 0) && (h = o[_]);
          return h;
        } }, { key: "extract", value: function(o, h, _) {
          h = gt.clamp(h, 0, o.length);
          var I = (_ = gt.clamp(_, -1, o.length)) - h + 1;
          _ < 0 && (I = 0), h >= o.length && (I = 0), _ < h && (I = 0);
          var D = new Array(I).fill(null);
          if (I === 0) return D;
          for (var B = 0, W = h; W <= _; W++) D[B++] = o[W];
          return D;
        } }]);
      })(), Sr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "compare", value: function(y, o) {
          var h = y, _ = o;
          return wt.compare(h, _);
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }]);
      })(), en = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "compare", value: function(y, o) {
          var h = y, _ = o;
          if (h.length < _.length) return -1;
          if (h.length > _.length) return 1;
          if (h.length === 0) return 0;
          var I = wt.compare(h, _);
          return wt.isEqualReversed(h, _) ? 0 : I;
        } }, { key: "OLDcompare", value: function(y, o) {
          var h = y, _ = o;
          if (h.length < _.length) return -1;
          if (h.length > _.length) return 1;
          if (h.length === 0) return 0;
          for (var I = wt.increasingDirection(h), D = wt.increasingDirection(_), B = I > 0 ? 0 : h.length - 1, W = D > 0 ? 0 : h.length - 1, oe = 0; oe < h.length; oe++) {
            var de = h[B].compareTo(_[W]);
            if (de !== 0) return de;
            B += I, W += D;
          }
          return 0;
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }]);
      })();
      wt.ForwardComparator = Sr, wt.BidirectionalComparator = en, wt.coordArrayType = new Array(0).fill(null);
      var Mr = (function() {
        return u((function y(o) {
          x(this, y), this.str = o;
        }), [{ key: "append", value: function(y) {
          this.str += y;
        } }, { key: "setCharAt", value: function(y, o) {
          this.str = this.str.substr(0, y) + o + this.str.substr(y + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      })(), Mn = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getM", value: function(o) {
          return this.hasM() ? this._coordinates[o].getM() : ft.NaN;
        } }, { key: "setOrdinate", value: function(o, h, _) {
          switch (h) {
            case Fe.X:
              this._coordinates[o].x = _;
              break;
            case Fe.Y:
              this._coordinates[o].y = _;
              break;
            default:
              this._coordinates[o].setOrdinate(h, _);
          }
        } }, { key: "getZ", value: function(o) {
          return this.hasZ() ? this._coordinates[o].getZ() : ft.NaN;
        } }, { key: "size", value: function() {
          return this._coordinates.length;
        } }, { key: "getOrdinate", value: function(o, h) {
          switch (h) {
            case Fe.X:
              return this._coordinates[o].x;
            case Fe.Y:
              return this._coordinates[o].y;
            default:
              return this._coordinates[o].getOrdinate(h);
          }
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this._coordinates[o];
          }
          if (arguments.length === 2) {
            var h = arguments[0];
            arguments[1].setCoordinate(this._coordinates[h]);
          }
        } }, { key: "getCoordinateCopy", value: function(o) {
          var h = this.createCoordinate();
          return h.setCoordinate(this._coordinates[o]), h;
        } }, { key: "createCoordinate", value: function() {
          return we.create(this.getDimension(), this.getMeasures());
        } }, { key: "getDimension", value: function() {
          return this._dimension;
        } }, { key: "getX", value: function(o) {
          return this._coordinates[o].x;
        } }, { key: "getMeasures", value: function() {
          return this._measures;
        } }, { key: "expandEnvelope", value: function(o) {
          for (var h = 0; h < this._coordinates.length; h++) o.expandToInclude(this._coordinates[h]);
          return o;
        } }, { key: "copy", value: function() {
          for (var o = new Array(this.size()).fill(null), h = 0; h < this._coordinates.length; h++) {
            var _ = this.createCoordinate();
            _.setCoordinate(this._coordinates[h]), o[h] = _;
          }
          return new y(o, this._dimension, this._measures);
        } }, { key: "toString", value: function() {
          if (this._coordinates.length > 0) {
            var o = new Mr(17 * this._coordinates.length);
            o.append("("), o.append(this._coordinates[0]);
            for (var h = 1; h < this._coordinates.length; h++) o.append(", "), o.append(this._coordinates[h]);
            return o.append(")"), o.toString();
          }
          return "()";
        } }, { key: "getY", value: function(o) {
          return this._coordinates[o].y;
        } }, { key: "toCoordinateArray", value: function() {
          return this._coordinates;
        } }, { key: "interfaces_", get: function() {
          return [Fe, se];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              y.constructor_.call(this, o, wt.dimension(o), wt.measures(o));
            } else if (Number.isInteger(arguments[0])) {
              var h = arguments[0];
              this._coordinates = new Array(h).fill(null);
              for (var _ = 0; _ < h; _++) this._coordinates[_] = new He();
            } else if (tr(arguments[0], Fe)) {
              var I = arguments[0];
              if (I === null) return this._coordinates = new Array(0).fill(null), null;
              this._dimension = I.getDimension(), this._measures = I.getMeasures(), this._coordinates = new Array(I.size()).fill(null);
              for (var D = 0; D < this._coordinates.length; D++) this._coordinates[D] = I.getCoordinateCopy(D);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var B = arguments[0], W = arguments[1];
              y.constructor_.call(this, B, W, wt.measures(B));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var oe = arguments[0], de = arguments[1];
              this._coordinates = new Array(oe).fill(null), this._dimension = de;
              for (var Ze = 0; Ze < oe; Ze++) this._coordinates[Ze] = we.create(de);
            }
          } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var rt = arguments[0], xt = arguments[1], jt = arguments[2];
              this._dimension = xt, this._measures = jt, this._coordinates = rt === null ? new Array(0).fill(null) : rt;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var qt = arguments[0], Wt = arguments[1], _r = arguments[2];
              this._coordinates = new Array(qt).fill(null), this._dimension = Wt, this._measures = _r;
              for (var lr = 0; lr < qt; lr++) this._coordinates[lr] = this.createCoordinate();
            }
          }
        } }]);
      })(), Dn = (function() {
        function y() {
          x(this, y);
        }
        return u(y, [{ key: "readResolve", value: function() {
          return y.instance();
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new Mn(arguments[0]);
            if (tr(arguments[0], Fe)) return new Mn(arguments[0]);
          } else {
            if (arguments.length === 2) {
              var o = arguments[1];
              return o > 3 && (o = 3), o < 2 && (o = 2), new Mn(arguments[0], o);
            }
            if (arguments.length === 3) {
              var h = arguments[2], _ = arguments[1] - h;
              return h > 1 && (h = 1), _ > 3 && (_ = 3), _ < 2 && (_ = 2), new Mn(arguments[0], _ + h, h);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [vt, se];
        } }], [{ key: "instance", value: function() {
          return y.instanceObject;
        } }]);
      })();
      Dn.instanceObject = new Dn();
      var Nr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && ce(o, "equalsExact", this, 1).call(this, h, _);
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_MULTIPOLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          for (var h = new me(), _ = 0; _ < this._geometries.length; _++) for (var I = this._geometries[_].getBoundary(), D = 0; D < I.getNumGeometries(); D++) h.add(I.getGeometryN(D));
          var B = new Array(h.size()).fill(null);
          return this.getFactory().createMultiLineString(h.toArray(B));
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [pt];
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          yt.constructor_.call(this, h, _);
        } }]);
      })(yt), Er = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "get", value: function() {
        } }, { key: "put", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "values", value: function() {
        } }, { key: "entrySet", value: function() {
        } }]);
      })(), _n = (function(y) {
        function o() {
          var h;
          return x(this, o), (h = p(this, o)).map = /* @__PURE__ */ new Map(), h;
        }
        return $(o, y), u(o, [{ key: "get", value: function(h) {
          return this.map.get(h) || null;
        } }, { key: "put", value: function(h, _) {
          return this.map.set(h, _), _;
        } }, { key: "values", value: function() {
          for (var h = new me(), _ = this.map.values(), I = _.next(); !I.done; ) h.add(I.value), I = _.next();
          return h;
        } }, { key: "entrySet", value: function() {
          var h = new Dr();
          return this.map.entries().forEach((function(_) {
            return h.add(_);
          })), h;
        } }, { key: "size", value: function() {
          return this.map.size();
        } }]);
      })(Er), Rn = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "equals", value: function(o) {
          if (!(o instanceof y)) return !1;
          var h = o;
          return this._modelType === h._modelType && this._scale === h._scale;
        } }, { key: "compareTo", value: function(o) {
          var h = o, _ = this.getMaximumSignificantDigits(), I = h.getMaximumSignificantDigits();
          return Vn.compare(_, I);
        } }, { key: "getScale", value: function() {
          return this._scale;
        } }, { key: "isFloating", value: function() {
          return this._modelType === y.FLOATING || this._modelType === y.FLOATING_SINGLE;
        } }, { key: "getType", value: function() {
          return this._modelType;
        } }, { key: "toString", value: function() {
          var o = "UNKNOWN";
          return this._modelType === y.FLOATING ? o = "Floating" : this._modelType === y.FLOATING_SINGLE ? o = "Floating-Single" : this._modelType === y.FIXED && (o = "Fixed (Scale=" + this.getScale() + ")"), o;
        } }, { key: "makePrecise", value: function() {
          if (typeof arguments[0] == "number") {
            var o = arguments[0];
            return ft.isNaN(o) || this._modelType === y.FLOATING_SINGLE ? o : this._modelType === y.FIXED ? Math.round(o * this._scale) / this._scale : o;
          }
          if (arguments[0] instanceof He) {
            var h = arguments[0];
            if (this._modelType === y.FLOATING) return null;
            h.x = this.makePrecise(h.x), h.y = this.makePrecise(h.y);
          }
        } }, { key: "getMaximumSignificantDigits", value: function() {
          var o = 16;
          return this._modelType === y.FLOATING ? o = 16 : this._modelType === y.FLOATING_SINGLE ? o = 6 : this._modelType === y.FIXED && (o = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), o;
        } }, { key: "setScale", value: function(o) {
          this._scale = Math.abs(o);
        } }, { key: "interfaces_", get: function() {
          return [se, ut];
        } }], [{ key: "constructor_", value: function() {
          if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = y.FLOATING;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof Yi) {
              var o = arguments[0];
              this._modelType = o, o === y.FIXED && this.setScale(1);
            } else if (typeof arguments[0] == "number") {
              var h = arguments[0];
              this._modelType = y.FIXED, this.setScale(h);
            } else if (arguments[0] instanceof y) {
              var _ = arguments[0];
              this._modelType = _._modelType, this._scale = _._scale;
            }
          }
        } }, { key: "mostPrecise", value: function(o, h) {
          return o.compareTo(h) >= 0 ? o : h;
        } }]);
      })(), Yi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "readResolve", value: function() {
          return y.nameToTypeMap.get(this._name);
        } }, { key: "toString", value: function() {
          return this._name;
        } }, { key: "interfaces_", get: function() {
          return [se];
        } }], [{ key: "constructor_", value: function() {
          this._name = null;
          var o = arguments[0];
          this._name = o, y.nameToTypeMap.put(o, this);
        } }]);
      })();
      Yi.nameToTypeMap = new _n(), Rn.Type = Yi, Rn.FIXED = new Yi("FIXED"), Rn.FLOATING = new Yi("FLOATING"), Rn.FLOATING_SINGLE = new Yi("FLOATING SINGLE"), Rn.maximumPreciseValue = 9007199254740992;
      var Ds = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Bt) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && ce(o, "equalsExact", this, 1).call(this, h, _);
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? lt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          if (this.isEmpty()) return !1;
          for (var h = 0; h < this._geometries.length; h++) if (!this._geometries[h].isClosed()) return !1;
          return !0;
        } }, { key: "getTypeCode", value: function() {
          return Bt.TYPECODE_MULTILINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getBoundary", value: function() {
          throw new rr();
        } }, { key: "getGeometryType", value: function() {
          return Bt.TYPENAME_MULTILINESTRING;
        } }, { key: "interfaces_", get: function() {
          return [Cr];
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          yt.constructor_.call(this, h, _);
        } }]);
      })(yt), si = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "createEmpty", value: function(o) {
          switch (o) {
            case -1:
              return this.createGeometryCollection();
            case 0:
              return this.createPoint();
            case 1:
              return this.createLineString();
            case 2:
              return this.createPolygon();
            default:
              throw new et("Invalid dimension: " + o);
          }
        } }, { key: "toGeometry", value: function(o) {
          return o.isNull() ? this.createPoint() : o.getMinX() === o.getMaxX() && o.getMinY() === o.getMaxY() ? this.createPoint(new He(o.getMinX(), o.getMinY())) : o.getMinX() === o.getMaxX() || o.getMinY() === o.getMaxY() ? this.createLineString([new He(o.getMinX(), o.getMinY()), new He(o.getMaxX(), o.getMaxY())]) : this.createPolygon(this.createLinearRing([new He(o.getMinX(), o.getMinY()), new He(o.getMinX(), o.getMaxY()), new He(o.getMaxX(), o.getMaxY()), new He(o.getMaxX(), o.getMinY()), new He(o.getMinX(), o.getMinY())]), null);
        } }, { key: "createLineString", value: function() {
          if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              return this.createLineString(o !== null ? this.getCoordinateSequenceFactory().create(o) : null);
            }
            if (tr(arguments[0], Fe)) return new wr(arguments[0], this);
          }
        } }, { key: "createMultiLineString", value: function() {
          return arguments.length === 0 ? new Ds(null, this) : arguments.length === 1 ? new Ds(arguments[0], this) : void 0;
        } }, { key: "buildGeometry", value: function(o) {
          for (var h = null, _ = !1, I = !1, D = o.iterator(); D.hasNext(); ) {
            var B = D.next(), W = B.getTypeCode();
            h === null && (h = W), W !== h && (_ = !0), B instanceof yt && (I = !0);
          }
          if (h === null) return this.createGeometryCollection();
          if (_ || I) return this.createGeometryCollection(y.toGeometryArray(o));
          var oe = o.iterator().next();
          if (o.size() > 1) {
            if (oe instanceof jr) return this.createMultiPolygon(y.toPolygonArray(o));
            if (oe instanceof wr) return this.createMultiLineString(y.toLineStringArray(o));
            if (oe instanceof Qr) return this.createMultiPoint(y.toPointArray(o));
            At.shouldNeverReachHere("Unhandled geometry type: " + oe.getGeometryType());
          }
          return oe;
        } }, { key: "createMultiPointFromCoords", value: function(o) {
          return this.createMultiPoint(o !== null ? this.getCoordinateSequenceFactory().create(o) : null);
        } }, { key: "createPoint", value: function() {
          if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof He) {
              var o = arguments[0];
              return this.createPoint(o !== null ? this.getCoordinateSequenceFactory().create([o]) : null);
            }
            if (tr(arguments[0], Fe)) return new Qr(arguments[0], this);
          }
        } }, { key: "getCoordinateSequenceFactory", value: function() {
          return this._coordinateSequenceFactory;
        } }, { key: "createPolygon", value: function() {
          if (arguments.length === 0) return this.createPolygon(null, null);
          if (arguments.length === 1) {
            if (tr(arguments[0], Fe)) {
              var o = arguments[0];
              return this.createPolygon(this.createLinearRing(o));
            }
            if (arguments[0] instanceof Array) {
              var h = arguments[0];
              return this.createPolygon(this.createLinearRing(h));
            }
            if (arguments[0] instanceof ir) {
              var _ = arguments[0];
              return this.createPolygon(_, null);
            }
          } else if (arguments.length === 2)
            return new jr(arguments[0], arguments[1], this);
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "createGeometryCollection", value: function() {
          return arguments.length === 0 ? new yt(null, this) : arguments.length === 1 ? new yt(arguments[0], this) : void 0;
        } }, { key: "getPrecisionModel", value: function() {
          return this._precisionModel;
        } }, { key: "createLinearRing", value: function() {
          if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              return this.createLinearRing(o !== null ? this.getCoordinateSequenceFactory().create(o) : null);
            }
            if (tr(arguments[0], Fe)) return new ir(arguments[0], this);
          }
        } }, { key: "createMultiPolygon", value: function() {
          return arguments.length === 0 ? new Nr(null, this) : arguments.length === 1 ? new Nr(arguments[0], this) : void 0;
        } }, { key: "createMultiPoint", value: function() {
          if (arguments.length === 0) return new er(null, this);
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new er(arguments[0], this);
            if (tr(arguments[0], Fe)) {
              var o = arguments[0];
              if (o === null) return this.createMultiPoint(new Array(0).fill(null));
              for (var h = new Array(o.size()).fill(null), _ = 0; _ < o.size(); _++) {
                var I = this.getCoordinateSequenceFactory().create(1, o.getDimension(), o.getMeasures());
                kt.copy(o, _, I, 0, 1), h[_] = this.createPoint(I);
              }
              return this.createMultiPoint(h);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [se];
        } }], [{ key: "constructor_", value: function() {
          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) y.constructor_.call(this, new Rn(), 0);
          else if (arguments.length === 1) {
            if (tr(arguments[0], vt)) {
              var o = arguments[0];
              y.constructor_.call(this, new Rn(), 0, o);
            } else if (arguments[0] instanceof Rn) {
              var h = arguments[0];
              y.constructor_.call(this, h, 0, y.getDefaultCoordinateSequenceFactory());
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            y.constructor_.call(this, _, I, y.getDefaultCoordinateSequenceFactory());
          } else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], W = arguments[2];
            this._precisionModel = D, this._coordinateSequenceFactory = W, this._SRID = B;
          }
        } }, { key: "toMultiPolygonArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toGeometryArray", value: function(o) {
          if (o === null) return null;
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
          return Dn.instance();
        } }, { key: "toMultiLineStringArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toLineStringArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toMultiPointArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toLinearRingArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toPointArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toPolygonArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "createPointFromInternalCoord", value: function(o, h) {
          return h.getPrecisionModel().makePrecise(o), h.getFactory().createPoint(o);
        } }]);
      })(), yl = "XY", ba = "XYZ", vl = "XYM", cn = "XYZM", su = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, au = "EMPTY", ea = 1, bs = 2, Rs = 3, ou = 4, Fs = 5, lu = 6;
      for (var uu in su) su[uu].toUpperCase();
      var cu = (function() {
        return u((function y(o) {
          x(this, y), this.wkt = o, this.index_ = -1;
        }), [{ key: "isAlpha_", value: function(y) {
          return y >= "a" && y <= "z" || y >= "A" && y <= "Z";
        } }, { key: "isNumeric_", value: function(y, o) {
          return y >= "0" && y <= "9" || y == "." && !(o !== void 0 && o);
        } }, { key: "isWhiteSpace_", value: function(y) {
          return y == " " || y == "	" || y == "\r" || y == `
`;
        } }, { key: "nextChar_", value: function() {
          return this.wkt.charAt(++this.index_);
        } }, { key: "nextToken", value: function() {
          var y, o = this.nextChar_(), h = this.index_, _ = o;
          if (o == "(") y = bs;
          else if (o == ",") y = Fs;
          else if (o == ")") y = Rs;
          else if (this.isNumeric_(o) || o == "-") y = ou, _ = this.readNumber_();
          else if (this.isAlpha_(o)) y = ea, _ = this.readText_();
          else {
            if (this.isWhiteSpace_(o)) return this.nextToken();
            if (o !== "") throw new Error("Unexpected character: " + o);
            y = lu;
          }
          return { position: h, value: _, type: y };
        } }, { key: "readNumber_", value: function() {
          var y, o = this.index_, h = !1, _ = !1;
          do
            y == "." ? h = !0 : y != "e" && y != "E" || (_ = !0), y = this.nextChar_();
          while (this.isNumeric_(y, h) || !_ && (y == "e" || y == "E") || _ && (y == "-" || y == "+"));
          return parseFloat(this.wkt.substring(o, this.index_--));
        } }, { key: "readText_", value: function() {
          var y, o = this.index_;
          do
            y = this.nextChar_();
          while (this.isAlpha_(y));
          return this.wkt.substring(o, this.index_--).toUpperCase();
        } }]);
      })(), hu = (function() {
        return u((function y(o, h) {
          x(this, y), this.lexer_ = o, this.token_, this.layout_ = yl, this.factory = h;
        }), [{ key: "consume_", value: function() {
          this.token_ = this.lexer_.nextToken();
        } }, { key: "isTokenType", value: function(y) {
          return this.token_.type == y;
        } }, { key: "match", value: function(y) {
          var o = this.isTokenType(y);
          return o && this.consume_(), o;
        } }, { key: "parse", value: function() {
          return this.consume_(), this.parseGeometry_();
        } }, { key: "parseGeometryLayout_", value: function() {
          var y = yl, o = this.token_;
          if (this.isTokenType(ea)) {
            var h = o.value;
            h === "Z" ? y = ba : h === "M" ? y = vl : h === "ZM" && (y = cn), y !== yl && this.consume_();
          }
          return y;
        } }, { key: "parseGeometryCollectionText_", value: function() {
          if (this.match(bs)) {
            var y = [];
            do
              y.push(this.parseGeometry_());
            while (this.match(Fs));
            if (this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointText_", value: function() {
          if (this.match(bs)) {
            var y = this.parsePoint_();
            if (this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return null;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseLineStringText_", value: function() {
          if (this.match(bs)) {
            var y = this.parsePointList_();
            if (this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePolygonText_", value: function() {
          if (this.match(bs)) {
            var y = this.parseLineStringTextList_();
            if (this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPointText_", value: function() {
          var y;
          if (this.match(bs)) {
            if (y = this.token_.type == bs ? this.parsePointTextList_() : this.parsePointList_(), this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiLineStringText_", value: function() {
          if (this.match(bs)) {
            var y = this.parseLineStringTextList_();
            if (this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPolygonText_", value: function() {
          if (this.match(bs)) {
            var y = this.parsePolygonTextList_();
            if (this.match(Rs)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePoint_", value: function() {
          for (var y = [], o = this.layout_.length, h = 0; h < o; ++h) {
            var _ = this.token_;
            if (!this.match(ou)) break;
            y.push(_.value);
          }
          if (y.length == o) return y;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointList_", value: function() {
          for (var y = [this.parsePoint_()]; this.match(Fs); ) y.push(this.parsePoint_());
          return y;
        } }, { key: "parsePointTextList_", value: function() {
          for (var y = [this.parsePointText_()]; this.match(Fs); ) y.push(this.parsePointText_());
          return y;
        } }, { key: "parseLineStringTextList_", value: function() {
          for (var y = [this.parseLineStringText_()]; this.match(Fs); ) y.push(this.parseLineStringText_());
          return y;
        } }, { key: "parsePolygonTextList_", value: function() {
          for (var y = [this.parsePolygonText_()]; this.match(Fs); ) y.push(this.parsePolygonText_());
          return y;
        } }, { key: "isEmptyGeometry_", value: function() {
          var y = this.isTokenType(ea) && this.token_.value == au;
          return y && this.consume_(), y;
        } }, { key: "formatErrorMessage_", value: function() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        } }, { key: "parseGeometry_", value: function() {
          var y = this.factory, o = function(Wt) {
            return M(He, _e(Wt));
          }, h = function(Wt) {
            var _r = Wt.map((function(lr) {
              return y.createLinearRing(lr.map(o));
            }));
            return _r.length > 1 ? y.createPolygon(_r[0], _r.slice(1)) : y.createPolygon(_r[0]);
          }, _ = this.token_;
          if (this.match(ea)) {
            var I = _.value;
            if (this.layout_ = this.parseGeometryLayout_(), I == "GEOMETRYCOLLECTION") {
              var D = this.parseGeometryCollectionText_();
              return y.createGeometryCollection(D);
            }
            switch (I) {
              case "POINT":
                var B = this.parsePointText_();
                return B ? y.createPoint(M(He, _e(B))) : y.createPoint();
              case "LINESTRING":
                var W = this.parseLineStringText_().map(o);
                return y.createLineString(W);
              case "LINEARRING":
                var oe = this.parseLineStringText_().map(o);
                return y.createLinearRing(oe);
              case "POLYGON":
                var de = this.parsePolygonText_();
                return de && de.length !== 0 ? h(de) : y.createPolygon();
              case "MULTIPOINT":
                var Ze = this.parseMultiPointText_();
                if (!Ze || Ze.length === 0) return y.createMultiPoint();
                var rt = Ze.map(o).map((function(Wt) {
                  return y.createPoint(Wt);
                }));
                return y.createMultiPoint(rt);
              case "MULTILINESTRING":
                var xt = this.parseMultiLineStringText_().map((function(Wt) {
                  return y.createLineString(Wt.map(o));
                }));
                return y.createMultiLineString(xt);
              case "MULTIPOLYGON":
                var jt = this.parseMultiPolygonText_();
                if (!jt || jt.length === 0) return y.createMultiPolygon();
                var qt = jt.map(h);
                return y.createMultiPolygon(qt);
              default:
                throw new Error("Invalid geometry type: " + I);
            }
          }
          throw new Error(this.formatErrorMessage_());
        } }]);
      })();
      function wc(y) {
        if (y.isEmpty()) return "";
        var o = y.getCoordinate(), h = [o.x, o.y];
        return o.z === void 0 || Number.isNaN(o.z) || h.push(o.z), o.m === void 0 || Number.isNaN(o.m) || h.push(o.m), h.join(" ");
      }
      function Ns(y) {
        for (var o = y.getCoordinates().map((function(D) {
          var B = [D.x, D.y];
          return D.z === void 0 || Number.isNaN(D.z) || B.push(D.z), D.m === void 0 || Number.isNaN(D.m) || B.push(D.m), B;
        })), h = [], _ = 0, I = o.length; _ < I; ++_) h.push(o[_].join(" "));
        return h.join(", ");
      }
      function Ao(y) {
        var o = [];
        o.push("(" + Ns(y.getExteriorRing()) + ")");
        for (var h = 0, _ = y.getNumInteriorRing(); h < _; ++h) o.push("(" + Ns(y.getInteriorRingN(h)) + ")");
        return o.join(", ");
      }
      var Ec = { Point: wc, LineString: Ns, LinearRing: Ns, Polygon: Ao, MultiPoint: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push("(" + wc(y.getGeometryN(h)) + ")");
        return o.join(", ");
      }, MultiLineString: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push("(" + Ns(y.getGeometryN(h)) + ")");
        return o.join(", ");
      }, MultiPolygon: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push("(" + Ao(y.getGeometryN(h)) + ")");
        return o.join(", ");
      }, GeometryCollection: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push(wa(y.getGeometryN(h)));
        return o.join(", ");
      } };
      function wa(y) {
        var o = y.getGeometryType(), h = Ec[o];
        o = o.toUpperCase();
        var _ = (function(I) {
          var D = "";
          if (I.isEmpty()) return D;
          var B = I.getCoordinate();
          return B.z === void 0 || Number.isNaN(B.z) || (D += "Z"), B.m === void 0 || Number.isNaN(B.m) || (D += "M"), D;
        })(y);
        return _.length > 0 && (o += " " + _), y.isEmpty() ? o + " " + au : o + " (" + h(y) + ")";
      }
      var du = (function() {
        return u((function y(o) {
          x(this, y), this.geometryFactory = o || new si(), this.precisionModel = this.geometryFactory.getPrecisionModel();
        }), [{ key: "read", value: function(y) {
          var o = new cu(y);
          return new hu(o, this.geometryFactory).parse();
        } }, { key: "write", value: function(y) {
          return wa(y);
        } }]);
      })(), Ea = (function() {
        return u((function y(o) {
          x(this, y), this.parser = new du(o);
        }), [{ key: "write", value: function(y) {
          return this.parser.write(y);
        } }], [{ key: "toLineString", value: function(y, o) {
          if (arguments.length !== 2) throw new Error("Not implemented");
          return "LINESTRING ( " + y.x + " " + y.y + ", " + o.x + " " + o.y + " )";
        } }]);
      })(), Pr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getIndexAlongSegment", value: function(o, h) {
          return this.computeIntLineIndex(), this._intLineIndex[o][h];
        } }, { key: "getTopologySummary", value: function() {
          var o = new Mr();
          return this.isEndPoint() && o.append(" endpoint"), this._isProper && o.append(" proper"), this.isCollinear() && o.append(" collinear"), o.toString();
        } }, { key: "computeIntersection", value: function(o, h, _, I) {
          this._inputLines[0][0] = o, this._inputLines[0][1] = h, this._inputLines[1][0] = _, this._inputLines[1][1] = I, this._result = this.computeIntersect(o, h, _, I);
        } }, { key: "getIntersectionNum", value: function() {
          return this._result;
        } }, { key: "computeIntLineIndex", value: function() {
          if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map((function() {
            return Array(2);
          })), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (arguments.length === 1) {
            var o = arguments[0];
            this.getEdgeDistance(o, 0) > this.getEdgeDistance(o, 1) ? (this._intLineIndex[o][0] = 0, this._intLineIndex[o][1] = 1) : (this._intLineIndex[o][0] = 1, this._intLineIndex[o][1] = 0);
          }
        } }, { key: "isProper", value: function() {
          return this.hasIntersection() && this._isProper;
        } }, { key: "setPrecisionModel", value: function(o) {
          this._precisionModel = o;
        } }, { key: "isInteriorIntersection", value: function() {
          if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (arguments.length === 1) {
            for (var o = arguments[0], h = 0; h < this._result; h++) if (!this._intPt[h].equals2D(this._inputLines[o][0]) && !this._intPt[h].equals2D(this._inputLines[o][1])) return !0;
            return !1;
          }
        } }, { key: "getIntersection", value: function(o) {
          return this._intPt[o];
        } }, { key: "isEndPoint", value: function() {
          return this.hasIntersection() && !this._isProper;
        } }, { key: "hasIntersection", value: function() {
          return this._result !== y.NO_INTERSECTION;
        } }, { key: "getEdgeDistance", value: function(o, h) {
          return y.computeEdgeDistance(this._intPt[h], this._inputLines[o][0], this._inputLines[o][1]);
        } }, { key: "isCollinear", value: function() {
          return this._result === y.COLLINEAR_INTERSECTION;
        } }, { key: "toString", value: function() {
          return Ea.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Ea.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        } }, { key: "getEndpoint", value: function(o, h) {
          return this._inputLines[o][h];
        } }, { key: "isIntersection", value: function(o) {
          for (var h = 0; h < this._result; h++) if (this._intPt[h].equals2D(o)) return !0;
          return !1;
        } }, { key: "getIntersectionAlongSegment", value: function(o, h) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[o][h]];
        } }], [{ key: "constructor_", value: function() {
          this._result = null, this._inputLines = Array(2).fill().map((function() {
            return Array(2);
          })), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new He(), this._intPt[1] = new He(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        } }, { key: "computeEdgeDistance", value: function(o, h, _) {
          var I = Math.abs(_.x - h.x), D = Math.abs(_.y - h.y), B = -1;
          if (o.equals(h)) B = 0;
          else if (o.equals(_)) B = I > D ? I : D;
          else {
            var W = Math.abs(o.x - h.x), oe = Math.abs(o.y - h.y);
            (B = I > D ? W : oe) !== 0 || o.equals(h) || (B = Math.max(W, oe));
          }
          return At.isTrue(!(B === 0 && !o.equals(h)), "Bad distance calculation"), B;
        } }, { key: "nonRobustComputeEdgeDistance", value: function(o, h, _) {
          var I = o.x - h.x, D = o.y - h.y, B = Math.sqrt(I * I + D * D);
          return At.isTrue(!(B === 0 && !o.equals(h)), "Invalid distance calculation"), B;
        } }]);
      })();
      Pr.DONT_INTERSECT = 0, Pr.DO_INTERSECT = 1, Pr.COLLINEAR = 2, Pr.NO_INTERSECTION = 0, Pr.POINT_INTERSECTION = 1, Pr.COLLINEAR_INTERSECTION = 2;
      var Wi = (function(y) {
        function o() {
          return x(this, o), p(this, o);
        }
        return $(o, y), u(o, [{ key: "isInSegmentEnvelopes", value: function(h) {
          var _ = new fr(this._inputLines[0][0], this._inputLines[0][1]), I = new fr(this._inputLines[1][0], this._inputLines[1][1]);
          return _.contains(h) && I.contains(h);
        } }, { key: "computeIntersection", value: function() {
          if (arguments.length !== 3) return ce(o, "computeIntersection", this, 1).apply(this, arguments);
          var h = arguments[0], _ = arguments[1], I = arguments[2];
          if (this._isProper = !1, fr.intersects(_, I, h) && H.index(_, I, h) === 0 && H.index(I, _, h) === 0) return this._isProper = !0, (h.equals(_) || h.equals(I)) && (this._isProper = !1), this._result = Pr.POINT_INTERSECTION, null;
          this._result = Pr.NO_INTERSECTION;
        } }, { key: "intersection", value: function(h, _, I, D) {
          var B = this.intersectionSafe(h, _, I, D);
          return this.isInSegmentEnvelopes(B) || (B = new He(o.nearestEndpoint(h, _, I, D))), this._precisionModel !== null && this._precisionModel.makePrecise(B), B;
        } }, { key: "checkDD", value: function(h, _, I, D, B) {
          var W = os.intersection(h, _, I, D), oe = this.isInSegmentEnvelopes(W);
          $e.out.println("DD in env = " + oe + "  --------------------- " + W), B.distance(W) > 1e-4 && $e.out.println("Distance = " + B.distance(W));
        } }, { key: "intersectionSafe", value: function(h, _, I, D) {
          var B = Ve.intersection(h, _, I, D);
          return B === null && (B = o.nearestEndpoint(h, _, I, D)), B;
        } }, { key: "computeCollinearIntersection", value: function(h, _, I, D) {
          var B = fr.intersects(h, _, I), W = fr.intersects(h, _, D), oe = fr.intersects(I, D, h), de = fr.intersects(I, D, _);
          return B && W ? (this._intPt[0] = I, this._intPt[1] = D, Pr.COLLINEAR_INTERSECTION) : oe && de ? (this._intPt[0] = h, this._intPt[1] = _, Pr.COLLINEAR_INTERSECTION) : B && oe ? (this._intPt[0] = I, this._intPt[1] = h, !I.equals(h) || W || de ? Pr.COLLINEAR_INTERSECTION : Pr.POINT_INTERSECTION) : B && de ? (this._intPt[0] = I, this._intPt[1] = _, !I.equals(_) || W || oe ? Pr.COLLINEAR_INTERSECTION : Pr.POINT_INTERSECTION) : W && oe ? (this._intPt[0] = D, this._intPt[1] = h, !D.equals(h) || B || de ? Pr.COLLINEAR_INTERSECTION : Pr.POINT_INTERSECTION) : W && de ? (this._intPt[0] = D, this._intPt[1] = _, !D.equals(_) || B || oe ? Pr.COLLINEAR_INTERSECTION : Pr.POINT_INTERSECTION) : Pr.NO_INTERSECTION;
        } }, { key: "computeIntersect", value: function(h, _, I, D) {
          if (this._isProper = !1, !fr.intersects(h, _, I, D)) return Pr.NO_INTERSECTION;
          var B = H.index(h, _, I), W = H.index(h, _, D);
          if (B > 0 && W > 0 || B < 0 && W < 0) return Pr.NO_INTERSECTION;
          var oe = H.index(I, D, h), de = H.index(I, D, _);
          return oe > 0 && de > 0 || oe < 0 && de < 0 ? Pr.NO_INTERSECTION : B === 0 && W === 0 && oe === 0 && de === 0 ? this.computeCollinearIntersection(h, _, I, D) : (B === 0 || W === 0 || oe === 0 || de === 0 ? (this._isProper = !1, h.equals2D(I) || h.equals2D(D) ? this._intPt[0] = h : _.equals2D(I) || _.equals2D(D) ? this._intPt[0] = _ : B === 0 ? this._intPt[0] = new He(I) : W === 0 ? this._intPt[0] = new He(D) : oe === 0 ? this._intPt[0] = new He(h) : de === 0 && (this._intPt[0] = new He(_))) : (this._isProper = !0, this._intPt[0] = this.intersection(h, _, I, D)), Pr.POINT_INTERSECTION);
        } }], [{ key: "nearestEndpoint", value: function(h, _, I, D) {
          var B = h, W = st.pointToSegment(h, I, D), oe = st.pointToSegment(_, I, D);
          return oe < W && (W = oe, B = _), (oe = st.pointToSegment(I, h, _)) < W && (W = oe, B = I), (oe = st.pointToSegment(D, h, _)) < W && (W = oe, B = D), B;
        } }]);
      })(Pr), cr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "countSegment", value: function(o, h) {
          if (o.x < this._p.x && h.x < this._p.x) return null;
          if (this._p.x === h.x && this._p.y === h.y) return this._isPointOnSegment = !0, null;
          if (o.y === this._p.y && h.y === this._p.y) {
            var _ = o.x, I = h.x;
            return _ > I && (_ = h.x, I = o.x), this._p.x >= _ && this._p.x <= I && (this._isPointOnSegment = !0), null;
          }
          if (o.y > this._p.y && h.y <= this._p.y || h.y > this._p.y && o.y <= this._p.y) {
            var D = H.index(o, h, this._p);
            if (D === H.COLLINEAR) return this._isPointOnSegment = !0, null;
            h.y < o.y && (D = -D), D === H.LEFT && this._crossingCount++;
          }
        } }, { key: "isPointInPolygon", value: function() {
          return this.getLocation() !== Me.EXTERIOR;
        } }, { key: "getLocation", value: function() {
          return this._isPointOnSegment ? Me.BOUNDARY : this._crossingCount % 2 == 1 ? Me.INTERIOR : Me.EXTERIOR;
        } }, { key: "isOnSegment", value: function() {
          return this._isPointOnSegment;
        } }], [{ key: "constructor_", value: function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
          var o = arguments[0];
          this._p = o;
        } }, { key: "locatePointInRing", value: function() {
          if (arguments[0] instanceof He && tr(arguments[1], Fe)) {
            for (var o = arguments[1], h = new y(arguments[0]), _ = new He(), I = new He(), D = 1; D < o.size(); D++) if (o.getCoordinate(D, _), o.getCoordinate(D - 1, I), h.countSegment(_, I), h.isOnSegment()) return h.getLocation();
            return h.getLocation();
          }
          if (arguments[0] instanceof He && arguments[1] instanceof Array) {
            for (var B = arguments[1], W = new y(arguments[0]), oe = 1; oe < B.length; oe++) {
              var de = B[oe], Ze = B[oe - 1];
              if (W.countSegment(de, Ze), W.isOnSegment()) return W.getLocation();
            }
            return W.getLocation();
          }
        } }]);
      })(), Lo = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "isOnLine", value: function() {
          if (arguments[0] instanceof He && tr(arguments[1], Fe)) {
            for (var o = arguments[0], h = arguments[1], _ = new Wi(), I = new He(), D = new He(), B = h.size(), W = 1; W < B; W++) if (h.getCoordinate(W - 1, I), h.getCoordinate(W, D), _.computeIntersection(o, I, D), _.hasIntersection()) return !0;
            return !1;
          }
          if (arguments[0] instanceof He && arguments[1] instanceof Array) {
            for (var oe = arguments[0], de = arguments[1], Ze = new Wi(), rt = 1; rt < de.length; rt++) {
              var xt = de[rt - 1], jt = de[rt];
              if (Ze.computeIntersection(oe, xt, jt), Ze.hasIntersection()) return !0;
            }
            return !1;
          }
        } }, { key: "locateInRing", value: function(o, h) {
          return cr.locatePointInRing(o, h);
        } }, { key: "isInRing", value: function(o, h) {
          return y.locateInRing(o, h) !== Me.EXTERIOR;
        } }]);
      })(), Xi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "setAllLocations", value: function(o) {
          for (var h = 0; h < this.location.length; h++) this.location[h] = o;
        } }, { key: "isNull", value: function() {
          for (var o = 0; o < this.location.length; o++) if (this.location[o] !== Me.NONE) return !1;
          return !0;
        } }, { key: "setAllLocationsIfNull", value: function(o) {
          for (var h = 0; h < this.location.length; h++) this.location[h] === Me.NONE && (this.location[h] = o);
        } }, { key: "isLine", value: function() {
          return this.location.length === 1;
        } }, { key: "merge", value: function(o) {
          if (o.location.length > this.location.length) {
            var h = new Array(3).fill(null);
            h[Mt.ON] = this.location[Mt.ON], h[Mt.LEFT] = Me.NONE, h[Mt.RIGHT] = Me.NONE, this.location = h;
          }
          for (var _ = 0; _ < this.location.length; _++) this.location[_] === Me.NONE && _ < o.location.length && (this.location[_] = o.location[_]);
        } }, { key: "getLocations", value: function() {
          return this.location;
        } }, { key: "flip", value: function() {
          if (this.location.length <= 1) return null;
          var o = this.location[Mt.LEFT];
          this.location[Mt.LEFT] = this.location[Mt.RIGHT], this.location[Mt.RIGHT] = o;
        } }, { key: "toString", value: function() {
          var o = new ln();
          return this.location.length > 1 && o.append(Me.toLocationSymbol(this.location[Mt.LEFT])), o.append(Me.toLocationSymbol(this.location[Mt.ON])), this.location.length > 1 && o.append(Me.toLocationSymbol(this.location[Mt.RIGHT])), o.toString();
        } }, { key: "setLocations", value: function(o, h, _) {
          this.location[Mt.ON] = o, this.location[Mt.LEFT] = h, this.location[Mt.RIGHT] = _;
        } }, { key: "get", value: function(o) {
          return o < this.location.length ? this.location[o] : Me.NONE;
        } }, { key: "isArea", value: function() {
          return this.location.length > 1;
        } }, { key: "isAnyNull", value: function() {
          for (var o = 0; o < this.location.length; o++) if (this.location[o] === Me.NONE) return !0;
          return !1;
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.setLocation(Mt.ON, o);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.location[h] = _;
          }
        } }, { key: "init", value: function(o) {
          this.location = new Array(o).fill(null), this.setAllLocations(Me.NONE);
        } }, { key: "isEqualOnSide", value: function(o, h) {
          return this.location[h] === o.location[h];
        } }, { key: "allPositionsEqual", value: function(o) {
          for (var h = 0; h < this.location.length; h++) if (this.location[h] !== o) return !1;
          return !0;
        } }], [{ key: "constructor_", value: function() {
          if (this.location = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              this.init(o.length);
            } else if (Number.isInteger(arguments[0])) {
              var h = arguments[0];
              this.init(1), this.location[Mt.ON] = h;
            } else if (arguments[0] instanceof y) {
              var _ = arguments[0];
              if (this.init(_.location.length), _ !== null) for (var I = 0; I < this.location.length; I++) this.location[I] = _.location[I];
            }
          } else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], W = arguments[2];
            this.init(3), this.location[Mt.ON] = D, this.location[Mt.LEFT] = B, this.location[Mt.RIGHT] = W;
          }
        } }]);
      })(), ki = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getGeometryCount", value: function() {
          var o = 0;
          return this.elt[0].isNull() || o++, this.elt[1].isNull() || o++, o;
        } }, { key: "setAllLocations", value: function(o, h) {
          this.elt[o].setAllLocations(h);
        } }, { key: "isNull", value: function(o) {
          return this.elt[o].isNull();
        } }, { key: "setAllLocationsIfNull", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.setAllLocationsIfNull(0, o), this.setAllLocationsIfNull(1, o);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.elt[h].setAllLocationsIfNull(_);
          }
        } }, { key: "isLine", value: function(o) {
          return this.elt[o].isLine();
        } }, { key: "merge", value: function(o) {
          for (var h = 0; h < 2; h++) this.elt[h] === null && o.elt[h] !== null ? this.elt[h] = new Xi(o.elt[h]) : this.elt[h].merge(o.elt[h]);
        } }, { key: "flip", value: function() {
          this.elt[0].flip(), this.elt[1].flip();
        } }, { key: "getLocation", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.elt[o].get(Mt.ON);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return this.elt[h].get(_);
          }
        } }, { key: "toString", value: function() {
          var o = new ln();
          return this.elt[0] !== null && (o.append("A:"), o.append(this.elt[0].toString())), this.elt[1] !== null && (o.append(" B:"), o.append(this.elt[1].toString())), o.toString();
        } }, { key: "isArea", value: function() {
          if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.elt[o].isArea();
          }
        } }, { key: "isAnyNull", value: function(o) {
          return this.elt[o].isAnyNull();
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            this.elt[o].setLocation(Mt.ON, h);
          } else if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2];
            this.elt[_].setLocation(I, D);
          }
        } }, { key: "isEqualOnSide", value: function(o, h) {
          return this.elt[0].isEqualOnSide(o.elt[0], h) && this.elt[1].isEqualOnSide(o.elt[1], h);
        } }, { key: "allPositionsEqual", value: function(o, h) {
          return this.elt[o].allPositionsEqual(h);
        } }, { key: "toLine", value: function(o) {
          this.elt[o].isArea() && (this.elt[o] = new Xi(this.elt[o].location[0]));
        } }], [{ key: "constructor_", value: function() {
          if (this.elt = new Array(2).fill(null), arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
              var o = arguments[0];
              this.elt[0] = new Xi(o), this.elt[1] = new Xi(o);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this.elt[0] = new Xi(h.elt[0]), this.elt[1] = new Xi(h.elt[1]);
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.elt[0] = new Xi(Me.NONE), this.elt[1] = new Xi(Me.NONE), this.elt[_].setLocation(I);
          } else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], W = arguments[2];
            this.elt[0] = new Xi(D, B, W), this.elt[1] = new Xi(D, B, W);
          } else if (arguments.length === 4) {
            var oe = arguments[0], de = arguments[1], Ze = arguments[2], rt = arguments[3];
            this.elt[0] = new Xi(Me.NONE, Me.NONE, Me.NONE), this.elt[1] = new Xi(Me.NONE, Me.NONE, Me.NONE), this.elt[oe].setLocations(de, Ze, rt);
          }
        } }, { key: "toLineLabel", value: function(o) {
          for (var h = new y(Me.NONE), _ = 0; _ < 2; _++) h.setLocation(_, o.getLocation(_));
          return h;
        } }]);
      })(), Xn = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "computeRing", value: function() {
          if (this._ring !== null) return null;
          for (var y = new Array(this._pts.size()).fill(null), o = 0; o < this._pts.size(); o++) y[o] = this._pts.get(o);
          this._ring = this._geometryFactory.createLinearRing(y), this._isHole = H.isCCW(this._ring.getCoordinates());
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "computePoints", value: function(y) {
          this._startDe = y;
          var o = y, h = !0;
          do {
            if (o === null) throw new re("Found null DirectedEdge");
            if (o.getEdgeRing() === this) throw new re("Directed Edge visited twice during ring-building at " + o.getCoordinate());
            this._edges.add(o);
            var _ = o.getLabel();
            At.isTrue(_.isArea()), this.mergeLabel(_), this.addPoints(o.getEdge(), o.isForward(), h), h = !1, this.setEdgeRing(o, this), o = this.getNext(o);
          } while (o !== this._startDe);
        } }, { key: "getLinearRing", value: function() {
          return this._ring;
        } }, { key: "getCoordinate", value: function(y) {
          return this._pts.get(y);
        } }, { key: "computeMaxNodeDegree", value: function() {
          this._maxNodeDegree = 0;
          var y = this._startDe;
          do {
            var o = y.getNode().getEdges().getOutgoingDegree(this);
            o > this._maxNodeDegree && (this._maxNodeDegree = o), y = this.getNext(y);
          } while (y !== this._startDe);
          this._maxNodeDegree *= 2;
        } }, { key: "addPoints", value: function(y, o, h) {
          var _ = y.getCoordinates();
          if (o) {
            var I = 1;
            h && (I = 0);
            for (var D = I; D < _.length; D++) this._pts.add(_[D]);
          } else {
            var B = _.length - 2;
            h && (B = _.length - 1);
            for (var W = B; W >= 0; W--) this._pts.add(_[W]);
          }
        } }, { key: "isHole", value: function() {
          return this._isHole;
        } }, { key: "setInResult", value: function() {
          var y = this._startDe;
          do
            y.getEdge().setInResult(!0), y = y.getNext();
          while (y !== this._startDe);
        } }, { key: "containsPoint", value: function(y) {
          var o = this.getLinearRing();
          if (!o.getEnvelopeInternal().contains(y) || !Lo.isInRing(y, o.getCoordinates())) return !1;
          for (var h = this._holes.iterator(); h.hasNext(); )
            if (h.next().containsPoint(y)) return !1;
          return !0;
        } }, { key: "addHole", value: function(y) {
          this._holes.add(y);
        } }, { key: "isShell", value: function() {
          return this._shell === null;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "getMaxNodeDegree", value: function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        } }, { key: "getShell", value: function() {
          return this._shell;
        } }, { key: "mergeLabel", value: function() {
          if (arguments.length === 1) {
            var y = arguments[0];
            this.mergeLabel(y, 0), this.mergeLabel(y, 1);
          } else if (arguments.length === 2) {
            var o = arguments[1], h = arguments[0].getLocation(o, Mt.RIGHT);
            if (h === Me.NONE) return null;
            if (this._label.getLocation(o) === Me.NONE) return this._label.setLocation(o, h), null;
          }
        } }, { key: "setShell", value: function(y) {
          this._shell = y, y !== null && y.addHole(this);
        } }, { key: "toPolygon", value: function(y) {
          for (var o = new Array(this._holes.size()).fill(null), h = 0; h < this._holes.size(); h++) o[h] = this._holes.get(h).getLinearRing();
          return y.createPolygon(this.getLinearRing(), o);
        } }], [{ key: "constructor_", value: function() {
          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new me(), this._pts = new me(), this._label = new ki(Me.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new me(), this._geometryFactory = null, arguments.length !== 0 && arguments.length === 2) {
            var y = arguments[0], o = arguments[1];
            this._geometryFactory = o, this.computePoints(y), this.computeRing();
          }
        } }]);
      })(), ai = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "setEdgeRing", value: function(h, _) {
          h.setMinEdgeRing(_);
        } }, { key: "getNext", value: function(h) {
          return h.getNextMin();
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          Xn.constructor_.call(this, h, _);
        } }]);
      })(Xn), tn = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "buildMinimalRings", value: function() {
          var h = new me(), _ = this._startDe;
          do {
            if (_.getMinEdgeRing() === null) {
              var I = new ai(_, this._geometryFactory);
              h.add(I);
            }
            _ = _.getNext();
          } while (_ !== this._startDe);
          return h;
        } }, { key: "setEdgeRing", value: function(h, _) {
          h.setEdgeRing(_);
        } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
          var h = this._startDe;
          do
            h.getNode().getEdges().linkMinimalDirectedEdges(this), h = h.getNext();
          while (h !== this._startDe);
        } }, { key: "getNext", value: function(h) {
          return h.getNext();
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          Xn.constructor_.call(this, h, _);
        } }]);
      })(Xn), Kt = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "setVisited", value: function(y) {
          this._isVisited = y;
        } }, { key: "setInResult", value: function(y) {
          this._isInResult = y;
        } }, { key: "isCovered", value: function() {
          return this._isCovered;
        } }, { key: "isCoveredSet", value: function() {
          return this._isCoveredSet;
        } }, { key: "setLabel", value: function(y) {
          this._label = y;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "setCovered", value: function(y) {
          this._isCovered = y, this._isCoveredSet = !0;
        } }, { key: "updateIM", value: function(y) {
          At.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(y);
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0 && arguments.length === 1) {
            var y = arguments[0];
            this._label = y;
          }
        } }]);
      })(), Ar = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "isIncidentEdgeInResult", value: function() {
          for (var h = this.getEdges().getEdges().iterator(); h.hasNext(); )
            if (h.next().getEdge().isInResult()) return !0;
          return !1;
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "getCoordinate", value: function() {
          return this._coord;
        } }, { key: "print", value: function(h) {
          h.println("node " + this._coord + " lbl: " + this._label);
        } }, { key: "computeIM", value: function(h) {
        } }, { key: "computeMergedLocation", value: function(h, _) {
          var I = Me.NONE;
          if (I = this._label.getLocation(_), !h.isNull(_)) {
            var D = h.getLocation(_);
            I !== Me.BOUNDARY && (I = D);
          }
          return I;
        } }, { key: "setLabel", value: function() {
          if (arguments.length !== 2 || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return ce(o, "setLabel", this, 1).apply(this, arguments);
          var h = arguments[0], _ = arguments[1];
          this._label === null ? this._label = new ki(h, _) : this._label.setLocation(h, _);
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "mergeLabel", value: function() {
          if (arguments[0] instanceof o) {
            var h = arguments[0];
            this.mergeLabel(h._label);
          } else if (arguments[0] instanceof ki) for (var _ = arguments[0], I = 0; I < 2; I++) {
            var D = this.computeMergedLocation(_, I);
            this._label.getLocation(I) === Me.NONE && this._label.setLocation(I, D);
          }
        } }, { key: "add", value: function(h) {
          this._edges.insert(h), h.setNode(this);
        } }, { key: "setLabelBoundary", value: function(h) {
          if (this._label === null) return null;
          var _ = Me.NONE;
          this._label !== null && (_ = this._label.getLocation(h));
          var I = null;
          switch (_) {
            case Me.BOUNDARY:
              I = Me.INTERIOR;
              break;
            case Me.INTERIOR:
            default:
              I = Me.BOUNDARY;
          }
          this._label.setLocation(h, I);
        } }], [{ key: "constructor_", value: function() {
          this._coord = null, this._edges = null;
          var h = arguments[0], _ = arguments[1];
          this._coord = h, this._edges = _, this._label = new ki(0, Me.NONE);
        } }]);
      })(Kt), ta = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o);
      })(Er);
      function oi(y) {
        return y == null ? 0 : y.color;
      }
      function hr(y) {
        return y == null ? null : y.parent;
      }
      function rn(y, o) {
        y !== null && (y.color = o);
      }
      function ra(y) {
        return y == null ? null : y.left;
      }
      function Os(y) {
        return y == null ? null : y.right;
      }
      var qr = (function(y) {
        function o() {
          var h;
          return x(this, o), (h = p(this, o)).root_ = null, h.size_ = 0, h;
        }
        return $(o, y), u(o, [{ key: "get", value: function(h) {
          for (var _ = this.root_; _ !== null; ) {
            var I = h.compareTo(_.key);
            if (I < 0) _ = _.left;
            else {
              if (!(I > 0)) return _.value;
              _ = _.right;
            }
          }
          return null;
        } }, { key: "put", value: function(h, _) {
          if (this.root_ === null) return this.root_ = { key: h, value: _, left: null, right: null, parent: null, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
          var I, D, B = this.root_;
          do
            if (I = B, (D = h.compareTo(B.key)) < 0) B = B.left;
            else {
              if (!(D > 0)) {
                var W = B.value;
                return B.value = _, W;
              }
              B = B.right;
            }
          while (B !== null);
          var oe = { key: h, left: null, right: null, value: _, parent: I, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return D < 0 ? I.left = oe : I.right = oe, this.fixAfterInsertion(oe), this.size_++, null;
        } }, { key: "fixAfterInsertion", value: function(h) {
          var _;
          for (h.color = 1; h != null && h !== this.root_ && h.parent.color === 1; ) hr(h) === ra(hr(hr(h))) ? oi(_ = Os(hr(hr(h)))) === 1 ? (rn(hr(h), 0), rn(_, 0), rn(hr(hr(h)), 1), h = hr(hr(h))) : (h === Os(hr(h)) && (h = hr(h), this.rotateLeft(h)), rn(hr(h), 0), rn(hr(hr(h)), 1), this.rotateRight(hr(hr(h)))) : oi(_ = ra(hr(hr(h)))) === 1 ? (rn(hr(h), 0), rn(_, 0), rn(hr(hr(h)), 1), h = hr(hr(h))) : (h === ra(hr(h)) && (h = hr(h), this.rotateRight(h)), rn(hr(h), 0), rn(hr(hr(h)), 1), this.rotateLeft(hr(hr(h))));
          this.root_.color = 0;
        } }, { key: "values", value: function() {
          var h = new me(), _ = this.getFirstEntry();
          if (_ !== null) for (h.add(_.value); (_ = o.successor(_)) !== null; ) h.add(_.value);
          return h;
        } }, { key: "entrySet", value: function() {
          var h = new Dr(), _ = this.getFirstEntry();
          if (_ !== null) for (h.add(_); (_ = o.successor(_)) !== null; ) h.add(_);
          return h;
        } }, { key: "rotateLeft", value: function(h) {
          if (h != null) {
            var _ = h.right;
            h.right = _.left, _.left != null && (_.left.parent = h), _.parent = h.parent, h.parent == null ? this.root_ = _ : h.parent.left === h ? h.parent.left = _ : h.parent.right = _, _.left = h, h.parent = _;
          }
        } }, { key: "rotateRight", value: function(h) {
          if (h != null) {
            var _ = h.left;
            h.left = _.right, _.right != null && (_.right.parent = h), _.parent = h.parent, h.parent == null ? this.root_ = _ : h.parent.right === h ? h.parent.right = _ : h.parent.left = _, _.right = h, h.parent = _;
          }
        } }, { key: "getFirstEntry", value: function() {
          var h = this.root_;
          if (h != null) for (; h.left != null; ) h = h.left;
          return h;
        } }, { key: "size", value: function() {
          return this.size_;
        } }, { key: "containsKey", value: function(h) {
          for (var _ = this.root_; _ !== null; ) {
            var I = h.compareTo(_.key);
            if (I < 0) _ = _.left;
            else {
              if (!(I > 0)) return !0;
              _ = _.right;
            }
          }
          return !1;
        } }], [{ key: "successor", value: function(h) {
          var _;
          if (h === null) return null;
          if (h.right !== null) {
            for (_ = h.right; _.left !== null; ) _ = _.left;
            return _;
          }
          _ = h.parent;
          for (var I = h; _ !== null && I === _.right; ) I = _, _ = _.parent;
          return _;
        } }]);
      })(ta), na = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "find", value: function(y) {
          return this.nodeMap.get(y);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof He) {
            var y = arguments[0], o = this.nodeMap.get(y);
            return o === null && (o = this.nodeFact.createNode(y), this.nodeMap.put(y, o)), o;
          }
          if (arguments[0] instanceof Ar) {
            var h = arguments[0], _ = this.nodeMap.get(h.getCoordinate());
            return _ === null ? (this.nodeMap.put(h.getCoordinate(), h), h) : (_.mergeLabel(h), _);
          }
        } }, { key: "print", value: function(y) {
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "iterator", value: function() {
          return this.nodeMap.values().iterator();
        } }, { key: "values", value: function() {
          return this.nodeMap.values();
        } }, { key: "getBoundaryNodes", value: function(y) {
          for (var o = new me(), h = this.iterator(); h.hasNext(); ) {
            var _ = h.next();
            _.getLabel().getLocation(y) === Me.BOUNDARY && o.add(_);
          }
          return o;
        } }, { key: "add", value: function(y) {
          var o = y.getCoordinate();
          this.addNode(o).add(y);
        } }], [{ key: "constructor_", value: function() {
          this.nodeMap = new qr(), this.nodeFact = null;
          var y = arguments[0];
          this.nodeFact = y;
        } }]);
      })(), nn = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "isNorthern", value: function(o) {
          return o === y.NE || o === y.NW;
        } }, { key: "isOpposite", value: function(o, h) {
          return o !== h && (o - h + 4) % 4 === 2;
        } }, { key: "commonHalfPlane", value: function(o, h) {
          if (o === h) return o;
          if ((o - h + 4) % 4 === 2) return -1;
          var _ = o < h ? o : h;
          return _ === 0 && (o > h ? o : h) === 3 ? 3 : _;
        } }, { key: "isInHalfPlane", value: function(o, h) {
          return h === y.SE ? o === y.SE || o === y.SW : o === h || o === h + 1;
        } }, { key: "quadrant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1];
            if (o === 0 && h === 0) throw new et("Cannot compute the quadrant for point ( " + o + ", " + h + " )");
            return o >= 0 ? h >= 0 ? y.NE : y.SE : h >= 0 ? y.NW : y.SW;
          }
          if (arguments[0] instanceof He && arguments[1] instanceof He) {
            var _ = arguments[0], I = arguments[1];
            if (I.x === _.x && I.y === _.y) throw new et("Cannot compute the quadrant for two identical points " + _);
            return I.x >= _.x ? I.y >= _.y ? y.NE : y.SE : I.y >= _.y ? y.NW : y.SW;
          }
        } }]);
      })();
      nn.NE = 0, nn.NW = 1, nn.SW = 2, nn.SE = 3;
      var Do = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "compareDirection", value: function(o) {
          return this._dx === o._dx && this._dy === o._dy ? 0 : this._quadrant > o._quadrant ? 1 : this._quadrant < o._quadrant ? -1 : H.index(o._p0, o._p1, this._p1);
        } }, { key: "getDy", value: function() {
          return this._dy;
        } }, { key: "getCoordinate", value: function() {
          return this._p0;
        } }, { key: "setNode", value: function(o) {
          this._node = o;
        } }, { key: "print", value: function(o) {
          var h = Math.atan2(this._dy, this._dx), _ = this.getClass().getName(), I = _.lastIndexOf("."), D = _.substring(I + 1);
          o.print("  " + D + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + h + "   " + this._label);
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this.compareDirection(h);
        } }, { key: "getDirectedCoordinate", value: function() {
          return this._p1;
        } }, { key: "getDx", value: function() {
          return this._dx;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "getQuadrant", value: function() {
          return this._quadrant;
        } }, { key: "getNode", value: function() {
          return this._node;
        } }, { key: "toString", value: function() {
          var o = Math.atan2(this._dy, this._dx), h = this.getClass().getName(), _ = h.lastIndexOf(".");
          return "  " + h.substring(_ + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + o + "   " + this._label;
        } }, { key: "computeLabel", value: function(o) {
        } }, { key: "init", value: function(o, h) {
          this._p0 = o, this._p1 = h, this._dx = h.x - o.x, this._dy = h.y - o.y, this._quadrant = nn.quadrant(this._dx, this._dy), At.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
            var o = arguments[0];
            this._edge = o;
          } else if (arguments.length === 3) {
            var h = arguments[0], _ = arguments[1], I = arguments[2];
            y.constructor_.call(this, h, _, I, null);
          } else if (arguments.length === 4) {
            var D = arguments[0], B = arguments[1], W = arguments[2], oe = arguments[3];
            y.constructor_.call(this, D), this.init(B, W), this._label = oe;
          }
        } }]);
      })(), li = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getNextMin", value: function() {
          return this._nextMin;
        } }, { key: "getDepth", value: function(h) {
          return this._depth[h];
        } }, { key: "setVisited", value: function(h) {
          this._isVisited = h;
        } }, { key: "computeDirectedLabel", value: function() {
          this._label = new ki(this._edge.getLabel()), this._isForward || this._label.flip();
        } }, { key: "getNext", value: function() {
          return this._next;
        } }, { key: "setDepth", value: function(h, _) {
          if (this._depth[h] !== -999 && this._depth[h] !== _) throw new re("assigned depths do not match", this.getCoordinate());
          this._depth[h] = _;
        } }, { key: "isInteriorAreaEdge", value: function() {
          for (var h = !0, _ = 0; _ < 2; _++) this._label.isArea(_) && this._label.getLocation(_, Mt.LEFT) === Me.INTERIOR && this._label.getLocation(_, Mt.RIGHT) === Me.INTERIOR || (h = !1);
          return h;
        } }, { key: "setNextMin", value: function(h) {
          this._nextMin = h;
        } }, { key: "print", value: function(h) {
          ce(o, "print", this, 1).call(this, h), h.print(" " + this._depth[Mt.LEFT] + "/" + this._depth[Mt.RIGHT]), h.print(" (" + this.getDepthDelta() + ")"), this._isInResult && h.print(" inResult");
        } }, { key: "setMinEdgeRing", value: function(h) {
          this._minEdgeRing = h;
        } }, { key: "isLineEdge", value: function() {
          var h = this._label.isLine(0) || this._label.isLine(1), _ = !this._label.isArea(0) || this._label.allPositionsEqual(0, Me.EXTERIOR), I = !this._label.isArea(1) || this._label.allPositionsEqual(1, Me.EXTERIOR);
          return h && _ && I;
        } }, { key: "setEdgeRing", value: function(h) {
          this._edgeRing = h;
        } }, { key: "getMinEdgeRing", value: function() {
          return this._minEdgeRing;
        } }, { key: "getDepthDelta", value: function() {
          var h = this._edge.getDepthDelta();
          return this._isForward || (h = -h), h;
        } }, { key: "setInResult", value: function(h) {
          this._isInResult = h;
        } }, { key: "getSym", value: function() {
          return this._sym;
        } }, { key: "isForward", value: function() {
          return this._isForward;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "printEdge", value: function(h) {
          this.print(h), h.print(" "), this._isForward ? this._edge.print(h) : this._edge.printReverse(h);
        } }, { key: "setSym", value: function(h) {
          this._sym = h;
        } }, { key: "setVisitedEdge", value: function(h) {
          this.setVisited(h), this._sym.setVisited(h);
        } }, { key: "setEdgeDepths", value: function(h, _) {
          var I = this.getEdge().getDepthDelta();
          this._isForward || (I = -I);
          var D = 1;
          h === Mt.LEFT && (D = -1);
          var B = Mt.opposite(h), W = _ + I * D;
          this.setDepth(h, _), this.setDepth(B, W);
        } }, { key: "getEdgeRing", value: function() {
          return this._edgeRing;
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "setNext", value: function(h) {
          this._next = h;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
          var h = arguments[0], _ = arguments[1];
          if (Do.constructor_.call(this, h), this._isForward = _, _) this.init(h.getCoordinate(0), h.getCoordinate(1));
          else {
            var I = h.getNumPoints() - 1;
            this.init(h.getCoordinate(I), h.getCoordinate(I - 1));
          }
          this.computeDirectedLabel();
        } }, { key: "depthFactor", value: function(h, _) {
          return h === Me.EXTERIOR && _ === Me.INTERIOR ? 1 : h === Me.INTERIOR && _ === Me.EXTERIOR ? -1 : 0;
        } }]);
      })(Do), ia = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "createNode", value: function(y) {
          return new Ar(y, null);
        } }]);
      })(), ws = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "printEdges", value: function(y) {
          y.println("Edges:");
          for (var o = 0; o < this._edges.size(); o++) {
            y.println("edge " + o + ":");
            var h = this._edges.get(o);
            h.print(y), h.eiList.print(y);
          }
        } }, { key: "find", value: function(y) {
          return this._nodes.find(y);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof Ar) {
            var y = arguments[0];
            return this._nodes.addNode(y);
          }
          if (arguments[0] instanceof He) {
            var o = arguments[0];
            return this._nodes.addNode(o);
          }
        } }, { key: "getNodeIterator", value: function() {
          return this._nodes.iterator();
        } }, { key: "linkResultDirectedEdges", value: function() {
          for (var y = this._nodes.iterator(); y.hasNext(); )
            y.next().getEdges().linkResultDirectedEdges();
        } }, { key: "debugPrintln", value: function(y) {
          $e.out.println(y);
        } }, { key: "isBoundaryNode", value: function(y, o) {
          var h = this._nodes.find(o);
          if (h === null) return !1;
          var _ = h.getLabel();
          return _ !== null && _.getLocation(y) === Me.BOUNDARY;
        } }, { key: "linkAllDirectedEdges", value: function() {
          for (var y = this._nodes.iterator(); y.hasNext(); )
            y.next().getEdges().linkAllDirectedEdges();
        } }, { key: "matchInSameDirection", value: function(y, o, h, _) {
          return !!y.equals(h) && H.index(y, o, _) === H.COLLINEAR && nn.quadrant(y, o) === nn.quadrant(h, _);
        } }, { key: "getEdgeEnds", value: function() {
          return this._edgeEndList;
        } }, { key: "debugPrint", value: function(y) {
          $e.out.print(y);
        } }, { key: "getEdgeIterator", value: function() {
          return this._edges.iterator();
        } }, { key: "findEdgeInSameDirection", value: function(y, o) {
          for (var h = 0; h < this._edges.size(); h++) {
            var _ = this._edges.get(h), I = _.getCoordinates();
            if (this.matchInSameDirection(y, o, I[0], I[1]) || this.matchInSameDirection(y, o, I[I.length - 1], I[I.length - 2])) return _;
          }
          return null;
        } }, { key: "insertEdge", value: function(y) {
          this._edges.add(y);
        } }, { key: "findEdgeEnd", value: function(y) {
          for (var o = this.getEdgeEnds().iterator(); o.hasNext(); ) {
            var h = o.next();
            if (h.getEdge() === y) return h;
          }
          return null;
        } }, { key: "addEdges", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next();
            this._edges.add(h);
            var _ = new li(h, !0), I = new li(h, !1);
            _.setSym(I), I.setSym(_), this.add(_), this.add(I);
          }
        } }, { key: "add", value: function(y) {
          this._nodes.add(y), this._edgeEndList.add(y);
        } }, { key: "getNodes", value: function() {
          return this._nodes.values();
        } }, { key: "findEdge", value: function(y, o) {
          for (var h = 0; h < this._edges.size(); h++) {
            var _ = this._edges.get(h), I = _.getCoordinates();
            if (y.equals(I[0]) && o.equals(I[1])) return _;
          }
          return null;
        } }], [{ key: "constructor_", value: function() {
          if (this._edges = new me(), this._nodes = null, this._edgeEndList = new me(), arguments.length === 0) this._nodes = new na(new ia());
          else if (arguments.length === 1) {
            var y = arguments[0];
            this._nodes = new na(y);
          }
        } }, { key: "linkResultDirectedEdges", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); )
            o.next().getEdges().linkResultDirectedEdges();
        } }]);
      })(), Sc = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "sortShellsAndHoles", value: function(o, h, _) {
          for (var I = o.iterator(); I.hasNext(); ) {
            var D = I.next();
            D.isHole() ? _.add(D) : h.add(D);
          }
        } }, { key: "computePolygons", value: function(o) {
          for (var h = new me(), _ = o.iterator(); _.hasNext(); ) {
            var I = _.next().toPolygon(this._geometryFactory);
            h.add(I);
          }
          return h;
        } }, { key: "placeFreeHoles", value: function(o, h) {
          for (var _ = h.iterator(); _.hasNext(); ) {
            var I = _.next();
            if (I.getShell() === null) {
              var D = y.findEdgeRingContaining(I, o);
              if (D === null) throw new re("unable to assign hole to a shell", I.getCoordinate(0));
              I.setShell(D);
            }
          }
        } }, { key: "buildMinimalEdgeRings", value: function(o, h, _) {
          for (var I = new me(), D = o.iterator(); D.hasNext(); ) {
            var B = D.next();
            if (B.getMaxNodeDegree() > 2) {
              B.linkDirectedEdgesForMinimalEdgeRings();
              var W = B.buildMinimalRings(), oe = this.findShell(W);
              oe !== null ? (this.placePolygonHoles(oe, W), h.add(oe)) : _.addAll(W);
            } else I.add(B);
          }
          return I;
        } }, { key: "buildMaximalEdgeRings", value: function(o) {
          for (var h = new me(), _ = o.iterator(); _.hasNext(); ) {
            var I = _.next();
            if (I.isInResult() && I.getLabel().isArea() && I.getEdgeRing() === null) {
              var D = new tn(I, this._geometryFactory);
              h.add(D), D.setInResult();
            }
          }
          return h;
        } }, { key: "placePolygonHoles", value: function(o, h) {
          for (var _ = h.iterator(); _.hasNext(); ) {
            var I = _.next();
            I.isHole() && I.setShell(o);
          }
        } }, { key: "getPolygons", value: function() {
          return this.computePolygons(this._shellList);
        } }, { key: "findShell", value: function(o) {
          for (var h = 0, _ = null, I = o.iterator(); I.hasNext(); ) {
            var D = I.next();
            D.isHole() || (_ = D, h++);
          }
          return At.isTrue(h <= 1, "found two shells in MinimalEdgeRing list"), _;
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.add(o.getEdgeEnds(), o.getNodes());
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            ws.linkResultDirectedEdges(_);
            var I = this.buildMaximalEdgeRings(h), D = new me(), B = this.buildMinimalEdgeRings(I, this._shellList, D);
            this.sortShellsAndHoles(B, this._shellList, D), this.placeFreeHoles(this._shellList, D);
          }
        } }], [{ key: "constructor_", value: function() {
          this._geometryFactory = null, this._shellList = new me();
          var o = arguments[0];
          this._geometryFactory = o;
        } }, { key: "findEdgeRingContaining", value: function(o, h) {
          for (var _ = o.getLinearRing(), I = _.getEnvelopeInternal(), D = _.getCoordinateN(0), B = null, W = null, oe = h.iterator(); oe.hasNext(); ) {
            var de = oe.next(), Ze = de.getLinearRing(), rt = Ze.getEnvelopeInternal();
            if (!rt.equals(I) && rt.contains(I)) {
              D = wt.ptNotInList(_.getCoordinates(), Ze.getCoordinates());
              var xt = !1;
              Lo.isInRing(D, Ze.getCoordinates()) && (xt = !0), xt && (B === null || W.contains(rt)) && (W = (B = de).getLinearRing().getEnvelopeInternal());
            }
          }
          return B;
        } }]);
      })(), xl = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "getBounds", value: function() {
        } }]);
      })(), vi = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getItem", value: function() {
          return this._item;
        } }, { key: "getBounds", value: function() {
          return this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [xl, se];
        } }], [{ key: "constructor_", value: function() {
          this._bounds = null, this._item = null;
          var y = arguments[0], o = arguments[1];
          this._bounds = y, this._item = o;
        } }]);
      })(), Lr = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "poll", value: function() {
          if (this.isEmpty()) return null;
          var y = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), y;
        } }, { key: "size", value: function() {
          return this._size;
        } }, { key: "reorder", value: function(y) {
          for (var o = null, h = this._items.get(y); 2 * y <= this._size && ((o = 2 * y) !== this._size && this._items.get(o + 1).compareTo(this._items.get(o)) < 0 && o++, this._items.get(o).compareTo(h) < 0); y = o) this._items.set(y, this._items.get(o));
          this._items.set(y, h);
        } }, { key: "clear", value: function() {
          this._size = 0, this._items.clear();
        } }, { key: "peek", value: function() {
          return this.isEmpty() ? null : this._items.get(1);
        } }, { key: "isEmpty", value: function() {
          return this._size === 0;
        } }, { key: "add", value: function(y) {
          this._items.add(null), this._size += 1;
          var o = this._size;
          for (this._items.set(0, y); y.compareTo(this._items.get(Math.trunc(o / 2))) < 0; o /= 2) this._items.set(o, this._items.get(Math.trunc(o / 2)));
          this._items.set(o, y);
        } }], [{ key: "constructor_", value: function() {
          this._size = null, this._items = null, this._size = 0, this._items = new me(), this._items.add(null);
        } }]);
      })(), Qa = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "insert", value: function(y, o) {
        } }, { key: "remove", value: function(y, o) {
        } }, { key: "query", value: function() {
        } }]);
      })(), ar = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getLevel", value: function() {
          return this._level;
        } }, { key: "size", value: function() {
          return this._childBoundables.size();
        } }, { key: "getChildBoundables", value: function() {
          return this._childBoundables;
        } }, { key: "addChildBoundable", value: function(y) {
          At.isTrue(this._bounds === null), this._childBoundables.add(y);
        } }, { key: "isEmpty", value: function() {
          return this._childBoundables.isEmpty();
        } }, { key: "getBounds", value: function() {
          return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [xl, se];
        } }], [{ key: "constructor_", value: function() {
          if (this._childBoundables = new me(), this._bounds = null, this._level = null, arguments.length !== 0 && arguments.length === 1) {
            var y = arguments[0];
            this._level = y;
          }
        } }]);
      })(), sr = { reverseOrder: function() {
        return { compare: function(y, o) {
          return o.compareTo(y);
        } };
      }, min: function(y) {
        return sr.sort(y), y.get(0);
      }, sort: function(y, o) {
        var h = y.toArray();
        o ? Ir.sort(h, o) : Ir.sort(h);
        for (var _ = y.iterator(), I = 0, D = h.length; I < D; I++) _.next(), _.set(h[I]);
      }, singletonList: function(y) {
        var o = new me();
        return o.add(y), o;
      } }, eo = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "maxDistance", value: function(o, h, _, I, D, B, W, oe) {
          var de = y.distance(o, h, D, B);
          return de = Math.max(de, y.distance(o, h, W, oe)), de = Math.max(de, y.distance(_, I, D, B)), de = Math.max(de, y.distance(_, I, W, oe));
        } }, { key: "distance", value: function(o, h, _, I) {
          var D = _ - o, B = I - h;
          return Math.sqrt(D * D + B * B);
        } }, { key: "maximumDistance", value: function(o, h) {
          var _ = Math.min(o.getMinX(), h.getMinX()), I = Math.min(o.getMinY(), h.getMinY()), D = Math.max(o.getMaxX(), h.getMaxX()), B = Math.max(o.getMaxY(), h.getMaxY());
          return y.distance(_, I, D, B);
        } }, { key: "minMaxDistance", value: function(o, h) {
          var _ = o.getMinX(), I = o.getMinY(), D = o.getMaxX(), B = o.getMaxY(), W = h.getMinX(), oe = h.getMinY(), de = h.getMaxX(), Ze = h.getMaxY(), rt = y.maxDistance(_, I, _, B, W, oe, W, Ze);
          return rt = Math.min(rt, y.maxDistance(_, I, _, B, W, oe, de, oe)), rt = Math.min(rt, y.maxDistance(_, I, _, B, de, Ze, W, Ze)), rt = Math.min(rt, y.maxDistance(_, I, _, B, de, Ze, de, oe)), rt = Math.min(rt, y.maxDistance(_, I, D, I, W, oe, W, Ze)), rt = Math.min(rt, y.maxDistance(_, I, D, I, W, oe, de, oe)), rt = Math.min(rt, y.maxDistance(_, I, D, I, de, Ze, W, Ze)), rt = Math.min(rt, y.maxDistance(_, I, D, I, de, Ze, de, oe)), rt = Math.min(rt, y.maxDistance(D, B, _, B, W, oe, W, Ze)), rt = Math.min(rt, y.maxDistance(D, B, _, B, W, oe, de, oe)), rt = Math.min(rt, y.maxDistance(D, B, _, B, de, Ze, W, Ze)), rt = Math.min(rt, y.maxDistance(D, B, _, B, de, Ze, de, oe)), rt = Math.min(rt, y.maxDistance(D, B, D, I, W, oe, W, Ze)), rt = Math.min(rt, y.maxDistance(D, B, D, I, W, oe, de, oe)), rt = Math.min(rt, y.maxDistance(D, B, D, I, de, Ze, W, Ze)), rt = Math.min(rt, y.maxDistance(D, B, D, I, de, Ze, de, oe));
        } }]);
      })(), pr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "maximumDistance", value: function() {
          return eo.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
        } }, { key: "expandToQueue", value: function(o, h) {
          var _ = y.isComposite(this._boundable1), I = y.isComposite(this._boundable2);
          if (_ && I) return y.area(this._boundable1) > y.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, o, h), null) : (this.expand(this._boundable2, this._boundable1, !0, o, h), null);
          if (_) return this.expand(this._boundable1, this._boundable2, !1, o, h), null;
          if (I) return this.expand(this._boundable2, this._boundable1, !0, o, h), null;
          throw new et("neither boundable is composite");
        } }, { key: "isLeaves", value: function() {
          return !(y.isComposite(this._boundable1) || y.isComposite(this._boundable2));
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this._distance < h._distance ? -1 : this._distance > h._distance ? 1 : 0;
        } }, { key: "expand", value: function(o, h, _, I, D) {
          for (var B = o.getChildBoundables().iterator(); B.hasNext(); ) {
            var W = B.next(), oe = null;
            (oe = _ ? new y(h, W, this._itemDistance) : new y(W, h, this._itemDistance)).getDistance() < D && I.add(oe);
          }
        } }, { key: "getBoundable", value: function(o) {
          return o === 0 ? this._boundable1 : this._boundable2;
        } }, { key: "getDistance", value: function() {
          return this._distance;
        } }, { key: "distance", value: function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          this._boundable1 = o, this._boundable2 = h, this._itemDistance = _, this._distance = this.distance();
        } }, { key: "area", value: function(o) {
          return o.getBounds().getArea();
        } }, { key: "isComposite", value: function(o) {
          return o instanceof ar;
        } }]);
      })(), to = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "visitItem", value: function(y) {
        } }]);
      })(), Jn = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "queryInternal", value: function() {
          if (tr(arguments[2], to) && arguments[0] instanceof Object && arguments[1] instanceof ar) for (var o = arguments[0], h = arguments[2], _ = arguments[1].getChildBoundables(), I = 0; I < _.size(); I++) {
            var D = _.get(I);
            this.getIntersectsOp().intersects(D.getBounds(), o) && (D instanceof ar ? this.queryInternal(o, D, h) : D instanceof vi ? h.visitItem(D.getItem()) : At.shouldNeverReachHere());
          }
          else if (tr(arguments[2], jn) && arguments[0] instanceof Object && arguments[1] instanceof ar) for (var B = arguments[0], W = arguments[2], oe = arguments[1].getChildBoundables(), de = 0; de < oe.size(); de++) {
            var Ze = oe.get(de);
            this.getIntersectsOp().intersects(Ze.getBounds(), B) && (Ze instanceof ar ? this.queryInternal(B, Ze, W) : Ze instanceof vi ? W.add(Ze.getItem()) : At.shouldNeverReachHere());
          }
        } }, { key: "getNodeCapacity", value: function() {
          return this._nodeCapacity;
        } }, { key: "lastNode", value: function(o) {
          return o.get(o.size() - 1);
        } }, { key: "size", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (arguments.length === 1) {
            for (var o = 0, h = arguments[0].getChildBoundables().iterator(); h.hasNext(); ) {
              var _ = h.next();
              _ instanceof ar ? o += this.size(_) : _ instanceof vi && (o += 1);
            }
            return o;
          }
        } }, { key: "removeItem", value: function(o, h) {
          for (var _ = null, I = o.getChildBoundables().iterator(); I.hasNext(); ) {
            var D = I.next();
            D instanceof vi && D.getItem() === h && (_ = D);
          }
          return _ !== null && (o.getChildBoundables().remove(_), !0);
        } }, { key: "itemsTree", value: function() {
          if (arguments.length === 0) {
            this.build();
            var o = this.itemsTree(this._root);
            return o === null ? new me() : o;
          }
          if (arguments.length === 1) {
            for (var h = arguments[0], _ = new me(), I = h.getChildBoundables().iterator(); I.hasNext(); ) {
              var D = I.next();
              if (D instanceof ar) {
                var B = this.itemsTree(D);
                B !== null && _.add(B);
              } else D instanceof vi ? _.add(D.getItem()) : At.shouldNeverReachHere();
            }
            return _.size() <= 0 ? null : _;
          }
        } }, { key: "insert", value: function(o, h) {
          At.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new vi(o, h));
        } }, { key: "boundablesAtLevel", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0], h = new me();
            return this.boundablesAtLevel(o, this._root, h), h;
          }
          if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2];
            if (At.isTrue(_ > -2), I.getLevel() === _) return D.add(I), null;
            for (var B = I.getChildBoundables().iterator(); B.hasNext(); ) {
              var W = B.next();
              W instanceof ar ? this.boundablesAtLevel(_, W, D) : (At.isTrue(W instanceof vi), _ === -1 && D.add(W));
            }
            return null;
          }
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.build();
            var h = new me();
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), o) && this.queryInternal(o, this._root, h), h;
          }
          if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), _) && this.queryInternal(_, this._root, I);
          }
        } }, { key: "build", value: function() {
          if (this._built) return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
        } }, { key: "getRoot", value: function() {
          return this.build(), this._root;
        } }, { key: "remove", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), o) && this.remove(o, this._root, h);
          }
          if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2], B = this.removeItem(I, D);
            if (B) return !0;
            for (var W = null, oe = I.getChildBoundables().iterator(); oe.hasNext(); ) {
              var de = oe.next();
              if (this.getIntersectsOp().intersects(de.getBounds(), _) && de instanceof ar && (B = this.remove(_, de, D))) {
                W = de;
                break;
              }
            }
            return W !== null && W.getChildBoundables().isEmpty() && I.getChildBoundables().remove(W), B;
          }
        } }, { key: "createHigherLevels", value: function(o, h) {
          At.isTrue(!o.isEmpty());
          var _ = this.createParentBoundables(o, h + 1);
          return _.size() === 1 ? _.get(0) : this.createHigherLevels(_, h + 1);
        } }, { key: "depth", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (arguments.length === 1) {
            for (var o = 0, h = arguments[0].getChildBoundables().iterator(); h.hasNext(); ) {
              var _ = h.next();
              if (_ instanceof ar) {
                var I = this.depth(_);
                I > o && (o = I);
              }
            }
            return o + 1;
          }
        } }, { key: "createParentBoundables", value: function(o, h) {
          At.isTrue(!o.isEmpty());
          var _ = new me();
          _.add(this.createNode(h));
          var I = new me(o);
          sr.sort(I, this.getComparator());
          for (var D = I.iterator(); D.hasNext(); ) {
            var B = D.next();
            this.lastNode(_).getChildBoundables().size() === this.getNodeCapacity() && _.add(this.createNode(h)), this.lastNode(_).addChildBoundable(B);
          }
          return _;
        } }, { key: "isEmpty", value: function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        } }, { key: "interfaces_", get: function() {
          return [se];
        } }], [{ key: "constructor_", value: function() {
          if (this._root = null, this._built = !1, this._itemBoundables = new me(), this._nodeCapacity = null, arguments.length === 0) y.constructor_.call(this, y.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var o = arguments[0];
            At.isTrue(o > 1, "Node capacity must be greater than 1"), this._nodeCapacity = o;
          }
        } }, { key: "compareDoubles", value: function(o, h) {
          return o > h ? 1 : o < h ? -1 : 0;
        } }]);
      })();
      Jn.IntersectsOp = function() {
      }, Jn.DEFAULT_NODE_CAPACITY = 10;
      var ro = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "distance", value: function(y, o) {
        } }]);
      })(), Kn = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "createParentBoundablesFromVerticalSlices", value: function(h, _) {
          At.isTrue(h.length > 0);
          for (var I = new me(), D = 0; D < h.length; D++) I.addAll(this.createParentBoundablesFromVerticalSlice(h[D], _));
          return I;
        } }, { key: "nearestNeighbourK", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return this.nearestNeighbourK(h, ft.POSITIVE_INFINITY, _);
          }
          if (arguments.length === 3) {
            var I = arguments[0], D = arguments[2], B = arguments[1], W = new Lr();
            W.add(I);
            for (var oe = new Lr(); !W.isEmpty() && B >= 0; ) {
              var de = W.poll(), Ze = de.getDistance();
              if (Ze >= B) break;
              de.isLeaves() ? oe.size() < D ? oe.add(de) : (oe.peek().getDistance() > Ze && (oe.poll(), oe.add(de)), B = oe.peek().getDistance()) : de.expandToQueue(W, B);
            }
            return o.getItems(oe);
          }
        } }, { key: "createNode", value: function(h) {
          return new fu(h);
        } }, { key: "size", value: function() {
          return arguments.length === 0 ? ce(o, "size", this, 1).call(this) : ce(o, "size", this, 1).apply(this, arguments);
        } }, { key: "insert", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof fr)) return ce(o, "insert", this, 1).apply(this, arguments);
          var h = arguments[0], _ = arguments[1];
          if (h.isNull()) return null;
          ce(o, "insert", this, 1).call(this, h, _);
        } }, { key: "getIntersectsOp", value: function() {
          return o.intersectsOp;
        } }, { key: "verticalSlices", value: function(h, _) {
          for (var I = Math.trunc(Math.ceil(h.size() / _)), D = new Array(_).fill(null), B = h.iterator(), W = 0; W < _; W++) {
            D[W] = new me();
            for (var oe = 0; B.hasNext() && oe < I; ) {
              var de = B.next();
              D[W].add(de), oe++;
            }
          }
          return D;
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return ce(o, "query", this, 1).call(this, h);
          }
          if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            ce(o, "query", this, 1).call(this, _, I);
          }
        } }, { key: "getComparator", value: function() {
          return o.yComparator;
        } }, { key: "createParentBoundablesFromVerticalSlice", value: function(h, _) {
          return ce(o, "createParentBoundables", this, 1).call(this, h, _);
        } }, { key: "remove", value: function() {
          if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof fr) {
            var h = arguments[0], _ = arguments[1];
            return ce(o, "remove", this, 1).call(this, h, _);
          }
          return ce(o, "remove", this, 1).apply(this, arguments);
        } }, { key: "depth", value: function() {
          return arguments.length === 0 ? ce(o, "depth", this, 1).call(this) : ce(o, "depth", this, 1).apply(this, arguments);
        } }, { key: "createParentBoundables", value: function(h, _) {
          At.isTrue(!h.isEmpty());
          var I = Math.trunc(Math.ceil(h.size() / this.getNodeCapacity())), D = new me(h);
          sr.sort(D, o.xComparator);
          var B = this.verticalSlices(D, Math.trunc(Math.ceil(Math.sqrt(I))));
          return this.createParentBoundablesFromVerticalSlices(B, _);
        } }, { key: "nearestNeighbour", value: function() {
          if (arguments.length === 1) {
            if (tr(arguments[0], ro)) {
              var h = arguments[0];
              if (this.isEmpty()) return null;
              var _ = new pr(this.getRoot(), this.getRoot(), h);
              return this.nearestNeighbour(_);
            }
            if (arguments[0] instanceof pr) {
              var I = arguments[0], D = ft.POSITIVE_INFINITY, B = null, W = new Lr();
              for (W.add(I); !W.isEmpty() && D > 0; ) {
                var oe = W.poll(), de = oe.getDistance();
                if (de >= D) break;
                oe.isLeaves() ? (D = de, B = oe) : oe.expandToQueue(W, D);
              }
              return B === null ? null : [B.getBoundable(0).getItem(), B.getBoundable(1).getItem()];
            }
          } else {
            if (arguments.length === 2) {
              var Ze = arguments[0], rt = arguments[1];
              if (this.isEmpty() || Ze.isEmpty()) return null;
              var xt = new pr(this.getRoot(), Ze.getRoot(), rt);
              return this.nearestNeighbour(xt);
            }
            if (arguments.length === 3) {
              var jt = arguments[2], qt = new vi(arguments[0], arguments[1]), Wt = new pr(this.getRoot(), qt, jt);
              return this.nearestNeighbour(Wt)[0];
            }
            if (arguments.length === 4) {
              var _r = arguments[2], lr = arguments[3], Br = new vi(arguments[0], arguments[1]), qn = new pr(this.getRoot(), Br, _r);
              return this.nearestNeighbourK(qn, lr);
            }
          }
        } }, { key: "isWithinDistance", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1], I = ft.POSITIVE_INFINITY, D = new Lr();
            for (D.add(h); !D.isEmpty(); ) {
              var B = D.poll(), W = B.getDistance();
              if (W > _) return !1;
              if (B.maximumDistance() <= _) return !0;
              if (B.isLeaves()) {
                if ((I = W) <= _) return !0;
              } else B.expandToQueue(D, I);
            }
            return !1;
          }
          if (arguments.length === 3) {
            var oe = arguments[0], de = arguments[1], Ze = arguments[2], rt = new pr(this.getRoot(), oe.getRoot(), de);
            return this.isWithinDistance(rt, Ze);
          }
        } }, { key: "interfaces_", get: function() {
          return [Qa, se];
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) o.constructor_.call(this, o.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var h = arguments[0];
            Jn.constructor_.call(this, h);
          }
        } }, { key: "centreX", value: function(h) {
          return o.avg(h.getMinX(), h.getMaxX());
        } }, { key: "avg", value: function(h, _) {
          return (h + _) / 2;
        } }, { key: "getItems", value: function(h) {
          for (var _ = new Array(h.size()).fill(null), I = 0; !h.isEmpty(); ) {
            var D = h.poll();
            _[I] = D.getBoundable(0).getItem(), I++;
          }
          return _;
        } }, { key: "centreY", value: function(h) {
          return o.avg(h.getMinY(), h.getMaxY());
        } }]);
      })(Jn), fu = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeBounds", value: function() {
          for (var h = null, _ = this.getChildBoundables().iterator(); _.hasNext(); ) {
            var I = _.next();
            h === null ? h = new fr(I.getBounds()) : h.expandToInclude(I.getBounds());
          }
          return h;
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0];
          ar.constructor_.call(this, h);
        } }]);
      })(ar);
      Kn.STRtreeNode = fu, Kn.xComparator = new ((function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "interfaces_", get: function() {
          return [Tt];
        } }, { key: "compare", value: function(y, o) {
          return Jn.compareDoubles(Kn.centreX(y.getBounds()), Kn.centreX(o.getBounds()));
        } }]);
      })())(), Kn.yComparator = new ((function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "interfaces_", get: function() {
          return [Tt];
        } }, { key: "compare", value: function(y, o) {
          return Jn.compareDoubles(Kn.centreY(y.getBounds()), Kn.centreY(o.getBounds()));
        } }]);
      })())(), Kn.intersectsOp = new ((function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "interfaces_", get: function() {
          return [IntersectsOp];
        } }, { key: "intersects", value: function(y, o) {
          return y.intersects(o);
        } }]);
      })())(), Kn.DEFAULT_NODE_CAPACITY = 10;
      var Ro = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "relativeSign", value: function(o, h) {
          return o < h ? -1 : o > h ? 1 : 0;
        } }, { key: "compare", value: function(o, h, _) {
          if (h.equals2D(_)) return 0;
          var I = y.relativeSign(h.x, _.x), D = y.relativeSign(h.y, _.y);
          switch (o) {
            case 0:
              return y.compareValue(I, D);
            case 1:
              return y.compareValue(D, I);
            case 2:
              return y.compareValue(D, -I);
            case 3:
              return y.compareValue(-I, D);
            case 4:
              return y.compareValue(-I, -D);
            case 5:
              return y.compareValue(-D, -I);
            case 6:
              return y.compareValue(-D, I);
            case 7:
              return y.compareValue(I, -D);
          }
          return At.shouldNeverReachHere("invalid octant value"), 0;
        } }, { key: "compareValue", value: function(o, h) {
          return o < 0 ? -1 : o > 0 ? 1 : h < 0 ? -1 : h > 0 ? 1 : 0;
        } }]);
      })(), pu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(y) {
          y.print(this.coord), y.print(" seg # = " + this.segmentIndex);
        } }, { key: "compareTo", value: function(y) {
          var o = y;
          return this.segmentIndex < o.segmentIndex ? -1 : this.segmentIndex > o.segmentIndex ? 1 : this.coord.equals2D(o.coord) ? 0 : this._isInterior ? o._isInterior ? Ro.compare(this._segmentOctant, this.coord, o.coord) : 1 : -1;
        } }, { key: "isEndPoint", value: function(y) {
          return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === y;
        } }, { key: "toString", value: function() {
          return this.segmentIndex + ":" + this.coord.toString();
        } }, { key: "isInterior", value: function() {
          return this._isInterior;
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var y = arguments[0], o = arguments[1], h = arguments[2], _ = arguments[3];
          this._segString = y, this.coord = new He(o), this.segmentIndex = h, this._segmentOctant = _, this._isInterior = !o.equals2D(y.getCoordinate(h));
        } }]);
      })(), Kh = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "hasNext", value: function() {
        } }, { key: "next", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      })(), Tc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getSplitCoordinates", value: function() {
          var y = new Gt();
          this.addEndpoints();
          for (var o = this.iterator(), h = o.next(); o.hasNext(); ) {
            var _ = o.next();
            this.addEdgeCoordinates(h, _, y), h = _;
          }
          return y.toCoordinateArray();
        } }, { key: "addCollapsedNodes", value: function() {
          var y = new me();
          this.findCollapsesFromInsertedNodes(y), this.findCollapsesFromExistingVertices(y);
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next().intValue();
            this.add(this._edge.getCoordinate(h), h);
          }
        } }, { key: "createSplitEdgePts", value: function(y, o) {
          var h = o.segmentIndex - y.segmentIndex + 2;
          if (h === 2) return [new He(y.coord), new He(o.coord)];
          var _ = this._edge.getCoordinate(o.segmentIndex), I = o.isInterior() || !o.coord.equals2D(_);
          I || h--;
          var D = new Array(h).fill(null), B = 0;
          D[B++] = new He(y.coord);
          for (var W = y.segmentIndex + 1; W <= o.segmentIndex; W++) D[B++] = this._edge.getCoordinate(W);
          return I && (D[B] = new He(o.coord)), D;
        } }, { key: "print", value: function(y) {
          y.println("Intersections:");
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "findCollapsesFromExistingVertices", value: function(y) {
          for (var o = 0; o < this._edge.size() - 2; o++) {
            var h = this._edge.getCoordinate(o);
            this._edge.getCoordinate(o + 1);
            var _ = this._edge.getCoordinate(o + 2);
            h.equals2D(_) && y.add(Vn.valueOf(o + 1));
          }
        } }, { key: "addEdgeCoordinates", value: function(y, o, h) {
          var _ = this.createSplitEdgePts(y, o);
          h.add(_, !1);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(y) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var o = this.iterator(), h = o.next(); o.hasNext(); ) {
            var _ = o.next(), I = this.createSplitEdge(h, _);
            y.add(I), h = _;
          }
        } }, { key: "findCollapseIndex", value: function(y, o, h) {
          if (!y.coord.equals2D(o.coord)) return !1;
          var _ = o.segmentIndex - y.segmentIndex;
          return o.isInterior() || _--, _ === 1 && (h[0] = y.segmentIndex + 1, !0);
        } }, { key: "findCollapsesFromInsertedNodes", value: function(y) {
          for (var o = new Array(1).fill(null), h = this.iterator(), _ = h.next(); h.hasNext(); ) {
            var I = h.next();
            this.findCollapseIndex(_, I, o) && y.add(Vn.valueOf(o[0])), _ = I;
          }
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "addEndpoints", value: function() {
          var y = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(y), y);
        } }, { key: "createSplitEdge", value: function(y, o) {
          var h = this.createSplitEdgePts(y, o);
          return new ji(h, this._edge.getData());
        } }, { key: "add", value: function(y, o) {
          var h = new pu(this._edge, y, o, this._edge.getSegmentOctant(o)), _ = this._nodeMap.get(h);
          return _ !== null ? (At.isTrue(_.coord.equals2D(y), "Found equal nodes with different coordinates"), _) : (this._nodeMap.put(h, h), h);
        } }, { key: "checkSplitEdgesCorrectness", value: function(y) {
          var o = this._edge.getCoordinates(), h = y.get(0).getCoordinate(0);
          if (!h.equals2D(o[0])) throw new Zt("bad split edge start point at " + h);
          var _ = y.get(y.size() - 1).getCoordinates(), I = _[_.length - 1];
          if (!I.equals2D(o[o.length - 1])) throw new Zt("bad split edge end point at " + I);
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new qr(), this._edge = null;
          var y = arguments[0];
          this._edge = y;
        } }]);
      })(), xi = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "octant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1];
            if (o === 0 && h === 0) throw new et("Cannot compute the octant for point ( " + o + ", " + h + " )");
            var _ = Math.abs(o), I = Math.abs(h);
            return o >= 0 ? h >= 0 ? _ >= I ? 0 : 1 : _ >= I ? 7 : 6 : h >= 0 ? _ >= I ? 3 : 2 : _ >= I ? 4 : 5;
          }
          if (arguments[0] instanceof He && arguments[1] instanceof He) {
            var D = arguments[0], B = arguments[1], W = B.x - D.x, oe = B.y - D.y;
            if (W === 0 && oe === 0) throw new et("Cannot compute the octant for two identical points " + D);
            return y.octant(W, oe);
          }
        } }]);
      })(), Es = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "getCoordinates", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "getCoordinate", value: function(y) {
        } }, { key: "isClosed", value: function() {
        } }, { key: "setData", value: function(y) {
        } }, { key: "getData", value: function() {
        } }]);
      })(), Xr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "addIntersection", value: function(y, o) {
        } }, { key: "interfaces_", get: function() {
          return [Es];
        } }]);
      })(), ji = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getCoordinates", value: function() {
          return this._pts;
        } }, { key: "size", value: function() {
          return this._pts.length;
        } }, { key: "getCoordinate", value: function(o) {
          return this._pts[o];
        } }, { key: "isClosed", value: function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        } }, { key: "getSegmentOctant", value: function(o) {
          return o === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(o), this.getCoordinate(o + 1));
        } }, { key: "setData", value: function(o) {
          this._data = o;
        } }, { key: "safeOctant", value: function(o, h) {
          return o.equals2D(h) ? 0 : xi.octant(o, h);
        } }, { key: "getData", value: function() {
          return this._data;
        } }, { key: "addIntersection", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            this.addIntersectionNode(o, h);
          } else if (arguments.length === 4) {
            var _ = arguments[1], I = arguments[3], D = new He(arguments[0].getIntersection(I));
            this.addIntersection(D, _);
          }
        } }, { key: "toString", value: function() {
          return Ea.toLineString(new Mn(this._pts));
        } }, { key: "getNodeList", value: function() {
          return this._nodeList;
        } }, { key: "addIntersectionNode", value: function(o, h) {
          var _ = h, I = _ + 1;
          if (I < this._pts.length) {
            var D = this._pts[I];
            o.equals2D(D) && (_ = I);
          }
          return this._nodeList.add(o, _);
        } }, { key: "addIntersections", value: function(o, h, _) {
          for (var I = 0; I < o.getIntersectionNum(); I++) this.addIntersection(o, h, _, I);
        } }, { key: "interfaces_", get: function() {
          return [Xr];
        } }], [{ key: "constructor_", value: function() {
          this._nodeList = new Tc(this), this._pts = null, this._data = null;
          var o = arguments[0], h = arguments[1];
          this._pts = o, this._data = h;
        } }, { key: "getNodedSubstrings", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0], h = new me();
            return y.getNodedSubstrings(o, h), h;
          }
          if (arguments.length === 2) for (var _ = arguments[1], I = arguments[0].iterator(); I.hasNext(); )
            I.next().getNodeList().addSplitEdges(_);
        } }]);
      })(), bi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "minX", value: function() {
          return Math.min(this.p0.x, this.p1.x);
        } }, { key: "orientationIndex", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0], h = H.index(this.p0, this.p1, o.p0), _ = H.index(this.p0, this.p1, o.p1);
            return h >= 0 && _ >= 0 || h <= 0 && _ <= 0 ? Math.max(h, _) : 0;
          }
          if (arguments[0] instanceof He) {
            var I = arguments[0];
            return H.index(this.p0, this.p1, I);
          }
        } }, { key: "toGeometry", value: function(o) {
          return o.createLineString([this.p0, this.p1]);
        } }, { key: "isVertical", value: function() {
          return this.p0.x === this.p1.x;
        } }, { key: "equals", value: function(o) {
          if (!(o instanceof y)) return !1;
          var h = o;
          return this.p0.equals(h.p0) && this.p1.equals(h.p1);
        } }, { key: "intersection", value: function(o) {
          var h = new Wi();
          return h.computeIntersection(this.p0, this.p1, o.p0, o.p1), h.hasIntersection() ? h.getIntersection(0) : null;
        } }, { key: "project", value: function() {
          if (arguments[0] instanceof He) {
            var o = arguments[0];
            if (o.equals(this.p0) || o.equals(this.p1)) return new He(o);
            var h = this.projectionFactor(o), _ = new He();
            return _.x = this.p0.x + h * (this.p1.x - this.p0.x), _.y = this.p0.y + h * (this.p1.y - this.p0.y), _;
          }
          if (arguments[0] instanceof y) {
            var I = arguments[0], D = this.projectionFactor(I.p0), B = this.projectionFactor(I.p1);
            if (D >= 1 && B >= 1 || D <= 0 && B <= 0) return null;
            var W = this.project(I.p0);
            D < 0 && (W = this.p0), D > 1 && (W = this.p1);
            var oe = this.project(I.p1);
            return B < 0 && (oe = this.p0), B > 1 && (oe = this.p1), new y(W, oe);
          }
        } }, { key: "normalize", value: function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        } }, { key: "angle", value: function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        } }, { key: "getCoordinate", value: function(o) {
          return o === 0 ? this.p0 : this.p1;
        } }, { key: "distancePerpendicular", value: function(o) {
          return st.pointToLinePerpendicular(o, this.p0, this.p1);
        } }, { key: "minY", value: function() {
          return Math.min(this.p0.y, this.p1.y);
        } }, { key: "midPoint", value: function() {
          return y.midPoint(this.p0, this.p1);
        } }, { key: "projectionFactor", value: function(o) {
          if (o.equals(this.p0)) return 0;
          if (o.equals(this.p1)) return 1;
          var h = this.p1.x - this.p0.x, _ = this.p1.y - this.p0.y, I = h * h + _ * _;
          return I <= 0 ? ft.NaN : ((o.x - this.p0.x) * h + (o.y - this.p0.y) * _) / I;
        } }, { key: "closestPoints", value: function(o) {
          var h = this.intersection(o);
          if (h !== null) return [h, h];
          var _ = new Array(2).fill(null), I = ft.MAX_VALUE, D = null, B = this.closestPoint(o.p0);
          I = B.distance(o.p0), _[0] = B, _[1] = o.p0;
          var W = this.closestPoint(o.p1);
          (D = W.distance(o.p1)) < I && (I = D, _[0] = W, _[1] = o.p1);
          var oe = o.closestPoint(this.p0);
          (D = oe.distance(this.p0)) < I && (I = D, _[0] = this.p0, _[1] = oe);
          var de = o.closestPoint(this.p1);
          return (D = de.distance(this.p1)) < I && (I = D, _[0] = this.p1, _[1] = de), _;
        } }, { key: "closestPoint", value: function(o) {
          var h = this.projectionFactor(o);
          return h > 0 && h < 1 ? this.project(o) : this.p0.distance(o) < this.p1.distance(o) ? this.p0 : this.p1;
        } }, { key: "maxX", value: function() {
          return Math.max(this.p0.x, this.p1.x);
        } }, { key: "getLength", value: function() {
          return this.p0.distance(this.p1);
        } }, { key: "compareTo", value: function(o) {
          var h = o, _ = this.p0.compareTo(h.p0);
          return _ !== 0 ? _ : this.p1.compareTo(h.p1);
        } }, { key: "reverse", value: function() {
          var o = this.p0;
          this.p0 = this.p1, this.p1 = o;
        } }, { key: "equalsTopo", value: function(o) {
          return this.p0.equals(o.p0) && this.p1.equals(o.p1) || this.p0.equals(o.p1) && this.p1.equals(o.p0);
        } }, { key: "lineIntersection", value: function(o) {
          return Ve.intersection(this.p0, this.p1, o.p0, o.p1);
        } }, { key: "maxY", value: function() {
          return Math.max(this.p0.y, this.p1.y);
        } }, { key: "pointAlongOffset", value: function(o, h) {
          var _ = this.p0.x + o * (this.p1.x - this.p0.x), I = this.p0.y + o * (this.p1.y - this.p0.y), D = this.p1.x - this.p0.x, B = this.p1.y - this.p0.y, W = Math.sqrt(D * D + B * B), oe = 0, de = 0;
          if (h !== 0) {
            if (W <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
            oe = h * D / W, de = h * B / W;
          }
          return new He(_ - de, I + oe);
        } }, { key: "setCoordinates", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.setCoordinates(o.p0, o.p1);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.p0.x = h.x, this.p0.y = h.y, this.p1.x = _.x, this.p1.y = _.y;
          }
        } }, { key: "segmentFraction", value: function(o) {
          var h = this.projectionFactor(o);
          return h < 0 ? h = 0 : (h > 1 || ft.isNaN(h)) && (h = 1), h;
        } }, { key: "toString", value: function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        } }, { key: "isHorizontal", value: function() {
          return this.p0.y === this.p1.y;
        } }, { key: "reflect", value: function(o) {
          var h = this.p1.getY() - this.p0.getY(), _ = this.p0.getX() - this.p1.getX(), I = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), D = h * h + _ * _, B = h * h - _ * _, W = o.getX(), oe = o.getY();
          return new He((-B * W - 2 * h * _ * oe - 2 * h * I) / D, (B * oe - 2 * h * _ * W - 2 * _ * I) / D);
        } }, { key: "distance", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return st.segmentToSegment(this.p0, this.p1, o.p0, o.p1);
          }
          if (arguments[0] instanceof He) {
            var h = arguments[0];
            return st.pointToSegment(h, this.p0, this.p1);
          }
        } }, { key: "pointAlong", value: function(o) {
          var h = new He();
          return h.x = this.p0.x + o * (this.p1.x - this.p0.x), h.y = this.p0.y + o * (this.p1.y - this.p0.y), h;
        } }, { key: "hashCode", value: function() {
          var o = ft.doubleToLongBits(this.p0.x);
          o ^= 31 * ft.doubleToLongBits(this.p0.y);
          var h = Math.trunc(o) ^ Math.trunc(o >> 32), _ = ft.doubleToLongBits(this.p1.x);
          return _ ^= 31 * ft.doubleToLongBits(this.p1.y), h ^ (Math.trunc(_) ^ Math.trunc(_ >> 32));
        } }, { key: "interfaces_", get: function() {
          return [ut, se];
        } }], [{ key: "constructor_", value: function() {
          if (this.p0 = null, this.p1 = null, arguments.length === 0) y.constructor_.call(this, new He(), new He());
          else if (arguments.length === 1) {
            var o = arguments[0];
            y.constructor_.call(this, o.p0, o.p1);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.p0 = h, this.p1 = _;
          } else if (arguments.length === 4) {
            var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3];
            y.constructor_.call(this, new He(I, D), new He(B, W));
          }
        } }, { key: "midPoint", value: function(o, h) {
          return new He((o.x + h.x) / 2, (o.y + h.y) / 2);
        } }]);
      })(), Fo = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "overlap", value: function() {
          if (arguments.length !== 2 && arguments.length === 4) {
            var y = arguments[1], o = arguments[2], h = arguments[3];
            arguments[0].getLineSegment(y, this._overlapSeg1), o.getLineSegment(h, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._overlapSeg1 = new bi(), this._overlapSeg2 = new bi();
        } }]);
      })(), sn = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getLineSegment", value: function(y, o) {
          o.p0 = this._pts[y], o.p1 = this._pts[y + 1];
        } }, { key: "computeSelect", value: function(y, o, h, _) {
          var I = this._pts[o], D = this._pts[h];
          if (h - o == 1) return _.select(this, o), null;
          if (!y.intersects(I, D)) return null;
          var B = Math.trunc((o + h) / 2);
          o < B && this.computeSelect(y, o, B, _), B < h && this.computeSelect(y, B, h, _);
        } }, { key: "getCoordinates", value: function() {
          for (var y = new Array(this._end - this._start + 1).fill(null), o = 0, h = this._start; h <= this._end; h++) y[o++] = this._pts[h];
          return y;
        } }, { key: "computeOverlaps", value: function() {
          if (arguments.length === 2) {
            var y = arguments[0], o = arguments[1];
            this.computeOverlaps(this._start, this._end, y, y._start, y._end, o);
          } else if (arguments.length === 6) {
            var h = arguments[0], _ = arguments[1], I = arguments[2], D = arguments[3], B = arguments[4], W = arguments[5];
            if (_ - h == 1 && B - D == 1) return W.overlap(this, h, I, D), null;
            if (!this.overlaps(h, _, I, D, B)) return null;
            var oe = Math.trunc((h + _) / 2), de = Math.trunc((D + B) / 2);
            h < oe && (D < de && this.computeOverlaps(h, oe, I, D, de, W), de < B && this.computeOverlaps(h, oe, I, de, B, W)), oe < _ && (D < de && this.computeOverlaps(oe, _, I, D, de, W), de < B && this.computeOverlaps(oe, _, I, de, B, W));
          }
        } }, { key: "setId", value: function(y) {
          this._id = y;
        } }, { key: "select", value: function(y, o) {
          this.computeSelect(y, this._start, this._end, o);
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            var y = this._pts[this._start], o = this._pts[this._end];
            this._env = new fr(y, o);
          }
          return this._env;
        } }, { key: "overlaps", value: function(y, o, h, _, I) {
          return fr.intersects(this._pts[y], this._pts[o], h._pts[_], h._pts[I]);
        } }, { key: "getEndIndex", value: function() {
          return this._end;
        } }, { key: "getStartIndex", value: function() {
          return this._start;
        } }, { key: "getContext", value: function() {
          return this._context;
        } }, { key: "getId", value: function() {
          return this._id;
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var y = arguments[0], o = arguments[1], h = arguments[2], _ = arguments[3];
          this._pts = y, this._start = o, this._end = h, this._context = _;
        } }]);
      })(), kc = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "findChainEnd", value: function(o, h) {
          for (var _ = h; _ < o.length - 1 && o[_].equals2D(o[_ + 1]); ) _++;
          if (_ >= o.length - 1) return o.length - 1;
          for (var I = nn.quadrant(o[_], o[_ + 1]), D = h + 1; D < o.length && !(!o[D - 1].equals2D(o[D]) && nn.quadrant(o[D - 1], o[D]) !== I); )
            D++;
          return D - 1;
        } }, { key: "getChains", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return y.getChains(o, null);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1], I = new me(), D = 0;
            do {
              var B = y.findChainEnd(h, D), W = new sn(h, D, B, _);
              I.add(W), D = B;
            } while (D < h.length - 1);
            return I;
          }
        } }]);
      })(), No = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "computeNodes", value: function(y) {
        } }, { key: "getNodedSubstrings", value: function() {
        } }]);
      })(), gu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "setSegmentIntersector", value: function(y) {
          this._segInt = y;
        } }, { key: "interfaces_", get: function() {
          return [No];
        } }], [{ key: "constructor_", value: function() {
          if (this._segInt = null, arguments.length !== 0 && arguments.length === 1) {
            var y = arguments[0];
            this.setSegmentIntersector(y);
          }
        } }]);
      })(), mu = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getMonotoneChains", value: function() {
          return this._monoChains;
        } }, { key: "getNodedSubstrings", value: function() {
          return ji.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "getIndex", value: function() {
          return this._index;
        } }, { key: "add", value: function(h) {
          for (var _ = kc.getChains(h.getCoordinates(), h).iterator(); _.hasNext(); ) {
            var I = _.next();
            I.setId(this._idCounter++), this._index.insert(I.getEnvelope(), I), this._monoChains.add(I);
          }
        } }, { key: "computeNodes", value: function(h) {
          this._nodedSegStrings = h;
          for (var _ = h.iterator(); _.hasNext(); ) this.add(_.next());
          this.intersectChains();
        } }, { key: "intersectChains", value: function() {
          for (var h = new Sa(this._segInt), _ = this._monoChains.iterator(); _.hasNext(); ) for (var I = _.next(), D = this._index.query(I.getEnvelope()).iterator(); D.hasNext(); ) {
            var B = D.next();
            if (B.getId() > I.getId() && (I.computeOverlaps(B, h), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        } }], [{ key: "constructor_", value: function() {
          if (this._monoChains = new me(), this._index = new Kn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0 && arguments.length === 1) {
            var h = arguments[0];
            gu.constructor_.call(this, h);
          }
        } }]);
      })(gu), Sa = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "overlap", value: function() {
          if (arguments.length !== 4) return ce(o, "overlap", this, 1).apply(this, arguments);
          var h = arguments[1], _ = arguments[2], I = arguments[3], D = arguments[0].getContext(), B = _.getContext();
          this._si.processIntersections(D, h, B, I);
        } }], [{ key: "constructor_", value: function() {
          this._si = null;
          var h = arguments[0];
          this._si = h;
        } }]);
      })(Fo);
      mu.SegmentOverlapAction = Sa;
      var Ii = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isDeletable", value: function(o, h, _, I) {
          var D = this._inputLine[o], B = this._inputLine[h], W = this._inputLine[_];
          return !!this.isConcave(D, B, W) && !!this.isShallow(D, B, W, I) && this.isShallowSampled(D, B, o, _, I);
        } }, { key: "deleteShallowConcavities", value: function() {
          for (var o = 1, h = this.findNextNonDeletedIndex(o), _ = this.findNextNonDeletedIndex(h), I = !1; _ < this._inputLine.length; ) {
            var D = !1;
            this.isDeletable(o, h, _, this._distanceTol) && (this._isDeleted[h] = y.DELETE, D = !0, I = !0), o = D ? _ : h, h = this.findNextNonDeletedIndex(o), _ = this.findNextNonDeletedIndex(h);
          }
          return I;
        } }, { key: "isShallowConcavity", value: function(o, h, _, I) {
          return H.index(o, h, _) === this._angleOrientation && st.pointToSegment(h, o, _) < I;
        } }, { key: "isShallowSampled", value: function(o, h, _, I, D) {
          var B = Math.trunc((I - _) / y.NUM_PTS_TO_CHECK);
          B <= 0 && (B = 1);
          for (var W = _; W < I; W += B) if (!this.isShallow(o, h, this._inputLine[W], D)) return !1;
          return !0;
        } }, { key: "isConcave", value: function(o, h, _) {
          var I = H.index(o, h, _) === this._angleOrientation;
          return I;
        } }, { key: "simplify", value: function(o) {
          this._distanceTol = Math.abs(o), o < 0 && (this._angleOrientation = H.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var h = !1;
          do
            h = this.deleteShallowConcavities();
          while (h);
          return this.collapseLine();
        } }, { key: "findNextNonDeletedIndex", value: function(o) {
          for (var h = o + 1; h < this._inputLine.length && this._isDeleted[h] === y.DELETE; ) h++;
          return h;
        } }, { key: "isShallow", value: function(o, h, _, I) {
          return st.pointToSegment(h, o, _) < I;
        } }, { key: "collapseLine", value: function() {
          for (var o = new Gt(), h = 0; h < this._inputLine.length; h++) this._isDeleted[h] !== y.DELETE && o.add(this._inputLine[h]);
          return o.toCoordinateArray();
        } }], [{ key: "constructor_", value: function() {
          this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = H.COUNTERCLOCKWISE;
          var o = arguments[0];
          this._inputLine = o;
        } }, { key: "simplify", value: function(o, h) {
          return new y(o).simplify(h);
        } }]);
      })();
      Ii.INIT = 0, Ii.DELETE = 1, Ii.KEEP = 1, Ii.NUM_PTS_TO_CHECK = 10;
      var Ta = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getCoordinates", value: function() {
          return this._ptList.toArray(y.COORDINATE_ARRAY_TYPE);
        } }, { key: "setPrecisionModel", value: function(o) {
          this._precisionModel = o;
        } }, { key: "addPt", value: function(o) {
          var h = new He(o);
          if (this._precisionModel.makePrecise(h), this.isRedundant(h)) return null;
          this._ptList.add(h);
        } }, { key: "reverse", value: function() {
        } }, { key: "addPts", value: function(o, h) {
          if (h) for (var _ = 0; _ < o.length; _++) this.addPt(o[_]);
          else for (var I = o.length - 1; I >= 0; I--) this.addPt(o[I]);
        } }, { key: "isRedundant", value: function(o) {
          if (this._ptList.size() < 1) return !1;
          var h = this._ptList.get(this._ptList.size() - 1);
          return o.distance(h) < this._minimimVertexDistance;
        } }, { key: "toString", value: function() {
          return new si().createLineString(this.getCoordinates()).toString();
        } }, { key: "closeRing", value: function() {
          if (this._ptList.size() < 1) return null;
          var o = new He(this._ptList.get(0)), h = this._ptList.get(this._ptList.size() - 1);
          if (o.equals(h)) return null;
          this._ptList.add(o);
        } }, { key: "setMinimumVertexDistance", value: function(o) {
          this._minimimVertexDistance = o;
        } }], [{ key: "constructor_", value: function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new me();
        } }]);
      })();
      Ta.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var wi = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "toDegrees", value: function(o) {
          return 180 * o / Math.PI;
        } }, { key: "normalize", value: function(o) {
          for (; o > Math.PI; ) o -= y.PI_TIMES_2;
          for (; o <= -Math.PI; ) o += y.PI_TIMES_2;
          return o;
        } }, { key: "angle", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return Math.atan2(o.y, o.x);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1], I = _.x - h.x, D = _.y - h.y;
            return Math.atan2(D, I);
          }
        } }, { key: "isAcute", value: function(o, h, _) {
          var I = o.x - h.x, D = o.y - h.y;
          return I * (_.x - h.x) + D * (_.y - h.y) > 0;
        } }, { key: "isObtuse", value: function(o, h, _) {
          var I = o.x - h.x, D = o.y - h.y;
          return I * (_.x - h.x) + D * (_.y - h.y) < 0;
        } }, { key: "interiorAngle", value: function(o, h, _) {
          var I = y.angle(h, o), D = y.angle(h, _);
          return Math.abs(D - I);
        } }, { key: "normalizePositive", value: function(o) {
          if (o < 0) {
            for (; o < 0; ) o += y.PI_TIMES_2;
            o >= y.PI_TIMES_2 && (o = 0);
          } else {
            for (; o >= y.PI_TIMES_2; ) o -= y.PI_TIMES_2;
            o < 0 && (o = 0);
          }
          return o;
        } }, { key: "angleBetween", value: function(o, h, _) {
          var I = y.angle(h, o), D = y.angle(h, _);
          return y.diff(I, D);
        } }, { key: "diff", value: function(o, h) {
          var _ = null;
          return (_ = o < h ? h - o : o - h) > Math.PI && (_ = 2 * Math.PI - _), _;
        } }, { key: "toRadians", value: function(o) {
          return o * Math.PI / 180;
        } }, { key: "getTurn", value: function(o, h) {
          var _ = Math.sin(h - o);
          return _ > 0 ? y.COUNTERCLOCKWISE : _ < 0 ? y.CLOCKWISE : y.NONE;
        } }, { key: "angleBetweenOriented", value: function(o, h, _) {
          var I = y.angle(h, o), D = y.angle(h, _) - I;
          return D <= -Math.PI ? D + y.PI_TIMES_2 : D > Math.PI ? D - y.PI_TIMES_2 : D;
        } }]);
      })();
      wi.PI_TIMES_2 = 2 * Math.PI, wi.PI_OVER_2 = Math.PI / 2, wi.PI_OVER_4 = Math.PI / 4, wi.COUNTERCLOCKWISE = H.COUNTERCLOCKWISE, wi.CLOCKWISE = H.CLOCKWISE, wi.NONE = H.COLLINEAR;
      var zs = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "addNextSegment", value: function(o, h) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = o, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
          var _ = H.index(this._s0, this._s1, this._s2), I = _ === H.CLOCKWISE && this._side === Mt.LEFT || _ === H.COUNTERCLOCKWISE && this._side === Mt.RIGHT;
          _ === 0 ? this.addCollinear(h) : I ? this.addOutsideTurn(_, h) : this.addInsideTurn(_, h);
        } }, { key: "addLineEndCap", value: function(o, h) {
          var _ = new bi(o, h), I = new bi();
          this.computeOffsetSegment(_, Mt.LEFT, this._distance, I);
          var D = new bi();
          this.computeOffsetSegment(_, Mt.RIGHT, this._distance, D);
          var B = h.x - o.x, W = h.y - o.y, oe = Math.atan2(W, B);
          switch (this._bufParams.getEndCapStyle()) {
            case Ue.CAP_ROUND:
              this._segList.addPt(I.p1), this.addDirectedFillet(h, oe + Math.PI / 2, oe - Math.PI / 2, H.CLOCKWISE, this._distance), this._segList.addPt(D.p1);
              break;
            case Ue.CAP_FLAT:
              this._segList.addPt(I.p1), this._segList.addPt(D.p1);
              break;
            case Ue.CAP_SQUARE:
              var de = new He();
              de.x = Math.abs(this._distance) * Math.cos(oe), de.y = Math.abs(this._distance) * Math.sin(oe);
              var Ze = new He(I.p1.x + de.x, I.p1.y + de.y), rt = new He(D.p1.x + de.x, D.p1.y + de.y);
              this._segList.addPt(Ze), this._segList.addPt(rt);
          }
        } }, { key: "getCoordinates", value: function() {
          return this._segList.getCoordinates();
        } }, { key: "addMitreJoin", value: function(o, h, _, I) {
          var D = Ve.intersection(h.p0, h.p1, _.p0, _.p1);
          if (D !== null && (I <= 0 ? 1 : D.distance(o) / Math.abs(I)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(D), null;
          this.addLimitedMitreJoin(h, _, I, this._bufParams.getMitreLimit());
        } }, { key: "addOutsideTurn", value: function(o, h) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * y.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === Ue.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Ue.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (h && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, o, this._distance), this._segList.addPt(this._offset1.p0));
        } }, { key: "createSquare", value: function(o) {
          this._segList.addPt(new He(o.x + this._distance, o.y + this._distance)), this._segList.addPt(new He(o.x + this._distance, o.y - this._distance)), this._segList.addPt(new He(o.x - this._distance, o.y - this._distance)), this._segList.addPt(new He(o.x - this._distance, o.y + this._distance)), this._segList.closeRing();
        } }, { key: "addSegments", value: function(o, h) {
          this._segList.addPts(o, h);
        } }, { key: "addFirstSegment", value: function() {
          this._segList.addPt(this._offset1.p0);
        } }, { key: "addCornerFillet", value: function(o, h, _, I, D) {
          var B = h.x - o.x, W = h.y - o.y, oe = Math.atan2(W, B), de = _.x - o.x, Ze = _.y - o.y, rt = Math.atan2(Ze, de);
          I === H.CLOCKWISE ? oe <= rt && (oe += 2 * Math.PI) : oe >= rt && (oe -= 2 * Math.PI), this._segList.addPt(h), this.addDirectedFillet(o, oe, rt, I, D), this._segList.addPt(_);
        } }, { key: "addLastSegment", value: function() {
          this._segList.addPt(this._offset1.p1);
        } }, { key: "initSideSegments", value: function(o, h, _) {
          this._s1 = o, this._s2 = h, this._side = _, this._seg1.setCoordinates(o, h), this.computeOffsetSegment(this._seg1, _, this._distance, this._offset1);
        } }, { key: "addLimitedMitreJoin", value: function(o, h, _, I) {
          var D = this._seg0.p1, B = wi.angle(D, this._seg0.p0), W = wi.angleBetweenOriented(this._seg0.p0, D, this._seg1.p1) / 2, oe = wi.normalize(B + W), de = wi.normalize(oe + Math.PI), Ze = I * _, rt = _ - Ze * Math.abs(Math.sin(W)), xt = D.x + Ze * Math.cos(de), jt = D.y + Ze * Math.sin(de), qt = new He(xt, jt), Wt = new bi(D, qt), _r = Wt.pointAlongOffset(1, rt), lr = Wt.pointAlongOffset(1, -rt);
          this._side === Mt.LEFT ? (this._segList.addPt(_r), this._segList.addPt(lr)) : (this._segList.addPt(lr), this._segList.addPt(_r));
        } }, { key: "addDirectedFillet", value: function(o, h, _, I, D) {
          var B = I === H.CLOCKWISE ? -1 : 1, W = Math.abs(h - _), oe = Math.trunc(W / this._filletAngleQuantum + 0.5);
          if (oe < 1) return null;
          for (var de = W / oe, Ze = new He(), rt = 0; rt < oe; rt++) {
            var xt = h + B * rt * de;
            Ze.x = o.x + D * Math.cos(xt), Ze.y = o.y + D * Math.sin(xt), this._segList.addPt(Ze);
          }
        } }, { key: "computeOffsetSegment", value: function(o, h, _, I) {
          var D = h === Mt.LEFT ? 1 : -1, B = o.p1.x - o.p0.x, W = o.p1.y - o.p0.y, oe = Math.sqrt(B * B + W * W), de = D * _ * B / oe, Ze = D * _ * W / oe;
          I.p0.x = o.p0.x - Ze, I.p0.y = o.p0.y + de, I.p1.x = o.p1.x - Ze, I.p1.y = o.p1.y + de;
        } }, { key: "addInsideTurn", value: function(o, h) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * y.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var _ = new He((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(_);
              var I = new He((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(I);
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        } }, { key: "createCircle", value: function(o) {
          var h = new He(o.x + this._distance, o.y);
          this._segList.addPt(h), this.addDirectedFillet(o, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        } }, { key: "addBevelJoin", value: function(o, h) {
          this._segList.addPt(o.p1), this._segList.addPt(h.p0);
        } }, { key: "init", value: function(o) {
          this._distance = o, this._maxCurveSegmentError = o * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Ta(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(o * y.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        } }, { key: "addCollinear", value: function(o) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Ue.JOIN_BEVEL || this._bufParams.getJoinStyle() === Ue.JOIN_MITRE ? (o && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, H.CLOCKWISE, this._distance));
        } }, { key: "closeRing", value: function() {
          this._segList.closeRing();
        } }, { key: "hasNarrowConcaveAngle", value: function() {
          return this._hasNarrowConcaveAngle;
        } }], [{ key: "constructor_", value: function() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new bi(), this._seg1 = new bi(), this._offset0 = new bi(), this._offset1 = new bi(), this._side = 0, this._hasNarrowConcaveAngle = !1;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          this._precisionModel = o, this._bufParams = h, this._li = new Wi(), this._filletAngleQuantum = Math.PI / 2 / h.getQuadrantSegments(), h.getQuadrantSegments() >= 8 && h.getJoinStyle() === Ue.JOIN_ROUND && (this._closingSegLengthFactor = y.MAX_CLOSING_SEG_LEN_FACTOR), this.init(_);
        } }]);
      })();
      zs.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, zs.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, zs.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, zs.MAX_CLOSING_SEG_LEN_FACTOR = 80;
      var no = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getOffsetCurve", value: function(o, h) {
          if (this._distance = h, h === 0) return null;
          var _ = h < 0, I = Math.abs(h), D = this.getSegGen(I);
          o.length <= 1 ? this.computePointCurve(o[0], D) : this.computeOffsetCurve(o, _, D);
          var B = D.getCoordinates();
          return _ && wt.reverse(B), B;
        } }, { key: "computeSingleSidedBufferCurve", value: function(o, h, _) {
          var I = this.simplifyTolerance(this._distance);
          if (h) {
            _.addSegments(o, !0);
            var D = Ii.simplify(o, -I), B = D.length - 1;
            _.initSideSegments(D[B], D[B - 1], Mt.LEFT), _.addFirstSegment();
            for (var W = B - 2; W >= 0; W--) _.addNextSegment(D[W], !0);
          } else {
            _.addSegments(o, !1);
            var oe = Ii.simplify(o, I), de = oe.length - 1;
            _.initSideSegments(oe[0], oe[1], Mt.LEFT), _.addFirstSegment();
            for (var Ze = 2; Ze <= de; Ze++) _.addNextSegment(oe[Ze], !0);
          }
          _.addLastSegment(), _.closeRing();
        } }, { key: "computeRingBufferCurve", value: function(o, h, _) {
          var I = this.simplifyTolerance(this._distance);
          h === Mt.RIGHT && (I = -I);
          var D = Ii.simplify(o, I), B = D.length - 1;
          _.initSideSegments(D[B - 1], D[0], h);
          for (var W = 1; W <= B; W++) {
            var oe = W !== 1;
            _.addNextSegment(D[W], oe);
          }
          _.closeRing();
        } }, { key: "computeLineBufferCurve", value: function(o, h) {
          var _ = this.simplifyTolerance(this._distance), I = Ii.simplify(o, _), D = I.length - 1;
          h.initSideSegments(I[0], I[1], Mt.LEFT);
          for (var B = 2; B <= D; B++) h.addNextSegment(I[B], !0);
          h.addLastSegment(), h.addLineEndCap(I[D - 1], I[D]);
          var W = Ii.simplify(o, -_), oe = W.length - 1;
          h.initSideSegments(W[oe], W[oe - 1], Mt.LEFT);
          for (var de = oe - 2; de >= 0; de--) h.addNextSegment(W[de], !0);
          h.addLastSegment(), h.addLineEndCap(W[1], W[0]), h.closeRing();
        } }, { key: "computePointCurve", value: function(o, h) {
          switch (this._bufParams.getEndCapStyle()) {
            case Ue.CAP_ROUND:
              h.createCircle(o);
              break;
            case Ue.CAP_SQUARE:
              h.createSquare(o);
          }
        } }, { key: "getLineCurve", value: function(o, h) {
          if (this._distance = h, this.isLineOffsetEmpty(h)) return null;
          var _ = Math.abs(h), I = this.getSegGen(_);
          if (o.length <= 1) this.computePointCurve(o[0], I);
          else if (this._bufParams.isSingleSided()) {
            var D = h < 0;
            this.computeSingleSidedBufferCurve(o, D, I);
          } else this.computeLineBufferCurve(o, I);
          return I.getCoordinates();
        } }, { key: "getBufferParameters", value: function() {
          return this._bufParams;
        } }, { key: "simplifyTolerance", value: function(o) {
          return o * this._bufParams.getSimplifyFactor();
        } }, { key: "getRingCurve", value: function(o, h, _) {
          if (this._distance = _, o.length <= 2) return this.getLineCurve(o, _);
          if (_ === 0) return y.copyCoordinates(o);
          var I = this.getSegGen(_);
          return this.computeRingBufferCurve(o, h, I), I.getCoordinates();
        } }, { key: "computeOffsetCurve", value: function(o, h, _) {
          var I = this.simplifyTolerance(this._distance);
          if (h) {
            var D = Ii.simplify(o, -I), B = D.length - 1;
            _.initSideSegments(D[B], D[B - 1], Mt.LEFT), _.addFirstSegment();
            for (var W = B - 2; W >= 0; W--) _.addNextSegment(D[W], !0);
          } else {
            var oe = Ii.simplify(o, I), de = oe.length - 1;
            _.initSideSegments(oe[0], oe[1], Mt.LEFT), _.addFirstSegment();
            for (var Ze = 2; Ze <= de; Ze++) _.addNextSegment(oe[Ze], !0);
          }
          _.addLastSegment();
        } }, { key: "isLineOffsetEmpty", value: function(o) {
          return o === 0 || o < 0 && !this._bufParams.isSingleSided();
        } }, { key: "getSegGen", value: function(o) {
          return new zs(this._precisionModel, this._bufParams, o);
        } }], [{ key: "constructor_", value: function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var o = arguments[0], h = arguments[1];
          this._precisionModel = o, this._bufParams = h;
        } }, { key: "copyCoordinates", value: function(o) {
          for (var h = new Array(o.length).fill(null), _ = 0; _ < h.length; _++) h[_] = new He(o[_]);
          return h;
        } }]);
      })(), ka = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "findStabbedSegments", value: function() {
          if (arguments.length === 1) {
            for (var y = arguments[0], o = new me(), h = this._subgraphs.iterator(); h.hasNext(); ) {
              var _ = h.next(), I = _.getEnvelope();
              y.y < I.getMinY() || y.y > I.getMaxY() || this.findStabbedSegments(y, _.getDirectedEdges(), o);
            }
            return o;
          }
          if (arguments.length === 3) {
            if (tr(arguments[2], jn) && arguments[0] instanceof He && arguments[1] instanceof li) {
              for (var D = arguments[0], B = arguments[1], W = arguments[2], oe = B.getEdge().getCoordinates(), de = 0; de < oe.length - 1; de++)
                if (this._seg.p0 = oe[de], this._seg.p1 = oe[de + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < D.x || this._seg.isHorizontal() || D.y < this._seg.p0.y || D.y > this._seg.p1.y || H.index(this._seg.p0, this._seg.p1, D) === H.RIGHT)) {
                  var Ze = B.getDepth(Mt.LEFT);
                  this._seg.p0.equals(oe[de]) || (Ze = B.getDepth(Mt.RIGHT));
                  var rt = new En(this._seg, Ze);
                  W.add(rt);
                }
            } else if (tr(arguments[2], jn) && arguments[0] instanceof He && tr(arguments[1], jn)) for (var xt = arguments[0], jt = arguments[2], qt = arguments[1].iterator(); qt.hasNext(); ) {
              var Wt = qt.next();
              Wt.isForward() && this.findStabbedSegments(xt, Wt, jt);
            }
          }
        } }, { key: "getDepth", value: function(y) {
          var o = this.findStabbedSegments(y);
          return o.size() === 0 ? 0 : sr.min(o)._leftDepth;
        } }], [{ key: "constructor_", value: function() {
          this._subgraphs = null, this._seg = new bi();
          var y = arguments[0];
          this._subgraphs = y;
        } }]);
      })(), En = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "compareTo", value: function(y) {
          var o = y;
          if (this._upwardSeg.minX() >= o._upwardSeg.maxX()) return 1;
          if (this._upwardSeg.maxX() <= o._upwardSeg.minX()) return -1;
          var h = this._upwardSeg.orientationIndex(o._upwardSeg);
          return h !== 0 || (h = -1 * o._upwardSeg.orientationIndex(this._upwardSeg)) !== 0 ? h : this._upwardSeg.compareTo(o._upwardSeg);
        } }, { key: "compareX", value: function(y, o) {
          var h = y.p0.compareTo(o.p0);
          return h !== 0 ? h : y.p1.compareTo(o.p1);
        } }, { key: "toString", value: function() {
          return this._upwardSeg.toString();
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          this._upwardSeg = null, this._leftDepth = null;
          var y = arguments[0], o = arguments[1];
          this._upwardSeg = new bi(y), this._leftDepth = o;
        } }]);
      })();
      ka.DepthSegment = En;
      var _u = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, null, [{ key: "constructor_", value: function() {
          Qe.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
        } }]);
      })(Qe), sa = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getY", value: function() {
          var o = this.y / this.w;
          if (ft.isNaN(o) || ft.isInfinite(o)) throw new _u();
          return o;
        } }, { key: "getX", value: function() {
          var o = this.x / this.w;
          if (ft.isNaN(o) || ft.isInfinite(o)) throw new _u();
          return o;
        } }, { key: "getCoordinate", value: function() {
          var o = new He();
          return o.x = this.getX(), o.y = this.getY(), o;
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
          else if (arguments.length === 1) {
            var o = arguments[0];
            this.x = o.x, this.y = o.y, this.w = 1;
          } else if (arguments.length === 2) {
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var h = arguments[0], _ = arguments[1];
              this.x = h, this.y = _, this.w = 1;
            } else if (arguments[0] instanceof y && arguments[1] instanceof y) {
              var I = arguments[0], D = arguments[1];
              this.x = I.y * D.w - D.y * I.w, this.y = D.x * I.w - I.x * D.w, this.w = I.x * D.y - D.x * I.y;
            } else if (arguments[0] instanceof He && arguments[1] instanceof He) {
              var B = arguments[0], W = arguments[1];
              this.x = B.y - W.y, this.y = W.x - B.x, this.w = B.x * W.y - W.x * B.y;
            }
          } else if (arguments.length === 3) {
            var oe = arguments[0], de = arguments[1], Ze = arguments[2];
            this.x = oe, this.y = de, this.w = Ze;
          } else if (arguments.length === 4) {
            var rt = arguments[0], xt = arguments[1], jt = arguments[2], qt = arguments[3], Wt = rt.y - xt.y, _r = xt.x - rt.x, lr = rt.x * xt.y - xt.x * rt.y, Br = jt.y - qt.y, qn = qt.x - jt.x, $n = jt.x * qt.y - qt.x * jt.y;
            this.x = _r * $n - qn * lr, this.y = Br * lr - Wt * $n, this.w = Wt * qn - Br * _r;
          }
        } }]);
      })(), Oo = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "area", value: function() {
          return y.area(this.p0, this.p1, this.p2);
        } }, { key: "signedArea", value: function() {
          return y.signedArea(this.p0, this.p1, this.p2);
        } }, { key: "interpolateZ", value: function(o) {
          if (o === null) throw new et("Supplied point is null.");
          return y.interpolateZ(o, this.p0, this.p1, this.p2);
        } }, { key: "longestSideLength", value: function() {
          return y.longestSideLength(this.p0, this.p1, this.p2);
        } }, { key: "isAcute", value: function() {
          return y.isAcute(this.p0, this.p1, this.p2);
        } }, { key: "circumcentre", value: function() {
          return y.circumcentre(this.p0, this.p1, this.p2);
        } }, { key: "area3D", value: function() {
          return y.area3D(this.p0, this.p1, this.p2);
        } }, { key: "centroid", value: function() {
          return y.centroid(this.p0, this.p1, this.p2);
        } }, { key: "inCentre", value: function() {
          return y.inCentre(this.p0, this.p1, this.p2);
        } }], [{ key: "constructor_", value: function() {
          this.p0 = null, this.p1 = null, this.p2 = null;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          this.p0 = o, this.p1 = h, this.p2 = _;
        } }, { key: "area", value: function(o, h, _) {
          return Math.abs(((_.x - o.x) * (h.y - o.y) - (h.x - o.x) * (_.y - o.y)) / 2);
        } }, { key: "signedArea", value: function(o, h, _) {
          return ((_.x - o.x) * (h.y - o.y) - (h.x - o.x) * (_.y - o.y)) / 2;
        } }, { key: "det", value: function(o, h, _, I) {
          return o * I - h * _;
        } }, { key: "interpolateZ", value: function(o, h, _, I) {
          var D = h.x, B = h.y, W = _.x - D, oe = I.x - D, de = _.y - B, Ze = I.y - B, rt = W * Ze - oe * de, xt = o.x - D, jt = o.y - B, qt = (Ze * xt - oe * jt) / rt, Wt = (-de * xt + W * jt) / rt;
          return h.getZ() + qt * (_.getZ() - h.getZ()) + Wt * (I.getZ() - h.getZ());
        } }, { key: "longestSideLength", value: function(o, h, _) {
          var I = o.distance(h), D = h.distance(_), B = _.distance(o), W = I;
          return D > W && (W = D), B > W && (W = B), W;
        } }, { key: "circumcentreDD", value: function(o, h, _) {
          var I = Jt.valueOf(o.x).subtract(_.x), D = Jt.valueOf(o.y).subtract(_.y), B = Jt.valueOf(h.x).subtract(_.x), W = Jt.valueOf(h.y).subtract(_.y), oe = Jt.determinant(I, D, B, W).multiply(2), de = I.sqr().add(D.sqr()), Ze = B.sqr().add(W.sqr()), rt = Jt.determinant(D, de, W, Ze), xt = Jt.determinant(I, de, B, Ze), jt = Jt.valueOf(_.x).subtract(rt.divide(oe)).doubleValue(), qt = Jt.valueOf(_.y).add(xt.divide(oe)).doubleValue();
          return new He(jt, qt);
        } }, { key: "isAcute", value: function(o, h, _) {
          return !!wi.isAcute(o, h, _) && !!wi.isAcute(h, _, o) && !!wi.isAcute(_, o, h);
        } }, { key: "circumcentre", value: function(o, h, _) {
          var I = _.x, D = _.y, B = o.x - I, W = o.y - D, oe = h.x - I, de = h.y - D, Ze = 2 * y.det(B, W, oe, de), rt = y.det(W, B * B + W * W, de, oe * oe + de * de), xt = y.det(B, B * B + W * W, oe, oe * oe + de * de);
          return new He(I - rt / Ze, D + xt / Ze);
        } }, { key: "perpendicularBisector", value: function(o, h) {
          var _ = h.x - o.x, I = h.y - o.y, D = new sa(o.x + _ / 2, o.y + I / 2, 1), B = new sa(o.x - I + _ / 2, o.y + _ + I / 2, 1);
          return new sa(D, B);
        } }, { key: "angleBisector", value: function(o, h, _) {
          var I = h.distance(o), D = I / (I + h.distance(_)), B = _.x - o.x, W = _.y - o.y;
          return new He(o.x + D * B, o.y + D * W);
        } }, { key: "area3D", value: function(o, h, _) {
          var I = h.x - o.x, D = h.y - o.y, B = h.getZ() - o.getZ(), W = _.x - o.x, oe = _.y - o.y, de = _.getZ() - o.getZ(), Ze = D * de - B * oe, rt = B * W - I * de, xt = I * oe - D * W, jt = Ze * Ze + rt * rt + xt * xt, qt = Math.sqrt(jt) / 2;
          return qt;
        } }, { key: "centroid", value: function(o, h, _) {
          var I = (o.x + h.x + _.x) / 3, D = (o.y + h.y + _.y) / 3;
          return new He(I, D);
        } }, { key: "inCentre", value: function(o, h, _) {
          var I = h.distance(_), D = o.distance(_), B = o.distance(h), W = I + D + B, oe = (I * o.x + D * h.x + B * _.x) / W, de = (I * o.y + D * h.y + B * _.y) / W;
          return new He(oe, de);
        } }]);
      })(), Ia = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "addRingSide", value: function(y, o, h, _, I) {
          if (o === 0 && y.length < ir.MINIMUM_VALID_SIZE) return null;
          var D = _, B = I;
          y.length >= ir.MINIMUM_VALID_SIZE && H.isCCW(y) && (D = I, B = _, h = Mt.opposite(h));
          var W = this._curveBuilder.getRingCurve(y, h, o);
          this.addCurve(W, D, B);
        } }, { key: "addRingBothSides", value: function(y, o) {
          this.addRingSide(y, o, Mt.LEFT, Me.EXTERIOR, Me.INTERIOR), this.addRingSide(y, o, Mt.RIGHT, Me.INTERIOR, Me.EXTERIOR);
        } }, { key: "addPoint", value: function(y) {
          if (this._distance <= 0) return null;
          var o = y.getCoordinates(), h = this._curveBuilder.getLineCurve(o, this._distance);
          this.addCurve(h, Me.EXTERIOR, Me.INTERIOR);
        } }, { key: "addPolygon", value: function(y) {
          var o = this._distance, h = Mt.LEFT;
          this._distance < 0 && (o = -this._distance, h = Mt.RIGHT);
          var _ = y.getExteriorRing(), I = wt.removeRepeatedPoints(_.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(_, this._distance) || this._distance <= 0 && I.length < 3) return null;
          this.addRingSide(I, o, h, Me.EXTERIOR, Me.INTERIOR);
          for (var D = 0; D < y.getNumInteriorRing(); D++) {
            var B = y.getInteriorRingN(D), W = wt.removeRepeatedPoints(B.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(B, -this._distance) || this.addRingSide(W, o, Mt.opposite(h), Me.INTERIOR, Me.EXTERIOR);
          }
        } }, { key: "isTriangleErodedCompletely", value: function(y, o) {
          var h = new Oo(y[0], y[1], y[2]), _ = h.inCentre();
          return st.pointToSegment(_, h.p0, h.p1) < Math.abs(o);
        } }, { key: "addLineString", value: function(y) {
          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
          var o = wt.removeRepeatedPoints(y.getCoordinates());
          if (wt.isRing(o) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(o, this._distance);
          else {
            var h = this._curveBuilder.getLineCurve(o, this._distance);
            this.addCurve(h, Me.EXTERIOR, Me.INTERIOR);
          }
        } }, { key: "addCurve", value: function(y, o, h) {
          if (y === null || y.length < 2) return null;
          var _ = new ji(y, new ki(0, Me.BOUNDARY, o, h));
          this._curveList.add(_);
        } }, { key: "getCurves", value: function() {
          return this.add(this._inputGeom), this._curveList;
        } }, { key: "add", value: function(y) {
          if (y.isEmpty()) return null;
          if (y instanceof jr) this.addPolygon(y);
          else if (y instanceof wr) this.addLineString(y);
          else if (y instanceof Qr) this.addPoint(y);
          else if (y instanceof er) this.addCollection(y);
          else if (y instanceof Ds) this.addCollection(y);
          else if (y instanceof Nr) this.addCollection(y);
          else {
            if (!(y instanceof yt)) throw new rr(y.getGeometryType());
            this.addCollection(y);
          }
        } }, { key: "isErodedCompletely", value: function(y, o) {
          var h = y.getCoordinates();
          if (h.length < 4) return o < 0;
          if (h.length === 4) return this.isTriangleErodedCompletely(h, o);
          var _ = y.getEnvelopeInternal(), I = Math.min(_.getHeight(), _.getWidth());
          return o < 0 && 2 * Math.abs(o) > I;
        } }, { key: "addCollection", value: function(y) {
          for (var o = 0; o < y.getNumGeometries(); o++) {
            var h = y.getGeometryN(o);
            this.add(h);
          }
        } }], [{ key: "constructor_", value: function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new me();
          var y = arguments[0], o = arguments[1], h = arguments[2];
          this._inputGeom = y, this._distance = o, this._curveBuilder = h;
        } }]);
      })(), Qh = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "locate", value: function(y) {
        } }]);
      })(), bl = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "next", value: function() {
          if (this._atStart) return this._atStart = !1, y.isAtomic(this._parent) && this._index++, this._parent;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max) throw new ur();
          var o = this._parent.getGeometryN(this._index++);
          return o instanceof yt ? (this._subcollectionIterator = new y(o), this._subcollectionIterator.next()) : o;
        } }, { key: "remove", value: function() {
          throw new rr(this.getClass().getName());
        } }, { key: "hasNext", value: function() {
          if (this._atStart) return !0;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return !0;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        } }, { key: "interfaces_", get: function() {
          return [Kh];
        } }], [{ key: "constructor_", value: function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var o = arguments[0];
          this._parent = o, this._atStart = !0, this._index = 0, this._max = o.getNumGeometries();
        } }, { key: "isAtomic", value: function(o) {
          return !(o instanceof yt);
        } }]);
      })(), ed = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "locate", value: function(o) {
          return y.locate(o, this._geom);
        } }, { key: "interfaces_", get: function() {
          return [Qh];
        } }], [{ key: "constructor_", value: function() {
          this._geom = null;
          var o = arguments[0];
          this._geom = o;
        } }, { key: "locatePointInPolygon", value: function(o, h) {
          if (h.isEmpty()) return Me.EXTERIOR;
          var _ = h.getExteriorRing(), I = y.locatePointInRing(o, _);
          if (I !== Me.INTERIOR) return I;
          for (var D = 0; D < h.getNumInteriorRing(); D++) {
            var B = h.getInteriorRingN(D), W = y.locatePointInRing(o, B);
            if (W === Me.BOUNDARY) return Me.BOUNDARY;
            if (W === Me.INTERIOR) return Me.EXTERIOR;
          }
          return Me.INTERIOR;
        } }, { key: "locatePointInRing", value: function(o, h) {
          return h.getEnvelopeInternal().intersects(o) ? Lo.locateInRing(o, h.getCoordinates()) : Me.EXTERIOR;
        } }, { key: "containsPointInPolygon", value: function(o, h) {
          return Me.EXTERIOR !== y.locatePointInPolygon(o, h);
        } }, { key: "locateInGeometry", value: function(o, h) {
          if (h instanceof jr) return y.locatePointInPolygon(o, h);
          if (h instanceof yt) for (var _ = new bl(h); _.hasNext(); ) {
            var I = _.next();
            if (I !== h) {
              var D = y.locateInGeometry(o, I);
              if (D !== Me.EXTERIOR) return D;
            }
          }
          return Me.EXTERIOR;
        } }, { key: "isContained", value: function(o, h) {
          return Me.EXTERIOR !== y.locate(o, h);
        } }, { key: "locate", value: function(o, h) {
          return h.isEmpty() ? Me.EXTERIOR : h.getEnvelopeInternal().intersects(o) ? y.locateInGeometry(o, h) : Me.EXTERIOR;
        } }]);
      })(), io = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getNextCW", value: function(y) {
          this.getEdges();
          var o = this._edgeList.indexOf(y), h = o - 1;
          return o === 0 && (h = this._edgeList.size() - 1), this._edgeList.get(h);
        } }, { key: "propagateSideLabels", value: function(y) {
          for (var o = Me.NONE, h = this.iterator(); h.hasNext(); ) {
            var _ = h.next().getLabel();
            _.isArea(y) && _.getLocation(y, Mt.LEFT) !== Me.NONE && (o = _.getLocation(y, Mt.LEFT));
          }
          if (o === Me.NONE) return null;
          for (var I = o, D = this.iterator(); D.hasNext(); ) {
            var B = D.next(), W = B.getLabel();
            if (W.getLocation(y, Mt.ON) === Me.NONE && W.setLocation(y, Mt.ON, I), W.isArea(y)) {
              var oe = W.getLocation(y, Mt.LEFT), de = W.getLocation(y, Mt.RIGHT);
              if (de !== Me.NONE) {
                if (de !== I) throw new re("side location conflict", B.getCoordinate());
                oe === Me.NONE && At.shouldNeverReachHere("found single null side (at " + B.getCoordinate() + ")"), I = oe;
              } else At.isTrue(W.getLocation(y, Mt.LEFT) === Me.NONE, "found single null side"), W.setLocation(y, Mt.RIGHT, I), W.setLocation(y, Mt.LEFT, I);
            }
          }
        } }, { key: "getCoordinate", value: function() {
          var y = this.iterator();
          return y.hasNext() ? y.next().getCoordinate() : null;
        } }, { key: "print", value: function(y) {
          $e.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "isAreaLabelsConsistent", value: function(y) {
          return this.computeEdgeEndLabels(y.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        } }, { key: "checkAreaLabelsConsistent", value: function(y) {
          var o = this.getEdges();
          if (o.size() <= 0) return !0;
          var h = o.size() - 1, _ = o.get(h).getLabel().getLocation(y, Mt.LEFT);
          At.isTrue(_ !== Me.NONE, "Found unlabelled area edge");
          for (var I = _, D = this.iterator(); D.hasNext(); ) {
            var B = D.next().getLabel();
            At.isTrue(B.isArea(y), "Found non-area edge");
            var W = B.getLocation(y, Mt.LEFT), oe = B.getLocation(y, Mt.RIGHT);
            if (W === oe || oe !== I) return !1;
            I = W;
          }
          return !0;
        } }, { key: "findIndex", value: function(y) {
          this.iterator();
          for (var o = 0; o < this._edgeList.size(); o++)
            if (this._edgeList.get(o) === y) return o;
          return -1;
        } }, { key: "iterator", value: function() {
          return this.getEdges().iterator();
        } }, { key: "getEdges", value: function() {
          return this._edgeList === null && (this._edgeList = new me(this._edgeMap.values())), this._edgeList;
        } }, { key: "getLocation", value: function(y, o, h) {
          return this._ptInAreaLocation[y] === Me.NONE && (this._ptInAreaLocation[y] = ed.locate(o, h[y].getGeometry())), this._ptInAreaLocation[y];
        } }, { key: "toString", value: function() {
          var y = new ln();
          y.append("EdgeEndStar:   " + this.getCoordinate()), y.append(`
`);
          for (var o = this.iterator(); o.hasNext(); ) {
            var h = o.next();
            y.append(h), y.append(`
`);
          }
          return y.toString();
        } }, { key: "computeEdgeEndLabels", value: function(y) {
          for (var o = this.iterator(); o.hasNext(); )
            o.next().computeLabel(y);
        } }, { key: "computeLabelling", value: function(y) {
          this.computeEdgeEndLabels(y[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var o = [!1, !1], h = this.iterator(); h.hasNext(); ) for (var _ = h.next().getLabel(), I = 0; I < 2; I++) _.isLine(I) && _.getLocation(I) === Me.BOUNDARY && (o[I] = !0);
          for (var D = this.iterator(); D.hasNext(); ) for (var B = D.next(), W = B.getLabel(), oe = 0; oe < 2; oe++) if (W.isAnyNull(oe)) {
            var de = Me.NONE;
            if (o[oe]) de = Me.EXTERIOR;
            else {
              var Ze = B.getCoordinate();
              de = this.getLocation(oe, Ze, y);
            }
            W.setAllLocationsIfNull(oe, de);
          }
        } }, { key: "getDegree", value: function() {
          return this._edgeMap.size();
        } }, { key: "insertEdgeEnd", value: function(y, o) {
          this._edgeMap.put(y, o), this._edgeList = null;
        } }], [{ key: "constructor_", value: function() {
          this._edgeMap = new qr(), this._edgeList = null, this._ptInAreaLocation = [Me.NONE, Me.NONE];
        } }]);
      })(), wl = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "linkResultDirectedEdges", value: function() {
          this.getResultAreaEdges();
          for (var h = null, _ = null, I = this._SCANNING_FOR_INCOMING, D = 0; D < this._resultAreaEdgeList.size(); D++) {
            var B = this._resultAreaEdgeList.get(D), W = B.getSym();
            if (B.getLabel().isArea()) switch (h === null && B.isInResult() && (h = B), I) {
              case this._SCANNING_FOR_INCOMING:
                if (!W.isInResult()) continue;
                _ = W, I = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (!B.isInResult()) continue;
                _.setNext(B), I = this._SCANNING_FOR_INCOMING;
            }
          }
          if (I === this._LINKING_TO_OUTGOING) {
            if (h === null) throw new re("no outgoing dirEdge found", this.getCoordinate());
            At.isTrue(h.isInResult(), "unable to link last incoming dirEdge"), _.setNext(h);
          }
        } }, { key: "insert", value: function(h) {
          var _ = h;
          this.insertEdgeEnd(_, _);
        } }, { key: "getRightmostEdge", value: function() {
          var h = this.getEdges(), _ = h.size();
          if (_ < 1) return null;
          var I = h.get(0);
          if (_ === 1) return I;
          var D = h.get(_ - 1), B = I.getQuadrant(), W = D.getQuadrant();
          return nn.isNorthern(B) && nn.isNorthern(W) ? I : nn.isNorthern(B) || nn.isNorthern(W) ? I.getDy() !== 0 ? I : D.getDy() !== 0 ? D : (At.shouldNeverReachHere("found two horizontal edges incident on node"), null) : D;
        } }, { key: "print", value: function(h) {
          $e.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var _ = this.iterator(); _.hasNext(); ) {
            var I = _.next();
            h.print("out "), I.print(h), h.println(), h.print("in "), I.getSym().print(h), h.println();
          }
        } }, { key: "getResultAreaEdges", value: function() {
          if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new me();
          for (var h = this.iterator(); h.hasNext(); ) {
            var _ = h.next();
            (_.isInResult() || _.getSym().isInResult()) && this._resultAreaEdgeList.add(_);
          }
          return this._resultAreaEdgeList;
        } }, { key: "updateLabelling", value: function(h) {
          for (var _ = this.iterator(); _.hasNext(); ) {
            var I = _.next().getLabel();
            I.setAllLocationsIfNull(0, h.getLocation(0)), I.setAllLocationsIfNull(1, h.getLocation(1));
          }
        } }, { key: "linkAllDirectedEdges", value: function() {
          this.getEdges();
          for (var h = null, _ = null, I = this._edgeList.size() - 1; I >= 0; I--) {
            var D = this._edgeList.get(I), B = D.getSym();
            _ === null && (_ = B), h !== null && B.setNext(h), h = D;
          }
          _.setNext(h);
        } }, { key: "computeDepths", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], _ = this.findIndex(h), I = h.getDepth(Mt.LEFT), D = h.getDepth(Mt.RIGHT), B = this.computeDepths(_ + 1, this._edgeList.size(), I);
            if (this.computeDepths(0, _, B) !== D) throw new re("depth mismatch at " + h.getCoordinate());
          } else if (arguments.length === 3) {
            for (var W = arguments[1], oe = arguments[2], de = arguments[0]; de < W; de++) {
              var Ze = this._edgeList.get(de);
              Ze.setEdgeDepths(Mt.RIGHT, oe), oe = Ze.getDepth(Mt.LEFT);
            }
            return oe;
          }
        } }, { key: "mergeSymLabels", value: function() {
          for (var h = this.iterator(); h.hasNext(); ) {
            var _ = h.next();
            _.getLabel().merge(_.getSym().getLabel());
          }
        } }, { key: "linkMinimalDirectedEdges", value: function(h) {
          for (var _ = null, I = null, D = this._SCANNING_FOR_INCOMING, B = this._resultAreaEdgeList.size() - 1; B >= 0; B--) {
            var W = this._resultAreaEdgeList.get(B), oe = W.getSym();
            switch (_ === null && W.getEdgeRing() === h && (_ = W), D) {
              case this._SCANNING_FOR_INCOMING:
                if (oe.getEdgeRing() !== h) continue;
                I = oe, D = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (W.getEdgeRing() !== h) continue;
                I.setNextMin(W), D = this._SCANNING_FOR_INCOMING;
            }
          }
          D === this._LINKING_TO_OUTGOING && (At.isTrue(_ !== null, "found null for first outgoing dirEdge"), At.isTrue(_.getEdgeRing() === h, "unable to link last incoming dirEdge"), I.setNextMin(_));
        } }, { key: "getOutgoingDegree", value: function() {
          if (arguments.length === 0) {
            for (var h = 0, _ = this.iterator(); _.hasNext(); )
              _.next().isInResult() && h++;
            return h;
          }
          if (arguments.length === 1) {
            for (var I = arguments[0], D = 0, B = this.iterator(); B.hasNext(); )
              B.next().getEdgeRing() === I && D++;
            return D;
          }
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "findCoveredLineEdges", value: function() {
          for (var h = Me.NONE, _ = this.iterator(); _.hasNext(); ) {
            var I = _.next(), D = I.getSym();
            if (!I.isLineEdge()) {
              if (I.isInResult()) {
                h = Me.INTERIOR;
                break;
              }
              if (D.isInResult()) {
                h = Me.EXTERIOR;
                break;
              }
            }
          }
          if (h === Me.NONE) return null;
          for (var B = h, W = this.iterator(); W.hasNext(); ) {
            var oe = W.next(), de = oe.getSym();
            oe.isLineEdge() ? oe.getEdge().setCovered(B === Me.INTERIOR) : (oe.isInResult() && (B = Me.EXTERIOR), de.isInResult() && (B = Me.INTERIOR));
          }
        } }, { key: "computeLabelling", value: function(h) {
          ce(o, "computeLabelling", this, 1).call(this, h), this._label = new ki(Me.NONE);
          for (var _ = this.iterator(); _.hasNext(); ) for (var I = _.next().getEdge().getLabel(), D = 0; D < 2; D++) {
            var B = I.getLocation(D);
            B !== Me.INTERIOR && B !== Me.BOUNDARY || this._label.setLocation(D, Me.INTERIOR);
          }
        } }], [{ key: "constructor_", value: function() {
          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        } }]);
      })(io), Ic = (function(y) {
        function o() {
          return x(this, o), p(this, o);
        }
        return $(o, y), u(o, [{ key: "createNode", value: function(h) {
          return new Ar(h, new wl());
        } }]);
      })(ia), yu = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "compareTo", value: function(o) {
          var h = o;
          return y.compareOriented(this._pts, this._orientation, h._pts, h._orientation);
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._orientation = null;
          var o = arguments[0];
          this._pts = o, this._orientation = y.orientation(o);
        } }, { key: "orientation", value: function(o) {
          return wt.increasingDirection(o) === 1;
        } }, { key: "compareOriented", value: function(o, h, _, I) {
          for (var D = h ? 1 : -1, B = I ? 1 : -1, W = h ? o.length : -1, oe = I ? _.length : -1, de = h ? 0 : o.length - 1, Ze = I ? 0 : _.length - 1; ; ) {
            var rt = o[de].compareTo(_[Ze]);
            if (rt !== 0) return rt;
            var xt = (de += D) === W, jt = (Ze += B) === oe;
            if (xt && !jt) return -1;
            if (!xt && jt) return 1;
            if (xt && jt) return 0;
          }
        } }]);
      })(), vu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "print", value: function(y) {
          y.print("MULTILINESTRING ( ");
          for (var o = 0; o < this._edges.size(); o++) {
            var h = this._edges.get(o);
            o > 0 && y.print(","), y.print("(");
            for (var _ = h.getCoordinates(), I = 0; I < _.length; I++) I > 0 && y.print(","), y.print(_[I].x + " " + _[I].y);
            y.println(")");
          }
          y.print(")  ");
        } }, { key: "addAll", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) this.add(o.next());
        } }, { key: "findEdgeIndex", value: function(y) {
          for (var o = 0; o < this._edges.size(); o++) if (this._edges.get(o).equals(y)) return o;
          return -1;
        } }, { key: "iterator", value: function() {
          return this._edges.iterator();
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "get", value: function(y) {
          return this._edges.get(y);
        } }, { key: "findEqualEdge", value: function(y) {
          var o = new yu(y.getCoordinates());
          return this._ocaMap.get(o);
        } }, { key: "add", value: function(y) {
          this._edges.add(y);
          var o = new yu(y.getCoordinates());
          this._ocaMap.put(o, y);
        } }], [{ key: "constructor_", value: function() {
          this._edges = new me(), this._ocaMap = new qr();
        } }]);
      })(), El = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "processIntersections", value: function(y, o, h, _) {
        } }, { key: "isDone", value: function() {
        } }]);
      })(), xu = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isTrivialIntersection", value: function(o, h, _, I) {
          if (o === _ && this._li.getIntersectionNum() === 1) {
            if (y.isAdjacentSegments(h, I)) return !0;
            if (o.isClosed()) {
              var D = o.size() - 1;
              if (h === 0 && I === D || I === 0 && h === D) return !0;
            }
          }
          return !1;
        } }, { key: "getProperIntersectionPoint", value: function() {
          return this._properIntersectionPoint;
        } }, { key: "hasProperInteriorIntersection", value: function() {
          return this._hasProperInterior;
        } }, { key: "getLineIntersector", value: function() {
          return this._li;
        } }, { key: "hasProperIntersection", value: function() {
          return this._hasProper;
        } }, { key: "processIntersections", value: function(o, h, _, I) {
          if (o === _ && h === I) return null;
          this.numTests++;
          var D = o.getCoordinates()[h], B = o.getCoordinates()[h + 1], W = _.getCoordinates()[I], oe = _.getCoordinates()[I + 1];
          this._li.computeIntersection(D, B, W, oe), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(o, h, _, I) || (this._hasIntersection = !0, o.addIntersections(this._li, h, 0), _.addIntersections(this._li, I, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
        } }, { key: "hasIntersection", value: function() {
          return this._hasIntersection;
        } }, { key: "isDone", value: function() {
          return !1;
        } }, { key: "hasInteriorIntersection", value: function() {
          return this._hasInterior;
        } }, { key: "interfaces_", get: function() {
          return [El];
        } }], [{ key: "constructor_", value: function() {
          this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var o = arguments[0];
          this._li = o;
        } }, { key: "isAdjacentSegments", value: function(o, h) {
          return Math.abs(o - h) === 1;
        } }]);
      })(), Mc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getSegmentIndex", value: function() {
          return this.segmentIndex;
        } }, { key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(y) {
          y.print(this.coord), y.print(" seg # = " + this.segmentIndex), y.println(" dist = " + this.dist);
        } }, { key: "compareTo", value: function(y) {
          var o = y;
          return this.compare(o.segmentIndex, o.dist);
        } }, { key: "isEndPoint", value: function(y) {
          return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === y;
        } }, { key: "toString", value: function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        } }, { key: "getDistance", value: function() {
          return this.dist;
        } }, { key: "compare", value: function(y, o) {
          return this.segmentIndex < y ? -1 : this.segmentIndex > y ? 1 : this.dist < o ? -1 : this.dist > o ? 1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [ut];
        } }], [{ key: "constructor_", value: function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var y = arguments[0], o = arguments[1], h = arguments[2];
          this.coord = new He(y), this.segmentIndex = o, this.dist = h;
        } }]);
      })(), Cc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "print", value: function(y) {
          y.println("Intersections:");
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(y) {
          this.addEndpoints();
          for (var o = this.iterator(), h = o.next(); o.hasNext(); ) {
            var _ = o.next(), I = this.createSplitEdge(h, _);
            y.add(I), h = _;
          }
        } }, { key: "addEndpoints", value: function() {
          var y = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[y], y, 0);
        } }, { key: "createSplitEdge", value: function(y, o) {
          var h = o.segmentIndex - y.segmentIndex + 2, _ = this.edge.pts[o.segmentIndex], I = o.dist > 0 || !o.coord.equals2D(_);
          I || h--;
          var D = new Array(h).fill(null), B = 0;
          D[B++] = new He(y.coord);
          for (var W = y.segmentIndex + 1; W <= o.segmentIndex; W++) D[B++] = this.edge.pts[W];
          return I && (D[B] = o.coord), new wu(D, new ki(this.edge._label));
        } }, { key: "add", value: function(y, o, h) {
          var _ = new Mc(y, o, h), I = this._nodeMap.get(_);
          return I !== null ? I : (this._nodeMap.put(_, _), _);
        } }, { key: "isIntersection", value: function(y) {
          for (var o = this.iterator(); o.hasNext(); )
            if (o.next().coord.equals(y)) return !0;
          return !1;
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new qr(), this.edge = null;
          var y = arguments[0];
          this.edge = y;
        } }]);
      })(), Pc = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isIntersects", value: function() {
          return !this.isDisjoint();
        } }, { key: "isCovers", value: function() {
          return (y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) || y.isTrue(this._matrix[Me.INTERIOR][Me.BOUNDARY]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.INTERIOR]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.BOUNDARY])) && this._matrix[Me.EXTERIOR][Me.INTERIOR] === lt.FALSE && this._matrix[Me.EXTERIOR][Me.BOUNDARY] === lt.FALSE;
        } }, { key: "isCoveredBy", value: function() {
          return (y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) || y.isTrue(this._matrix[Me.INTERIOR][Me.BOUNDARY]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.INTERIOR]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.BOUNDARY])) && this._matrix[Me.INTERIOR][Me.EXTERIOR] === lt.FALSE && this._matrix[Me.BOUNDARY][Me.EXTERIOR] === lt.FALSE;
        } }, { key: "set", value: function() {
          if (arguments.length === 1) for (var o = arguments[0], h = 0; h < o.length; h++) {
            var _ = Math.trunc(h / 3), I = h % 3;
            this._matrix[_][I] = lt.toDimensionValue(o.charAt(h));
          }
          else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], W = arguments[2];
            this._matrix[D][B] = W;
          }
        } }, { key: "isContains", value: function() {
          return y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && this._matrix[Me.EXTERIOR][Me.INTERIOR] === lt.FALSE && this._matrix[Me.EXTERIOR][Me.BOUNDARY] === lt.FALSE;
        } }, { key: "setAtLeast", value: function() {
          if (arguments.length === 1) for (var o = arguments[0], h = 0; h < o.length; h++) {
            var _ = Math.trunc(h / 3), I = h % 3;
            this.setAtLeast(_, I, lt.toDimensionValue(o.charAt(h)));
          }
          else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], W = arguments[2];
            this._matrix[D][B] < W && (this._matrix[D][B] = W);
          }
        } }, { key: "setAtLeastIfValid", value: function(o, h, _) {
          o >= 0 && h >= 0 && this.setAtLeast(o, h, _);
        } }, { key: "isWithin", value: function() {
          return y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && this._matrix[Me.INTERIOR][Me.EXTERIOR] === lt.FALSE && this._matrix[Me.BOUNDARY][Me.EXTERIOR] === lt.FALSE;
        } }, { key: "isTouches", value: function(o, h) {
          return o > h ? this.isTouches(h, o) : (o === lt.A && h === lt.A || o === lt.L && h === lt.L || o === lt.L && h === lt.A || o === lt.P && h === lt.A || o === lt.P && h === lt.L) && this._matrix[Me.INTERIOR][Me.INTERIOR] === lt.FALSE && (y.isTrue(this._matrix[Me.INTERIOR][Me.BOUNDARY]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.INTERIOR]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.BOUNDARY]));
        } }, { key: "isOverlaps", value: function(o, h) {
          return o === lt.P && h === lt.P || o === lt.A && h === lt.A ? y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && y.isTrue(this._matrix[Me.INTERIOR][Me.EXTERIOR]) && y.isTrue(this._matrix[Me.EXTERIOR][Me.INTERIOR]) : o === lt.L && h === lt.L && this._matrix[Me.INTERIOR][Me.INTERIOR] === 1 && y.isTrue(this._matrix[Me.INTERIOR][Me.EXTERIOR]) && y.isTrue(this._matrix[Me.EXTERIOR][Me.INTERIOR]);
        } }, { key: "isEquals", value: function(o, h) {
          return o === h && y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && this._matrix[Me.INTERIOR][Me.EXTERIOR] === lt.FALSE && this._matrix[Me.BOUNDARY][Me.EXTERIOR] === lt.FALSE && this._matrix[Me.EXTERIOR][Me.INTERIOR] === lt.FALSE && this._matrix[Me.EXTERIOR][Me.BOUNDARY] === lt.FALSE;
        } }, { key: "toString", value: function() {
          for (var o = new Mr("123456789"), h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) o.setCharAt(3 * h + _, lt.toDimensionSymbol(this._matrix[h][_]));
          return o.toString();
        } }, { key: "setAll", value: function(o) {
          for (var h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) this._matrix[h][_] = o;
        } }, { key: "get", value: function(o, h) {
          return this._matrix[o][h];
        } }, { key: "transpose", value: function() {
          var o = this._matrix[1][0];
          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = o, o = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = o, o = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = o, this;
        } }, { key: "matches", value: function(o) {
          if (o.length !== 9) throw new et("Should be length 9: " + o);
          for (var h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) if (!y.matches(this._matrix[h][_], o.charAt(3 * h + _))) return !1;
          return !0;
        } }, { key: "add", value: function(o) {
          for (var h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) this.setAtLeast(h, _, o.get(h, _));
        } }, { key: "isDisjoint", value: function() {
          return this._matrix[Me.INTERIOR][Me.INTERIOR] === lt.FALSE && this._matrix[Me.INTERIOR][Me.BOUNDARY] === lt.FALSE && this._matrix[Me.BOUNDARY][Me.INTERIOR] === lt.FALSE && this._matrix[Me.BOUNDARY][Me.BOUNDARY] === lt.FALSE;
        } }, { key: "isCrosses", value: function(o, h) {
          return o === lt.P && h === lt.L || o === lt.P && h === lt.A || o === lt.L && h === lt.A ? y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && y.isTrue(this._matrix[Me.INTERIOR][Me.EXTERIOR]) : o === lt.L && h === lt.P || o === lt.A && h === lt.P || o === lt.A && h === lt.L ? y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && y.isTrue(this._matrix[Me.EXTERIOR][Me.INTERIOR]) : o === lt.L && h === lt.L && this._matrix[Me.INTERIOR][Me.INTERIOR] === 0;
        } }, { key: "interfaces_", get: function() {
          return [Q];
        } }], [{ key: "constructor_", value: function() {
          if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map((function() {
            return Array(3);
          })), this.setAll(lt.FALSE);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "string") {
              var o = arguments[0];
              y.constructor_.call(this), this.set(o);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              y.constructor_.call(this), this._matrix[Me.INTERIOR][Me.INTERIOR] = h._matrix[Me.INTERIOR][Me.INTERIOR], this._matrix[Me.INTERIOR][Me.BOUNDARY] = h._matrix[Me.INTERIOR][Me.BOUNDARY], this._matrix[Me.INTERIOR][Me.EXTERIOR] = h._matrix[Me.INTERIOR][Me.EXTERIOR], this._matrix[Me.BOUNDARY][Me.INTERIOR] = h._matrix[Me.BOUNDARY][Me.INTERIOR], this._matrix[Me.BOUNDARY][Me.BOUNDARY] = h._matrix[Me.BOUNDARY][Me.BOUNDARY], this._matrix[Me.BOUNDARY][Me.EXTERIOR] = h._matrix[Me.BOUNDARY][Me.EXTERIOR], this._matrix[Me.EXTERIOR][Me.INTERIOR] = h._matrix[Me.EXTERIOR][Me.INTERIOR], this._matrix[Me.EXTERIOR][Me.BOUNDARY] = h._matrix[Me.EXTERIOR][Me.BOUNDARY], this._matrix[Me.EXTERIOR][Me.EXTERIOR] = h._matrix[Me.EXTERIOR][Me.EXTERIOR];
            }
          }
        } }, { key: "matches", value: function() {
          if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
            var o = arguments[0], h = arguments[1];
            return h === lt.SYM_DONTCARE || h === lt.SYM_TRUE && (o >= 0 || o === lt.TRUE) || h === lt.SYM_FALSE && o === lt.FALSE || h === lt.SYM_P && o === lt.P || h === lt.SYM_L && o === lt.L || h === lt.SYM_A && o === lt.A;
          }
          if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
            var _ = arguments[1];
            return new y(arguments[0]).matches(_);
          }
        } }, { key: "isTrue", value: function(o) {
          return o >= 0 || o === lt.TRUE;
        } }]);
      })(), Ma = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "size", value: function() {
          return this._size;
        } }, { key: "addAll", value: function(o) {
          return o === null || o.length === 0 ? null : (this.ensureCapacity(this._size + o.length), $e.arraycopy(o, 0, this._data, this._size, o.length), void (this._size += o.length));
        } }, { key: "ensureCapacity", value: function(o) {
          if (o <= this._data.length) return null;
          var h = Math.max(o, 2 * this._data.length);
          this._data = Ir.copyOf(this._data, h);
        } }, { key: "toArray", value: function() {
          var o = new Array(this._size).fill(null);
          return $e.arraycopy(this._data, 0, o, 0, this._size), o;
        } }, { key: "add", value: function(o) {
          this.ensureCapacity(this._size + 1), this._data[this._size] = o, ++this._size;
        } }], [{ key: "constructor_", value: function() {
          if (this._data = null, this._size = 0, arguments.length === 0) y.constructor_.call(this, 10);
          else if (arguments.length === 1) {
            var o = arguments[0];
            this._data = new Array(o).fill(null);
          }
        } }]);
      })(), Ac = (function() {
        function y() {
          x(this, y);
        }
        return u(y, [{ key: "getChainStartIndices", value: function(o) {
          var h = 0, _ = new Ma(Math.trunc(o.length / 2));
          _.add(h);
          do {
            var I = this.findChainEnd(o, h);
            _.add(I), h = I;
          } while (h < o.length - 1);
          return _.toArray();
        } }, { key: "findChainEnd", value: function(o, h) {
          for (var _ = nn.quadrant(o[h], o[h + 1]), I = h + 1; I < o.length && nn.quadrant(o[I - 1], o[I]) === _; )
            I++;
          return I - 1;
        } }, { key: "OLDgetChainStartIndices", value: function(o) {
          var h = 0, _ = new me();
          _.add(h);
          do {
            var I = this.findChainEnd(o, h);
            _.add(I), h = I;
          } while (h < o.length - 1);
          return y.toIntArray(_);
        } }], [{ key: "toIntArray", value: function(o) {
          for (var h = new Array(o.size()).fill(null), _ = 0; _ < h.length; _++) h[_] = o.get(_).intValue();
          return h;
        } }]);
      })(), bu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "getMaxX", value: function(y) {
          var o = this.pts[this.startIndex[y]].x, h = this.pts[this.startIndex[y + 1]].x;
          return o > h ? o : h;
        } }, { key: "getMinX", value: function(y) {
          var o = this.pts[this.startIndex[y]].x, h = this.pts[this.startIndex[y + 1]].x;
          return o < h ? o : h;
        } }, { key: "computeIntersectsForChain", value: function() {
          if (arguments.length === 4) {
            var y = arguments[0], o = arguments[1], h = arguments[2], _ = arguments[3];
            this.computeIntersectsForChain(this.startIndex[y], this.startIndex[y + 1], o, o.startIndex[h], o.startIndex[h + 1], _);
          } else if (arguments.length === 6) {
            var I = arguments[0], D = arguments[1], B = arguments[2], W = arguments[3], oe = arguments[4], de = arguments[5];
            if (D - I == 1 && oe - W == 1) return de.addIntersections(this.e, I, B.e, W), null;
            if (!this.overlaps(I, D, B, W, oe)) return null;
            var Ze = Math.trunc((I + D) / 2), rt = Math.trunc((W + oe) / 2);
            I < Ze && (W < rt && this.computeIntersectsForChain(I, Ze, B, W, rt, de), rt < oe && this.computeIntersectsForChain(I, Ze, B, rt, oe, de)), Ze < D && (W < rt && this.computeIntersectsForChain(Ze, D, B, W, rt, de), rt < oe && this.computeIntersectsForChain(Ze, D, B, rt, oe, de));
          }
        } }, { key: "overlaps", value: function(y, o, h, _, I) {
          return fr.intersects(this.pts[y], this.pts[o], h.pts[_], h.pts[I]);
        } }, { key: "getStartIndexes", value: function() {
          return this.startIndex;
        } }, { key: "computeIntersects", value: function(y, o) {
          for (var h = 0; h < this.startIndex.length - 1; h++) for (var _ = 0; _ < y.startIndex.length - 1; _++) this.computeIntersectsForChain(h, y, _, o);
        } }], [{ key: "constructor_", value: function() {
          this.e = null, this.pts = null, this.startIndex = null;
          var y = arguments[0];
          this.e = y, this.pts = y.getCoordinates();
          var o = new Ac();
          this.startIndex = o.getChainStartIndices(this.pts);
        } }]);
      })(), Ca = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getDepth", value: function(o, h) {
          return this._depth[o][h];
        } }, { key: "setDepth", value: function(o, h, _) {
          this._depth[o][h] = _;
        } }, { key: "isNull", value: function() {
          if (arguments.length === 0) {
            for (var o = 0; o < 2; o++) for (var h = 0; h < 3; h++) if (this._depth[o][h] !== y.NULL_VALUE) return !1;
            return !0;
          }
          if (arguments.length === 1) {
            var _ = arguments[0];
            return this._depth[_][1] === y.NULL_VALUE;
          }
          if (arguments.length === 2) {
            var I = arguments[0], D = arguments[1];
            return this._depth[I][D] === y.NULL_VALUE;
          }
        } }, { key: "normalize", value: function() {
          for (var o = 0; o < 2; o++) if (!this.isNull(o)) {
            var h = this._depth[o][1];
            this._depth[o][2] < h && (h = this._depth[o][2]), h < 0 && (h = 0);
            for (var _ = 1; _ < 3; _++) {
              var I = 0;
              this._depth[o][_] > h && (I = 1), this._depth[o][_] = I;
            }
          }
        } }, { key: "getDelta", value: function(o) {
          return this._depth[o][Mt.RIGHT] - this._depth[o][Mt.LEFT];
        } }, { key: "getLocation", value: function(o, h) {
          return this._depth[o][h] <= 0 ? Me.EXTERIOR : Me.INTERIOR;
        } }, { key: "toString", value: function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        } }, { key: "add", value: function() {
          if (arguments.length === 1) for (var o = arguments[0], h = 0; h < 2; h++) for (var _ = 1; _ < 3; _++) {
            var I = o.getLocation(h, _);
            I !== Me.EXTERIOR && I !== Me.INTERIOR || (this.isNull(h, _) ? this._depth[h][_] = y.depthAtLocation(I) : this._depth[h][_] += y.depthAtLocation(I));
          }
          else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1];
            arguments[2] === Me.INTERIOR && this._depth[D][B]++;
          }
        } }], [{ key: "constructor_", value: function() {
          this._depth = Array(2).fill().map((function() {
            return Array(3);
          }));
          for (var o = 0; o < 2; o++) for (var h = 0; h < 3; h++) this._depth[o][h] = y.NULL_VALUE;
        } }, { key: "depthAtLocation", value: function(o) {
          return o === Me.EXTERIOR ? 0 : o === Me.INTERIOR ? 1 : y.NULL_VALUE;
        } }]);
      })();
      Ca.NULL_VALUE = -1;
      var wu = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getDepth", value: function() {
          return this._depth;
        } }, { key: "getCollapsedEdge", value: function() {
          var h = new Array(2).fill(null);
          return h[0] = this.pts[0], h[1] = this.pts[1], new o(h, ki.toLineLabel(this._label));
        } }, { key: "isIsolated", value: function() {
          return this._isIsolated;
        } }, { key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "setIsolated", value: function(h) {
          this._isIsolated = h;
        } }, { key: "setName", value: function(h) {
          this._name = h;
        } }, { key: "equals", value: function(h) {
          if (!(h instanceof o)) return !1;
          var _ = h;
          if (this.pts.length !== _.pts.length) return !1;
          for (var I = !0, D = !0, B = this.pts.length, W = 0; W < this.pts.length; W++) if (this.pts[W].equals2D(_.pts[W]) || (I = !1), this.pts[W].equals2D(_.pts[--B]) || (D = !1), !I && !D) return !1;
          return !0;
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.pts[h];
          }
        } }, { key: "print", value: function(h) {
          h.print("edge " + this._name + ": "), h.print("LINESTRING (");
          for (var _ = 0; _ < this.pts.length; _++) _ > 0 && h.print(","), h.print(this.pts[_].x + " " + this.pts[_].y);
          h.print(")  " + this._label + " " + this._depthDelta);
        } }, { key: "computeIM", value: function(h) {
          o.updateIM(this._label, h);
        } }, { key: "isCollapsed", value: function() {
          return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
        } }, { key: "isClosed", value: function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        } }, { key: "getMaximumSegmentIndex", value: function() {
          return this.pts.length - 1;
        } }, { key: "getDepthDelta", value: function() {
          return this._depthDelta;
        } }, { key: "getNumPoints", value: function() {
          return this.pts.length;
        } }, { key: "printReverse", value: function(h) {
          h.print("edge " + this._name + ": ");
          for (var _ = this.pts.length - 1; _ >= 0; _--) h.print(this.pts[_] + " ");
          h.println("");
        } }, { key: "getMonotoneChainEdge", value: function() {
          return this._mce === null && (this._mce = new bu(this)), this._mce;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            this._env = new fr();
            for (var h = 0; h < this.pts.length; h++) this._env.expandToInclude(this.pts[h]);
          }
          return this._env;
        } }, { key: "addIntersection", value: function(h, _, I, D) {
          var B = new He(h.getIntersection(D)), W = _, oe = h.getEdgeDistance(I, D), de = W + 1;
          if (de < this.pts.length) {
            var Ze = this.pts[de];
            B.equals2D(Ze) && (W = de, oe = 0);
          }
          this.eiList.add(B, W, oe);
        } }, { key: "toString", value: function() {
          var h = new Mr();
          h.append("edge " + this._name + ": "), h.append("LINESTRING (");
          for (var _ = 0; _ < this.pts.length; _++) _ > 0 && h.append(","), h.append(this.pts[_].x + " " + this.pts[_].y);
          return h.append(")  " + this._label + " " + this._depthDelta), h.toString();
        } }, { key: "isPointwiseEqual", value: function(h) {
          if (this.pts.length !== h.pts.length) return !1;
          for (var _ = 0; _ < this.pts.length; _++) if (!this.pts[_].equals2D(h.pts[_])) return !1;
          return !0;
        } }, { key: "setDepthDelta", value: function(h) {
          this._depthDelta = h;
        } }, { key: "getEdgeIntersectionList", value: function() {
          return this.eiList;
        } }, { key: "addIntersections", value: function(h, _, I) {
          for (var D = 0; D < h.getIntersectionNum(); D++) this.addIntersection(h, _, I, D);
        } }], [{ key: "constructor_", value: function() {
          if (this.pts = null, this._env = null, this.eiList = new Cc(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new Ca(), this._depthDelta = 0, arguments.length === 1) {
            var h = arguments[0];
            o.constructor_.call(this, h, null);
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.pts = _, this._label = I;
          }
        } }, { key: "updateIM", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof Pc && arguments[0] instanceof ki)) return ce(o, "updateIM", this).apply(this, arguments);
          var h = arguments[0], _ = arguments[1];
          _.setAtLeastIfValid(h.getLocation(0, Mt.ON), h.getLocation(1, Mt.ON), 1), h.isArea() && (_.setAtLeastIfValid(h.getLocation(0, Mt.LEFT), h.getLocation(1, Mt.LEFT), 2), _.setAtLeastIfValid(h.getLocation(0, Mt.RIGHT), h.getLocation(1, Mt.RIGHT), 2));
        } }]);
      })(Kt), zo = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "setWorkingPrecisionModel", value: function(o) {
          this._workingPrecisionModel = o;
        } }, { key: "insertUniqueEdge", value: function(o) {
          var h = this._edgeList.findEqualEdge(o);
          if (h !== null) {
            var _ = h.getLabel(), I = o.getLabel();
            h.isPointwiseEqual(o) || (I = new ki(o.getLabel())).flip(), _.merge(I);
            var D = y.depthDelta(I), B = h.getDepthDelta() + D;
            h.setDepthDelta(B);
          } else this._edgeList.add(o), o.setDepthDelta(y.depthDelta(o.getLabel()));
        } }, { key: "buildSubgraphs", value: function(o, h) {
          for (var _ = new me(), I = o.iterator(); I.hasNext(); ) {
            var D = I.next(), B = D.getRightmostCoordinate(), W = new ka(_).getDepth(B);
            D.computeDepth(W), D.findResultEdges(), _.add(D), h.add(D.getDirectedEdges(), D.getNodes());
          }
        } }, { key: "createSubgraphs", value: function(o) {
          for (var h = new me(), _ = o.getNodes().iterator(); _.hasNext(); ) {
            var I = _.next();
            if (!I.isVisited()) {
              var D = new We();
              D.create(I), h.add(D);
            }
          }
          return sr.sort(h, sr.reverseOrder()), h;
        } }, { key: "createEmptyResultGeometry", value: function() {
          return this._geomFact.createPolygon();
        } }, { key: "getNoder", value: function(o) {
          if (this._workingNoder !== null) return this._workingNoder;
          var h = new mu(), _ = new Wi();
          return _.setPrecisionModel(o), h.setSegmentIntersector(new xu(_)), h;
        } }, { key: "buffer", value: function(o, h) {
          var _ = this._workingPrecisionModel;
          _ === null && (_ = o.getPrecisionModel()), this._geomFact = o.getFactory();
          var I = new no(_, this._bufParams), D = new Ia(o, h, I).getCurves();
          if (D.size() <= 0) return this.createEmptyResultGeometry();
          this.computeNodedEdges(D, _), this._graph = new ws(new Ic()), this._graph.addEdges(this._edgeList.getEdges());
          var B = this.createSubgraphs(this._graph), W = new Sc(this._geomFact);
          this.buildSubgraphs(B, W);
          var oe = W.getPolygons();
          return oe.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(oe);
        } }, { key: "computeNodedEdges", value: function(o, h) {
          var _ = this.getNoder(h);
          _.computeNodes(o);
          for (var I = _.getNodedSubstrings().iterator(); I.hasNext(); ) {
            var D = I.next(), B = D.getCoordinates();
            if (B.length !== 2 || !B[0].equals2D(B[1])) {
              var W = D.getData(), oe = new wu(D.getCoordinates(), new ki(W));
              this.insertUniqueEdge(oe);
            }
          }
        } }, { key: "setNoder", value: function(o) {
          this._workingNoder = o;
        } }], [{ key: "constructor_", value: function() {
          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new vu();
          var o = arguments[0];
          this._bufParams = o;
        } }, { key: "depthDelta", value: function(o) {
          var h = o.getLocation(0, Mt.LEFT), _ = o.getLocation(0, Mt.RIGHT);
          return h === Me.INTERIOR && _ === Me.EXTERIOR ? 1 : h === Me.EXTERIOR && _ === Me.INTERIOR ? -1 : 0;
        } }, { key: "convertSegStrings", value: function(o) {
          for (var h = new si(), _ = new me(); o.hasNext(); ) {
            var I = o.next(), D = h.createLineString(I.getCoordinates());
            _.add(D);
          }
          return h.buildGeometry(_);
        } }]);
      })(), td = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "rescale", value: function() {
          if (tr(arguments[0], br)) for (var o = arguments[0].iterator(); o.hasNext(); ) {
            var h = o.next();
            this.rescale(h.getCoordinates());
          }
          else if (arguments[0] instanceof Array) {
            for (var _ = arguments[0], I = 0; I < _.length; I++) _[I].x = _[I].x / this._scaleFactor + this._offsetX, _[I].y = _[I].y / this._scaleFactor + this._offsetY;
            _.length === 2 && _[0].equals2D(_[1]) && $e.out.println(_);
          }
        } }, { key: "scale", value: function() {
          if (tr(arguments[0], br)) {
            for (var o = arguments[0], h = new me(o.size()), _ = o.iterator(); _.hasNext(); ) {
              var I = _.next();
              h.add(new ji(this.scale(I.getCoordinates()), I.getData()));
            }
            return h;
          }
          if (arguments[0] instanceof Array) {
            for (var D = arguments[0], B = new Array(D.length).fill(null), W = 0; W < D.length; W++) B[W] = new He(Math.round((D[W].x - this._offsetX) * this._scaleFactor), Math.round((D[W].y - this._offsetY) * this._scaleFactor), D[W].getZ());
            return wt.removeRepeatedPoints(B);
          }
        } }, { key: "isIntegerPrecision", value: function() {
          return this._scaleFactor === 1;
        } }, { key: "getNodedSubstrings", value: function() {
          var o = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(o), o;
        } }, { key: "computeNodes", value: function(o) {
          var h = o;
          this._isScaled && (h = this.scale(o)), this._noder.computeNodes(h);
        } }, { key: "interfaces_", get: function() {
          return [No];
        } }], [{ key: "constructor_", value: function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            y.constructor_.call(this, o, h, 0, 0);
          } else if (arguments.length === 4) {
            var _ = arguments[0], I = arguments[1];
            this._noder = _, this._scaleFactor = I, this._isScaled = !this.isIntegerPrecision();
          }
        } }]);
      })(), Lc = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "checkEndPtVertexIntersections", value: function() {
          if (arguments.length === 0) for (var o = this._segStrings.iterator(); o.hasNext(); ) {
            var h = o.next().getCoordinates();
            this.checkEndPtVertexIntersections(h[0], this._segStrings), this.checkEndPtVertexIntersections(h[h.length - 1], this._segStrings);
          }
          else if (arguments.length === 2) {
            for (var _ = arguments[0], I = arguments[1].iterator(); I.hasNext(); ) for (var D = I.next().getCoordinates(), B = 1; B < D.length - 1; B++) if (D[B].equals(_)) throw new Zt("found endpt/interior pt intersection at index " + B + " :pt " + _);
          }
        } }, { key: "checkInteriorIntersections", value: function() {
          if (arguments.length === 0) for (var o = this._segStrings.iterator(); o.hasNext(); ) for (var h = o.next(), _ = this._segStrings.iterator(); _.hasNext(); ) {
            var I = _.next();
            this.checkInteriorIntersections(h, I);
          }
          else if (arguments.length === 2) for (var D = arguments[0], B = arguments[1], W = D.getCoordinates(), oe = B.getCoordinates(), de = 0; de < W.length - 1; de++) for (var Ze = 0; Ze < oe.length - 1; Ze++) this.checkInteriorIntersections(D, de, B, Ze);
          else if (arguments.length === 4) {
            var rt = arguments[0], xt = arguments[1], jt = arguments[2], qt = arguments[3];
            if (rt === jt && xt === qt) return null;
            var Wt = rt.getCoordinates()[xt], _r = rt.getCoordinates()[xt + 1], lr = jt.getCoordinates()[qt], Br = jt.getCoordinates()[qt + 1];
            if (this._li.computeIntersection(Wt, _r, lr, Br), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, Wt, _r) || this.hasInteriorIntersection(this._li, lr, Br))) throw new Zt("found non-noded intersection at " + Wt + "-" + _r + " and " + lr + "-" + Br);
          }
        } }, { key: "checkValid", value: function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        } }, { key: "checkCollapses", value: function() {
          if (arguments.length === 0) for (var o = this._segStrings.iterator(); o.hasNext(); ) {
            var h = o.next();
            this.checkCollapses(h);
          }
          else if (arguments.length === 1) for (var _ = arguments[0].getCoordinates(), I = 0; I < _.length - 2; I++) this.checkCollapse(_[I], _[I + 1], _[I + 2]);
        } }, { key: "hasInteriorIntersection", value: function(o, h, _) {
          for (var I = 0; I < o.getIntersectionNum(); I++) {
            var D = o.getIntersection(I);
            if (!D.equals(h) && !D.equals(_)) return !0;
          }
          return !1;
        } }, { key: "checkCollapse", value: function(o, h, _) {
          if (o.equals(_)) throw new Zt("found non-noded collapse at " + y.fact.createLineString([o, h, _]));
        } }], [{ key: "constructor_", value: function() {
          this._li = new Wi(), this._segStrings = null;
          var o = arguments[0];
          this._segStrings = o;
        } }]);
      })();
      Lc.fact = new si();
      var Sl = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "intersectsScaled", value: function(o, h) {
          var _ = Math.min(o.x, h.x), I = Math.max(o.x, h.x), D = Math.min(o.y, h.y), B = Math.max(o.y, h.y), W = this._maxx < _ || this._minx > I || this._maxy < D || this._miny > B;
          if (W) return !1;
          var oe = this.intersectsToleranceSquare(o, h);
          return At.isTrue(!(W && oe), "Found bad envelope test"), oe;
        } }, { key: "initCorners", value: function(o) {
          var h = 0.5;
          this._minx = o.x - h, this._maxx = o.x + h, this._miny = o.y - h, this._maxy = o.y + h, this._corner[0] = new He(this._maxx, this._maxy), this._corner[1] = new He(this._minx, this._maxy), this._corner[2] = new He(this._minx, this._miny), this._corner[3] = new He(this._maxx, this._miny);
        } }, { key: "intersects", value: function(o, h) {
          return this._scaleFactor === 1 ? this.intersectsScaled(o, h) : (this.copyScaled(o, this._p0Scaled), this.copyScaled(h, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        } }, { key: "scale", value: function(o) {
          return Math.round(o * this._scaleFactor);
        } }, { key: "getCoordinate", value: function() {
          return this._originalPt;
        } }, { key: "copyScaled", value: function(o, h) {
          h.x = this.scale(o.x), h.y = this.scale(o.y);
        } }, { key: "getSafeEnvelope", value: function() {
          if (this._safeEnv === null) {
            var o = y.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new fr(this._originalPt.x - o, this._originalPt.x + o, this._originalPt.y - o, this._originalPt.y + o);
          }
          return this._safeEnv;
        } }, { key: "intersectsPixelClosure", value: function(o, h) {
          return this._li.computeIntersection(o, h, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(o, h, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(o, h, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(o, h, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        } }, { key: "intersectsToleranceSquare", value: function(o, h) {
          var _ = !1, I = !1;
          return this._li.computeIntersection(o, h, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(o, h, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (_ = !0), this._li.computeIntersection(o, h, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (I = !0), this._li.computeIntersection(o, h, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!_ || !I) || !!o.equals(this._pt) || !!h.equals(this._pt))));
        } }, { key: "addSnappedNode", value: function(o, h) {
          var _ = o.getCoordinate(h), I = o.getCoordinate(h + 1);
          return !!this.intersects(_, I) && (o.addIntersection(this.getCoordinate(), h), !0);
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          if (this._originalPt = o, this._pt = o, this._scaleFactor = h, this._li = _, h <= 0) throw new et("Scale factor must be non-zero");
          h !== 1 && (this._pt = new He(this.scale(o.x), this.scale(o.y)), this._p0Scaled = new He(), this._p1Scaled = new He()), this.initCorners(this._pt);
        } }]);
      })();
      Sl.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var Bo = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "select", value: function() {
          if (arguments.length !== 1 && arguments.length === 2) {
            var y = arguments[1];
            arguments[0].getLineSegment(y, this.selectedSegment), this.select(this.selectedSegment);
          }
        } }], [{ key: "constructor_", value: function() {
          this.selectedSegment = new bi();
        } }]);
      })(), Eu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "snap", value: function() {
          if (arguments.length === 1) {
            var y = arguments[0];
            return this.snap(y, null, -1);
          }
          if (arguments.length === 3) {
            var o = arguments[0], h = arguments[1], _ = arguments[2], I = o.getSafeEnvelope(), D = new Tl(o, h, _);
            return this._index.query(I, new ((function() {
              return u((function B() {
                x(this, B);
              }), [{ key: "interfaces_", get: function() {
                return [to];
              } }, { key: "visitItem", value: function(B) {
                B.select(I, D);
              } }]);
            })())()), D.isNodeAdded();
          }
        } }], [{ key: "constructor_", value: function() {
          this._index = null;
          var y = arguments[0];
          this._index = y;
        } }]);
      })(), Tl = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "isNodeAdded", value: function() {
          return this._isNodeAdded;
        } }, { key: "select", value: function() {
          if (!(arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof sn)) return ce(o, "select", this, 1).apply(this, arguments);
          var h = arguments[1], _ = arguments[0].getContext();
          if (this._parentEdge === _ && (h === this._hotPixelVertexIndex || h + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(_, h);
        } }], [{ key: "constructor_", value: function() {
          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
          var h = arguments[0], _ = arguments[1], I = arguments[2];
          this._hotPixel = h, this._parentEdge = _, this._hotPixelVertexIndex = I;
        } }]);
      })(Bo);
      Eu.HotPixelSnapAction = Tl;
      var Dc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "processIntersections", value: function(y, o, h, _) {
          if (y === h && o === _) return null;
          var I = y.getCoordinates()[o], D = y.getCoordinates()[o + 1], B = h.getCoordinates()[_], W = h.getCoordinates()[_ + 1];
          if (this._li.computeIntersection(I, D, B, W), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var oe = 0; oe < this._li.getIntersectionNum(); oe++) this._interiorIntersections.add(this._li.getIntersection(oe));
            y.addIntersections(this._li, o, 0), h.addIntersections(this._li, _, 1);
          }
        } }, { key: "isDone", value: function() {
          return !1;
        } }, { key: "getInteriorIntersections", value: function() {
          return this._interiorIntersections;
        } }, { key: "interfaces_", get: function() {
          return [El];
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._interiorIntersections = null;
          var y = arguments[0];
          this._li = y, this._interiorIntersections = new me();
        } }]);
      })(), kl = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "checkCorrectness", value: function(y) {
          var o = ji.getNodedSubstrings(y), h = new Lc(o);
          try {
            h.checkValid();
          } catch (_) {
            if (!(_ instanceof Qe)) throw _;
            _.printStackTrace();
          }
        } }, { key: "getNodedSubstrings", value: function() {
          return ji.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "snapRound", value: function(y, o) {
          var h = this.findInteriorIntersections(y, o);
          this.computeIntersectionSnaps(h), this.computeVertexSnaps(y);
        } }, { key: "findInteriorIntersections", value: function(y, o) {
          var h = new Dc(o);
          return this._noder.setSegmentIntersector(h), this._noder.computeNodes(y), h.getInteriorIntersections();
        } }, { key: "computeVertexSnaps", value: function() {
          if (tr(arguments[0], br)) for (var y = arguments[0].iterator(); y.hasNext(); ) {
            var o = y.next();
            this.computeVertexSnaps(o);
          }
          else if (arguments[0] instanceof ji) for (var h = arguments[0], _ = h.getCoordinates(), I = 0; I < _.length; I++) {
            var D = new Sl(_[I], this._scaleFactor, this._li);
            this._pointSnapper.snap(D, h, I) && h.addIntersection(_[I], I);
          }
        } }, { key: "computeNodes", value: function(y) {
          this._nodedSegStrings = y, this._noder = new mu(), this._pointSnapper = new Eu(this._noder.getIndex()), this.snapRound(y, this._li);
        } }, { key: "computeIntersectionSnaps", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next(), _ = new Sl(h, this._scaleFactor, this._li);
            this._pointSnapper.snap(_);
          }
        } }, { key: "interfaces_", get: function() {
          return [No];
        } }], [{ key: "constructor_", value: function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var y = arguments[0];
          this._pm = y, this._li = new Wi(), this._li.setPrecisionModel(y), this._scaleFactor = y.getScale();
        } }]);
      })(), ui = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "bufferFixedPrecision", value: function(o) {
          var h = new td(new kl(new Rn(1)), o.getScale()), _ = new zo(this._bufParams);
          _.setWorkingPrecisionModel(o), _.setNoder(h), this._resultGeometry = _.buffer(this._argGeom, this._distance);
        } }, { key: "bufferReducedPrecision", value: function() {
          if (arguments.length === 0) {
            for (var o = y.MAX_PRECISION_DIGITS; o >= 0; o--) {
              try {
                this.bufferReducedPrecision(o);
              } catch (D) {
                if (!(D instanceof re)) throw D;
                this._saveException = D;
              }
              if (this._resultGeometry !== null) return null;
            }
            throw this._saveException;
          }
          if (arguments.length === 1) {
            var h = arguments[0], _ = y.precisionScaleFactor(this._argGeom, this._distance, h), I = new Rn(_);
            this.bufferFixedPrecision(I);
          }
        } }, { key: "computeGeometry", value: function() {
          if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
          var o = this._argGeom.getFactory().getPrecisionModel();
          o.getType() === Rn.FIXED ? this.bufferFixedPrecision(o) : this.bufferReducedPrecision();
        } }, { key: "setQuadrantSegments", value: function(o) {
          this._bufParams.setQuadrantSegments(o);
        } }, { key: "bufferOriginalPrecision", value: function() {
          try {
            var o = new zo(this._bufParams);
            this._resultGeometry = o.buffer(this._argGeom, this._distance);
          } catch (h) {
            if (!(h instanceof Zt)) throw h;
            this._saveException = h;
          }
        } }, { key: "getResultGeometry", value: function(o) {
          return this._distance = o, this.computeGeometry(), this._resultGeometry;
        } }, { key: "setEndCapStyle", value: function(o) {
          this._bufParams.setEndCapStyle(o);
        } }], [{ key: "constructor_", value: function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new Ue(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
            var o = arguments[0];
            this._argGeom = o;
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this._argGeom = h, this._bufParams = _;
          }
        } }, { key: "bufferOp", value: function() {
          if (arguments.length === 2) {
            var o = arguments[1];
            return new y(arguments[0]).getResultGeometry(o);
          }
          if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Bt && typeof arguments[1] == "number") {
              var h = arguments[1], _ = arguments[2], I = new y(arguments[0]);
              return I.setQuadrantSegments(_), I.getResultGeometry(h);
            }
            if (arguments[2] instanceof Ue && arguments[0] instanceof Bt && typeof arguments[1] == "number") {
              var D = arguments[1];
              return new y(arguments[0], arguments[2]).getResultGeometry(D);
            }
          } else if (arguments.length === 4) {
            var B = arguments[1], W = arguments[2], oe = arguments[3], de = new y(arguments[0]);
            return de.setQuadrantSegments(W), de.setEndCapStyle(oe), de.getResultGeometry(B);
          }
        } }, { key: "precisionScaleFactor", value: function(o, h, _) {
          var I = o.getEnvelopeInternal(), D = gt.max(Math.abs(I.getMaxX()), Math.abs(I.getMaxY()), Math.abs(I.getMinX()), Math.abs(I.getMinY())) + 2 * (h > 0 ? h : 0), B = _ - Math.trunc(Math.log(D) / Math.log(10) + 1);
          return Math.pow(10, B);
        } }]);
      })();
      ui.CAP_ROUND = Ue.CAP_ROUND, ui.CAP_BUTT = Ue.CAP_FLAT, ui.CAP_FLAT = Ue.CAP_FLAT, ui.CAP_SQUARE = Ue.CAP_SQUARE, ui.MAX_PRECISION_DIGITS = 12;
      var Il = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ml = (function() {
        return u((function y(o) {
          x(this, y), this.geometryFactory = o || new si();
        }), [{ key: "read", value: function(y) {
          var o, h = (o = typeof y == "string" ? JSON.parse(y) : y).type;
          if (!Mi[h]) throw new Error("Unknown GeoJSON type: " + o.type);
          return Il.indexOf(h) !== -1 ? Mi[h].call(this, o.coordinates) : h === "GeometryCollection" ? Mi[h].call(this, o.geometries) : Mi[h].call(this, o);
        } }, { key: "write", value: function(y) {
          var o = y.getGeometryType();
          if (!Ji[o]) throw new Error("Geometry is not supported");
          return Ji[o].call(this, y);
        } }]);
      })(), Mi = { Feature: function(y) {
        var o = {};
        for (var h in y) o[h] = y[h];
        if (y.geometry) {
          var _ = y.geometry.type;
          if (!Mi[_]) throw new Error("Unknown GeoJSON type: " + y.type);
          o.geometry = this.read(y.geometry);
        }
        return y.bbox && (o.bbox = Mi.bbox.call(this, y.bbox)), o;
      }, FeatureCollection: function(y) {
        var o = {};
        if (y.features) {
          o.features = [];
          for (var h = 0; h < y.features.length; ++h) o.features.push(this.read(y.features[h]));
        }
        return y.bbox && (o.bbox = this.parse.bbox.call(this, y.bbox)), o;
      }, coordinates: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) {
          var _ = y[h];
          o.push(M(He, _e(_)));
        }
        return o;
      }, bbox: function(y) {
        return this.geometryFactory.createLinearRing([new He(y[0], y[1]), new He(y[2], y[1]), new He(y[2], y[3]), new He(y[0], y[3]), new He(y[0], y[1])]);
      }, Point: function(y) {
        var o = M(He, _e(y));
        return this.geometryFactory.createPoint(o);
      }, MultiPoint: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) o.push(Mi.Point.call(this, y[h]));
        return this.geometryFactory.createMultiPoint(o);
      }, LineString: function(y) {
        var o = Mi.coordinates.call(this, y);
        return this.geometryFactory.createLineString(o);
      }, MultiLineString: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) o.push(Mi.LineString.call(this, y[h]));
        return this.geometryFactory.createMultiLineString(o);
      }, Polygon: function(y) {
        for (var o = Mi.coordinates.call(this, y[0]), h = this.geometryFactory.createLinearRing(o), _ = [], I = 1; I < y.length; ++I) {
          var D = y[I], B = Mi.coordinates.call(this, D), W = this.geometryFactory.createLinearRing(B);
          _.push(W);
        }
        return this.geometryFactory.createPolygon(h, _);
      }, MultiPolygon: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) {
          var _ = y[h];
          o.push(Mi.Polygon.call(this, _));
        }
        return this.geometryFactory.createMultiPolygon(o);
      }, GeometryCollection: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) {
          var _ = y[h];
          o.push(this.read(_));
        }
        return this.geometryFactory.createGeometryCollection(o);
      } }, Ji = { coordinate: function(y) {
        var o = [y.x, y.y];
        return y.z && o.push(y.z), y.m && o.push(y.m), o;
      }, Point: function(y) {
        return { type: "Point", coordinates: Ji.coordinate.call(this, y.getCoordinate()) };
      }, MultiPoint: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = Ji.Point.call(this, _);
          o.push(I.coordinates);
        }
        return { type: "MultiPoint", coordinates: o };
      }, LineString: function(y) {
        for (var o = [], h = y.getCoordinates(), _ = 0; _ < h.length; ++_) {
          var I = h[_];
          o.push(Ji.coordinate.call(this, I));
        }
        return { type: "LineString", coordinates: o };
      }, MultiLineString: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = Ji.LineString.call(this, _);
          o.push(I.coordinates);
        }
        return { type: "MultiLineString", coordinates: o };
      }, Polygon: function(y) {
        var o = [], h = Ji.LineString.call(this, y._shell);
        o.push(h.coordinates);
        for (var _ = 0; _ < y._holes.length; ++_) {
          var I = y._holes[_], D = Ji.LineString.call(this, I);
          o.push(D.coordinates);
        }
        return { type: "Polygon", coordinates: o };
      }, MultiPolygon: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = Ji.Polygon.call(this, _);
          o.push(I.coordinates);
        }
        return { type: "MultiPolygon", coordinates: o };
      }, GeometryCollection: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = _.getGeometryType();
          o.push(Ji[I].call(this, _));
        }
        return { type: "GeometryCollection", geometries: o };
      } };
      return { BufferOp: ui, GeoJSONReader: (function() {
        return u((function y(o) {
          x(this, y), this.parser = new Ml(o || new si());
        }), [{ key: "read", value: function(y) {
          return this.parser.read(y);
        } }]);
      })(), GeoJSONWriter: (function() {
        return u((function y() {
          x(this, y), this.parser = new Ml(this.geometryFactory);
        }), [{ key: "write", value: function(y) {
          return this.parser.write(y);
        } }]);
      })() };
    }));
  })(wy)), wy.exports;
}
var eN = QF();
const tN = /* @__PURE__ */ bw(eN);
function iu() {
  return new Lg();
}
function Lg() {
  this.reset();
}
Lg.prototype = {
  constructor: Lg,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(a) {
    n1(eg, a, this.t), n1(this, eg.s, this.s), this.s ? this.t += eg.t : this.s = eg.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var eg = new Lg();
function n1(a, n, l) {
  var p = a.s = n + l, x = p - n, M = p - x;
  a.t = n - M + (l - x);
}
var wn = 1e-6, Gr = Math.PI, Eo = Gr / 2, i1 = Gr / 4, Co = Gr * 2, ql = 180 / Gr, ma = Gr / 180, zi = Math.abs, rN = Math.atan, jh = Math.atan2, Bn = Math.cos, Gn = Math.sin, Jh = Math.sqrt;
function X2(a) {
  return a > 1 ? 0 : a < -1 ? Gr : Math.acos(a);
}
function gc(a) {
  return a > 1 ? Eo : a < -1 ? -Eo : Math.asin(a);
}
function cf() {
}
function Dg(a, n) {
  a && a1.hasOwnProperty(a.type) && a1[a.type](a, n);
}
var s1 = {
  Feature: function(a, n) {
    Dg(a.geometry, n);
  },
  FeatureCollection: function(a, n) {
    for (var l = a.features, p = -1, x = l.length; ++p < x; ) Dg(l[p].geometry, n);
  }
}, a1 = {
  Sphere: function(a, n) {
    n.sphere();
  },
  Point: function(a, n) {
    a = a.coordinates, n.point(a[0], a[1], a[2]);
  },
  MultiPoint: function(a, n) {
    for (var l = a.coordinates, p = -1, x = l.length; ++p < x; ) a = l[p], n.point(a[0], a[1], a[2]);
  },
  LineString: function(a, n) {
    Ey(a.coordinates, n, 0);
  },
  MultiLineString: function(a, n) {
    for (var l = a.coordinates, p = -1, x = l.length; ++p < x; ) Ey(l[p], n, 0);
  },
  Polygon: function(a, n) {
    o1(a.coordinates, n);
  },
  MultiPolygon: function(a, n) {
    for (var l = a.coordinates, p = -1, x = l.length; ++p < x; ) o1(l[p], n);
  },
  GeometryCollection: function(a, n) {
    for (var l = a.geometries, p = -1, x = l.length; ++p < x; ) Dg(l[p], n);
  }
};
function Ey(a, n, l) {
  var p = -1, x = a.length - l, M;
  for (n.lineStart(); ++p < x; ) M = a[p], n.point(M[0], M[1], M[2]);
  n.lineEnd();
}
function o1(a, n) {
  var l = -1, p = a.length;
  for (n.polygonStart(); ++l < p; ) Ey(a[l], n, 1);
  n.polygonEnd();
}
function nN(a, n) {
  a && s1.hasOwnProperty(a.type) ? s1[a.type](a, n) : Dg(a, n);
}
iu();
iu();
function Sy(a) {
  return [jh(a[1], a[0]), gc(a[2])];
}
function Vh(a) {
  var n = a[0], l = a[1], p = Bn(l);
  return [p * Bn(n), p * Gn(n), Gn(l)];
}
function tg(a, n) {
  return a[0] * n[0] + a[1] * n[1] + a[2] * n[2];
}
function Rg(a, n) {
  return [a[1] * n[2] - a[2] * n[1], a[2] * n[0] - a[0] * n[2], a[0] * n[1] - a[1] * n[0]];
}
function z_(a, n) {
  a[0] += n[0], a[1] += n[1], a[2] += n[2];
}
function rg(a, n) {
  return [a[0] * n, a[1] * n, a[2] * n];
}
function Ty(a) {
  var n = Jh(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
  a[0] /= n, a[1] /= n, a[2] /= n;
}
iu();
function J2(a, n) {
  function l(p, x) {
    return p = a(p, x), n(p[0], p[1]);
  }
  return a.invert && n.invert && (l.invert = function(p, x) {
    return p = n.invert(p, x), p && a.invert(p[0], p[1]);
  }), l;
}
function ky(a, n) {
  return [a > Gr ? a - Co : a < -Gr ? a + Co : a, n];
}
ky.invert = ky;
function iN(a, n, l) {
  return (a %= Co) ? n || l ? J2(u1(a), c1(n, l)) : u1(a) : n || l ? c1(n, l) : ky;
}
function l1(a) {
  return function(n, l) {
    return n += a, [n > Gr ? n - Co : n < -Gr ? n + Co : n, l];
  };
}
function u1(a) {
  var n = l1(a);
  return n.invert = l1(-a), n;
}
function c1(a, n) {
  var l = Bn(a), p = Gn(a), x = Bn(n), M = Gn(n);
  function S(u, R) {
    var z = Bn(R), U = Bn(u) * z, $ = Gn(u) * z, ee = Gn(R), le = ee * l + U * p;
    return [
      jh($ * x - le * M, U * l - ee * p),
      gc(le * x + $ * M)
    ];
  }
  return S.invert = function(u, R) {
    var z = Bn(R), U = Bn(u) * z, $ = Gn(u) * z, ee = Gn(R), le = ee * x - $ * M;
    return [
      jh($ * x + ee * M, U * l + le * p),
      gc(le * l - U * p)
    ];
  }, S;
}
function sN(a, n, l, p, x, M) {
  if (l) {
    var S = Bn(n), u = Gn(n), R = p * l;
    x == null ? (x = n + p * Co, M = n - R / 2) : (x = h1(S, x), M = h1(S, M), (p > 0 ? x < M : x > M) && (x += p * Co));
    for (var z, U = x; p > 0 ? U > M : U < M; U -= R)
      z = Sy([S, -u * Bn(U), -u * Gn(U)]), a.point(z[0], z[1]);
  }
}
function h1(a, n) {
  n = Vh(n), n[0] -= a, Ty(n);
  var l = X2(-n[1]);
  return ((-n[2] < 0 ? -l : l) + Co - wn) % Co;
}
function K2() {
  var a = [], n;
  return {
    point: function(l, p) {
      n.push([l, p]);
    },
    lineStart: function() {
      a.push(n = []);
    },
    lineEnd: cf,
    rejoin: function() {
      a.length > 1 && a.push(a.pop().concat(a.shift()));
    },
    result: function() {
      var l = a;
      return a = [], n = null, l;
    }
  };
}
function aN(a, n, l, p, x, M) {
  var S = a[0], u = a[1], R = n[0], z = n[1], U = 0, $ = 1, ee = R - S, le = z - u, ce;
  if (ce = l - S, !(!ee && ce > 0)) {
    if (ce /= ee, ee < 0) {
      if (ce < U) return;
      ce < $ && ($ = ce);
    } else if (ee > 0) {
      if (ce > $) return;
      ce > U && (U = ce);
    }
    if (ce = x - S, !(!ee && ce < 0)) {
      if (ce /= ee, ee < 0) {
        if (ce > $) return;
        ce > U && (U = ce);
      } else if (ee > 0) {
        if (ce < U) return;
        ce < $ && ($ = ce);
      }
      if (ce = p - u, !(!le && ce > 0)) {
        if (ce /= le, le < 0) {
          if (ce < U) return;
          ce < $ && ($ = ce);
        } else if (le > 0) {
          if (ce > $) return;
          ce > U && (U = ce);
        }
        if (ce = M - u, !(!le && ce < 0)) {
          if (ce /= le, le < 0) {
            if (ce > $) return;
            ce > U && (U = ce);
          } else if (le > 0) {
            if (ce < U) return;
            ce < $ && ($ = ce);
          }
          return U > 0 && (a[0] = S + U * ee, a[1] = u + U * le), $ < 1 && (n[0] = S + $ * ee, n[1] = u + $ * le), !0;
        }
      }
    }
  }
}
function _g(a, n) {
  return zi(a[0] - n[0]) < wn && zi(a[1] - n[1]) < wn;
}
function ng(a, n, l, p) {
  this.x = a, this.z = n, this.o = l, this.e = p, this.v = !1, this.n = this.p = null;
}
function Q2(a, n, l, p, x) {
  var M = [], S = [], u, R;
  if (a.forEach(function(ce) {
    if (!((_e = ce.length - 1) <= 0)) {
      var _e, ne = ce[0], Pe = ce[_e], ve;
      if (_g(ne, Pe)) {
        for (x.lineStart(), u = 0; u < _e; ++u) x.point((ne = ce[u])[0], ne[1]);
        x.lineEnd();
        return;
      }
      M.push(ve = new ng(ne, ce, null, !0)), S.push(ve.o = new ng(ne, null, ve, !1)), M.push(ve = new ng(Pe, ce, null, !1)), S.push(ve.o = new ng(Pe, null, ve, !0));
    }
  }), !!M.length) {
    for (S.sort(n), d1(M), d1(S), u = 0, R = S.length; u < R; ++u)
      S[u].e = l = !l;
    for (var z = M[0], U, $; ; ) {
      for (var ee = z, le = !0; ee.v; ) if ((ee = ee.n) === z) return;
      U = ee.z, x.lineStart();
      do {
        if (ee.v = ee.o.v = !0, ee.e) {
          if (le)
            for (u = 0, R = U.length; u < R; ++u) x.point(($ = U[u])[0], $[1]);
          else
            p(ee.x, ee.n.x, 1, x);
          ee = ee.n;
        } else {
          if (le)
            for (U = ee.p.z, u = U.length - 1; u >= 0; --u) x.point(($ = U[u])[0], $[1]);
          else
            p(ee.x, ee.p.x, -1, x);
          ee = ee.p;
        }
        ee = ee.o, U = ee.z, le = !le;
      } while (!ee.v);
      x.lineEnd();
    }
  }
}
function d1(a) {
  if (n = a.length) {
    for (var n, l = 0, p = a[0], x; ++l < n; )
      p.n = x = a[l], x.p = p, p = x;
    p.n = x = a[0], x.p = p;
  }
}
function eE(a, n) {
  return a < n ? -1 : a > n ? 1 : a >= n ? 0 : NaN;
}
function oN(a) {
  return a.length === 1 && (a = lN(a)), {
    left: function(n, l, p, x) {
      for (p == null && (p = 0), x == null && (x = n.length); p < x; ) {
        var M = p + x >>> 1;
        a(n[M], l) < 0 ? p = M + 1 : x = M;
      }
      return p;
    },
    right: function(n, l, p, x) {
      for (p == null && (p = 0), x == null && (x = n.length); p < x; ) {
        var M = p + x >>> 1;
        a(n[M], l) > 0 ? x = M : p = M + 1;
      }
      return p;
    }
  };
}
function lN(a) {
  return function(n, l) {
    return eE(a(n), l);
  };
}
oN(eE);
function tE(a) {
  for (var n = a.length, l, p = -1, x = 0, M, S; ++p < n; ) x += a[p].length;
  for (M = new Array(x); --n >= 0; )
    for (S = a[n], l = S.length; --l >= 0; )
      M[--x] = S[l];
  return M;
}
var hf = 1e9, ig = -hf;
function uN(a, n, l, p) {
  function x(z, U) {
    return a <= z && z <= l && n <= U && U <= p;
  }
  function M(z, U, $, ee) {
    var le = 0, ce = 0;
    if (z == null || (le = S(z, $)) !== (ce = S(U, $)) || R(z, U) < 0 ^ $ > 0)
      do
        ee.point(le === 0 || le === 3 ? a : l, le > 1 ? p : n);
      while ((le = (le + $ + 4) % 4) !== ce);
    else
      ee.point(U[0], U[1]);
  }
  function S(z, U) {
    return zi(z[0] - a) < wn ? U > 0 ? 0 : 3 : zi(z[0] - l) < wn ? U > 0 ? 2 : 1 : zi(z[1] - n) < wn ? U > 0 ? 1 : 0 : U > 0 ? 3 : 2;
  }
  function u(z, U) {
    return R(z.x, U.x);
  }
  function R(z, U) {
    var $ = S(z, 1), ee = S(U, 1);
    return $ !== ee ? $ - ee : $ === 0 ? U[1] - z[1] : $ === 1 ? z[0] - U[0] : $ === 2 ? z[1] - U[1] : U[0] - z[0];
  }
  return function(z) {
    var U = z, $ = K2(), ee, le, ce, _e, ne, Pe, ve, Ue, Qe, et, Xe, ut = {
      point: Q,
      lineStart: Ie,
      lineEnd: ze,
      polygonStart: ge,
      polygonEnd: Se
    };
    function Q(De, Ne) {
      x(De, Ne) && U.point(De, Ne);
    }
    function se() {
      for (var De = 0, Ne = 0, Ge = le.length; Ne < Ge; ++Ne)
        for (var qe = le[Ne], Je = 1, ft = qe.length, Tt = qe[0], Zt, zt, At = Tt[0], Dt = Tt[1]; Je < ft; ++Je)
          Zt = At, zt = Dt, Tt = qe[Je], At = Tt[0], Dt = Tt[1], zt <= p ? Dt > p && (At - Zt) * (p - zt) > (Dt - zt) * (a - Zt) && ++De : Dt <= p && (At - Zt) * (p - zt) < (Dt - zt) * (a - Zt) && --De;
      return De;
    }
    function ge() {
      U = $, ee = [], le = [], Xe = !0;
    }
    function Se() {
      var De = se(), Ne = Xe && De, Ge = (ee = tE(ee)).length;
      (Ne || Ge) && (z.polygonStart(), Ne && (z.lineStart(), M(null, null, 1, z), z.lineEnd()), Ge && Q2(ee, u, De, M, z), z.polygonEnd()), U = z, ee = le = ce = null;
    }
    function Ie() {
      ut.point = Re, le && le.push(ce = []), et = !0, Qe = !1, ve = Ue = NaN;
    }
    function ze() {
      ee && (Re(_e, ne), Pe && Qe && $.rejoin(), ee.push($.result())), ut.point = Q, Qe && U.lineEnd();
    }
    function Re(De, Ne) {
      var Ge = x(De, Ne);
      if (le && ce.push([De, Ne]), et)
        _e = De, ne = Ne, Pe = Ge, et = !1, Ge && (U.lineStart(), U.point(De, Ne));
      else if (Ge && Qe) U.point(De, Ne);
      else {
        var qe = [ve = Math.max(ig, Math.min(hf, ve)), Ue = Math.max(ig, Math.min(hf, Ue))], Je = [De = Math.max(ig, Math.min(hf, De)), Ne = Math.max(ig, Math.min(hf, Ne))];
        aN(qe, Je, a, n, l, p) ? (Qe || (U.lineStart(), U.point(qe[0], qe[1])), U.point(Je[0], Je[1]), Ge || U.lineEnd(), Xe = !1) : Ge && (U.lineStart(), U.point(De, Ne), Xe = !1);
      }
      ve = De, Ue = Ne, Qe = Ge;
    }
    return ut;
  };
}
var B_ = iu();
function cN(a, n) {
  var l = n[0], p = n[1], x = [Gn(l), -Bn(l), 0], M = 0, S = 0;
  B_.reset();
  for (var u = 0, R = a.length; u < R; ++u)
    if (U = (z = a[u]).length)
      for (var z, U, $ = z[U - 1], ee = $[0], le = $[1] / 2 + i1, ce = Gn(le), _e = Bn(le), ne = 0; ne < U; ++ne, ee = ve, ce = Qe, _e = et, $ = Pe) {
        var Pe = z[ne], ve = Pe[0], Ue = Pe[1] / 2 + i1, Qe = Gn(Ue), et = Bn(Ue), Xe = ve - ee, ut = Xe >= 0 ? 1 : -1, Q = ut * Xe, se = Q > Gr, ge = ce * Qe;
        if (B_.add(jh(ge * ut * Gn(Q), _e * et + ge * Bn(Q))), M += se ? Xe + ut * Co : Xe, se ^ ee >= l ^ ve >= l) {
          var Se = Rg(Vh($), Vh(Pe));
          Ty(Se);
          var Ie = Rg(x, Se);
          Ty(Ie);
          var ze = (se ^ Xe >= 0 ? -1 : 1) * gc(Ie[2]);
          (p > ze || p === ze && (Se[0] || Se[1])) && (S += se ^ Xe >= 0 ? 1 : -1);
        }
      }
  return (M < -wn || M < wn && B_ < -wn) ^ S & 1;
}
iu();
function f1(a) {
  return a;
}
iu();
iu();
var Uh = 1 / 0, Fg = Uh, Lf = -Uh, Ng = Lf, p1 = {
  point: hN,
  lineStart: cf,
  lineEnd: cf,
  polygonStart: cf,
  polygonEnd: cf,
  result: function() {
    var a = [[Uh, Fg], [Lf, Ng]];
    return Lf = Ng = -(Fg = Uh = 1 / 0), a;
  }
};
function hN(a, n) {
  a < Uh && (Uh = a), a > Lf && (Lf = a), n < Fg && (Fg = n), n > Ng && (Ng = n);
}
iu();
function rE(a, n, l, p) {
  return function(x, M) {
    var S = n(M), u = x.invert(p[0], p[1]), R = K2(), z = n(R), U = !1, $, ee, le, ce = {
      point: _e,
      lineStart: Pe,
      lineEnd: ve,
      polygonStart: function() {
        ce.point = Ue, ce.lineStart = Qe, ce.lineEnd = et, ee = [], $ = [];
      },
      polygonEnd: function() {
        ce.point = _e, ce.lineStart = Pe, ce.lineEnd = ve, ee = tE(ee);
        var Xe = cN($, u);
        ee.length ? (U || (M.polygonStart(), U = !0), Q2(ee, fN, Xe, l, M)) : Xe && (U || (M.polygonStart(), U = !0), M.lineStart(), l(null, null, 1, M), M.lineEnd()), U && (M.polygonEnd(), U = !1), ee = $ = null;
      },
      sphere: function() {
        M.polygonStart(), M.lineStart(), l(null, null, 1, M), M.lineEnd(), M.polygonEnd();
      }
    };
    function _e(Xe, ut) {
      var Q = x(Xe, ut);
      a(Xe = Q[0], ut = Q[1]) && M.point(Xe, ut);
    }
    function ne(Xe, ut) {
      var Q = x(Xe, ut);
      S.point(Q[0], Q[1]);
    }
    function Pe() {
      ce.point = ne, S.lineStart();
    }
    function ve() {
      ce.point = _e, S.lineEnd();
    }
    function Ue(Xe, ut) {
      le.push([Xe, ut]);
      var Q = x(Xe, ut);
      z.point(Q[0], Q[1]);
    }
    function Qe() {
      z.lineStart(), le = [];
    }
    function et() {
      Ue(le[0][0], le[0][1]), z.lineEnd();
      var Xe = z.clean(), ut = R.result(), Q, se = ut.length, ge, Se, Ie;
      if (le.pop(), $.push(le), le = null, !!se) {
        if (Xe & 1) {
          if (Se = ut[0], (ge = Se.length - 1) > 0) {
            for (U || (M.polygonStart(), U = !0), M.lineStart(), Q = 0; Q < ge; ++Q) M.point((Ie = Se[Q])[0], Ie[1]);
            M.lineEnd();
          }
          return;
        }
        se > 1 && Xe & 2 && ut.push(ut.pop().concat(ut.shift())), ee.push(ut.filter(dN));
      }
    }
    return ce;
  };
}
function dN(a) {
  return a.length > 1;
}
function fN(a, n) {
  return ((a = a.x)[0] < 0 ? a[1] - Eo - wn : Eo - a[1]) - ((n = n.x)[0] < 0 ? n[1] - Eo - wn : Eo - n[1]);
}
const g1 = rE(
  function() {
    return !0;
  },
  pN,
  mN,
  [-Gr, -Eo]
);
function pN(a) {
  var n = NaN, l = NaN, p = NaN, x;
  return {
    lineStart: function() {
      a.lineStart(), x = 1;
    },
    point: function(M, S) {
      var u = M > 0 ? Gr : -Gr, R = zi(M - n);
      zi(R - Gr) < wn ? (a.point(n, l = (l + S) / 2 > 0 ? Eo : -Eo), a.point(p, l), a.lineEnd(), a.lineStart(), a.point(u, l), a.point(M, l), x = 0) : p !== u && R >= Gr && (zi(n - p) < wn && (n -= p * wn), zi(M - u) < wn && (M -= u * wn), l = gN(n, l, M, S), a.point(p, l), a.lineEnd(), a.lineStart(), a.point(u, l), x = 0), a.point(n = M, l = S), p = u;
    },
    lineEnd: function() {
      a.lineEnd(), n = l = NaN;
    },
    clean: function() {
      return 2 - x;
    }
  };
}
function gN(a, n, l, p) {
  var x, M, S = Gn(a - l);
  return zi(S) > wn ? rN((Gn(n) * (M = Bn(p)) * Gn(l) - Gn(p) * (x = Bn(n)) * Gn(a)) / (x * M * S)) : (n + p) / 2;
}
function mN(a, n, l, p) {
  var x;
  if (a == null)
    x = l * Eo, p.point(-Gr, x), p.point(0, x), p.point(Gr, x), p.point(Gr, 0), p.point(Gr, -x), p.point(0, -x), p.point(-Gr, -x), p.point(-Gr, 0), p.point(-Gr, x);
  else if (zi(a[0] - n[0]) > wn) {
    var M = a[0] < n[0] ? Gr : -Gr;
    x = l * M / 2, p.point(-M, x), p.point(0, x), p.point(M, x);
  } else
    p.point(n[0], n[1]);
}
function _N(a, n) {
  var l = Bn(a), p = l > 0, x = zi(l) > wn;
  function M(U, $, ee, le) {
    sN(le, a, n, ee, U, $);
  }
  function S(U, $) {
    return Bn(U) * Bn($) > l;
  }
  function u(U) {
    var $, ee, le, ce, _e;
    return {
      lineStart: function() {
        ce = le = !1, _e = 1;
      },
      point: function(ne, Pe) {
        var ve = [ne, Pe], Ue, Qe = S(ne, Pe), et = p ? Qe ? 0 : z(ne, Pe) : Qe ? z(ne + (ne < 0 ? Gr : -Gr), Pe) : 0;
        if (!$ && (ce = le = Qe) && U.lineStart(), Qe !== le && (Ue = R($, ve), (!Ue || _g($, Ue) || _g(ve, Ue)) && (ve[0] += wn, ve[1] += wn, Qe = S(ve[0], ve[1]))), Qe !== le)
          _e = 0, Qe ? (U.lineStart(), Ue = R(ve, $), U.point(Ue[0], Ue[1])) : (Ue = R($, ve), U.point(Ue[0], Ue[1]), U.lineEnd()), $ = Ue;
        else if (x && $ && p ^ Qe) {
          var Xe;
          !(et & ee) && (Xe = R(ve, $, !0)) && (_e = 0, p ? (U.lineStart(), U.point(Xe[0][0], Xe[0][1]), U.point(Xe[1][0], Xe[1][1]), U.lineEnd()) : (U.point(Xe[1][0], Xe[1][1]), U.lineEnd(), U.lineStart(), U.point(Xe[0][0], Xe[0][1])));
        }
        Qe && (!$ || !_g($, ve)) && U.point(ve[0], ve[1]), $ = ve, le = Qe, ee = et;
      },
      lineEnd: function() {
        le && U.lineEnd(), $ = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return _e | (ce && le) << 1;
      }
    };
  }
  function R(U, $, ee) {
    var le = Vh(U), ce = Vh($), _e = [1, 0, 0], ne = Rg(le, ce), Pe = tg(ne, ne), ve = ne[0], Ue = Pe - ve * ve;
    if (!Ue) return !ee && U;
    var Qe = l * Pe / Ue, et = -l * ve / Ue, Xe = Rg(_e, ne), ut = rg(_e, Qe), Q = rg(ne, et);
    z_(ut, Q);
    var se = Xe, ge = tg(ut, se), Se = tg(se, se), Ie = ge * ge - Se * (tg(ut, ut) - 1);
    if (!(Ie < 0)) {
      var ze = Jh(Ie), Re = rg(se, (-ge - ze) / Se);
      if (z_(Re, ut), Re = Sy(Re), !ee) return Re;
      var De = U[0], Ne = $[0], Ge = U[1], qe = $[1], Je;
      Ne < De && (Je = De, De = Ne, Ne = Je);
      var ft = Ne - De, Tt = zi(ft - Gr) < wn, Zt = Tt || ft < wn;
      if (!Tt && qe < Ge && (Je = Ge, Ge = qe, qe = Je), Zt ? Tt ? Ge + qe > 0 ^ Re[1] < (zi(Re[0] - De) < wn ? Ge : qe) : Ge <= Re[1] && Re[1] <= qe : ft > Gr ^ (De <= Re[0] && Re[0] <= Ne)) {
        var zt = rg(se, (-ge + ze) / Se);
        return z_(zt, ut), [Re, Sy(zt)];
      }
    }
  }
  function z(U, $) {
    var ee = p ? a : Gr - a, le = 0;
    return U < -ee ? le |= 1 : U > ee && (le |= 2), $ < -ee ? le |= 4 : $ > ee && (le |= 8), le;
  }
  return rE(S, u, M, p ? [0, -a] : [-Gr, a - Gr]);
}
function nE(a) {
  return function(n) {
    var l = new Iy();
    for (var p in a) l[p] = a[p];
    return l.stream = n, l;
  };
}
function Iy() {
}
Iy.prototype = {
  constructor: Iy,
  point: function(a, n) {
    this.stream.point(a, n);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function iE(a, n, l) {
  var p = n[1][0] - n[0][0], x = n[1][1] - n[0][1], M = a.clipExtent && a.clipExtent();
  a.scale(150).translate([0, 0]), M != null && a.clipExtent(null), nN(l, a.stream(p1));
  var S = p1.result(), u = Math.min(p / (S[1][0] - S[0][0]), x / (S[1][1] - S[0][1])), R = +n[0][0] + (p - u * (S[1][0] + S[0][0])) / 2, z = +n[0][1] + (x - u * (S[1][1] + S[0][1])) / 2;
  return M != null && a.clipExtent(M), a.scale(u * 150).translate([R, z]);
}
function yN(a, n, l) {
  return iE(a, [[0, 0], n], l);
}
var m1 = 16, vN = Bn(30 * ma);
function _1(a, n) {
  return +n ? bN(a, n) : xN(a);
}
function xN(a) {
  return nE({
    point: function(n, l) {
      n = a(n, l), this.stream.point(n[0], n[1]);
    }
  });
}
function bN(a, n) {
  function l(p, x, M, S, u, R, z, U, $, ee, le, ce, _e, ne) {
    var Pe = z - p, ve = U - x, Ue = Pe * Pe + ve * ve;
    if (Ue > 4 * n && _e--) {
      var Qe = S + ee, et = u + le, Xe = R + ce, ut = Jh(Qe * Qe + et * et + Xe * Xe), Q = gc(Xe /= ut), se = zi(zi(Xe) - 1) < wn || zi(M - $) < wn ? (M + $) / 2 : jh(et, Qe), ge = a(se, Q), Se = ge[0], Ie = ge[1], ze = Se - p, Re = Ie - x, De = ve * ze - Pe * Re;
      (De * De / Ue > n || zi((Pe * ze + ve * Re) / Ue - 0.5) > 0.3 || S * ee + u * le + R * ce < vN) && (l(p, x, M, S, u, R, Se, Ie, se, Qe /= ut, et /= ut, Xe, _e, ne), ne.point(Se, Ie), l(Se, Ie, se, Qe, et, Xe, z, U, $, ee, le, ce, _e, ne));
    }
  }
  return function(p) {
    var x, M, S, u, R, z, U, $, ee, le, ce, _e, ne = {
      point: Pe,
      lineStart: ve,
      lineEnd: Qe,
      polygonStart: function() {
        p.polygonStart(), ne.lineStart = et;
      },
      polygonEnd: function() {
        p.polygonEnd(), ne.lineStart = ve;
      }
    };
    function Pe(Q, se) {
      Q = a(Q, se), p.point(Q[0], Q[1]);
    }
    function ve() {
      $ = NaN, ne.point = Ue, p.lineStart();
    }
    function Ue(Q, se) {
      var ge = Vh([Q, se]), Se = a(Q, se);
      l($, ee, U, le, ce, _e, $ = Se[0], ee = Se[1], U = Q, le = ge[0], ce = ge[1], _e = ge[2], m1, p), p.point($, ee);
    }
    function Qe() {
      ne.point = Pe, p.lineEnd();
    }
    function et() {
      ve(), ne.point = Xe, ne.lineEnd = ut;
    }
    function Xe(Q, se) {
      Ue(x = Q, se), M = $, S = ee, u = le, R = ce, z = _e, ne.point = Ue;
    }
    function ut() {
      l($, ee, U, le, ce, _e, M, S, x, u, R, z, m1, p), ne.lineEnd = Qe, Qe();
    }
    return ne;
  };
}
var wN = nE({
  point: function(a, n) {
    this.stream.point(a * ma, n * ma);
  }
});
function EN(a) {
  return SN(function() {
    return a;
  })();
}
function SN(a) {
  var n, l = 150, p = 480, x = 250, M, S, u = 0, R = 0, z = 0, U = 0, $ = 0, ee, le, ce = null, _e = g1, ne = null, Pe, ve, Ue, Qe = f1, et = 0.5, Xe = _1(Se, et), ut, Q;
  function se(Re) {
    return Re = le(Re[0] * ma, Re[1] * ma), [Re[0] * l + M, S - Re[1] * l];
  }
  function ge(Re) {
    return Re = le.invert((Re[0] - M) / l, (S - Re[1]) / l), Re && [Re[0] * ql, Re[1] * ql];
  }
  function Se(Re, De) {
    return Re = n(Re, De), [Re[0] * l + M, S - Re[1] * l];
  }
  se.stream = function(Re) {
    return ut && Q === Re ? ut : ut = wN(_e(ee, Xe(Qe(Q = Re))));
  }, se.clipAngle = function(Re) {
    return arguments.length ? (_e = +Re ? _N(ce = Re * ma, 6 * ma) : (ce = null, g1), ze()) : ce * ql;
  }, se.clipExtent = function(Re) {
    return arguments.length ? (Qe = Re == null ? (ne = Pe = ve = Ue = null, f1) : uN(ne = +Re[0][0], Pe = +Re[0][1], ve = +Re[1][0], Ue = +Re[1][1]), ze()) : ne == null ? null : [[ne, Pe], [ve, Ue]];
  }, se.scale = function(Re) {
    return arguments.length ? (l = +Re, Ie()) : l;
  }, se.translate = function(Re) {
    return arguments.length ? (p = +Re[0], x = +Re[1], Ie()) : [p, x];
  }, se.center = function(Re) {
    return arguments.length ? (u = Re[0] % 360 * ma, R = Re[1] % 360 * ma, Ie()) : [u * ql, R * ql];
  }, se.rotate = function(Re) {
    return arguments.length ? (z = Re[0] % 360 * ma, U = Re[1] % 360 * ma, $ = Re.length > 2 ? Re[2] % 360 * ma : 0, Ie()) : [z * ql, U * ql, $ * ql];
  }, se.precision = function(Re) {
    return arguments.length ? (Xe = _1(Se, et = Re * Re), ze()) : Jh(et);
  }, se.fitExtent = function(Re, De) {
    return iE(se, Re, De);
  }, se.fitSize = function(Re, De) {
    return yN(se, Re, De);
  };
  function Ie() {
    le = J2(ee = iN(z, U, $), n);
    var Re = n(u, R);
    return M = p - Re[0] * l, S = x + Re[1] * l, ze();
  }
  function ze() {
    return ut = Q = null, se;
  }
  return function() {
    return n = a.apply(this, arguments), se.invert = n.invert && ge, Ie();
  };
}
function sE(a) {
  return function(n, l) {
    var p = Bn(n), x = Bn(l), M = a(p * x);
    return [
      M * x * Gn(n),
      M * Gn(l)
    ];
  };
}
function aE(a) {
  return function(n, l) {
    var p = Jh(n * n + l * l), x = a(p), M = Gn(x), S = Bn(x);
    return [
      jh(n * M, p * S),
      gc(p && l * M / p)
    ];
  };
}
var TN = sE(function(a) {
  return Jh(2 / (1 + a));
});
TN.invert = aE(function(a) {
  return 2 * gc(a / 2);
});
var oE = sE(function(a) {
  return (a = X2(a)) && a / Gn(a);
});
oE.invert = aE(function(a) {
  return a;
});
function kN() {
  return EN(oE).scale(79.4188).clipAngle(180 - 1e-3);
}
function y1(a, n) {
  return [a, n];
}
y1.invert = y1;
var { BufferOp: IN, GeoJSONReader: MN, GeoJSONWriter: CN } = tN;
function PN(a, n, l) {
  l = l || {};
  var p = l.units || "kilometers", x = l.steps || 8;
  if (!a) throw new Error("geojson is required");
  if (typeof l != "object") throw new Error("options must be an object");
  if (typeof x != "number") throw new Error("steps must be an number");
  if (n === void 0) throw new Error("radius is required");
  if (x <= 0) throw new Error("steps must be greater than 0");
  var M = [];
  switch (a.type) {
    case "GeometryCollection":
      return xc(a, function(S) {
        var u = yg(S, n, p, x);
        u && M.push(u);
      }), _i(M);
    case "FeatureCollection":
      return Mo(a, function(S) {
        var u = yg(S, n, p, x);
        u && Mo(u, function(R) {
          R && M.push(R);
        });
      }), _i(M);
  }
  return yg(a, n, p, x);
}
function yg(a, n, l, p) {
  var x = a.properties || {}, M = a.type === "Feature" ? a.geometry : a;
  if (M.type === "GeometryCollection") {
    var S = [];
    return xc(a, function(_e) {
      var ne = yg(_e, n, l, p);
      ne && S.push(ne);
    }), _i(S);
  }
  var u = AN(M), R = {
    type: M.type,
    coordinates: uE(M.coordinates, u)
  }, z = new MN(), U = z.read(R), $ = uv(cv(n, l), "meters"), ee = IN.bufferOp(U, $, p), le = new CN();
  if (ee = le.write(ee), !lE(ee.coordinates)) {
    var ce = {
      type: ee.type,
      coordinates: cE(ee.coordinates, u)
    };
    return Ja(ce, x);
  }
}
function lE(a) {
  return Array.isArray(a[0]) ? lE(a[0]) : isNaN(a[0]);
}
function uE(a, n) {
  return typeof a[0] != "object" ? n(a) : a.map(function(l) {
    return uE(l, n);
  });
}
function cE(a, n) {
  return typeof a[0] != "object" ? n.invert(a) : a.map(function(l) {
    return cE(l, n);
  });
}
function AN(a) {
  var n = JF(a).geometry.coordinates, l = [-n[0], -n[1]];
  return kN().rotate(l).scale(Fi);
}
var LN = PN;
class hE {
  constructor(n = [], l = DN) {
    if (this.data = n, this.length = this.data.length, this.compare = l, this.length > 0)
      for (let p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
  }
  push(n) {
    this.data.push(n), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const n = this.data[0], l = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = l, this._down(0)), n;
  }
  peek() {
    return this.data[0];
  }
  _up(n) {
    const { data: l, compare: p } = this, x = l[n];
    for (; n > 0; ) {
      const M = n - 1 >> 1, S = l[M];
      if (p(x, S) >= 0) break;
      l[n] = S, n = M;
    }
    l[n] = x;
  }
  _down(n) {
    const { data: l, compare: p } = this, x = this.length >> 1, M = l[n];
    for (; n < x; ) {
      let S = (n << 1) + 1, u = l[S];
      const R = S + 1;
      if (R < this.length && p(l[R], u) < 0 && (S = R, u = l[R]), p(u, M) >= 0) break;
      l[n] = u, n = S;
    }
    l[n] = M;
  }
}
function DN(a, n) {
  return a < n ? -1 : a > n ? 1 : 0;
}
function dE(a, n) {
  return a.p.x > n.p.x ? 1 : a.p.x < n.p.x ? -1 : a.p.y !== n.p.y ? a.p.y > n.p.y ? 1 : -1 : 1;
}
function RN(a, n) {
  return a.rightSweepEvent.p.x > n.rightSweepEvent.p.x ? 1 : a.rightSweepEvent.p.x < n.rightSweepEvent.p.x ? -1 : a.rightSweepEvent.p.y !== n.rightSweepEvent.p.y ? a.rightSweepEvent.p.y < n.rightSweepEvent.p.y ? 1 : -1 : 1;
}
class v1 {
  constructor(n, l, p, x) {
    this.p = {
      x: n[0],
      y: n[1]
    }, this.featureId = l, this.ringId = p, this.eventId = x, this.otherEvent = null, this.isLeftEndpoint = null;
  }
  isSamePoint(n) {
    return this.p.x === n.p.x && this.p.y === n.p.y;
  }
}
function FN(a, n) {
  if (a.type === "FeatureCollection") {
    const l = a.features;
    for (let p = 0; p < l.length; p++)
      x1(l[p], n);
  } else
    x1(a, n);
}
let sg = 0, ag = 0, og = 0;
function x1(a, n) {
  const l = a.type === "Feature" ? a.geometry : a;
  let p = l.coordinates;
  (l.type === "Polygon" || l.type === "MultiLineString") && (p = [p]), l.type === "LineString" && (p = [[p]]);
  for (let x = 0; x < p.length; x++)
    for (let M = 0; M < p[x].length; M++) {
      let S = p[x][M][0], u = null;
      ag = ag + 1;
      for (let R = 0; R < p[x][M].length - 1; R++) {
        u = p[x][M][R + 1];
        const z = new v1(S, sg, ag, og), U = new v1(u, sg, ag, og + 1);
        z.otherEvent = U, U.otherEvent = z, dE(z, U) > 0 ? (U.isLeftEndpoint = !0, z.isLeftEndpoint = !1) : (z.isLeftEndpoint = !0, U.isLeftEndpoint = !1), n.push(z), n.push(U), S = u, og = og + 1;
      }
    }
  sg = sg + 1;
}
let NN = class {
  constructor(a) {
    this.leftSweepEvent = a, this.rightSweepEvent = a.otherEvent;
  }
};
function ON(a, n) {
  if (a === null || n === null || a.leftSweepEvent.ringId === n.leftSweepEvent.ringId && (a.rightSweepEvent.isSamePoint(n.leftSweepEvent) || a.rightSweepEvent.isSamePoint(n.leftSweepEvent) || a.rightSweepEvent.isSamePoint(n.rightSweepEvent) || a.leftSweepEvent.isSamePoint(n.leftSweepEvent) || a.leftSweepEvent.isSamePoint(n.rightSweepEvent))) return !1;
  const l = a.leftSweepEvent.p.x, p = a.leftSweepEvent.p.y, x = a.rightSweepEvent.p.x, M = a.rightSweepEvent.p.y, S = n.leftSweepEvent.p.x, u = n.leftSweepEvent.p.y, R = n.rightSweepEvent.p.x, z = n.rightSweepEvent.p.y, U = (z - u) * (x - l) - (R - S) * (M - p), $ = (R - S) * (p - u) - (z - u) * (l - S), ee = (x - l) * (p - u) - (M - p) * (l - S);
  if (U === 0)
    return !1;
  const le = $ / U, ce = ee / U;
  if (le >= 0 && le <= 1 && ce >= 0 && ce <= 1) {
    const _e = l + le * (x - l), ne = p + le * (M - p);
    return [_e, ne];
  }
  return !1;
}
function zN(a, n) {
  n = n || !1;
  const l = [], p = new hE([], RN);
  for (; a.length; ) {
    const x = a.pop();
    if (x.isLeftEndpoint) {
      const M = new NN(x);
      for (let S = 0; S < p.data.length; S++) {
        const u = p.data[S];
        if (n && u.leftSweepEvent.featureId === x.featureId)
          continue;
        const R = ON(M, u);
        R !== !1 && l.push(R);
      }
      p.push(M);
    } else x.isLeftEndpoint === !1 && p.pop();
  }
  return l;
}
function BN(a, n) {
  const l = new hE([], dE);
  return FN(a, l), zN(l, n);
}
var GN = BN;
function $f(a, n, l = {}) {
  const { removeDuplicates: p = !0, ignoreSelfIntersections: x = !0 } = l;
  let M = [];
  a.type === "FeatureCollection" ? M = M.concat(a.features) : a.type === "Feature" ? M.push(a) : (a.type === "LineString" || a.type === "Polygon" || a.type === "MultiLineString" || a.type === "MultiPolygon") && M.push(Ja(a)), n.type === "FeatureCollection" ? M = M.concat(n.features) : n.type === "Feature" ? M.push(n) : (n.type === "LineString" || n.type === "Polygon" || n.type === "MultiLineString" || n.type === "MultiPolygon") && M.push(Ja(n));
  const S = GN(
    _i(M),
    x
  );
  let u = [];
  if (p) {
    const R = {};
    S.forEach((z) => {
      const U = z.join(",");
      R[U] || (R[U] = !0, u.push(z));
    });
  } else
    u = S;
  return _i(u.map((R) => Ha(R)));
}
var jN = $f;
function My(a) {
  const n = Js(a);
  let l = 0, p = 1, x, M;
  for (; p < n.length; )
    x = M || n[0], M = n[p], l += (M[0] - x[0]) * (M[1] + x[1]), p++;
  return l > 0;
}
function VN(a, n = {}) {
  var l, p;
  if (n = n || {}, !Qg(n)) throw new Error("options is invalid");
  const x = (l = n.mutate) != null ? l : !1, M = (p = n.reverse) != null ? p : !1;
  if (!a) throw new Error("<geojson> is required");
  if (typeof M != "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof x != "boolean")
    throw new Error("<mutate> must be a boolean");
  !x && a.type !== "Point" && a.type !== "MultiPoint" && (a = em(a));
  const S = [];
  switch (a.type) {
    case "GeometryCollection":
      return xc(a, function(u) {
        vg(u, M);
      }), a;
    case "FeatureCollection":
      return Mo(a, function(u) {
        const R = vg(u, M);
        Mo(R, function(z) {
          S.push(z);
        });
      }), _i(S);
  }
  return vg(a, M);
}
function vg(a, n) {
  switch (a.type === "Feature" ? a.geometry.type : a.type) {
    case "GeometryCollection":
      return xc(a, function(l) {
        vg(l, n);
      }), a;
    case "LineString":
      return b1(Js(a), n), a;
    case "Polygon":
      return w1(Js(a), n), a;
    case "MultiLineString":
      return Js(a).forEach(function(l) {
        b1(l, n);
      }), a;
    case "MultiPolygon":
      return Js(a).forEach(function(l) {
        w1(l, n);
      }), a;
    case "Point":
    case "MultiPoint":
      return a;
  }
}
function b1(a, n) {
  My(a) === n && a.reverse();
}
function w1(a, n) {
  My(a[0]) !== n && a[0].reverse();
  for (let l = 1; l < a.length; l++)
    My(a[l]) === n && a[l].reverse();
}
var UN = VN;
const qN = ["Point", "MultiPoint"], $N = [
  "LineString",
  "MultiLineString",
  "Polygon",
  "MultiPolygon"
], fE = (a) => qN.includes(a.geometry.type), Cy = (a) => $N.includes(a.geometry.type), ZN = (a, n) => (Vf(a, (l) => {
  const p = l.coordinate;
  p[0] += n.lng, p[1] += n.lat;
}), a), HN = (a, n) => {
  const l = a.getBounds(), p = B2(l[0], l[1], { units: "meters" });
  return LN(n, p * 1e-4, { units: "meters" }) || null;
}, YN = (a, n) => {
  const l = Qs(a.getGeoJson());
  return ZN(l, n), l;
}, WN = (a, n) => {
  try {
    Vf(a, (l) => {
      if (!pc(l.coordinate, n))
        throw new Error("stop");
    });
  } catch {
    return !1;
  }
  return !0;
}, lg = (a, n) => {
  const l = WN(a, n);
  return fE(a) ? l : l && Cy(a) ? !jN(a, n, { ignoreSelfIntersections: !0 }).features.length : !1;
}, bv = (a) => {
  const n = a.getGeoJson();
  return typeof n != "object" ? null : $2(n);
}, XN = (a) => {
  if (Cy(a)) {
    const n = UN(a, { mutate: !1 });
    if (n.type === "Feature" && Cy(n))
      return {
        ...n,
        properties: a.properties || {}
      };
  }
  return fE(a) ? a : null;
}, JN = (a, n) => {
  const l = a.properties?.[n];
  return typeof l == "string" || typeof l == "number" ? l : null;
};
class wv extends qf {
  mode = "drag";
  previousLngLat = null;
  pointBasedShapes = ["marker", "circle_marker", "text_marker"];
  throttledMethods = bc(
    {
      onMouseMove: this.onMouseMove
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  eventHandlers = {
    [`${Ot}:edit`]: this.handleGmEdit.bind(this),
    mousedown: this.onMouseDown.bind(this),
    touchstart: this.onMouseDown.bind(this),
    mousemove: this.throttledMethods.onMouseMove.bind(this),
    touchmove: this.throttledMethods.onMouseMove.bind(this),
    mouseup: this.onMouseUp.bind(this),
    touchend: this.onMouseUp.bind(this)
  };
  getUpdatedGeoJsonHandlers = {
    marker: this.moveSource.bind(this),
    ellipse: this.moveEllipse.bind(this),
    circle: this.moveCircle.bind(this),
    circle_marker: this.moveSource.bind(this),
    text_marker: this.moveSource.bind(this),
    line: this.moveSource.bind(this),
    rectangle: this.moveSource.bind(this),
    polygon: this.moveSource.bind(this)
  };
  onMouseDown(n) {
    if (!Yn(n))
      return { next: !0 };
    const l = this.getFeatureByMouseEvent({ event: n, sourceNames: [Et.main] });
    return l && this.getUpdatedGeoJsonHandlers[l.shape] ? (this.featureData = l, this.featureData.changeSource({ sourceName: Et.temporary, atomic: !0 }), this.gm.mapAdapter.setDragPan(!1), this.snappingHelper?.addExcludedFeature(this.featureData), this.fireFeatureEditStartEvent({ feature: this.featureData, forceMode: "drag" }), this.flags.actionInProgress = !0, this.isPointBasedShape() && this.alignShapeCenterWithControlMarker(this.featureData, n), { next: !1 }) : { next: !0 };
  }
  onMouseUp(n) {
    return !this.featureData || !Yn(n, { warning: !0 }) ? { next: !0 } : (this.snappingHelper?.clearExcludedFeatures(), this.featureData.changeSource({ sourceName: Et.main, atomic: !0 }), this.previousLngLat = null, this.gm.mapAdapter.setDragPan(!0), this.fireFeatureEditEndEvent({ feature: this.featureData, forceMode: "drag" }), this.flags.actionInProgress = !1, this.featureData = null, { next: !0 });
  }
  onMouseMove(n) {
    if (!this.flags.actionInProgress || !Yn(n, { warning: !0 }))
      return { next: !0 };
    if (this.featureData) {
      const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
      this.moveFeature(this.featureData, l);
    }
    return { next: !1 };
  }
  isPointBasedShape() {
    return !!this.featureData && this.pointBasedShapes.includes(this.featureData.shape);
  }
  alignShapeCenterWithControlMarker(n, l) {
    const p = bv(n);
    p && (this.gm.markerPointer.marker?.setLngLat(p), this.onMouseMove(l));
  }
  moveFeature(n, l) {
    if (!this.flags.actionInProgress)
      return;
    if (!this.previousLngLat) {
      this.previousLngLat = l;
      return;
    }
    const p = this.getUpdatedGeoJsonHandlers[n.shape];
    if (p) {
      const x = p(n, this.previousLngLat, l);
      if (!x) {
        Ct.error("BaseDrag.moveFeature: invalid updatedGeoJson", n);
        return;
      }
      this.fireBeforeFeatureUpdate({
        features: [n],
        geoJsonFeatures: [x],
        forceMode: "drag"
      });
      const M = this.updateFeatureGeoJson({
        featureData: n,
        featureGeoJson: x,
        forceMode: "drag"
      });
      $h(n.getGeoJson().properties, x.properties) || n._updateAllProperties(x.properties), M && (this.previousLngLat = l);
    }
  }
  moveSource(n, l, p) {
    const x = L_(l, p);
    return YN(n, x);
  }
  moveEllipse(n, l, p) {
    if (n.shape !== "ellipse")
      return Ct.error("BaseDrag.moveCircle: invalid shape type", n), null;
    const x = n.getShapeProperty("center"), M = n.getShapeProperty("xSemiAxis"), S = n.getShapeProperty("ySemiAxis"), u = n.getShapeProperty("angle");
    if (!Array.isArray(x) || typeof M != "number" || typeof S != "number" || typeof u != "number")
      return Ct.error(
        "BaseDrag.moveEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        n
      ), null;
    const R = L_(l, p), z = [
      x[0] + R.lng,
      x[1] + R.lat
    ];
    return rm({
      center: z,
      xSemiAxis: M,
      ySemiAxis: S,
      angle: u
    });
  }
  moveCircle(n, l, p) {
    if (n.shape !== "circle")
      return Ct.error("BaseDrag.moveCircle: invalid shape type", n), null;
    const x = n.getShapeProperty("center");
    if (!Array.isArray(x))
      return Ct.error("BaseDrag.moveCircle: missing center in the featureData", n), null;
    const M = n.getGeoJson(), S = L_(l, p), u = $2(M);
    if (!u)
      return Ct.error("BaseDrag.moveCircle: missing center circleRimLngLat"), null;
    const R = [
      x[0] + S.lng,
      x[1] + S.lat
    ];
    n.setShapeProperty("center", R);
    const z = pv({
      center: R,
      radius: this.gm.mapAdapter.getDistance(x, u)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle"
      },
      geometry: z.geometry
    };
  }
}
const KN = (a, n) => (a % n + n) % n;
class QN extends wv {
  mode = "change";
  cutVertexShapeTypes = ["line", "polygon", "rectangle"];
  markerData = null;
  shapeUpdateHandlers = {
    marker: this.updateSingleVertex.bind(this),
    circle: this.updateCircle.bind(this),
    circle_marker: this.updateSingleVertex.bind(this),
    ellipse: this.updateEllipse.bind(this),
    text_marker: this.updateSingleVertex.bind(this),
    line: this.updateSingleVertex.bind(this),
    rectangle: this.updateRectangle.bind(this),
    polygon: this.updateSingleVertex.bind(this)
  };
  get snapGuidesInstance() {
    const n = this.gm.actionInstances.helper__snap_guides;
    return Y2(n) ? n : null;
  }
  onStartAction() {
  }
  onEndAction() {
    this.snapGuidesInstance?.removeSnapGuides();
  }
  handleGmEdit(n) {
    if (!Xh(n))
      return { next: !0 };
    if (n.action === "marker_move" && n.lngLatStart && n.markerData) {
      if (n.markerData.type === "vertex")
        return this.moveVertex(n), { next: !1 };
      if (n.lngLatEnd)
        return this.moveSource(n.featureData, n.lngLatStart, n.lngLatEnd), { next: !1 };
    }
    return n.action === "marker_right_click" ? (this.cutVertex(n), this.fireFeatureEditEndEvent({ feature: n.featureData })) : n.action === "edge_marker_click" ? this.insertVertex(n) : n.action === "marker_captured" ? (this.setCursorToPointer(), n.featureData.changeSource({ sourceName: Et.temporary, atomic: !0 }), this.flags.actionInProgress = !0, this.fireFeatureEditStartEvent({ feature: n.featureData })) : n.action === "marker_released" && (this.markerData = null, this.snapGuidesInstance?.removeSnapGuides(), n.featureData.changeSource({ sourceName: Et.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: n.featureData }), this.flags.actionInProgress = !1), { next: !0 };
  }
  moveVertex(n) {
    this.markerData || (this.markerData = n.markerData || null, this.snapGuidesInstance?.updateSnapGuides(n.featureData.getGeoJson(), n.lngLatStart));
    const l = n.featureData, p = l.shape, x = this.shapeUpdateHandlers[p]?.(n) || null;
    x ? (this.fireBeforeFeatureUpdate({
      features: [l],
      geoJsonFeatures: [x]
    }), this.updateFeatureGeoJson({ featureData: l, featureGeoJson: x })) : Ct.error("EditChange.moveVertex: invalid geojson", x, n);
  }
  cutVertex(n) {
    const l = n.featureData;
    if (n.markerData.type !== "vertex" || !this.cutVertexShapeTypes.includes(l.shape))
      return;
    let p = !1;
    const x = l.getGeoJson(), M = n.markerData.instance;
    if (j2(x)) {
      if (D_(x) <= 2) {
        this.gm.features.delete(l);
        return;
      }
    } else if (U2(x)) {
      if (D_(x) <= 3) {
        this.gm.features.delete(l);
        return;
      }
    } else if (V2(x) && D_(x) <= 3) {
      this.gm.features.delete(l);
      return;
    }
    const S = bv(M);
    S && (p = HR(x, S)), p ? (l.convertToPolygon(), l.updateGeoJsonGeometry(x.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [l],
      targetFeatures: [l],
      markerData: n.markerData
    })) : Ct.error("EditChange.cutVertex: feature not updated", n);
  }
  insertVertex(n) {
    if (n.markerData.type !== "edge")
      return;
    const l = n.featureData.getGeoJson(), p = n.markerData.segment.end.path, x = p.pop(), M = Nh(l, p);
    typeof x == "number" && (M.splice(x, 0, [...n.markerData.position.coordinate]), n.featureData.updateGeoJsonGeometry(l.geometry), n.featureData.convertToPolygon(), this.fireFeatureUpdatedEvent({
      sourceFeatures: [n.featureData],
      targetFeatures: [n.featureData],
      markerData: n.markerData
    }));
  }
  updateSingleVertex({ featureData: n, lngLatEnd: l, markerData: p }) {
    const x = Qs(n.getGeoJson()), M = Qs(p.position.path), S = M.pop(), u = Nh(x, M);
    return Array.isArray(u) && typeof S == "number" ? (u[S] = [...l], S === 0 && n.shape === "polygon" && (u[u.length - 1] = [...l])) : Ct.error("BaseDrag.moveSingleVertex: invalid coordinates", x, M), x;
  }
  updateCircle({ featureData: n, lngLatEnd: l }) {
    const p = n.getShapeProperty("center");
    if (n.shape !== "circle" || !p)
      return Ct.error("BaseDrag.moveCircle: invalid shape type / missing center", n), null;
    const x = pv({
      center: p,
      radius: this.gm.mapAdapter.getDistance(p, l)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle"
      },
      geometry: x.geometry
    };
  }
  updateEllipse(n) {
    const { featureData: l, lngLatEnd: p, markerData: x } = n;
    if (l.shape !== "ellipse")
      return Ct.error("EditChange.updateEllipse: invalid shape type", l), null;
    const M = l.getShapeProperty("center");
    let S = l.getShapeProperty("xSemiAxis"), u = l.getShapeProperty("ySemiAxis");
    const R = l.getShapeProperty("angle");
    if (!Array.isArray(M) || typeof S != "number" || typeof u != "number" || typeof R != "number")
      return Ct.error(
        "updateEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        l
      ), null;
    const z = this.gm.mapAdapter.getDistance(M, p), U = x.position.path[3], $ = Math.floor(U / Z2 * 4);
    return ($ === 0 || $ === 2 ? "x" : "y") == "x" ? S = z : u = z, rm({
      center: M,
      xSemiAxis: S,
      ySemiAxis: u,
      angle: R
    });
  }
  updateRectangle({ featureData: n, lngLatStart: l, lngLatEnd: p }) {
    const x = n.getGeoJson(), M = x.geometry.coordinates[0], { absCoordIndex: S } = tm(x, l);
    if (S === -1)
      return Ct.error("EditChange.updateRectangle: start vertex not found", n), null;
    const u = KN(S - 2, 4), R = M[u];
    return vy(p, R);
  }
}
function eO(a, n, {
  ignoreSelfIntersections: l = !0
} = { ignoreSelfIntersections: !0 }) {
  let p = !0;
  return tu(a, (x) => {
    tu(n, (M) => {
      if (p === !1)
        return !1;
      p = tO(
        x.geometry,
        M.geometry,
        l
      );
    });
  }), p;
}
function tO(a, n, l) {
  switch (a.type) {
    case "Point":
      switch (n.type) {
        case "Point":
          return !sO(a.coordinates, n.coordinates);
        case "LineString":
          return !E1(n, a);
        case "Polygon":
          return !pc(a, n);
      }
      break;
    case "LineString":
      switch (n.type) {
        case "Point":
          return !E1(a, n);
        case "LineString":
          return !rO(a, n, l);
        case "Polygon":
          return !S1(n, a, l);
      }
      break;
    case "Polygon":
      switch (n.type) {
        case "Point":
          return !pc(n, a);
        case "LineString":
          return !S1(a, n, l);
        case "Polygon":
          return !nO(n, a, l);
      }
  }
  return !1;
}
function E1(a, n) {
  for (let l = 0; l < a.coordinates.length - 1; l++)
    if (iO(
      a.coordinates[l],
      a.coordinates[l + 1],
      n.coordinates
    ))
      return !0;
  return !1;
}
function rO(a, n, l) {
  return $f(a, n, {
    ignoreSelfIntersections: l
  }).features.length > 0;
}
function S1(a, n, l) {
  for (const p of n.coordinates)
    if (pc(p, a))
      return !0;
  return $f(n, yy(a), {
    ignoreSelfIntersections: l
  }).features.length > 0;
}
function nO(a, n, l) {
  for (const p of a.coordinates[0])
    if (pc(p, n))
      return !0;
  for (const p of n.coordinates[0])
    if (pc(p, a))
      return !0;
  return $f(
    yy(a),
    yy(n),
    { ignoreSelfIntersections: l }
  ).features.length > 0;
}
function iO(a, n, l) {
  const p = l[0] - a[0], x = l[1] - a[1], M = n[0] - a[0], S = n[1] - a[1];
  return p * S - x * M !== 0 ? !1 : Math.abs(M) >= Math.abs(S) ? M > 0 ? a[0] <= l[0] && l[0] <= n[0] : n[0] <= l[0] && l[0] <= a[0] : S > 0 ? a[1] <= l[1] && l[1] <= n[1] : n[1] <= l[1] && l[1] <= a[1];
}
function sO(a, n) {
  return a[0] === n[0] && a[1] === n[1];
}
function aO(a, n, {
  ignoreSelfIntersections: l = !0
} = {}) {
  let p = !1;
  return tu(a, (x) => {
    tu(n, (M) => {
      if (p === !0)
        return !0;
      p = !eO(x.geometry, M.geometry, {
        ignoreSelfIntersections: l
      });
    });
  }), p;
}
var oO = aO, lO = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, G_ = Math.ceil, da = Math.floor, Ms = "[BigNumber Error] ", T1 = Ms + "Number primitive has more than 15 significant digits: ", Ba = 1e14, vr = 14, j_ = 9007199254740991, V_ = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], $l = 1e7, Di = 1e9;
function pE(a) {
  var n, l, p, x = ve.prototype = { constructor: ve, toString: null, valueOf: null }, M = new ve(1), S = 20, u = 4, R = -7, z = 21, U = -1e7, $ = 1e7, ee = !1, le = 1, ce = 0, _e = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ne = "0123456789abcdefghijklmnopqrstuvwxyz", Pe = !0;
  function ve(Q, se) {
    var ge, Se, Ie, ze, Re, De, Ne, Ge, qe = this;
    if (!(qe instanceof ve)) return new ve(Q, se);
    if (se == null) {
      if (Q && Q._isBigNumber === !0) {
        qe.s = Q.s, !Q.c || Q.e > $ ? qe.c = qe.e = null : Q.e < U ? qe.c = [qe.e = 0] : (qe.e = Q.e, qe.c = Q.c.slice());
        return;
      }
      if ((De = typeof Q == "number") && Q * 0 == 0) {
        if (qe.s = 1 / Q < 0 ? (Q = -Q, -1) : 1, Q === ~~Q) {
          for (ze = 0, Re = Q; Re >= 10; Re /= 10, ze++) ;
          ze > $ ? qe.c = qe.e = null : (qe.e = ze, qe.c = [Q]);
          return;
        }
        Ge = String(Q);
      } else {
        if (!lO.test(Ge = String(Q))) return p(qe, Ge, De);
        qe.s = Ge.charCodeAt(0) == 45 ? (Ge = Ge.slice(1), -1) : 1;
      }
      (ze = Ge.indexOf(".")) > -1 && (Ge = Ge.replace(".", "")), (Re = Ge.search(/e/i)) > 0 ? (ze < 0 && (ze = Re), ze += +Ge.slice(Re + 1), Ge = Ge.substring(0, Re)) : ze < 0 && (ze = Ge.length);
    } else {
      if (On(se, 2, ne.length, "Base"), se == 10 && Pe)
        return qe = new ve(Q), Xe(qe, S + qe.e + 1, u);
      if (Ge = String(Q), De = typeof Q == "number") {
        if (Q * 0 != 0) return p(qe, Ge, De, se);
        if (qe.s = 1 / Q < 0 ? (Ge = Ge.slice(1), -1) : 1, ve.DEBUG && Ge.replace(/^0\.0*|\./, "").length > 15)
          throw Error(T1 + Q);
      } else
        qe.s = Ge.charCodeAt(0) === 45 ? (Ge = Ge.slice(1), -1) : 1;
      for (ge = ne.slice(0, se), ze = Re = 0, Ne = Ge.length; Re < Ne; Re++)
        if (ge.indexOf(Se = Ge.charAt(Re)) < 0) {
          if (Se == ".") {
            if (Re > ze) {
              ze = Ne;
              continue;
            }
          } else if (!Ie && (Ge == Ge.toUpperCase() && (Ge = Ge.toLowerCase()) || Ge == Ge.toLowerCase() && (Ge = Ge.toUpperCase()))) {
            Ie = !0, Re = -1, ze = 0;
            continue;
          }
          return p(qe, String(Q), De, se);
        }
      De = !1, Ge = l(Ge, se, 10, qe.s), (ze = Ge.indexOf(".")) > -1 ? Ge = Ge.replace(".", "") : ze = Ge.length;
    }
    for (Re = 0; Ge.charCodeAt(Re) === 48; Re++) ;
    for (Ne = Ge.length; Ge.charCodeAt(--Ne) === 48; ) ;
    if (Ge = Ge.slice(Re, ++Ne)) {
      if (Ne -= Re, De && ve.DEBUG && Ne > 15 && (Q > j_ || Q !== da(Q)))
        throw Error(T1 + qe.s * Q);
      if ((ze = ze - Re - 1) > $)
        qe.c = qe.e = null;
      else if (ze < U)
        qe.c = [qe.e = 0];
      else {
        if (qe.e = ze, qe.c = [], Re = (ze + 1) % vr, ze < 0 && (Re += vr), Re < Ne) {
          for (Re && qe.c.push(+Ge.slice(0, Re)), Ne -= vr; Re < Ne; )
            qe.c.push(+Ge.slice(Re, Re += vr));
          Re = vr - (Ge = Ge.slice(Re)).length;
        } else
          Re -= Ne;
        for (; Re--; Ge += "0") ;
        qe.c.push(+Ge);
      }
    } else
      qe.c = [qe.e = 0];
  }
  ve.clone = pE, ve.ROUND_UP = 0, ve.ROUND_DOWN = 1, ve.ROUND_CEIL = 2, ve.ROUND_FLOOR = 3, ve.ROUND_HALF_UP = 4, ve.ROUND_HALF_DOWN = 5, ve.ROUND_HALF_EVEN = 6, ve.ROUND_HALF_CEIL = 7, ve.ROUND_HALF_FLOOR = 8, ve.EUCLID = 9, ve.config = ve.set = function(Q) {
    var se, ge;
    if (Q != null)
      if (typeof Q == "object") {
        if (Q.hasOwnProperty(se = "DECIMAL_PLACES") && (ge = Q[se], On(ge, 0, Di, se), S = ge), Q.hasOwnProperty(se = "ROUNDING_MODE") && (ge = Q[se], On(ge, 0, 8, se), u = ge), Q.hasOwnProperty(se = "EXPONENTIAL_AT") && (ge = Q[se], ge && ge.pop ? (On(ge[0], -Di, 0, se), On(ge[1], 0, Di, se), R = ge[0], z = ge[1]) : (On(ge, -Di, Di, se), R = -(z = ge < 0 ? -ge : ge))), Q.hasOwnProperty(se = "RANGE"))
          if (ge = Q[se], ge && ge.pop)
            On(ge[0], -Di, -1, se), On(ge[1], 1, Di, se), U = ge[0], $ = ge[1];
          else if (On(ge, -Di, Di, se), ge)
            U = -($ = ge < 0 ? -ge : ge);
          else
            throw Error(Ms + se + " cannot be zero: " + ge);
        if (Q.hasOwnProperty(se = "CRYPTO"))
          if (ge = Q[se], ge === !!ge)
            if (ge)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                ee = ge;
              else
                throw ee = !ge, Error(Ms + "crypto unavailable");
            else
              ee = ge;
          else
            throw Error(Ms + se + " not true or false: " + ge);
        if (Q.hasOwnProperty(se = "MODULO_MODE") && (ge = Q[se], On(ge, 0, 9, se), le = ge), Q.hasOwnProperty(se = "POW_PRECISION") && (ge = Q[se], On(ge, 0, Di, se), ce = ge), Q.hasOwnProperty(se = "FORMAT"))
          if (ge = Q[se], typeof ge == "object") _e = ge;
          else throw Error(Ms + se + " not an object: " + ge);
        if (Q.hasOwnProperty(se = "ALPHABET"))
          if (ge = Q[se], typeof ge == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(ge))
            Pe = ge.slice(0, 10) == "0123456789", ne = ge;
          else
            throw Error(Ms + se + " invalid: " + ge);
      } else
        throw Error(Ms + "Object expected: " + Q);
    return {
      DECIMAL_PLACES: S,
      ROUNDING_MODE: u,
      EXPONENTIAL_AT: [R, z],
      RANGE: [U, $],
      CRYPTO: ee,
      MODULO_MODE: le,
      POW_PRECISION: ce,
      FORMAT: _e,
      ALPHABET: ne
    };
  }, ve.isBigNumber = function(Q) {
    if (!Q || Q._isBigNumber !== !0) return !1;
    if (!ve.DEBUG) return !0;
    var se, ge, Se = Q.c, Ie = Q.e, ze = Q.s;
    e: if ({}.toString.call(Se) == "[object Array]") {
      if ((ze === 1 || ze === -1) && Ie >= -Di && Ie <= Di && Ie === da(Ie)) {
        if (Se[0] === 0) {
          if (Ie === 0 && Se.length === 1) return !0;
          break e;
        }
        if (se = (Ie + 1) % vr, se < 1 && (se += vr), String(Se[0]).length == se) {
          for (se = 0; se < Se.length; se++)
            if (ge = Se[se], ge < 0 || ge >= Ba || ge !== da(ge)) break e;
          if (ge !== 0) return !0;
        }
      }
    } else if (Se === null && Ie === null && (ze === null || ze === 1 || ze === -1))
      return !0;
    throw Error(Ms + "Invalid BigNumber: " + Q);
  }, ve.maximum = ve.max = function() {
    return Qe(arguments, -1);
  }, ve.minimum = ve.min = function() {
    return Qe(arguments, 1);
  }, ve.random = (function() {
    var Q = 9007199254740992, se = Math.random() * Q & 2097151 ? function() {
      return da(Math.random() * Q);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(ge) {
      var Se, Ie, ze, Re, De, Ne = 0, Ge = [], qe = new ve(M);
      if (ge == null ? ge = S : On(ge, 0, Di), Re = G_(ge / vr), ee)
        if (crypto.getRandomValues) {
          for (Se = crypto.getRandomValues(new Uint32Array(Re *= 2)); Ne < Re; )
            De = Se[Ne] * 131072 + (Se[Ne + 1] >>> 11), De >= 9e15 ? (Ie = crypto.getRandomValues(new Uint32Array(2)), Se[Ne] = Ie[0], Se[Ne + 1] = Ie[1]) : (Ge.push(De % 1e14), Ne += 2);
          Ne = Re / 2;
        } else if (crypto.randomBytes) {
          for (Se = crypto.randomBytes(Re *= 7); Ne < Re; )
            De = (Se[Ne] & 31) * 281474976710656 + Se[Ne + 1] * 1099511627776 + Se[Ne + 2] * 4294967296 + Se[Ne + 3] * 16777216 + (Se[Ne + 4] << 16) + (Se[Ne + 5] << 8) + Se[Ne + 6], De >= 9e15 ? crypto.randomBytes(7).copy(Se, Ne) : (Ge.push(De % 1e14), Ne += 7);
          Ne = Re / 7;
        } else
          throw ee = !1, Error(Ms + "crypto unavailable");
      if (!ee)
        for (; Ne < Re; )
          De = se(), De < 9e15 && (Ge[Ne++] = De % 1e14);
      for (Re = Ge[--Ne], ge %= vr, Re && ge && (De = V_[vr - ge], Ge[Ne] = da(Re / De) * De); Ge[Ne] === 0; Ge.pop(), Ne--) ;
      if (Ne < 0)
        Ge = [ze = 0];
      else {
        for (ze = -1; Ge[0] === 0; Ge.splice(0, 1), ze -= vr) ;
        for (Ne = 1, De = Ge[0]; De >= 10; De /= 10, Ne++) ;
        Ne < vr && (ze -= vr - Ne);
      }
      return qe.e = ze, qe.c = Ge, qe;
    };
  })(), ve.sum = function() {
    for (var Q = 1, se = arguments, ge = new ve(se[0]); Q < se.length; ) ge = ge.plus(se[Q++]);
    return ge;
  }, l = /* @__PURE__ */ (function() {
    var Q = "0123456789";
    function se(ge, Se, Ie, ze) {
      for (var Re, De = [0], Ne, Ge = 0, qe = ge.length; Ge < qe; ) {
        for (Ne = De.length; Ne--; De[Ne] *= Se) ;
        for (De[0] += ze.indexOf(ge.charAt(Ge++)), Re = 0; Re < De.length; Re++)
          De[Re] > Ie - 1 && (De[Re + 1] == null && (De[Re + 1] = 0), De[Re + 1] += De[Re] / Ie | 0, De[Re] %= Ie);
      }
      return De.reverse();
    }
    return function(ge, Se, Ie, ze, Re) {
      var De, Ne, Ge, qe, Je, ft, Tt, Zt, zt = ge.indexOf("."), At = S, Dt = u;
      for (zt >= 0 && (qe = ce, ce = 0, ge = ge.replace(".", ""), Zt = new ve(Se), ft = Zt.pow(ge.length - zt), ce = qe, Zt.c = se(
        rl(ha(ft.c), ft.e, "0"),
        10,
        Ie,
        Q
      ), Zt.e = Zt.c.length), Tt = se(ge, Se, Ie, Re ? (De = ne, Q) : (De = Q, ne)), Ge = qe = Tt.length; Tt[--qe] == 0; Tt.pop()) ;
      if (!Tt[0]) return De.charAt(0);
      if (zt < 0 ? --Ge : (ft.c = Tt, ft.e = Ge, ft.s = ze, ft = n(ft, Zt, At, Dt, Ie), Tt = ft.c, Je = ft.r, Ge = ft.e), Ne = Ge + At + 1, zt = Tt[Ne], qe = Ie / 2, Je = Je || Ne < 0 || Tt[Ne + 1] != null, Je = Dt < 4 ? (zt != null || Je) && (Dt == 0 || Dt == (ft.s < 0 ? 3 : 2)) : zt > qe || zt == qe && (Dt == 4 || Je || Dt == 6 && Tt[Ne - 1] & 1 || Dt == (ft.s < 0 ? 8 : 7)), Ne < 1 || !Tt[0])
        ge = Je ? rl(De.charAt(1), -At, De.charAt(0)) : De.charAt(0);
      else {
        if (Tt.length = Ne, Je)
          for (--Ie; ++Tt[--Ne] > Ie; )
            Tt[Ne] = 0, Ne || (++Ge, Tt = [1].concat(Tt));
        for (qe = Tt.length; !Tt[--qe]; ) ;
        for (zt = 0, ge = ""; zt <= qe; ge += De.charAt(Tt[zt++])) ;
        ge = rl(ge, Ge, De.charAt(0));
      }
      return ge;
    };
  })(), n = /* @__PURE__ */ (function() {
    function Q(Se, Ie, ze) {
      var Re, De, Ne, Ge, qe = 0, Je = Se.length, ft = Ie % $l, Tt = Ie / $l | 0;
      for (Se = Se.slice(); Je--; )
        Ne = Se[Je] % $l, Ge = Se[Je] / $l | 0, Re = Tt * Ne + Ge * ft, De = ft * Ne + Re % $l * $l + qe, qe = (De / ze | 0) + (Re / $l | 0) + Tt * Ge, Se[Je] = De % ze;
      return qe && (Se = [qe].concat(Se)), Se;
    }
    function se(Se, Ie, ze, Re) {
      var De, Ne;
      if (ze != Re)
        Ne = ze > Re ? 1 : -1;
      else
        for (De = Ne = 0; De < ze; De++)
          if (Se[De] != Ie[De]) {
            Ne = Se[De] > Ie[De] ? 1 : -1;
            break;
          }
      return Ne;
    }
    function ge(Se, Ie, ze, Re) {
      for (var De = 0; ze--; )
        Se[ze] -= De, De = Se[ze] < Ie[ze] ? 1 : 0, Se[ze] = De * Re + Se[ze] - Ie[ze];
      for (; !Se[0] && Se.length > 1; Se.splice(0, 1)) ;
    }
    return function(Se, Ie, ze, Re, De) {
      var Ne, Ge, qe, Je, ft, Tt, Zt, zt, At, Dt, Yt, mr, He, yi, fr, Bt, Me, br = Se.s == Ie.s ? 1 : -1, ur = Se.c, rr = Ie.c;
      if (!ur || !ur[0] || !rr || !rr[0])
        return new ve(
          // Return NaN if either NaN, or both Infinity or 0.
          !Se.s || !Ie.s || (ur ? rr && ur[0] == rr[0] : !rr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            ur && ur[0] == 0 || !rr ? br * 0 : br / 0
          )
        );
      for (zt = new ve(br), At = zt.c = [], Ge = Se.e - Ie.e, br = ze + Ge + 1, De || (De = Ba, Ge = fa(Se.e / vr) - fa(Ie.e / vr), br = br / vr | 0), qe = 0; rr[qe] == (ur[qe] || 0); qe++) ;
      if (rr[qe] > (ur[qe] || 0) && Ge--, br < 0)
        At.push(1), Je = !0;
      else {
        for (yi = ur.length, Bt = rr.length, qe = 0, br += 2, ft = da(De / (rr[0] + 1)), ft > 1 && (rr = Q(rr, ft, De), ur = Q(ur, ft, De), Bt = rr.length, yi = ur.length), He = Bt, Dt = ur.slice(0, Bt), Yt = Dt.length; Yt < Bt; Dt[Yt++] = 0) ;
        Me = rr.slice(), Me = [0].concat(Me), fr = rr[0], rr[1] >= De / 2 && fr++;
        do {
          if (ft = 0, Ne = se(rr, Dt, Bt, Yt), Ne < 0) {
            if (mr = Dt[0], Bt != Yt && (mr = mr * De + (Dt[1] || 0)), ft = da(mr / fr), ft > 1)
              for (ft >= De && (ft = De - 1), Tt = Q(rr, ft, De), Zt = Tt.length, Yt = Dt.length; se(Tt, Dt, Zt, Yt) == 1; )
                ft--, ge(Tt, Bt < Zt ? Me : rr, Zt, De), Zt = Tt.length, Ne = 1;
            else
              ft == 0 && (Ne = ft = 1), Tt = rr.slice(), Zt = Tt.length;
            if (Zt < Yt && (Tt = [0].concat(Tt)), ge(Dt, Tt, Yt, De), Yt = Dt.length, Ne == -1)
              for (; se(rr, Dt, Bt, Yt) < 1; )
                ft++, ge(Dt, Bt < Yt ? Me : rr, Yt, De), Yt = Dt.length;
          } else Ne === 0 && (ft++, Dt = [0]);
          At[qe++] = ft, Dt[0] ? Dt[Yt++] = ur[He] || 0 : (Dt = [ur[He]], Yt = 1);
        } while ((He++ < yi || Dt[0] != null) && br--);
        Je = Dt[0] != null, At[0] || At.splice(0, 1);
      }
      if (De == Ba) {
        for (qe = 1, br = At[0]; br >= 10; br /= 10, qe++) ;
        Xe(zt, ze + (zt.e = qe + Ge * vr - 1) + 1, Re, Je);
      } else
        zt.e = Ge, zt.r = +Je;
      return zt;
    };
  })();
  function Ue(Q, se, ge, Se) {
    var Ie, ze, Re, De, Ne;
    if (ge == null ? ge = u : On(ge, 0, 8), !Q.c) return Q.toString();
    if (Ie = Q.c[0], Re = Q.e, se == null)
      Ne = ha(Q.c), Ne = Se == 1 || Se == 2 && (Re <= R || Re >= z) ? cg(Ne, Re) : rl(Ne, Re, "0");
    else if (Q = Xe(new ve(Q), se, ge), ze = Q.e, Ne = ha(Q.c), De = Ne.length, Se == 1 || Se == 2 && (se <= ze || ze <= R)) {
      for (; De < se; Ne += "0", De++) ;
      Ne = cg(Ne, ze);
    } else if (se -= Re + (Se === 2 && ze > Re), Ne = rl(Ne, ze, "0"), ze + 1 > De) {
      if (--se > 0) for (Ne += "."; se--; Ne += "0") ;
    } else if (se += ze - De, se > 0)
      for (ze + 1 == De && (Ne += "."); se--; Ne += "0") ;
    return Q.s < 0 && Ie ? "-" + Ne : Ne;
  }
  function Qe(Q, se) {
    for (var ge, Se, Ie = 1, ze = new ve(Q[0]); Ie < Q.length; Ie++)
      Se = new ve(Q[Ie]), (!Se.s || (ge = nc(ze, Se)) === se || ge === 0 && ze.s === se) && (ze = Se);
    return ze;
  }
  function et(Q, se, ge) {
    for (var Se = 1, Ie = se.length; !se[--Ie]; se.pop()) ;
    for (Ie = se[0]; Ie >= 10; Ie /= 10, Se++) ;
    return (ge = Se + ge * vr - 1) > $ ? Q.c = Q.e = null : ge < U ? Q.c = [Q.e = 0] : (Q.e = ge, Q.c = se), Q;
  }
  p = /* @__PURE__ */ (function() {
    var Q = /^(-?)0([xbo])(?=\w[\w.]*$)/i, se = /^([^.]+)\.$/, ge = /^\.([^.]+)$/, Se = /^-?(Infinity|NaN)$/, Ie = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(ze, Re, De, Ne) {
      var Ge, qe = De ? Re : Re.replace(Ie, "");
      if (Se.test(qe))
        ze.s = isNaN(qe) ? null : qe < 0 ? -1 : 1;
      else {
        if (!De && (qe = qe.replace(Q, function(Je, ft, Tt) {
          return Ge = (Tt = Tt.toLowerCase()) == "x" ? 16 : Tt == "b" ? 2 : 8, !Ne || Ne == Ge ? ft : Je;
        }), Ne && (Ge = Ne, qe = qe.replace(se, "$1").replace(ge, "0.$1")), Re != qe))
          return new ve(qe, Ge);
        if (ve.DEBUG)
          throw Error(Ms + "Not a" + (Ne ? " base " + Ne : "") + " number: " + Re);
        ze.s = null;
      }
      ze.c = ze.e = null;
    };
  })();
  function Xe(Q, se, ge, Se) {
    var Ie, ze, Re, De, Ne, Ge, qe, Je = Q.c, ft = V_;
    if (Je) {
      e: {
        for (Ie = 1, De = Je[0]; De >= 10; De /= 10, Ie++) ;
        if (ze = se - Ie, ze < 0)
          ze += vr, Re = se, Ne = Je[Ge = 0], qe = da(Ne / ft[Ie - Re - 1] % 10);
        else if (Ge = G_((ze + 1) / vr), Ge >= Je.length)
          if (Se) {
            for (; Je.length <= Ge; Je.push(0)) ;
            Ne = qe = 0, Ie = 1, ze %= vr, Re = ze - vr + 1;
          } else
            break e;
        else {
          for (Ne = De = Je[Ge], Ie = 1; De >= 10; De /= 10, Ie++) ;
          ze %= vr, Re = ze - vr + Ie, qe = Re < 0 ? 0 : da(Ne / ft[Ie - Re - 1] % 10);
        }
        if (Se = Se || se < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        Je[Ge + 1] != null || (Re < 0 ? Ne : Ne % ft[Ie - Re - 1]), Se = ge < 4 ? (qe || Se) && (ge == 0 || ge == (Q.s < 0 ? 3 : 2)) : qe > 5 || qe == 5 && (ge == 4 || Se || ge == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (ze > 0 ? Re > 0 ? Ne / ft[Ie - Re] : 0 : Je[Ge - 1]) % 10 & 1 || ge == (Q.s < 0 ? 8 : 7)), se < 1 || !Je[0])
          return Je.length = 0, Se ? (se -= Q.e + 1, Je[0] = ft[(vr - se % vr) % vr], Q.e = -se || 0) : Je[0] = Q.e = 0, Q;
        if (ze == 0 ? (Je.length = Ge, De = 1, Ge--) : (Je.length = Ge + 1, De = ft[vr - ze], Je[Ge] = Re > 0 ? da(Ne / ft[Ie - Re] % ft[Re]) * De : 0), Se)
          for (; ; )
            if (Ge == 0) {
              for (ze = 1, Re = Je[0]; Re >= 10; Re /= 10, ze++) ;
              for (Re = Je[0] += De, De = 1; Re >= 10; Re /= 10, De++) ;
              ze != De && (Q.e++, Je[0] == Ba && (Je[0] = 1));
              break;
            } else {
              if (Je[Ge] += De, Je[Ge] != Ba) break;
              Je[Ge--] = 0, De = 1;
            }
        for (ze = Je.length; Je[--ze] === 0; Je.pop()) ;
      }
      Q.e > $ ? Q.c = Q.e = null : Q.e < U && (Q.c = [Q.e = 0]);
    }
    return Q;
  }
  function ut(Q) {
    var se, ge = Q.e;
    return ge === null ? Q.toString() : (se = ha(Q.c), se = ge <= R || ge >= z ? cg(se, ge) : rl(se, ge, "0"), Q.s < 0 ? "-" + se : se);
  }
  return x.absoluteValue = x.abs = function() {
    var Q = new ve(this);
    return Q.s < 0 && (Q.s = 1), Q;
  }, x.comparedTo = function(Q, se) {
    return nc(this, new ve(Q, se));
  }, x.decimalPlaces = x.dp = function(Q, se) {
    var ge, Se, Ie, ze = this;
    if (Q != null)
      return On(Q, 0, Di), se == null ? se = u : On(se, 0, 8), Xe(new ve(ze), Q + ze.e + 1, se);
    if (!(ge = ze.c)) return null;
    if (Se = ((Ie = ge.length - 1) - fa(this.e / vr)) * vr, Ie = ge[Ie]) for (; Ie % 10 == 0; Ie /= 10, Se--) ;
    return Se < 0 && (Se = 0), Se;
  }, x.dividedBy = x.div = function(Q, se) {
    return n(this, new ve(Q, se), S, u);
  }, x.dividedToIntegerBy = x.idiv = function(Q, se) {
    return n(this, new ve(Q, se), 0, 1);
  }, x.exponentiatedBy = x.pow = function(Q, se) {
    var ge, Se, Ie, ze, Re, De, Ne, Ge, qe, Je = this;
    if (Q = new ve(Q), Q.c && !Q.isInteger())
      throw Error(Ms + "Exponent not an integer: " + ut(Q));
    if (se != null && (se = new ve(se)), De = Q.e > 14, !Je.c || !Je.c[0] || Je.c[0] == 1 && !Je.e && Je.c.length == 1 || !Q.c || !Q.c[0])
      return qe = new ve(Math.pow(+ut(Je), De ? Q.s * (2 - ug(Q)) : +ut(Q))), se ? qe.mod(se) : qe;
    if (Ne = Q.s < 0, se) {
      if (se.c ? !se.c[0] : !se.s) return new ve(NaN);
      Se = !Ne && Je.isInteger() && se.isInteger(), Se && (Je = Je.mod(se));
    } else {
      if (Q.e > 9 && (Je.e > 0 || Je.e < -1 || (Je.e == 0 ? Je.c[0] > 1 || De && Je.c[1] >= 24e7 : Je.c[0] < 8e13 || De && Je.c[0] <= 9999975e7)))
        return ze = Je.s < 0 && ug(Q) ? -0 : 0, Je.e > -1 && (ze = 1 / ze), new ve(Ne ? 1 / ze : ze);
      ce && (ze = G_(ce / vr + 2));
    }
    for (De ? (ge = new ve(0.5), Ne && (Q.s = 1), Ge = ug(Q)) : (Ie = Math.abs(+ut(Q)), Ge = Ie % 2), qe = new ve(M); ; ) {
      if (Ge) {
        if (qe = qe.times(Je), !qe.c) break;
        ze ? qe.c.length > ze && (qe.c.length = ze) : Se && (qe = qe.mod(se));
      }
      if (Ie) {
        if (Ie = da(Ie / 2), Ie === 0) break;
        Ge = Ie % 2;
      } else if (Q = Q.times(ge), Xe(Q, Q.e + 1, 1), Q.e > 14)
        Ge = ug(Q);
      else {
        if (Ie = +ut(Q), Ie === 0) break;
        Ge = Ie % 2;
      }
      Je = Je.times(Je), ze ? Je.c && Je.c.length > ze && (Je.c.length = ze) : Se && (Je = Je.mod(se));
    }
    return Se ? qe : (Ne && (qe = M.div(qe)), se ? qe.mod(se) : ze ? Xe(qe, ce, u, Re) : qe);
  }, x.integerValue = function(Q) {
    var se = new ve(this);
    return Q == null ? Q = u : On(Q, 0, 8), Xe(se, se.e + 1, Q);
  }, x.isEqualTo = x.eq = function(Q, se) {
    return nc(this, new ve(Q, se)) === 0;
  }, x.isFinite = function() {
    return !!this.c;
  }, x.isGreaterThan = x.gt = function(Q, se) {
    return nc(this, new ve(Q, se)) > 0;
  }, x.isGreaterThanOrEqualTo = x.gte = function(Q, se) {
    return (se = nc(this, new ve(Q, se))) === 1 || se === 0;
  }, x.isInteger = function() {
    return !!this.c && fa(this.e / vr) > this.c.length - 2;
  }, x.isLessThan = x.lt = function(Q, se) {
    return nc(this, new ve(Q, se)) < 0;
  }, x.isLessThanOrEqualTo = x.lte = function(Q, se) {
    return (se = nc(this, new ve(Q, se))) === -1 || se === 0;
  }, x.isNaN = function() {
    return !this.s;
  }, x.isNegative = function() {
    return this.s < 0;
  }, x.isPositive = function() {
    return this.s > 0;
  }, x.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, x.minus = function(Q, se) {
    var ge, Se, Ie, ze, Re = this, De = Re.s;
    if (Q = new ve(Q, se), se = Q.s, !De || !se) return new ve(NaN);
    if (De != se)
      return Q.s = -se, Re.plus(Q);
    var Ne = Re.e / vr, Ge = Q.e / vr, qe = Re.c, Je = Q.c;
    if (!Ne || !Ge) {
      if (!qe || !Je) return qe ? (Q.s = -se, Q) : new ve(Je ? Re : NaN);
      if (!qe[0] || !Je[0])
        return Je[0] ? (Q.s = -se, Q) : new ve(qe[0] ? Re : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          u == 3 ? -0 : 0
        ));
    }
    if (Ne = fa(Ne), Ge = fa(Ge), qe = qe.slice(), De = Ne - Ge) {
      for ((ze = De < 0) ? (De = -De, Ie = qe) : (Ge = Ne, Ie = Je), Ie.reverse(), se = De; se--; Ie.push(0)) ;
      Ie.reverse();
    } else
      for (Se = (ze = (De = qe.length) < (se = Je.length)) ? De : se, De = se = 0; se < Se; se++)
        if (qe[se] != Je[se]) {
          ze = qe[se] < Je[se];
          break;
        }
    if (ze && (Ie = qe, qe = Je, Je = Ie, Q.s = -Q.s), se = (Se = Je.length) - (ge = qe.length), se > 0) for (; se--; qe[ge++] = 0) ;
    for (se = Ba - 1; Se > De; ) {
      if (qe[--Se] < Je[Se]) {
        for (ge = Se; ge && !qe[--ge]; qe[ge] = se) ;
        --qe[ge], qe[Se] += Ba;
      }
      qe[Se] -= Je[Se];
    }
    for (; qe[0] == 0; qe.splice(0, 1), --Ge) ;
    return qe[0] ? et(Q, qe, Ge) : (Q.s = u == 3 ? -1 : 1, Q.c = [Q.e = 0], Q);
  }, x.modulo = x.mod = function(Q, se) {
    var ge, Se, Ie = this;
    return Q = new ve(Q, se), !Ie.c || !Q.s || Q.c && !Q.c[0] ? new ve(NaN) : !Q.c || Ie.c && !Ie.c[0] ? new ve(Ie) : (le == 9 ? (Se = Q.s, Q.s = 1, ge = n(Ie, Q, 0, 3), Q.s = Se, ge.s *= Se) : ge = n(Ie, Q, 0, le), Q = Ie.minus(ge.times(Q)), !Q.c[0] && le == 1 && (Q.s = Ie.s), Q);
  }, x.multipliedBy = x.times = function(Q, se) {
    var ge, Se, Ie, ze, Re, De, Ne, Ge, qe, Je, ft, Tt, Zt, zt, At, Dt = this, Yt = Dt.c, mr = (Q = new ve(Q, se)).c;
    if (!Yt || !mr || !Yt[0] || !mr[0])
      return !Dt.s || !Q.s || Yt && !Yt[0] && !mr || mr && !mr[0] && !Yt ? Q.c = Q.e = Q.s = null : (Q.s *= Dt.s, !Yt || !mr ? Q.c = Q.e = null : (Q.c = [0], Q.e = 0)), Q;
    for (Se = fa(Dt.e / vr) + fa(Q.e / vr), Q.s *= Dt.s, Ne = Yt.length, Je = mr.length, Ne < Je && (Zt = Yt, Yt = mr, mr = Zt, Ie = Ne, Ne = Je, Je = Ie), Ie = Ne + Je, Zt = []; Ie--; Zt.push(0)) ;
    for (zt = Ba, At = $l, Ie = Je; --Ie >= 0; ) {
      for (ge = 0, ft = mr[Ie] % At, Tt = mr[Ie] / At | 0, Re = Ne, ze = Ie + Re; ze > Ie; )
        Ge = Yt[--Re] % At, qe = Yt[Re] / At | 0, De = Tt * Ge + qe * ft, Ge = ft * Ge + De % At * At + Zt[ze] + ge, ge = (Ge / zt | 0) + (De / At | 0) + Tt * qe, Zt[ze--] = Ge % zt;
      Zt[ze] = ge;
    }
    return ge ? ++Se : Zt.splice(0, 1), et(Q, Zt, Se);
  }, x.negated = function() {
    var Q = new ve(this);
    return Q.s = -Q.s || null, Q;
  }, x.plus = function(Q, se) {
    var ge, Se = this, Ie = Se.s;
    if (Q = new ve(Q, se), se = Q.s, !Ie || !se) return new ve(NaN);
    if (Ie != se)
      return Q.s = -se, Se.minus(Q);
    var ze = Se.e / vr, Re = Q.e / vr, De = Se.c, Ne = Q.c;
    if (!ze || !Re) {
      if (!De || !Ne) return new ve(Ie / 0);
      if (!De[0] || !Ne[0]) return Ne[0] ? Q : new ve(De[0] ? Se : Ie * 0);
    }
    if (ze = fa(ze), Re = fa(Re), De = De.slice(), Ie = ze - Re) {
      for (Ie > 0 ? (Re = ze, ge = Ne) : (Ie = -Ie, ge = De), ge.reverse(); Ie--; ge.push(0)) ;
      ge.reverse();
    }
    for (Ie = De.length, se = Ne.length, Ie - se < 0 && (ge = Ne, Ne = De, De = ge, se = Ie), Ie = 0; se; )
      Ie = (De[--se] = De[se] + Ne[se] + Ie) / Ba | 0, De[se] = Ba === De[se] ? 0 : De[se] % Ba;
    return Ie && (De = [Ie].concat(De), ++Re), et(Q, De, Re);
  }, x.precision = x.sd = function(Q, se) {
    var ge, Se, Ie, ze = this;
    if (Q != null && Q !== !!Q)
      return On(Q, 1, Di), se == null ? se = u : On(se, 0, 8), Xe(new ve(ze), Q, se);
    if (!(ge = ze.c)) return null;
    if (Ie = ge.length - 1, Se = Ie * vr + 1, Ie = ge[Ie]) {
      for (; Ie % 10 == 0; Ie /= 10, Se--) ;
      for (Ie = ge[0]; Ie >= 10; Ie /= 10, Se++) ;
    }
    return Q && ze.e + 1 > Se && (Se = ze.e + 1), Se;
  }, x.shiftedBy = function(Q) {
    return On(Q, -j_, j_), this.times("1e" + Q);
  }, x.squareRoot = x.sqrt = function() {
    var Q, se, ge, Se, Ie, ze = this, Re = ze.c, De = ze.s, Ne = ze.e, Ge = S + 4, qe = new ve("0.5");
    if (De !== 1 || !Re || !Re[0])
      return new ve(!De || De < 0 && (!Re || Re[0]) ? NaN : Re ? ze : 1 / 0);
    if (De = Math.sqrt(+ut(ze)), De == 0 || De == 1 / 0 ? (se = ha(Re), (se.length + Ne) % 2 == 0 && (se += "0"), De = Math.sqrt(+se), Ne = fa((Ne + 1) / 2) - (Ne < 0 || Ne % 2), De == 1 / 0 ? se = "5e" + Ne : (se = De.toExponential(), se = se.slice(0, se.indexOf("e") + 1) + Ne), ge = new ve(se)) : ge = new ve(De + ""), ge.c[0]) {
      for (Ne = ge.e, De = Ne + Ge, De < 3 && (De = 0); ; )
        if (Ie = ge, ge = qe.times(Ie.plus(n(ze, Ie, Ge, 1))), ha(Ie.c).slice(0, De) === (se = ha(ge.c)).slice(0, De))
          if (ge.e < Ne && --De, se = se.slice(De - 3, De + 1), se == "9999" || !Se && se == "4999") {
            if (!Se && (Xe(Ie, Ie.e + S + 2, 0), Ie.times(Ie).eq(ze))) {
              ge = Ie;
              break;
            }
            Ge += 4, De += 4, Se = 1;
          } else {
            (!+se || !+se.slice(1) && se.charAt(0) == "5") && (Xe(ge, ge.e + S + 2, 1), Q = !ge.times(ge).eq(ze));
            break;
          }
    }
    return Xe(ge, ge.e + S + 1, u, Q);
  }, x.toExponential = function(Q, se) {
    return Q != null && (On(Q, 0, Di), Q++), Ue(this, Q, se, 1);
  }, x.toFixed = function(Q, se) {
    return Q != null && (On(Q, 0, Di), Q = Q + this.e + 1), Ue(this, Q, se);
  }, x.toFormat = function(Q, se, ge) {
    var Se, Ie = this;
    if (ge == null)
      Q != null && se && typeof se == "object" ? (ge = se, se = null) : Q && typeof Q == "object" ? (ge = Q, Q = se = null) : ge = _e;
    else if (typeof ge != "object")
      throw Error(Ms + "Argument not an object: " + ge);
    if (Se = Ie.toFixed(Q, se), Ie.c) {
      var ze, Re = Se.split("."), De = +ge.groupSize, Ne = +ge.secondaryGroupSize, Ge = ge.groupSeparator || "", qe = Re[0], Je = Re[1], ft = Ie.s < 0, Tt = ft ? qe.slice(1) : qe, Zt = Tt.length;
      if (Ne && (ze = De, De = Ne, Ne = ze, Zt -= ze), De > 0 && Zt > 0) {
        for (ze = Zt % De || De, qe = Tt.substr(0, ze); ze < Zt; ze += De) qe += Ge + Tt.substr(ze, De);
        Ne > 0 && (qe += Ge + Tt.slice(ze)), ft && (qe = "-" + qe);
      }
      Se = Je ? qe + (ge.decimalSeparator || "") + ((Ne = +ge.fractionGroupSize) ? Je.replace(
        new RegExp("\\d{" + Ne + "}\\B", "g"),
        "$&" + (ge.fractionGroupSeparator || "")
      ) : Je) : qe;
    }
    return (ge.prefix || "") + Se + (ge.suffix || "");
  }, x.toFraction = function(Q) {
    var se, ge, Se, Ie, ze, Re, De, Ne, Ge, qe, Je, ft, Tt = this, Zt = Tt.c;
    if (Q != null && (De = new ve(Q), !De.isInteger() && (De.c || De.s !== 1) || De.lt(M)))
      throw Error(Ms + "Argument " + (De.isInteger() ? "out of range: " : "not an integer: ") + ut(De));
    if (!Zt) return new ve(Tt);
    for (se = new ve(M), Ge = ge = new ve(M), Se = Ne = new ve(M), ft = ha(Zt), ze = se.e = ft.length - Tt.e - 1, se.c[0] = V_[(Re = ze % vr) < 0 ? vr + Re : Re], Q = !Q || De.comparedTo(se) > 0 ? ze > 0 ? se : Ge : De, Re = $, $ = 1 / 0, De = new ve(ft), Ne.c[0] = 0; qe = n(De, se, 0, 1), Ie = ge.plus(qe.times(Se)), Ie.comparedTo(Q) != 1; )
      ge = Se, Se = Ie, Ge = Ne.plus(qe.times(Ie = Ge)), Ne = Ie, se = De.minus(qe.times(Ie = se)), De = Ie;
    return Ie = n(Q.minus(ge), Se, 0, 1), Ne = Ne.plus(Ie.times(Ge)), ge = ge.plus(Ie.times(Se)), Ne.s = Ge.s = Tt.s, ze = ze * 2, Je = n(Ge, Se, ze, u).minus(Tt).abs().comparedTo(
      n(Ne, ge, ze, u).minus(Tt).abs()
    ) < 1 ? [Ge, Se] : [Ne, ge], $ = Re, Je;
  }, x.toNumber = function() {
    return +ut(this);
  }, x.toPrecision = function(Q, se) {
    return Q != null && On(Q, 1, Di), Ue(this, Q, se, 2);
  }, x.toString = function(Q) {
    var se, ge = this, Se = ge.s, Ie = ge.e;
    return Ie === null ? Se ? (se = "Infinity", Se < 0 && (se = "-" + se)) : se = "NaN" : (Q == null ? se = Ie <= R || Ie >= z ? cg(ha(ge.c), Ie) : rl(ha(ge.c), Ie, "0") : Q === 10 && Pe ? (ge = Xe(new ve(ge), S + Ie + 1, u), se = rl(ha(ge.c), ge.e, "0")) : (On(Q, 2, ne.length, "Base"), se = l(rl(ha(ge.c), Ie, "0"), 10, Q, Se, !0)), Se < 0 && ge.c[0] && (se = "-" + se)), se;
  }, x.valueOf = x.toJSON = function() {
    return ut(this);
  }, x._isBigNumber = !0, x[Symbol.toStringTag] = "BigNumber", x[/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")] = x.valueOf, a != null && ve.set(a), ve;
}
function fa(a) {
  var n = a | 0;
  return a > 0 || a === n ? n : n - 1;
}
function ha(a) {
  for (var n, l, p = 1, x = a.length, M = a[0] + ""; p < x; ) {
    for (n = a[p++] + "", l = vr - n.length; l--; n = "0" + n) ;
    M += n;
  }
  for (x = M.length; M.charCodeAt(--x) === 48; ) ;
  return M.slice(0, x + 1 || 1);
}
function nc(a, n) {
  var l, p, x = a.c, M = n.c, S = a.s, u = n.s, R = a.e, z = n.e;
  if (!S || !u) return null;
  if (l = x && !x[0], p = M && !M[0], l || p) return l ? p ? 0 : -u : S;
  if (S != u) return S;
  if (l = S < 0, p = R == z, !x || !M) return p ? 0 : !x ^ l ? 1 : -1;
  if (!p) return R > z ^ l ? 1 : -1;
  for (u = (R = x.length) < (z = M.length) ? R : z, S = 0; S < u; S++) if (x[S] != M[S]) return x[S] > M[S] ^ l ? 1 : -1;
  return R == z ? 0 : R > z ^ l ? 1 : -1;
}
function On(a, n, l, p) {
  if (a < n || a > l || a !== da(a))
    throw Error(Ms + (p || "Argument") + (typeof a == "number" ? a < n || a > l ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(a));
}
function ug(a) {
  var n = a.c.length - 1;
  return fa(a.e / vr) == n && a.c[n] % 2 != 0;
}
function cg(a, n) {
  return (a.length > 1 ? a.charAt(0) + "." + a.slice(1) : a) + (n < 0 ? "e" : "e+") + n;
}
function rl(a, n, l) {
  var p, x;
  if (n < 0) {
    for (x = l + "."; ++n; x += l) ;
    a = x + a;
  } else if (p = a.length, ++n > p) {
    for (x = l, n -= p; --n; x += l) ;
    a += x;
  } else n < p && (a = a.slice(0, n) + "." + a.slice(n));
  return a;
}
var So = pE(), uO = class {
  key;
  left = null;
  right = null;
  constructor(a) {
    this.key = a;
  }
}, ef = class extends uO {
  constructor(a) {
    super(a);
  }
}, cO = class {
  size = 0;
  modificationCount = 0;
  splayCount = 0;
  splay(a) {
    const n = this.root;
    if (n == null)
      return this.compare(a, a), -1;
    let l = null, p = null, x = null, M = null, S = n;
    const u = this.compare;
    let R;
    for (; ; )
      if (R = u(S.key, a), R > 0) {
        let z = S.left;
        if (z == null || (R = u(z.key, a), R > 0 && (S.left = z.right, z.right = S, S = z, z = S.left, z == null)))
          break;
        l == null ? p = S : l.left = S, l = S, S = z;
      } else if (R < 0) {
        let z = S.right;
        if (z == null || (R = u(z.key, a), R < 0 && (S.right = z.left, z.left = S, S = z, z = S.right, z == null)))
          break;
        x == null ? M = S : x.right = S, x = S, S = z;
      } else
        break;
    return x != null && (x.right = S.left, S.left = M), l != null && (l.left = S.right, S.right = p), this.root !== S && (this.root = S, this.splayCount++), R;
  }
  splayMin(a) {
    let n = a, l = n.left;
    for (; l != null; ) {
      const p = l;
      n.left = p.right, p.right = n, n = p, l = n.left;
    }
    return n;
  }
  splayMax(a) {
    let n = a, l = n.right;
    for (; l != null; ) {
      const p = l;
      n.right = p.left, p.left = n, n = p, l = n.right;
    }
    return n;
  }
  _delete(a) {
    if (this.root == null || this.splay(a) != 0) return null;
    let n = this.root;
    const l = n, p = n.left;
    if (this.size--, p == null)
      this.root = n.right;
    else {
      const x = n.right;
      n = this.splayMax(p), n.right = x, this.root = n;
    }
    return this.modificationCount++, l;
  }
  addNewRoot(a, n) {
    this.size++, this.modificationCount++;
    const l = this.root;
    if (l == null) {
      this.root = a;
      return;
    }
    n < 0 ? (a.left = l, a.right = l.right, l.right = null) : (a.right = l, a.left = l.left, l.left = null), this.root = a;
  }
  _first() {
    const a = this.root;
    return a == null ? null : (this.root = this.splayMin(a), this.root);
  }
  _last() {
    const a = this.root;
    return a == null ? null : (this.root = this.splayMax(a), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(a) {
    return this.validKey(a) && this.splay(a) == 0;
  }
  defaultCompare() {
    return (a, n) => a < n ? -1 : a > n ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (a) => {
        this.root = a;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (a) => {
        this.splayCount = a;
      },
      splay: (a) => this.splay(a),
      has: (a) => this.has(a)
    };
  }
}, Og = class df extends cO {
  root = null;
  compare;
  validKey;
  constructor(n, l) {
    super(), this.compare = n ?? this.defaultCompare(), this.validKey = l ?? ((p) => p != null && p != null);
  }
  delete(n) {
    return this.validKey(n) ? this._delete(n) != null : !1;
  }
  deleteAll(n) {
    for (const l of n)
      this.delete(l);
  }
  forEach(n) {
    const l = this[Symbol.iterator]();
    let p;
    for (; p = l.next(), !p.done; )
      n(p.value, p.value, this);
  }
  add(n) {
    const l = this.splay(n);
    return l != 0 && this.addNewRoot(new ef(n), l), this;
  }
  addAndReturn(n) {
    const l = this.splay(n);
    return l != 0 && this.addNewRoot(new ef(n), l), this.root.key;
  }
  addAll(n) {
    for (const l of n)
      this.add(l);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(n) {
    if (n == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(n) < 0) return this.root.key;
    let l = this.root.left;
    if (l == null) return null;
    let p = l.right;
    for (; p != null; )
      l = p, p = l.right;
    return l.key;
  }
  firstAfter(n) {
    if (n == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(n) > 0) return this.root.key;
    let l = this.root.right;
    if (l == null) return null;
    let p = l.left;
    for (; p != null; )
      l = p, p = l.left;
    return l.key;
  }
  retainAll(n) {
    const l = new df(this.compare, this.validKey), p = this.modificationCount;
    for (const x of n) {
      if (p != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(x) && this.splay(x) == 0 && l.add(this.root.key);
    }
    l.size != this.size && (this.root = l.root, this.size = l.size, this.modificationCount++);
  }
  lookup(n) {
    return !this.validKey(n) || this.splay(n) != 0 ? null : this.root.key;
  }
  intersection(n) {
    const l = new df(this.compare, this.validKey);
    for (const p of this)
      n.has(p) && l.add(p);
    return l;
  }
  difference(n) {
    const l = new df(this.compare, this.validKey);
    for (const p of this)
      n.has(p) || l.add(p);
    return l;
  }
  union(n) {
    const l = this.clone();
    return l.addAll(n), l;
  }
  clone() {
    const n = new df(this.compare, this.validKey);
    return n.size = this.size, n.root = this.copyNode(this.root), n;
  }
  copyNode(n) {
    if (n == null) return null;
    function l(x, M) {
      let S, u;
      do {
        if (S = x.left, u = x.right, S != null) {
          const R = new ef(S.key);
          M.left = R, l(S, R);
        }
        if (u != null) {
          const R = new ef(u.key);
          M.right = R, x = u, M = R;
        }
      } while (u != null);
    }
    const p = new ef(n.key);
    return l(n, p), p;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new dO(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new hO(this.wrap());
  }
  [Symbol.toStringTag] = "[object Set]";
}, gE = class {
  tree;
  path = new Array();
  modificationCount = null;
  splayCount;
  constructor(a) {
    this.tree = a, this.splayCount = a.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const a = this.path[this.path.length - 1];
    return this.getValue(a);
  }
  rebuildPath(a) {
    this.path.splice(0, this.path.length), this.tree.splay(a), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(a) {
    for (; a != null; )
      this.path.push(a), a = a.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let l = this.tree.getRoot();
        for (; l != null; )
          this.path.push(l), l = l.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return !1;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let a = this.path[this.path.length - 1], n = a.right;
    if (n != null) {
      for (; n != null; )
        this.path.push(n), n = n.left;
      return !0;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === a; )
      a = this.path.pop();
    return this.path.length > 0;
  }
}, hO = class extends gE {
  getValue(a) {
    return a.key;
  }
}, dO = class extends gE {
  getValue(a) {
    return [a.key, a.key];
  }
}, mE = (a) => () => a, Py = (a) => {
  const n = a ? (l, p) => p.minus(l).abs().isLessThanOrEqualTo(a) : mE(!1);
  return (l, p) => n(l, p) ? 0 : l.comparedTo(p);
};
function fO(a) {
  const n = a ? (l, p, x, M, S) => l.exponentiatedBy(2).isLessThanOrEqualTo(
    M.minus(p).exponentiatedBy(2).plus(S.minus(x).exponentiatedBy(2)).times(a)
  ) : mE(!1);
  return (l, p, x) => {
    const M = l.x, S = l.y, u = x.x, R = x.y, z = S.minus(R).times(p.x.minus(u)).minus(M.minus(u).times(p.y.minus(R)));
    return n(z, M, S, u, R) ? 0 : z.comparedTo(0);
  };
}
var pO = (a) => a, gO = (a) => {
  if (a) {
    const n = new Og(Py(a)), l = new Og(Py(a)), p = (M, S) => S.addAndReturn(M), x = (M) => ({
      x: p(M.x, n),
      y: p(M.y, l)
    });
    return x({ x: new So(0), y: new So(0) }), x;
  }
  return pO;
}, Ay = (a) => ({
  set: (n) => {
    dl = Ay(n);
  },
  reset: () => Ay(a),
  compare: Py(a),
  snap: gO(a),
  orient: fO(a)
}), dl = Ay(), tf = (a, n) => a.ll.x.isLessThanOrEqualTo(n.x) && n.x.isLessThanOrEqualTo(a.ur.x) && a.ll.y.isLessThanOrEqualTo(n.y) && n.y.isLessThanOrEqualTo(a.ur.y), Ly = (a, n) => {
  if (n.ur.x.isLessThan(a.ll.x) || a.ur.x.isLessThan(n.ll.x) || n.ur.y.isLessThan(a.ll.y) || a.ur.y.isLessThan(n.ll.y))
    return null;
  const l = a.ll.x.isLessThan(n.ll.x) ? n.ll.x : a.ll.x, p = a.ur.x.isLessThan(n.ur.x) ? a.ur.x : n.ur.x, x = a.ll.y.isLessThan(n.ll.y) ? n.ll.y : a.ll.y, M = a.ur.y.isLessThan(n.ur.y) ? a.ur.y : n.ur.y;
  return { ll: { x: l, y: x }, ur: { x: p, y: M } };
}, xg = (a, n) => a.x.times(n.y).minus(a.y.times(n.x)), _E = (a, n) => a.x.times(n.x).plus(a.y.times(n.y)), zg = (a) => _E(a, a).sqrt(), mO = (a, n, l) => {
  const p = { x: n.x.minus(a.x), y: n.y.minus(a.y) }, x = { x: l.x.minus(a.x), y: l.y.minus(a.y) };
  return xg(x, p).div(zg(x)).div(zg(p));
}, _O = (a, n, l) => {
  const p = { x: n.x.minus(a.x), y: n.y.minus(a.y) }, x = { x: l.x.minus(a.x), y: l.y.minus(a.y) };
  return _E(x, p).div(zg(x)).div(zg(p));
}, k1 = (a, n, l) => n.y.isZero() ? null : { x: a.x.plus(n.x.div(n.y).times(l.minus(a.y))), y: l }, I1 = (a, n, l) => n.x.isZero() ? null : { x: l, y: a.y.plus(n.y.div(n.x).times(l.minus(a.x))) }, yO = (a, n, l, p) => {
  if (n.x.isZero()) return I1(l, p, a.x);
  if (p.x.isZero()) return I1(a, n, l.x);
  if (n.y.isZero()) return k1(l, p, a.y);
  if (p.y.isZero()) return k1(a, n, l.y);
  const x = xg(n, p);
  if (x.isZero()) return null;
  const M = { x: l.x.minus(a.x), y: l.y.minus(a.y) }, S = xg(M, n).div(x), u = xg(M, p).div(x), R = a.x.plus(u.times(n.x)), z = l.x.plus(S.times(p.x)), U = a.y.plus(u.times(n.y)), $ = l.y.plus(S.times(p.y)), ee = R.plus(z).div(2), le = U.plus($).div(2);
  return { x: ee, y: le };
}, xo = class yE {
  point;
  isLeft;
  segment;
  otherSE;
  consumedBy;
  // for ordering sweep events in the sweep event queue
  static compare(n, l) {
    const p = yE.comparePoints(n.point, l.point);
    return p !== 0 ? p : (n.point !== l.point && n.link(l), n.isLeft !== l.isLeft ? n.isLeft ? 1 : -1 : Bg.compare(n.segment, l.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(n, l) {
    return n.x.isLessThan(l.x) ? -1 : n.x.isGreaterThan(l.x) ? 1 : n.y.isLessThan(l.y) ? -1 : n.y.isGreaterThan(l.y) ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(n, l) {
    n.events === void 0 ? n.events = [this] : n.events.push(this), this.point = n, this.isLeft = l;
  }
  link(n) {
    if (n.point === this.point)
      throw new Error("Tried to link already linked events");
    const l = n.point.events;
    for (let p = 0, x = l.length; p < x; p++) {
      const M = l[p];
      this.point.events.push(M), M.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const n = this.point.events.length;
    for (let l = 0; l < n; l++) {
      const p = this.point.events[l];
      if (p.segment.consumedBy === void 0)
        for (let x = l + 1; x < n; x++) {
          const M = this.point.events[x];
          M.consumedBy === void 0 && p.otherSE.point.events === M.otherSE.point.events && p.segment.consume(M.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const n = [];
    for (let l = 0, p = this.point.events.length; l < p; l++) {
      const x = this.point.events[l];
      x !== this && !x.segment.ringOut && x.segment.isInResult() && n.push(x);
    }
    return n;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(n) {
    const l = /* @__PURE__ */ new Map(), p = (x) => {
      const M = x.otherSE;
      l.set(x, {
        sine: mO(this.point, n.point, M.point),
        cosine: _O(this.point, n.point, M.point)
      });
    };
    return (x, M) => {
      l.has(x) || p(x), l.has(M) || p(M);
      const { sine: S, cosine: u } = l.get(x), { sine: R, cosine: z } = l.get(M);
      return S.isGreaterThanOrEqualTo(0) && R.isGreaterThanOrEqualTo(0) ? u.isLessThan(z) ? 1 : u.isGreaterThan(z) ? -1 : 0 : S.isLessThan(0) && R.isLessThan(0) ? u.isLessThan(z) ? -1 : u.isGreaterThan(z) ? 1 : 0 : R.isLessThan(S) ? -1 : R.isGreaterThan(S) ? 1 : 0;
    };
  }
}, vO = class Dy {
  events;
  poly;
  _isExteriorRing;
  _enclosingRing;
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(n) {
    const l = [];
    for (let p = 0, x = n.length; p < x; p++) {
      const M = n[p];
      if (!M.isInResult() || M.ringOut) continue;
      let S = null, u = M.leftSE, R = M.rightSE;
      const z = [u], U = u.point, $ = [];
      for (; S = u, u = R, z.push(u), u.point !== U; )
        for (; ; ) {
          const ee = u.getAvailableLinkedEvents();
          if (ee.length === 0) {
            const _e = z[0].point, ne = z[z.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${_e.x}, ${_e.y}]. Last matching segment found ends at [${ne.x}, ${ne.y}].`
            );
          }
          if (ee.length === 1) {
            R = ee[0].otherSE;
            break;
          }
          let le = null;
          for (let _e = 0, ne = $.length; _e < ne; _e++)
            if ($[_e].point === u.point) {
              le = _e;
              break;
            }
          if (le !== null) {
            const _e = $.splice(le)[0], ne = z.splice(_e.index);
            ne.unshift(ne[0].otherSE), l.push(new Dy(ne.reverse()));
            continue;
          }
          $.push({
            index: z.length,
            point: u.point
          });
          const ce = u.getLeftmostComparator(S);
          R = ee.sort(ce)[0].otherSE;
          break;
        }
      l.push(new Dy(z));
    }
    return l;
  }
  constructor(n) {
    this.events = n;
    for (let l = 0, p = n.length; l < p; l++)
      n[l].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let n = this.events[0].point;
    const l = [n];
    for (let z = 1, U = this.events.length - 1; z < U; z++) {
      const $ = this.events[z].point, ee = this.events[z + 1].point;
      dl.orient($, n, ee) !== 0 && (l.push($), n = $);
    }
    if (l.length === 1) return null;
    const p = l[0], x = l[1];
    dl.orient(p, n, x) === 0 && l.shift(), l.push(l[0]);
    const M = this.isExteriorRing() ? 1 : -1, S = this.isExteriorRing() ? 0 : l.length - 1, u = this.isExteriorRing() ? l.length : -1, R = [];
    for (let z = S; z != u; z += M)
      R.push([l[z].x.toNumber(), l[z].y.toNumber()]);
    return R;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const n = this.enclosingRing();
      this._isExteriorRing = n ? !n.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let n = this.events[0];
    for (let x = 1, M = this.events.length; x < M; x++) {
      const S = this.events[x];
      xo.compare(n, S) > 0 && (n = S);
    }
    let l = n.segment.prevInResult(), p = l ? l.prevInResult() : null;
    for (; ; ) {
      if (!l) return null;
      if (!p) return l.ringOut;
      if (p.ringOut !== l.ringOut)
        return p.ringOut?.enclosingRing() !== l.ringOut ? l.ringOut : l.ringOut?.enclosingRing();
      l = p.prevInResult(), p = l ? l.prevInResult() : null;
    }
  }
}, M1 = class {
  exteriorRing;
  interiorRings;
  constructor(a) {
    this.exteriorRing = a, a.poly = this, this.interiorRings = [];
  }
  addInterior(a) {
    this.interiorRings.push(a), a.poly = this;
  }
  getGeom() {
    const a = this.exteriorRing.getGeom();
    if (a === null) return null;
    const n = [a];
    for (let l = 0, p = this.interiorRings.length; l < p; l++) {
      const x = this.interiorRings[l].getGeom();
      x !== null && n.push(x);
    }
    return n;
  }
}, xO = class {
  rings;
  polys;
  constructor(a) {
    this.rings = a, this.polys = this._composePolys(a);
  }
  getGeom() {
    const a = [];
    for (let n = 0, l = this.polys.length; n < l; n++) {
      const p = this.polys[n].getGeom();
      p !== null && a.push(p);
    }
    return a;
  }
  _composePolys(a) {
    const n = [];
    for (let l = 0, p = a.length; l < p; l++) {
      const x = a[l];
      if (!x.poly)
        if (x.isExteriorRing()) n.push(new M1(x));
        else {
          const M = x.enclosingRing();
          M?.poly || n.push(new M1(M)), M?.poly?.addInterior(x);
        }
    }
    return n;
  }
}, bO = class {
  queue;
  tree;
  segments;
  constructor(a, n = Bg.compare) {
    this.queue = a, this.tree = new Og(n), this.segments = [];
  }
  process(a) {
    const n = a.segment, l = [];
    if (a.consumedBy)
      return a.isLeft ? this.queue.delete(a.otherSE) : this.tree.delete(n), l;
    a.isLeft && this.tree.add(n);
    let p = n, x = n;
    do
      p = this.tree.lastBefore(p);
    while (p != null && p.consumedBy != null);
    do
      x = this.tree.firstAfter(x);
    while (x != null && x.consumedBy != null);
    if (a.isLeft) {
      let M = null;
      if (p) {
        const u = p.getIntersection(n);
        if (u !== null && (n.isAnEndpoint(u) || (M = u), !p.isAnEndpoint(u))) {
          const R = this._splitSafely(p, u);
          for (let z = 0, U = R.length; z < U; z++)
            l.push(R[z]);
        }
      }
      let S = null;
      if (x) {
        const u = x.getIntersection(n);
        if (u !== null && (n.isAnEndpoint(u) || (S = u), !x.isAnEndpoint(u))) {
          const R = this._splitSafely(x, u);
          for (let z = 0, U = R.length; z < U; z++)
            l.push(R[z]);
        }
      }
      if (M !== null || S !== null) {
        let u = null;
        M === null ? u = S : S === null ? u = M : u = xo.comparePoints(
          M,
          S
        ) <= 0 ? M : S, this.queue.delete(n.rightSE), l.push(n.rightSE);
        const R = n.split(u);
        for (let z = 0, U = R.length; z < U; z++)
          l.push(R[z]);
      }
      l.length > 0 ? (this.tree.delete(n), l.push(a)) : (this.segments.push(n), n.prev = p);
    } else {
      if (p && x) {
        const M = p.getIntersection(x);
        if (M !== null) {
          if (!p.isAnEndpoint(M)) {
            const S = this._splitSafely(p, M);
            for (let u = 0, R = S.length; u < R; u++)
              l.push(S[u]);
          }
          if (!x.isAnEndpoint(M)) {
            const S = this._splitSafely(x, M);
            for (let u = 0, R = S.length; u < R; u++)
              l.push(S[u]);
          }
        }
      }
      this.tree.delete(n);
    }
    return l;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(a, n) {
    this.tree.delete(a);
    const l = a.rightSE;
    this.queue.delete(l);
    const p = a.split(n);
    return p.push(l), a.consumedBy === void 0 && this.tree.add(a), p;
  }
}, wO = class {
  type;
  numMultiPolys;
  run(a, n, l) {
    ff.type = a;
    const p = [new P1(n, !0)];
    for (let R = 0, z = l.length; R < z; R++)
      p.push(new P1(l[R], !1));
    if (ff.numMultiPolys = p.length, ff.type === "difference") {
      const R = p[0];
      let z = 1;
      for (; z < p.length; )
        Ly(p[z].bbox, R.bbox) !== null ? z++ : p.splice(z, 1);
    }
    if (ff.type === "intersection")
      for (let R = 0, z = p.length; R < z; R++) {
        const U = p[R];
        for (let $ = R + 1, ee = p.length; $ < ee; $++)
          if (Ly(U.bbox, p[$].bbox) === null) return [];
      }
    const x = new Og(xo.compare);
    for (let R = 0, z = p.length; R < z; R++) {
      const U = p[R].getSweepEvents();
      for (let $ = 0, ee = U.length; $ < ee; $++)
        x.add(U[$]);
    }
    const M = new bO(x);
    let S = null;
    for (x.size != 0 && (S = x.first(), x.delete(S)); S; ) {
      const R = M.process(S);
      for (let z = 0, U = R.length; z < U; z++) {
        const $ = R[z];
        $.consumedBy === void 0 && x.add($);
      }
      x.size != 0 ? (S = x.first(), x.delete(S)) : S = null;
    }
    dl.reset();
    const u = vO.factory(M.segments);
    return new xO(u).getGeom();
  }
}, ff = new wO(), Ry = ff, EO = 0, Bg = class bg {
  id;
  leftSE;
  rightSE;
  rings;
  windings;
  ringOut;
  consumedBy;
  prev;
  _prevInResult;
  _beforeState;
  _afterState;
  _isInResult;
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(n, l) {
    const p = n.leftSE.point.x, x = l.leftSE.point.x, M = n.rightSE.point.x, S = l.rightSE.point.x;
    if (S.isLessThan(p)) return 1;
    if (M.isLessThan(x)) return -1;
    const u = n.leftSE.point.y, R = l.leftSE.point.y, z = n.rightSE.point.y, U = l.rightSE.point.y;
    if (p.isLessThan(x)) {
      if (R.isLessThan(u) && R.isLessThan(z)) return 1;
      if (R.isGreaterThan(u) && R.isGreaterThan(z)) return -1;
      const $ = n.comparePoint(l.leftSE.point);
      if ($ < 0) return 1;
      if ($ > 0) return -1;
      const ee = l.comparePoint(n.rightSE.point);
      return ee !== 0 ? ee : -1;
    }
    if (p.isGreaterThan(x)) {
      if (u.isLessThan(R) && u.isLessThan(U)) return -1;
      if (u.isGreaterThan(R) && u.isGreaterThan(U)) return 1;
      const $ = l.comparePoint(n.leftSE.point);
      if ($ !== 0) return $;
      const ee = n.comparePoint(l.rightSE.point);
      return ee < 0 ? 1 : ee > 0 ? -1 : 1;
    }
    if (u.isLessThan(R)) return -1;
    if (u.isGreaterThan(R)) return 1;
    if (M.isLessThan(S)) {
      const $ = l.comparePoint(n.rightSE.point);
      if ($ !== 0) return $;
    }
    if (M.isGreaterThan(S)) {
      const $ = n.comparePoint(l.rightSE.point);
      if ($ < 0) return 1;
      if ($ > 0) return -1;
    }
    if (!M.eq(S)) {
      const $ = z.minus(u), ee = M.minus(p), le = U.minus(R), ce = S.minus(x);
      if ($.isGreaterThan(ee) && le.isLessThan(ce)) return 1;
      if ($.isLessThan(ee) && le.isGreaterThan(ce)) return -1;
    }
    return M.isGreaterThan(S) ? 1 : M.isLessThan(S) || z.isLessThan(U) ? -1 : z.isGreaterThan(U) ? 1 : n.id < l.id ? -1 : n.id > l.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(n, l, p, x) {
    this.id = ++EO, this.leftSE = n, n.segment = this, n.otherSE = l, this.rightSE = l, l.segment = this, l.otherSE = n, this.rings = p, this.windings = x;
  }
  static fromRing(n, l, p) {
    let x, M, S;
    const u = xo.comparePoints(n, l);
    if (u < 0)
      x = n, M = l, S = 1;
    else if (u > 0)
      x = l, M = n, S = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${n.x}, ${n.y}]`
      );
    const R = new xo(x, !0), z = new xo(M, !1);
    return new bg(R, z, [p], [S]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(n) {
    this.rightSE = n, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const n = this.leftSE.point.y, l = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: n.isLessThan(l) ? n : l },
      ur: { x: this.rightSE.point.x, y: n.isGreaterThan(l) ? n : l }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(n) {
    return n.x.eq(this.leftSE.point.x) && n.y.eq(this.leftSE.point.y) || n.x.eq(this.rightSE.point.x) && n.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(n) {
    return dl.orient(this.leftSE.point, n, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(n) {
    const l = this.bbox(), p = n.bbox(), x = Ly(l, p);
    if (x === null) return null;
    const M = this.leftSE.point, S = this.rightSE.point, u = n.leftSE.point, R = n.rightSE.point, z = tf(l, u) && this.comparePoint(u) === 0, U = tf(p, M) && n.comparePoint(M) === 0, $ = tf(l, R) && this.comparePoint(R) === 0, ee = tf(p, S) && n.comparePoint(S) === 0;
    if (U && z)
      return ee && !$ ? S : !ee && $ ? R : null;
    if (U)
      return $ && M.x.eq(R.x) && M.y.eq(R.y) ? null : M;
    if (z)
      return ee && S.x.eq(u.x) && S.y.eq(u.y) ? null : u;
    if (ee && $) return null;
    if (ee) return S;
    if ($) return R;
    const le = yO(M, this.vector(), u, n.vector());
    return le === null || !tf(x, le) ? null : dl.snap(le);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(n) {
    const l = [], p = n.events !== void 0, x = new xo(n, !0), M = new xo(n, !1), S = this.rightSE;
    this.replaceRightSE(M), l.push(M), l.push(x);
    const u = new bg(
      x,
      S,
      this.rings.slice(),
      this.windings.slice()
    );
    return xo.comparePoints(u.leftSE.point, u.rightSE.point) > 0 && u.swapEvents(), xo.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), p && (x.checkForConsuming(), M.checkForConsuming()), l;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const n = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = n, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let l = 0, p = this.windings.length; l < p; l++)
      this.windings[l] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(n) {
    let l = this, p = n;
    for (; l.consumedBy; ) l = l.consumedBy;
    for (; p.consumedBy; ) p = p.consumedBy;
    const x = bg.compare(l, p);
    if (x !== 0) {
      if (x > 0) {
        const M = l;
        l = p, p = M;
      }
      if (l.prev === p) {
        const M = l;
        l = p, p = M;
      }
      for (let M = 0, S = p.rings.length; M < S; M++) {
        const u = p.rings[M], R = p.windings[M], z = l.rings.indexOf(u);
        z === -1 ? (l.rings.push(u), l.windings.push(R)) : l.windings[z] += R;
      }
      p.rings = null, p.windings = null, p.consumedBy = l, p.leftSE.consumedBy = l.leftSE, p.rightSE.consumedBy = l.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const n = this.prev.consumedBy || this.prev;
      this._beforeState = n.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const n = this.beforeState();
    this._afterState = {
      rings: n.rings.slice(0),
      windings: n.windings.slice(0),
      multiPolys: []
    };
    const l = this._afterState.rings, p = this._afterState.windings, x = this._afterState.multiPolys;
    for (let u = 0, R = this.rings.length; u < R; u++) {
      const z = this.rings[u], U = this.windings[u], $ = l.indexOf(z);
      $ === -1 ? (l.push(z), p.push(U)) : p[$] += U;
    }
    const M = [], S = [];
    for (let u = 0, R = l.length; u < R; u++) {
      if (p[u] === 0) continue;
      const z = l[u], U = z.poly;
      if (S.indexOf(U) === -1)
        if (z.isExterior) M.push(U);
        else {
          S.indexOf(U) === -1 && S.push(U);
          const $ = M.indexOf(z.poly);
          $ !== -1 && M.splice($, 1);
        }
    }
    for (let u = 0, R = M.length; u < R; u++) {
      const z = M[u].multiPoly;
      x.indexOf(z) === -1 && x.push(z);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const n = this.beforeState().multiPolys, l = this.afterState().multiPolys;
    switch (Ry.type) {
      case "union": {
        const p = n.length === 0, x = l.length === 0;
        this._isInResult = p !== x;
        break;
      }
      case "intersection": {
        let p, x;
        n.length < l.length ? (p = n.length, x = l.length) : (p = l.length, x = n.length), this._isInResult = x === Ry.numMultiPolys && p < x;
        break;
      }
      case "xor": {
        const p = Math.abs(n.length - l.length);
        this._isInResult = p % 2 === 1;
        break;
      }
      case "difference": {
        const p = (x) => x.length === 1 && x[0].isSubject;
        this._isInResult = p(n) !== p(l);
        break;
      }
    }
    return this._isInResult;
  }
}, C1 = class {
  poly;
  isExterior;
  segments;
  bbox;
  constructor(a, n, l) {
    if (!Array.isArray(a) || a.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = n, this.isExterior = l, this.segments = [], typeof a[0][0] != "number" || typeof a[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const p = dl.snap({ x: new So(a[0][0]), y: new So(a[0][1]) });
    this.bbox = {
      ll: { x: p.x, y: p.y },
      ur: { x: p.x, y: p.y }
    };
    let x = p;
    for (let M = 1, S = a.length; M < S; M++) {
      if (typeof a[M][0] != "number" || typeof a[M][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const u = dl.snap({ x: new So(a[M][0]), y: new So(a[M][1]) });
      u.x.eq(x.x) && u.y.eq(x.y) || (this.segments.push(Bg.fromRing(x, u, this)), u.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = u.x), u.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = u.y), u.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = u.x), u.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = u.y), x = u);
    }
    (!p.x.eq(x.x) || !p.y.eq(x.y)) && this.segments.push(Bg.fromRing(x, p, this));
  }
  getSweepEvents() {
    const a = [];
    for (let n = 0, l = this.segments.length; n < l; n++) {
      const p = this.segments[n];
      a.push(p.leftSE), a.push(p.rightSE);
    }
    return a;
  }
}, SO = class {
  multiPoly;
  exteriorRing;
  interiorRings;
  bbox;
  constructor(a, n) {
    if (!Array.isArray(a))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new C1(a[0], this, !0), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let l = 1, p = a.length; l < p; l++) {
      const x = new C1(a[l], this, !1);
      x.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = x.bbox.ll.x), x.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = x.bbox.ll.y), x.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = x.bbox.ur.x), x.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = x.bbox.ur.y), this.interiorRings.push(x);
    }
    this.multiPoly = n;
  }
  getSweepEvents() {
    const a = this.exteriorRing.getSweepEvents();
    for (let n = 0, l = this.interiorRings.length; n < l; n++) {
      const p = this.interiorRings[n].getSweepEvents();
      for (let x = 0, M = p.length; x < M; x++)
        a.push(p[x]);
    }
    return a;
  }
}, P1 = class {
  isSubject;
  polys;
  bbox;
  constructor(a, n) {
    if (!Array.isArray(a))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof a[0][0][0] == "number" && (a = [a]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new So(Number.POSITIVE_INFINITY), y: new So(Number.POSITIVE_INFINITY) },
      ur: { x: new So(Number.NEGATIVE_INFINITY), y: new So(Number.NEGATIVE_INFINITY) }
    };
    for (let l = 0, p = a.length; l < p; l++) {
      const x = new SO(a[l], this);
      x.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = x.bbox.ll.x), x.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = x.bbox.ll.y), x.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = x.bbox.ur.x), x.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = x.bbox.ur.y), this.polys.push(x);
    }
    this.isSubject = n;
  }
  getSweepEvents() {
    const a = [];
    for (let n = 0, l = this.polys.length; n < l; n++) {
      const p = this.polys[n].getSweepEvents();
      for (let x = 0, M = p.length; x < M; x++)
        a.push(p[x]);
    }
    return a;
  }
}, TO = (a, ...n) => Ry.run("difference", a, n);
dl.set;
function kO(a) {
  const n = [];
  if (xc(a, (x) => {
    n.push(x.coordinates);
  }), n.length < 2)
    throw new Error("Must have at least two features");
  const l = a.features[0].properties || {}, p = TO(n[0], ...n.slice(1));
  return p.length === 0 ? null : p.length === 1 ? Ql(p[0], l) : C2(p, l);
}
var IO = kO;
function vE(a) {
  var n = new pa(a);
  return n.insert = function(l) {
    if (l.type !== "Feature") throw new Error("invalid feature");
    return l.bbox = l.bbox ? l.bbox : il(l), pa.prototype.insert.call(this, l);
  }, n.load = function(l) {
    var p = [];
    return Array.isArray(l) ? l.forEach(function(x) {
      if (x.type !== "Feature") throw new Error("invalid features");
      x.bbox = x.bbox ? x.bbox : il(x), p.push(x);
    }) : Mo(l, function(x) {
      if (x.type !== "Feature") throw new Error("invalid features");
      x.bbox = x.bbox ? x.bbox : il(x), p.push(x);
    }), pa.prototype.load.call(this, p);
  }, n.remove = function(l, p) {
    if (l.type !== "Feature") throw new Error("invalid feature");
    return l.bbox = l.bbox ? l.bbox : il(l), pa.prototype.remove.call(this, l, p);
  }, n.clear = function() {
    return pa.prototype.clear.call(this);
  }, n.search = function(l) {
    var p = pa.prototype.search.call(this, this.toBBox(l));
    return _i(p);
  }, n.collides = function(l) {
    return pa.prototype.collides.call(this, this.toBBox(l));
  }, n.all = function() {
    var l = pa.prototype.all.call(this);
    return _i(l);
  }, n.toJSON = function() {
    return pa.prototype.toJSON.call(this);
  }, n.fromJSON = function(l) {
    return pa.prototype.fromJSON.call(this, l);
  }, n.toBBox = function(l) {
    var p;
    if (l.bbox) p = l.bbox;
    else if (Array.isArray(l) && l.length === 4) p = l;
    else if (Array.isArray(l) && l.length === 6)
      p = [l[0], l[1], l[3], l[4]];
    else if (l.type === "Feature") p = il(l);
    else if (l.type === "FeatureCollection") p = il(l);
    else throw new Error("invalid geojson");
    return {
      minX: p[0],
      minY: p[1],
      maxX: p[2],
      maxY: p[3]
    };
  }, n;
}
function MO(a, n) {
  if (n = n ?? {}, !Qg(n)) throw new Error("options is invalid");
  var l = n.precision, p = n.coordinates, x = n.mutate;
  if (l = l == null || isNaN(l) ? 6 : l, p = p == null || isNaN(p) ? 3 : p, !a) throw new Error("<geojson> is required");
  if (typeof l != "number")
    throw new Error("<precision> must be a number");
  if (typeof p != "number")
    throw new Error("<coordinates> must be a number");
  (x === !1 || x === void 0) && (a = JSON.parse(JSON.stringify(a)));
  var M = Math.pow(10, l);
  return ru(a, function(S) {
    CO(S, M, p);
  }), a;
}
function CO(a, n, l) {
  a.length > l && a.splice(l, a.length);
  for (var p = 0; p < a.length; p++)
    a[p] = Math.round(a[p] * n) / n;
  return a;
}
function PO(a) {
  if (!a)
    throw new Error("geojson is required");
  const n = [];
  return tu(a, (l) => {
    AO(l, n);
  }), _i(n);
}
function AO(a, n) {
  let l = [];
  const p = a.geometry;
  if (p !== null) {
    switch (p.type) {
      case "Polygon":
        l = Js(p);
        break;
      case "LineString":
        l = [Js(p)];
    }
    l.forEach((x) => {
      LO(x, a.properties).forEach((M) => {
        M.id = n.length, n.push(M);
      });
    });
  }
}
function LO(a, n) {
  const l = [];
  return a.reduce((p, x) => {
    const M = eu([p, x], n);
    return M.bbox = DO(p, x), l.push(M), x;
  }), l;
}
function DO(a, n) {
  const l = a[0], p = a[1], x = n[0], M = n[1], S = l < x ? l : x, u = p < M ? p : M, R = l > x ? l : x, z = p > M ? p : M;
  return [S, u, R, z];
}
var RO = Object.defineProperty, FO = Object.defineProperties, NO = Object.getOwnPropertyDescriptors, A1 = Object.getOwnPropertySymbols, OO = Object.prototype.hasOwnProperty, zO = Object.prototype.propertyIsEnumerable, L1 = (a, n, l) => n in a ? RO(a, n, { enumerable: !0, configurable: !0, writable: !0, value: l }) : a[n] = l, D1 = (a, n) => {
  for (var l in n || (n = {}))
    OO.call(n, l) && L1(a, l, n[l]);
  if (A1)
    for (var l of A1(n))
      zO.call(n, l) && L1(a, l, n[l]);
  return a;
}, R1 = (a, n) => FO(a, NO(n));
function BO(a, n, l = {}) {
  if (!a || !n)
    throw new Error("lines and pt are required arguments");
  const p = ri(n);
  let x = Ha([1 / 0, 1 / 0], {
    dist: 1 / 0,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  }), M = 0;
  return tu(
    a,
    function(S, u, R) {
      const z = Js(S);
      for (let U = 0; U < z.length - 1; U++) {
        const $ = Ha(z[U]), ee = ri($), le = Ha(z[U + 1]), ce = ri(le), _e = Dh($, le, l);
        let ne, Pe;
        ce[0] === p[0] && ce[1] === p[1] ? [ne, Pe] = [ce, !0] : ee[0] === p[0] && ee[1] === p[1] ? [ne, Pe] = [ee, !1] : [ne, Pe] = VO(
          ee,
          ce,
          p
        );
        const ve = Ha(ne, {
          dist: Dh(n, ne, l),
          multiFeatureIndex: R,
          location: M + Dh($, ne, l)
        });
        ve.properties.dist < x.properties.dist && (x = R1(D1({}, ve), {
          properties: R1(D1({}, ve.properties), {
            // Legacy behaviour where index progresses to next segment # if we
            // went with the end point this iteration.
            index: Pe ? U + 1 : U
          })
        })), M += _e;
      }
    }
  ), x;
}
function ic(a, n) {
  const [l, p, x] = a, [M, S, u] = n;
  return l * M + p * S + x * u;
}
function rf(a, n) {
  const [l, p, x] = a, [M, S, u] = n;
  return [p * u - x * S, x * M - l * u, l * S - p * M];
}
function GO(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2));
}
function F1(a) {
  const n = GO(a);
  return [a[0] / n, a[1] / n, a[2] / n];
}
function U_(a) {
  const n = Oi(a[1]), l = Oi(a[0]);
  return [
    Math.cos(n) * Math.cos(l),
    Math.cos(n) * Math.sin(l),
    Math.sin(n)
  ];
}
function jO(a) {
  const [n, l, p] = a, x = Math.min(Math.max(p, -1), 1), M = fc(Math.asin(x));
  return [fc(Math.atan2(l, n)), M];
}
function VO(a, n, l) {
  const p = U_(a), x = U_(n), M = U_(l), S = rf(p, x);
  if (S[0] === 0 && S[1] === 0 && S[2] === 0)
    return ic(p, x) > 0 ? [[...n], !0] : [[...l], !1];
  const u = rf(S, M);
  if (u[0] === 0 && u[1] === 0 && u[2] === 0)
    return [[...n], !0];
  const R = rf(u, S), z = F1(R), U = [-z[0], -z[1], -z[2]], $ = ic(M, z) > ic(M, U) ? z : U, ee = F1(S), le = ic(rf(p, $), ee), ce = ic(rf($, x), ee);
  return le >= 0 && ce >= 0 ? [jO($), !1] : ic(p, M) > ic(x, M) ? [[...a], !1] : [[...n], !0];
}
function UO(a, n) {
  if (!a) throw new Error("line is required");
  if (!n) throw new Error("splitter is required");
  var l = Gb(a), p = Gb(n);
  if (l !== "LineString") throw new Error("line must be LineString");
  if (p === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (p === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var x = MO(n, { precision: 7 });
  switch (p) {
    case "Point":
      return Fy(a, x);
    case "MultiPoint":
      return N1(a, x);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return N1(
        a,
        $f(a, x, {
          ignoreSelfIntersections: !0
        })
      );
  }
}
function N1(a, n) {
  var l = [], p = vE();
  return tu(n, function(x) {
    if (l.forEach(function(u, R) {
      u.id = R;
    }), !l.length)
      l = Fy(a, x).features, p.load(_i(l));
    else {
      var M = p.search(x);
      if (M.features.length) {
        var S = xE(x, M);
        l = l.filter(function(u) {
          return u.id !== S.id;
        }), p.remove(S), Mo(Fy(S, x), function(u) {
          l.push(u), p.insert(u);
        });
      }
    }
  }), _i(l);
}
function Fy(a, n) {
  var l = [], p = Js(a)[0], x = Js(a)[a.geometry.coordinates.length - 1];
  if (q_(p, ri(n)) || q_(x, ri(n)))
    return _i([a]);
  var M = vE(), S = PO(a);
  M.load(S);
  var u = M.search(n);
  if (!u.features.length) return _i([a]);
  var R = xE(n, u), z = [p], U = kR(
    S,
    function($, ee, le) {
      var ce = Js(ee)[1], _e = ri(n);
      return le === R.id ? ($.push(_e), l.push(eu($)), q_(_e, ce) ? [_e] : [_e, ce]) : ($.push(ce), $);
    },
    z
  );
  return U.length > 1 && l.push(eu(U)), _i(l);
}
function xE(a, n) {
  if (!n.features.length) throw new Error("lines must contain features");
  if (n.features.length === 1) return n.features[0];
  var l, p = 1 / 0;
  return Mo(n, function(x) {
    var M = BO(x, a), S = M.properties.dist;
    S < p && (l = x, p = S);
  }), l;
}
function q_(a, n) {
  return a[0] === n[0] && a[1] === n[1];
}
var O1 = UO;
class qO extends qf {
  mode = "cut";
  lineDrawer = new xv(this.gm, { snappingMarkers: "first", targetShape: "polygon" });
  cutShapesAllowed = ["circle", "ellipse", "line", "rectangle", "polygon"];
  eventHandlers = {
    [`${Ot}:draw`]: this.forwardLineDrawerEvent.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("firstMarkerClick", this.cutPolygonFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(n) {
    return Yn(n) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  cutPolygonFinished(n) {
    this.lineDrawer.endShape();
    const l = vv(n.geoJson), p = this.getBBoxFeaturesByPolygon(l);
    this.cutFeaturesByPolygon(p, l);
  }
  getBBoxFeaturesByPolygon(n) {
    const l = dv(n), p = this.gm.mapAdapter.coordBoundsToScreenBounds(l);
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: p,
      sourceNames: [Et.main]
    });
  }
  cutFeaturesByPolygon(n, l) {
    n.forEach((p) => {
      if (p.getShapeProperty("disableEdit") !== !0) {
        if (lg(p.getGeoJson(), l)) {
          this.gm.features.delete(p), this.fireFeatureRemovedEvent(p);
          return;
        }
        if (oO(p.getGeoJson(), l) && this.cutShapesAllowed.includes(p.shape)) {
          if (p.shape === "line") {
            this.cutLineFeatureByPolygon(p, l);
            return;
          }
          this.cutPolygonFeatureByPolygon(p.id, l);
        }
      }
    });
  }
  cutLineFeatureByPolygon(n, l) {
    const p = n.getGeoJson(), x = HN(this.gm.mapAdapter, l);
    let M = !1, S = [];
    if (x) {
      if (p.geometry.type === "MultiLineString")
        p.geometry.coordinates.forEach((u) => {
          if (lg(eu(u), l))
            return;
          const R = O1(eu(u), l);
          if (R.features.length === 0) {
            S.push(u);
            return;
          }
          R.features.filter((z) => !lg(z, x)).forEach((z) => {
            M = !0, S.push(z.geometry.coordinates);
          });
        });
      else if (p.geometry.type === "LineString") {
        const u = O1(p, l);
        S = u.features.filter(
          (R) => !lg(R, x) && R.geometry.type === "LineString"
        ).map((R) => R.geometry.coordinates), u.features.length > 0 && (M = !0);
      }
      M && S.length && (S.length === 1 ? n.updateGeoJsonGeometry({ type: "LineString", coordinates: S[0] }) : n.updateGeoJsonGeometry({ type: "MultiLineString", coordinates: S }), this.fireFeatureUpdatedEvent({
        sourceFeatures: [n],
        targetFeatures: [n]
      }));
    }
  }
  cutPolygonFeatureByPolygon(n, l) {
    const p = this.gm.features.get(Et.main, n);
    if (!p) {
      Ct.warn("cutPolygonFeatureByPolygon: featureData not found", n);
      return;
    }
    p.convertToPolygon();
    const x = p.getGeoJson(), M = this.getGeoJsonDifference(x, l);
    M && (p.updateGeoJsonGeometry(M.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [p],
      targetFeatures: [p]
    }));
  }
  getGeoJsonDifference(n, l) {
    const p = _i([n, l]), x = IO(p);
    return x ? x.type === "Feature" ? x : (x.type === "FeatureCollection" && Ct.error("getGeoJsonDifference: FeatureCollection detected (not supported)", x), null) : null;
  }
}
class $O extends qf {
  mode = "delete";
  allowedShapes = [...ol];
  eventHandlers = {
    click: this.onMouseClick.bind(this)
  };
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: !0 }), this.gm.markerPointer.pauseSnapping();
  }
  onEndAction() {
    this.gm.markerPointer.resumeSnapping(), this.gm.markerPointer.disable();
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !1 };
    const l = this.getFeatureByMouseEvent({ event: n, sourceNames: [Et.main] });
    return l && this.allowedShapes.includes(l.shape) && (this.gm.features.delete(l), this.fireFeatureRemovedEvent(l)), { next: !1 };
  }
}
class ZO extends wv {
  mode = "drag";
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(n) {
    return Xh(n) ? n.action === "marker_move" && n.lngLatStart && n.lngLatEnd ? (this.previousLngLat || (this.previousLngLat = n.lngLatStart), this.moveFeature(n.featureData, n.lngLatEnd), { next: !1 }) : (n.action === "marker_captured" ? (n.featureData.changeSource({ sourceName: Et.temporary, atomic: !0 }), this.flags.actionInProgress = !0, this.fireFeatureEditStartEvent({ feature: n.featureData }), this.setCursorToPointer()) : n.action === "marker_released" && (this.previousLngLat = null, n.featureData.changeSource({ sourceName: Et.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: n.featureData }), this.flags.actionInProgress = !1), { next: !0 }) : (Ct.error("EditDrag.handleGmEdit: not an edit event", n), { next: !0 });
  }
}
class HO extends wv {
  mode = "rotate";
  allowedShapes = ["line", "rectangle", "polygon", "ellipse"];
  convertFeaturesTypes = ["rectangle"];
  shapeRotateHandlers = {
    marker: this.rotateFeature.bind(this),
    circle: this.rotateFeature.bind(this),
    circle_marker: this.rotateFeature.bind(this),
    text_marker: this.rotateFeature.bind(this),
    line: this.rotateFeature.bind(this),
    rectangle: this.rotateFeature.bind(this),
    polygon: this.rotateFeature.bind(this),
    ellipse: this.rotateEllipse.bind(this)
  };
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(n) {
    return Xh(n) ? this.isFeatureAllowed(n) ? { next: !0 } : n.action === "marker_move" && n.lngLatStart && n.lngLatEnd ? (n.markerData?.type === "vertex" ? this.moveVertex(n) : this.moveSource(n.featureData, n.lngLatStart, n.lngLatEnd), { next: !1 }) : (n.action === "marker_captured" ? (n.featureData.changeSource({ sourceName: Et.temporary, atomic: !0 }), this.setCursorToPointer(), this.flags.actionInProgress = !0, this.fireFeatureEditStartEvent({ feature: n.featureData })) : n.action === "marker_released" && (n.featureData.changeSource({ sourceName: Et.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: n.featureData }), this.flags.actionInProgress = !1), { next: !0 }) : (Ct.error("EditChange.handleGmEdit: not an edit event", n), { next: !1 });
  }
  isFeatureAllowed(n) {
    return "featureData" in n && !this.allowedShapes.includes(n.featureData.shape);
  }
  moveVertex(n) {
    const l = n.featureData, p = this.shapeRotateHandlers[l.shape]?.(n) || null;
    p ? (this.fireBeforeFeatureUpdate({
      features: [l],
      geoJsonFeatures: [p]
    }), this.updateFeatureGeoJson({ featureData: l, featureGeoJson: p }) && this.convertFeaturesTypes.includes(l.shape) && l.convertToPolygon()) : Ct.error("EditRotate.moveVertex: invalid geojson", p, n);
  }
  rotateEllipse(n) {
    const { featureData: l } = n;
    if (l.shape !== "ellipse")
      return Ct.error("EditRotate.rotateEllipse: invalid shape type", l), null;
    const p = l.getShapeProperty("center"), x = l.getShapeProperty("xSemiAxis"), M = l.getShapeProperty("ySemiAxis"), S = l.getShapeProperty("angle");
    if (!Array.isArray(p) || typeof x != "number" || typeof M != "number" || typeof S != "number")
      return Ct.error(
        "rotateEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        l
      ), null;
    const u = this.calculateRotationAngle(
      p,
      n.lngLatStart,
      n.lngLatEnd,
      !1
    );
    return rm({
      center: p,
      xSemiAxis: x,
      ySemiAxis: M,
      angle: S + u
    });
  }
  rotateFeature(n) {
    const l = n.featureData, p = Qs(l.getGeoJson()), x = xy(_y(p)), M = this.calculateRotationAngle(x, n.lngLatStart, n.lngLatEnd);
    return p.geometry = OR(p, M, { pivot: x }).geometry, p;
  }
  calculateRotationAngle(n, l, p, x = !0) {
    const M = Pg(n, l), S = Pg(n, p) - M;
    return x ? (S + 360) % 360 : S;
  }
}
const Ny = {
  drag: ZO,
  change: QN,
  rotate: HO,
  scale: null,
  copy: null,
  cut: qO,
  split: null,
  union: null,
  difference: null,
  line_simplification: null,
  lasso: null,
  delete: $O
}, YO = (a, n) => Ny[n] ? new Ny[n](a) : (Ct.error(`Edit "${n}" is not available`), null);
class WO extends Kg {
  eventHandlers = {
    [`${Ot}:edit`]: this.handleEditEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleEditEvent(n) {
    if (!Xh(n))
      return { next: !0 };
    const l = `${n.actionType}__${n.mode}`;
    return n.action === "mode_start" ? (this.trackExclusiveModes(n), this.start(l, n), this.trackRelatedModes(n)) : n.action === "mode_end" && (this.trackRelatedModes(n), this.end(l)), { next: !0 };
  }
  start(n, l) {
    if (l.action !== "mode_start")
      return;
    const p = YO(this.gm, l.mode);
    p && (n in this.gm.actionInstances && Ct.error(`Action instance "${n}" already exists`), this.gm.actionInstances[n] = p, p.startAction());
  }
  end(n) {
    const l = this.gm.actionInstances[n];
    l instanceof qf ? (l.endAction(), delete this.gm.actionInstances[n]) : console.error(
      `Wrong action instance for edit event "${n}": `,
      l
    );
  }
}
class XO extends nu {
  mode = "shape_markers";
  pinEnabled = this.gm.options.controls.helper.pin?.active || !1;
  previousPosition = null;
  activeMarker = null;
  activeFeatureData = null;
  sharedMarkers = [];
  allowedShapes = ["circle", "line", "rectangle", "polygon", "ellipse"];
  edgeMarkersAllowed = !1;
  edgeMarkerAllowedShapes = ["line", "rectangle", "polygon"];
  shapeMarkerAllowedModes = ["drag", "change", "cut", "split"];
  eventHandlers = {
    [`${Ot}:draw`]: this.handleGmDraw.bind(this),
    [`${Ot}:edit`]: this.handleGmEdit.bind(this),
    mousedown: this.onMouseDown.bind(this),
    touchstart: this.onMouseDown.bind(this),
    mouseup: this.onMouseUp.bind(this),
    touchend: this.onMouseUp.bind(this),
    mousemove: this.onMouseMove.bind(this),
    touchmove: this.onMouseMove.bind(this),
    contextmenu: this.onMouseRightButtonClick.bind(this)
  };
  throttledMethods = bc(
    {
      sendMarkerMoveEvent: this.sendMarkerMoveEvent,
      sendMarkerRightClickEvent: this.sendMarkerRightClickEvent
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  debouncedMethods = eF(
    {
      refreshMarkers: this.refreshMarkers
    },
    this,
    this.gm.options.settings.throttlingDelay * 10
  );
  get pinHelperInstance() {
    return this.pinEnabled && Object.values(this.gm.actionInstances).find(oF) || null;
  }
  onStartAction() {
    this.isShapeMarkerAllowed() && this.gm.markerPointer.enable({ invisibleMarker: !0 }), this.edgeMarkersAllowed = this.gm.getActiveEditModes().includes("change"), this.addMarkers();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.removeMarkers();
  }
  setPin(n) {
    this.pinEnabled = n;
  }
  onMouseDown(n) {
    const l = ["mousedown", "touchstart"];
    if (!Yn(n, { warning: !0 }) || !l.includes(n.type) || nF(n))
      return { next: !0 };
    if (n.type === "mousedown" && n.originalEvent.button !== 0)
      return { next: !0 };
    const p = this.getFeatureMarkerByMouseEvent(n);
    return this.activeMarker = p || null, this.activeFeatureData = p?.instance.parent || null, this.activeMarker && this.activeFeatureData ? (this.previousPosition = bv(this.activeMarker.instance), this.gm.mapAdapter.setDragPan(!1), this.activeMarker.type === "edge" && this.sendMarkerEvent("edge_marker_click", this.activeFeatureData, this.activeMarker), this.pinEnabled && this.pinHelperInstance ? (this.sharedMarkers = this.pinHelperInstance.getSharedMarkers(
      this.activeMarker.position.coordinate
    ), this.sharedMarkers.forEach(
      (x) => this.snappingHelper?.addExcludedFeature(x.featureData)
    )) : this.snappingHelper?.addExcludedFeature(this.activeFeatureData), this.sendMarkerEvent("marker_captured", this.activeFeatureData, this.activeMarker), { next: !1 }) : { next: !0 };
  }
  onMouseUp() {
    if (!this.activeMarker)
      return { next: !0 };
    const n = {
      featureData: this.activeFeatureData,
      markerData: this.activeMarker
    };
    return this.activeMarker = null, this.activeFeatureData = null, this.sharedMarkers = [], this.snappingHelper?.clearExcludedFeatures(), this.previousPosition = null, this.gm.mapAdapter.setDragPan(!0), n.featureData && n.markerData ? (this.sendMarkerEvent("marker_released", n.featureData, n.markerData), { next: !1 }) : (Ct.debug("ShapeMarkersHelper.onMouseUp: no active marker or featureData", n), { next: !0 });
  }
  onMouseMove(n) {
    return !this.activeMarker || !Yn(n, { warning: !0 }) ? { next: !0 } : (this.throttledMethods.sendMarkerMoveEvent(n), { next: !1 });
  }
  onMouseRightButtonClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !0 };
    const l = this.getFeatureMarkerByMouseEvent(n);
    return l && l.instance.parent ? (this.throttledMethods.sendMarkerRightClickEvent(
      l.instance.parent,
      l
    ), { next: !1 }) : { next: !0 };
  }
  isShapeMarkerAllowed() {
    return MA(this.shapeMarkerAllowedModes, this.gm.getActiveEditModes()).length > 0;
  }
  convertToVertexMarker(n) {
    if (n.type === "edge" && n.instance.parent) {
      const l = n.position, p = n.instance.parent;
      this.removeMarker(n);
      const x = this.createMarker({
        type: "vertex",
        positionData: l,
        parentFeature: p
      }), M = p.getGeoJson(), S = jR(M, l.coordinate);
      if (S) {
        const u = S.path.join("."), R = p.markers.get(u);
        return R && this.removeMarker(R), p.markers.set(u, x), x;
      }
    }
    return Ct.error("ShapeMarkersHelper.convertToVertexMarker: invalid marker type", n), n;
  }
  getFeatureMarkerByMouseEvent(n) {
    const l = this.gm.features.getFeatureByMouseEvent({
      event: n,
      sourceNames: [Et.main]
    });
    if (l?.parent?.markers) {
      const p = $A(
        l.parent.markers,
        (x) => x.instance === l
      );
      if (p?.type !== "dom")
        return p;
    }
    return null;
  }
  addMarkers() {
    this.gm.features.forEach((n) => {
      if (!n || !this.allowedShapes.includes(n.shape) || n.getShapeProperty("disableEdit") === !0)
        return;
      this.addCenterMarker(n);
      const l = this.getAllShapeSegments(n), p = this.getEndMarkerIndexes(n);
      l.forEach((x, M) => {
        if (this.isMarkerIndexAllowed(
          n.shape,
          M,
          l.length
        )) {
          const S = this.createOrUpdateVertexMarker(x.segment.start, n);
          if (n.markers.set(S.markerKey, S.markerData), p.has(M)) {
            const u = this.createOrUpdateVertexMarker(
              x.segment.end,
              n
            );
            n.markers.set(u.markerKey, u.markerData);
          }
        }
        if (this.isEdgeMarkerAllowed(n)) {
          const S = this.createOrUpdateEdgeMarker(x, n);
          n.markers.set(S.markerKey, S.markerData);
        }
      });
    });
  }
  addCenterMarker(n) {
    const l = n.getShapeProperty("center");
    if (l) {
      const p = this.createMarker({
        type: "center",
        positionData: {
          path: [],
          coordinate: l
        },
        parentFeature: n
      });
      n.markers.set("center", p);
    }
  }
  getAllShapeSegments(n) {
    const l = n.getGeoJson(), p = [];
    return q2(l, (x, M) => {
      p.push({
        segment: x,
        middle: this.getSegmentMiddlePosition(x),
        edgeMarkerKey: this.getEdgeMarkerKey(M)
      });
    }), p;
  }
  isEdgeMarkerAllowed(n) {
    return this.edgeMarkersAllowed && this.edgeMarkerAllowedShapes.includes(n.shape);
  }
  isMarkerIndexAllowed(n, l, p) {
    const x = Math.floor(p / 4);
    return n === "circle" ? (l + x / 2) % x === 0 : n === "ellipse" ? l % x === 0 : !0;
  }
  getEdgeMarkerKey(n) {
    return `edge.${n}`;
  }
  getEndMarkerIndexes(n) {
    const l = n.getGeoJson().geometry;
    return n.shape !== "line" || !["LineString", "MultiLineString"].includes(l.type) ? /* @__PURE__ */ new Set() : l.type === "MultiLineString" ? l.coordinates.reduce(
      (p, x) => (p.indexes.add(p.sum + x.length - 2), p.sum += x.length - 1, p),
      { sum: 0, indexes: /* @__PURE__ */ new Set() }
    ).indexes : /* @__PURE__ */ new Set([l.coordinates.length - 2]);
  }
  getSegmentMiddlePosition(n) {
    const l = this.gm.mapAdapter.project(n.start.coordinate), p = this.gm.mapAdapter.project(n.end.coordinate), x = [
      (l[0] + p[0]) / 2,
      (l[1] + p[1]) / 2
    ], M = n.start.path.slice(0, n.start.path.length - 1).concat([-1]);
    return {
      coordinate: this.gm.mapAdapter.unproject(x),
      path: M
    };
  }
  removeMarkers() {
    this.gm.features.forEach((n, l) => {
      const p = this.gm.features.get(Et.main, l);
      p && (p.markers.forEach((x) => {
        x.type !== "dom" ? this.gm.features.delete(x.instance) : Ct.error("Non a FeatureData marker", x);
      }), p.markers = /* @__PURE__ */ new Map());
    });
  }
  removeMarker(n) {
    if (n.type === "dom") {
      Ct.error("Wrong marker type", n);
      return;
    }
    const l = n.instance.parent;
    if (!l) {
      Ct.error("Missing parent feature data", n);
      return;
    }
    try {
      l.markers.forEach((p, x) => {
        if (p === n)
          throw this.gm.features.delete(p.instance), l.markers.delete(x), new Error("break");
      });
    } catch {
    }
  }
  handleGmDraw(n) {
    return _v(n) ? (["feature_created", "mode_start"].includes(n.action) && this.debouncedMethods.refreshMarkers(), { next: !0 }) : (Ct.error("ShapeMarkersHelper.handleGmDraw: not a draw event", n), { next: !0 });
  }
  refreshMarkers() {
    this.gm.options.isModeEnabled("helper", "shape_markers") && (this.removeMarkers(), this.addMarkers());
  }
  handleGmEdit(n) {
    return Xh(n) ? (n.action === "feature_updated" && this.handleShapeUpdate(n), { next: !0 }) : (Ct.error("ShapeMarkersHelper.handleGmEdit: not an edit event", n), { next: !0 });
  }
  handleShapeUpdate(n) {
    const l = n.targetFeatures[0];
    if (!l) {
      Ct.error("ShapeMarkersHelper.handleShapeUpdate: no featureData", n);
      return;
    }
    this.activeMarker?.type === "edge" && (this.activeMarker = this.convertToVertexMarker(this.activeMarker));
    const p = this.getAllShapeSegments(l), x = new Set(l.markers.keys()), M = this.getEndMarkerIndexes(l);
    p.forEach((S, u) => {
      if (this.isMarkerIndexAllowed(
        l.shape,
        u,
        p.length
      )) {
        const R = this.createOrUpdateVertexMarker(S.segment.start, l);
        if (x.delete(R.markerKey), M.has(u)) {
          const z = this.createOrUpdateVertexMarker(
            S.segment.end,
            l
          );
          x.delete(z.markerKey);
        }
      }
      if (this.isEdgeMarkerAllowed(l)) {
        const R = this.createOrUpdateEdgeMarker(S, l);
        x.delete(R.markerKey);
      }
    }), this.updateCenterMarkerPosition(l), x.delete("center"), x.forEach((S) => {
      const u = l.markers.get(S);
      u && u.type !== "dom" ? this.gm.features.delete(u.instance) : Ct.error("Non a FeatureData marker"), l.markers.delete(S);
    });
  }
  createOrUpdateVertexMarker(n, l) {
    const p = n.path.join(".");
    let x = l.markers.get(p) || null;
    if (x && x?.type !== "vertex")
      throw new Error(`Invalid marker type "${x?.type}" for edge marker`);
    return x ? (Ub(x.position.coordinate, n.coordinate) || this.gm.features.updateMarkerFeaturePosition(x.instance, n.coordinate), x.position = n) : (x = this.createMarker({
      type: "vertex",
      positionData: n,
      parentFeature: l
    }), l.markers.set(p, x)), { markerKey: p, markerData: x };
  }
  createOrUpdateEdgeMarker(n, l) {
    let p = l.markers.get(n.edgeMarkerKey) || null;
    if (p && p?.type !== "edge")
      throw new Error(`Invalid marker type "${p?.type}" for edge marker`);
    return p ? (Ub(p.position.coordinate, n.middle.coordinate) || p.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: n.middle.coordinate
    }), p.position = n.middle, p.segment = n.segment) : (p = this.createMarker({
      type: "edge",
      positionData: n.middle,
      segment: n.segment,
      parentFeature: l
    }), l.markers.set(n.edgeMarkerKey, p)), { markerKey: n.edgeMarkerKey, markerData: p };
  }
  updateCenterMarkerPosition(n) {
    const l = n.markers.get("center") || null, p = n.getShapeProperty("center");
    l && l.type !== "dom" && p && (l.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: p
    }), l.position.coordinate = p);
  }
  sendMarkerEvent(n, l, p) {
    const x = {
      name: `${Ot}:edit:marker`,
      level: "system",
      actionType: "edit",
      mode: "change",
      action: n,
      featureData: l,
      markerData: p
    };
    this.gm.events.fire(`${Ot}:edit`, x);
  }
  sendMarkerRightClickEvent(n, l) {
    const p = {
      name: `${Ot}:edit:marker`,
      level: "system",
      actionType: "edit",
      mode: "change",
      action: "marker_right_click",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ot}:edit`, p);
  }
  sendMarkerMoveEvent(n) {
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    this.activeMarker && this.activeFeatureData && (this.pinEnabled ? this.sharedMarkers : [
      {
        markerData: this.activeMarker,
        featureData: this.activeFeatureData
      }
    ]).forEach((p) => {
      if (this.previousPosition) {
        const x = {
          name: `${Ot}:edit:marker_move`,
          level: "system",
          actionType: "edit",
          mode: "drag",
          action: "marker_move",
          featureData: p.featureData,
          markerData: p.markerData,
          lngLatStart: this.previousPosition,
          lngLatEnd: l
        };
        this.gm.events.fire(`${Ot}:edit`, x);
      }
    }), this.previousPosition = l;
  }
  createMarker({
    type: n,
    segment: l,
    positionData: p,
    parentFeature: x
  }) {
    const M = p.coordinate, S = this.gm.features.createMarkerFeature({
      sourceName: x.sourceName,
      parentFeature: x,
      type: n,
      coordinate: M
    });
    if (!S)
      throw new Error(`Missine feature data for the "${n}" marker`);
    if (n === "edge" && l)
      return {
        type: n,
        instance: S,
        position: Qs(p),
        segment: l
      };
    if (n === "vertex" || n === "center")
      return {
        type: n,
        instance: S,
        position: Qs(p)
      };
    throw new Error(`Invalid marker type "${n}" with segment: ${l}`);
  }
}
class JO extends nu {
  mode = "snapping";
  tolerance = 18;
  lineSnappingShapes = [
    "circle",
    "line",
    "rectangle",
    "polygon",
    "snap_guide"
  ];
  eventHandlers = {};
  shapeSnappingHandlers = {
    marker: this.getPointsSnapping.bind(this),
    circle: this.getLineSnapping.bind(this),
    circle_marker: this.getPointsSnapping.bind(this),
    text_marker: this.getPointsSnapping.bind(this),
    line: this.getLineSnapping.bind(this),
    rectangle: this.getLineSnapping.bind(this),
    polygon: this.getLineSnapping.bind(this),
    snap_guide: this.getLineSnapping.bind(this)
  };
  excludedFeature = /* @__PURE__ */ new Set();
  customSnappingLngLats = /* @__PURE__ */ new Map();
  customSnappingFeatures = /* @__PURE__ */ new Set();
  onStartAction() {
    this.gm.markerPointer.setSnapping(!0);
  }
  onEndAction() {
    this.gm.markerPointer.setSnapping(!1);
  }
  addExcludedFeature(n) {
    this.excludedFeature.add(n);
  }
  clearExcludedFeatures() {
    this.excludedFeature.clear();
  }
  addCustomSnappingFeature(n) {
    this.customSnappingFeatures.add(n);
  }
  removeCustomSnappingFeature(n) {
    this.customSnappingFeatures.delete(n);
  }
  clearCustomSnappingFeature() {
    this.customSnappingFeatures.clear();
  }
  setCustomSnappingCoordinates(n, l) {
    this.customSnappingLngLats.set(n, l);
  }
  clearCustomSnappingCoordinates(n) {
    this.customSnappingLngLats.delete(n);
  }
  getSnappedLngLat(n, l) {
    let p = this.getCustomLngLatsSnapping(l);
    if (p)
      return p;
    const x = this.getFeaturesInPointBounds(l).filter(
      (M) => !this.excludedFeature.has(M)
    );
    return p = this.getFeaturePointsSnapping(x, n, l), p || (p = this.getFeatureLinesSnapping(x, n, l), p) ? p : n;
  }
  getCustomLngLatsSnapping(n) {
    const l = {
      distance: 1 / 0,
      lngLat: null
    };
    return this.customSnappingLngLats.forEach((p) => {
      p.forEach((x) => {
        const M = this.gm.mapAdapter.project(x), S = gg(n, M);
        S < this.tolerance && S < l.distance && (l.distance = S, l.lngLat = x);
      });
    }), l.lngLat;
  }
  getFeaturePointsSnapping(n, l, p) {
    let x = n.map((M) => ({
      shape: M.shape,
      ...this.getPointsSnapping(M, l, p)
    })).filter((M) => M.distance < this.tolerance);
    return x.length ? (x = fb(x, ["distance"]), x[0].lngLat) : null;
  }
  getFeatureLinesSnapping(n, l, p) {
    let x = n.filter((M) => this.lineSnappingShapes.includes(M.shape)).map((M) => {
      const S = this.shapeSnappingHandlers[M.shape];
      return S ? {
        shape: M.shape,
        ...S(M, l, p)
      } : null;
    }).filter((M) => M !== null && M.distance < this.tolerance);
    return x.length ? (x = fb(x, ["distance"]), x[0].lngLat) : null;
  }
  getFeaturesInPointBounds(n) {
    const l = [
      [n[0] - this.tolerance, n[1] - this.tolerance],
      [n[0] + this.tolerance, n[1] + this.tolerance]
    ];
    return this.gm.features.getFeaturesByScreenBounds({ bounds: l, sourceNames: [Et.main, Et.temporary] }).filter((p) => p.temporary ? this.customSnappingFeatures.has(p) : !0) || [];
  }
  getPointsSnapping(n, l, p) {
    const x = n.getGeoJson(), M = {
      distance: 1 / 0,
      coord: null
      // lngLat coords
    };
    return Vf(
      x,
      (S) => {
        const u = this.gm.mapAdapter.project(S.coordinate), R = gg(p, u);
        R < this.tolerance && R < M.distance && (M.distance = R, M.coord = S.coordinate);
      },
      !0
    ), {
      lngLat: M.coord ? M.coord : l,
      distance: M.distance
    };
  }
  getLineSnapping(n, l, p) {
    const x = n.getGeoJson();
    return this.getNearestLinePointData(x, l, p);
  }
  getNearestLinePointData(n, l, p) {
    const x = {
      lngLat: l,
      distance: 1 / 0
    }, M = this.gm.mapAdapter.getEuclideanNearestLngLat(n, l), S = this.gm.mapAdapter.project(M);
    return x.distance = gg(S, p), x.distance < this.tolerance && (x.lngLat = M), x;
  }
}
class KO extends nu {
  mode = "zoom_to_features";
  eventHandlers = {};
  onStartAction() {
    this.fitMapToFeatures(), setTimeout(() => {
      this.gm.options.disableMode("helper", "zoom_to_features");
    });
  }
  onEndAction() {
  }
  fitMapToFeatures() {
    const n = this.gm.features.asGeoJsonFeatureCollection({
      sourceNames: [Et.main, ...Ri ? [Et.standby] : []]
    }), l = A2(n), p = [
      [l[0], l[1]],
      [l[2], l[3]]
    ];
    try {
      this.gm.mapAdapter.fitBounds(p, { padding: 20 });
    } catch {
      Ct.warn("Wrong bounds for zooming to features", p, n);
    }
  }
}
const Oy = {
  shape_markers: XO,
  pin: null,
  snapping: JO,
  snap_guides: null,
  measurements: null,
  auto_trace: null,
  geofencing: null,
  zoom_to_features: KO,
  click_to_edit: null
}, QO = (a, n) => Oy[n] ? new Oy[n](a) : (Ct.error(`Helper "${n}" is not available`), null);
class ez extends Kg {
  eventHandlers = {
    [`${Ot}:helper`]: this.handleHelperEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleHelperEvent(n) {
    if (!gv(n))
      return { next: !0 };
    const l = `${n.actionType}__${n.mode}`;
    return n.action === "mode_start" ? (this.trackExclusiveModes(n), this.start(l, n), this.trackRelatedModes(n)) : n.action === "mode_end" && (this.trackRelatedModes(n), this.end(l)), { next: !0 };
  }
  start(n, l) {
    const p = QO(this.gm, l.mode);
    p && (n in this.gm.actionInstances && Ct.error(`Action instance "${n}" already exists`), this.gm.actionInstances[n] = p, p.startAction());
  }
  end(n) {
    const l = this.gm.actionInstances[n];
    l instanceof nu ? (l.endAction(), delete this.gm.actionInstances[n]) : console.error(`Wrong action instance for edit event "${n}":`, l);
  }
}
class tz {
  gm;
  bus;
  listeners = {};
  constructor(n) {
    this.gm = n, this.bus = new vR(this.gm), this.listeners = {
      draw: new XF(this.gm, this.bus),
      edit: new WO(this.gm, this.bus),
      helper: new ez(this.gm, this.bus),
      control: new xR(this.gm, this.bus)
    };
  }
  fire(n, l) {
    this.listeners[l.actionType] || Ct.error(`Can't find event listener for "${l.actionType}" event type`), this.bus.fireEvent(n, l);
  }
}
const z1 = 5e3;
class rz {
  gm;
  updateStorage;
  autoUpdatesEnabled = !0;
  delayedSourceUpdateMethods;
  // Track pending update promises per source to allow waiting for MapLibre to commit data
  // Using an array to track multiple concurrent promises (prevents overwriting if rapid updates occur)
  pendingUpdatePromises;
  constructor(n) {
    this.gm = n, this.updateStorage = Object.fromEntries(my(Et).map((l) => [l, []])), this.pendingUpdatePromises = {}, this.delayedSourceUpdateMethods = Object.fromEntries(
      my(Et).map((l) => [
        l,
        xw(
          () => this.updateSourceActual(l),
          this.gm.options.settings.throttlingDelay
        )
      ])
    );
  }
  updatesPending(n) {
    return !!this.updateStorage[n]?.length || !!(this.pendingUpdatePromises[n]?.length ?? 0);
  }
  getFeatureId(n) {
    const l = n.properties?.[Ws] ?? n.id;
    return l == null && console.warn("Feature id is null or undefined", n), l;
  }
  updateSource({
    sourceName: n,
    diff: l
  }) {
    l && this.updateStorage[n].push(l), this.delayedSourceUpdateMethods[n]();
  }
  updateSourceActual(n) {
    const l = this.gm.features.sources[n];
    if (this.autoUpdatesEnabled && l) {
      if (!l.loaded) {
        setTimeout(() => {
          this.updateSourceActual(n);
        }, this.gm.options.settings.throttlingDelay);
        return;
      }
      const p = this.getCombinedDiff(n);
      if (p) {
        const x = l.updateData(p);
        this.addPendingPromise(n, x);
      }
      this.updateStorage[n].length > 0 && setTimeout(
        () => this.updateSourceActual(n),
        this.gm.options.settings.throttlingDelay
      );
    }
  }
  /**
   * Add a pending promise to the tracking array for a source.
   * Automatically removes the promise from the array when it resolves.
   */
  addPendingPromise(n, l) {
    this.pendingUpdatePromises[n] || (this.pendingUpdatePromises[n] = []), this.pendingUpdatePromises[n].push(l), l.finally(() => {
      const p = this.pendingUpdatePromises[n];
      if (p) {
        const x = p.indexOf(l);
        x !== -1 && p.splice(x, 1), p.length === 0 && delete this.pendingUpdatePromises[n];
      }
    });
  }
  /**
   * Wait for any pending MapLibre source updates to complete.
   * This ensures data is committed before events are fired.
   *
   * When there are queued updates in updateStorage that haven't been processed yet
   * (due to throttling), this method flushes them immediately and waits for completion.
   *
   * Note: We call updateData() directly here rather than going through updateSourceActual()
   * because updateSourceActual() checks `!source.loaded` and may delay processing.
   * When waiting for pending updates (e.g., for event handlers), we need immediate processing.
   *
   * This is safe and won't cause duplicates because getCombinedDiff() atomically drains
   * the storage - whoever calls it first gets the diffs, subsequent calls get null.
   *
   * IMPORTANT: MapLibre's _updateWorkerData() has a guard that returns early if already
   * updating (`if (this._isUpdatingWorker) return`). This means updateData() can return
   * a promise that resolves before the data is actually committed to serialize().
   * To handle this, we loop until both storage and pending promises are empty, with
   * a microtask yield between iterations to allow MapLibre's recursive updates to run.
   */
  async waitForPendingUpdates(n) {
    const l = this.gm.features.sources[n];
    if (l) {
      for (; this.updateStorage[n]?.length || this.pendingUpdatePromises[n]?.length; ) {
        if (this.updateStorage[n]?.length) {
          const x = this.getCombinedDiff(n);
          if (x) {
            const M = l.updateData(x);
            this.addPendingPromise(n, M);
          }
        }
        const p = this.pendingUpdatePromises[n];
        p?.length && await Promise.all(p), await new Promise((x) => setTimeout(x, 0));
      }
      await new Promise((p) => requestAnimationFrame(p));
    }
  }
  withAtomicSourcesUpdate(n) {
    try {
      return this.autoUpdatesEnabled = !1, n();
    } finally {
      ti(this.gm.features.sources).forEach((l) => {
        this.updateSource({ sourceName: l });
      }), this.autoUpdatesEnabled = !0;
    }
  }
  getCombinedDiff(n) {
    let l = {
      remove: [],
      add: [],
      update: []
    };
    for (let p = 0; p < z1 && this.updateStorage[n][p] !== void 0; p += 1)
      l = this.mergeGeoJsonDiff(l, this.updateStorage[n][p]);
    return this.updateStorage[n] = this.updateStorage[n].slice(z1), Object.values(l).find((p) => p.length) ? l : null;
  }
  mergeGeoJsonDiff(n, l) {
    const p = n ?? { add: [], update: [], remove: [] }, x = l ?? { add: [], update: [], remove: [] }, M = new Set(x.remove), S = p.add?.filter((z) => !M.has(this.getFeatureId(z))) || [], u = p.update?.filter((z) => !M.has(this.getFeatureId(z))) || [], R = [];
    return x.update?.forEach((z) => {
      const U = S.findIndex(
        (ee) => this.getFeatureId(ee) === this.getFeatureId(z)
      ), $ = u.findIndex(
        (ee) => this.getFeatureId(ee) === this.getFeatureId(z)
      );
      if (U === -1 && $ === -1) {
        R.push(z);
        return;
      }
      U !== -1 && (S[U] = z), $ !== -1 && (u[$] = z);
    }), {
      add: [...S, ...x.add || []],
      update: [...u, ...R],
      remove: [...p.remove || [], ...x.remove || []]
    };
  }
}
class nz {
  isInstanceAvailable() {
    return this.sourceInstance ? !0 : (Ct.error("Source instance is not available"), !1);
  }
}
class iz {
  gm;
  featureCounter = 0;
  featureStore = /* @__PURE__ */ new Map();
  featureStoreAllowedSources = [Et.main, Et.temporary];
  sources;
  defaultSourceName = Et.main;
  updateManager;
  layers;
  constructor(n) {
    this.gm = n, this.updateManager = new rz(n), this.sources = Object.fromEntries(
      my(Et).map((l) => [l, null])
    ), this.layers = [];
  }
  get forEach() {
    return this.filteredForEach((n) => !n.temporary);
  }
  get tmpForEach() {
    return this.filteredForEach((n) => n.temporary);
  }
  init() {
    if (Object.values(this.sources).some((n) => n !== null)) {
      Ct.warn("features.init(): features are already initialized");
      return;
    }
    ti(this.sources).forEach((n) => {
      this.sources[n] = this.createSource(n);
    }), this.hydrateFromExistingSources(), this.gm.options.settings.useDefaultLayers && (this.layers = this.createLayers());
  }
  /**
   * Hydrates the feature store from existing sources and syncs the ID counter.
   * This is called during init to restore state when remounting on preserved sources.
   */
  hydrateFromExistingSources() {
    let n = 0;
    ti(this.sources).forEach((l) => {
      const p = this.sources[l];
      if (p)
        try {
          const x = p.getGeoJson();
          if (x && "features" in x)
            for (const M of x.features) {
              const S = M.properties?.[Ws];
              if (!S) continue;
              if (typeof S == "string" && S.startsWith("feature-")) {
                const z = parseInt(S.replace("feature-", ""), 10);
                !isNaN(z) && z > n && (n = z);
              }
              if (this.featureStore.has(S)) continue;
              const u = M, R = new xf({
                gm: this.gm,
                id: S,
                parent: null,
                source: p,
                geoJsonShapeFeature: Qs(u),
                skipSourceUpdate: !0
              });
              this.featureStore.set(S, R);
            }
        } catch {
        }
    }), n > this.featureCounter && (this.featureCounter = n);
  }
  getNewFeatureId(n) {
    if (this.featureCounter += 1, this.gm.options.settings.idGenerator)
      return this.gm.options.settings.idGenerator(n);
    let l = `feature-${this.featureCounter}`;
    for (; this.featureStore.has(l); )
      this.featureCounter += 1, l = `feature-${this.featureCounter}`;
    return l;
  }
  filteredForEach(n) {
    return (l) => {
      this.featureStore.forEach((p, x, M) => {
        n(p) && l(p, x, M);
      });
    };
  }
  has(n, l) {
    const p = this.featureStore.get(l);
    return !!p && p?.source === this.sources[n];
  }
  get(n, l) {
    const p = this.featureStore.get(l) || null;
    return p?.source === this.sources[n] ? p : null;
  }
  add(n) {
    if (this.featureStore.has(n.id)) {
      Ct.error(`features.add: feature with the id "${n.id}" already exists`);
      return;
    }
    this.featureStoreAllowedSources.includes(n.source.id) && this.featureStore.set(n.id, n);
  }
  setDefaultSourceName(n) {
    this.defaultSourceName = n;
  }
  createSource(n) {
    const l = this.gm.mapAdapter.addSource(n, {
      type: "FeatureCollection",
      features: []
    });
    if (l)
      return l;
    throw new Error(`Features: failed to create the source: "${n}"`);
  }
  delete(n) {
    let l;
    n instanceof xf ? l = n : l = this.featureStore.get(n) || null, l ? (this.featureStore.delete(l.id), l.delete()) : Ct.error(`features.delete: feature "${n}" not found`);
  }
  deleteAll() {
    this.featureStore.forEach((n) => {
      n.delete();
    }), this.featureStore.clear();
  }
  getFeatureByMouseEvent({
    event: n,
    sourceNames: l
  }) {
    if (!Yn(n, { warning: !0 }))
      return null;
    const p = [n.point.x, n.point.y], x = this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: p,
      sourceNames: l
    });
    return x.length ? x[0] : null;
  }
  getFeaturesByGeoJsonBounds({
    geoJson: n,
    sourceNames: l
  }) {
    const p = dv(n), x = this.gm.mapAdapter.coordBoundsToScreenBounds(p);
    return this.getFeaturesByScreenBounds({ bounds: x, sourceNames: l });
  }
  getFeaturesByScreenBounds({
    bounds: n,
    sourceNames: l
  }) {
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: n,
      sourceNames: l
    });
  }
  createFeature({
    featureId: n,
    shapeGeoJson: l,
    parent: p,
    sourceName: x,
    imported: M
  }) {
    const S = this.sources[x];
    if (!S)
      return Ct.error("Features.createFeature Missing source for feature creation"), null;
    const u = n ?? l.properties[Ws] ?? this.getNewFeatureId(l);
    if (this.featureStore.get(u))
      return Ct.error(
        `Features.createFeature: feature with the id "${u}" already exists`,
        this.featureStore.get(u)
      ), null;
    const R = new xf({
      gm: this.gm,
      id: u,
      parent: p || null,
      source: S,
      geoJsonShapeFeature: Qs(l)
    });
    return this.add(R), !R.temporary && !M && this.fireFeatureCreatedEvent(R), this.featureCounter += 1, R;
  }
  importGeoJson(n, l) {
    const p = l ?? {}, x = "features" in n ? n.features : [n], M = {
      stats: {
        total: 0,
        success: 0,
        failed: 0,
        overwritten: 0
      },
      addedFeatures: []
    };
    return x.forEach((S) => {
      let u = null;
      M.stats.total += 1;
      const R = XN(S);
      if (R) {
        if (p.idPropertyName) {
          const z = JN(R, p.idPropertyName);
          z && (R.id = z);
        }
        if (p.overwrite) {
          const z = R.id ?? R.properties?.[Ws];
          z && this.featureStore.has(z) && (this.delete(z), M.stats.overwritten += 1);
        }
        u = this.importGeoJsonFeature(R);
      }
      u ? (M.addedFeatures.push(u), M.stats.success += 1) : M.stats.failed += 1;
    }), M;
  }
  importGeoJsonFeature(n) {
    const l = this.defaultSourceName, p = this.getFeatureShapeByGeoJson(n);
    return p ? this.createFeature({
      featureId: n.id,
      shapeGeoJson: n,
      sourceName: l,
      imported: !0
    }) : (Ct.error("features.addGeoJsonFeature: unknown shape", p), null);
  }
  getAll() {
    return this.exportGeoJson();
  }
  /**
   * Exports GeoJSON from Geoman's internal state.
   *
   * This is the recommended method for most use cases as it always returns the latest
   * feature data, even during event handlers before MapLibre has committed changes.
   *
   * @param options - Export options
   * @param options.allowedShapes - Filter to only include specific shape types
   * @param options.idPropertyName - Property name to use for feature IDs (default: 'gm_id')
   * @returns GeoJSON FeatureCollection with all features
   *
   * @example
   * // Export all features
   * const geoJson = geoman.features.exportGeoJson();
   *
   * // Export only polygons and circles
   * const shapes = geoman.features.exportGeoJson({ allowedShapes: ['polygon', 'circle'] });
   */
  exportGeoJson({
    allowedShapes: n,
    idPropertyName: l
  } = { allowedShapes: void 0 }) {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [Et.main, ...Ri ? [Et.standby] : []],
      shapeTypes: n || [...ol],
      idPropertyName: l,
      useMapLibreSource: !1
    });
  }
  /**
   * Exports GeoJSON directly from MapLibre's underlying source data.
   *
   * This method reads from MapLibre's serialized source state, which may lag slightly
   * behind Geoman's internal state during rapid updates or in event handlers.
   *
   * Use this method when you specifically need to verify what MapLibre has committed
   * to its source, for debugging, or for synchronization with external systems that
   * read directly from MapLibre sources.
   *
   * For most use cases, prefer `exportGeoJson()` which uses Geoman's internal state
   * and is always up-to-date.
   *
   * @param options - Export options
   * @param options.allowedShapes - Filter to only include specific shape types
   * @param options.idPropertyName - Property name to use for feature IDs (default: 'gm_id')
   * @returns GeoJSON FeatureCollection from MapLibre's source
   *
   * @example
   * // Export features as stored in MapLibre source
   * const geoJson = geoman.features.exportGeoJsonFromSource();
   *
   * // Verify MapLibre has committed the data
   * await geoman.features.waitForPendingUpdates();
   * const committed = geoman.features.exportGeoJsonFromSource();
   */
  exportGeoJsonFromSource({
    allowedShapes: n,
    idPropertyName: l
  } = { allowedShapes: void 0 }) {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [Et.main, ...Ri ? [Et.standby] : []],
      shapeTypes: n || [...ol],
      idPropertyName: l,
      useMapLibreSource: !0
    });
  }
  asGeoJsonFeatureCollection({
    shapeTypes: n,
    sourceNames: l,
    idPropertyName: p,
    useMapLibreSource: x = !1
  }) {
    const M = {
      type: "FeatureCollection",
      features: []
    };
    return p ??= Ws, l.forEach((S) => {
      const u = this.sources[S];
      u && (x ? u.getGeoJson() : u.getGmGeoJson()).features.filter((R) => !!R).forEach((R) => {
        const z = this.get(S, R.id);
        if (!z)
          return;
        const U = R.properties[Ws];
        p !== Ws && (R.properties[p] = U, delete R.properties[Ws]), (n === void 0 || n.includes(z.shape)) && M.features.push({ ...R, id: U });
      });
    }), M;
  }
  convertSourceToGm(n) {
    const l = [], p = n.getGeoJson(), x = "features" in p ? p.features : [p];
    return this.gm.mapAdapter.getSource(n.id).remove(), x.forEach((M) => {
      const S = this.addGeoJsonFeature({
        shapeGeoJson: M,
        defaultSource: !0
      });
      S && l.push(S);
    }), l;
  }
  addGeoJsonFeature({
    shapeGeoJson: n,
    sourceName: l,
    defaultSource: p
  }) {
    let x;
    if (p ? (x = this.defaultSourceName, l && Ct.warn("features.addGeoJsonFeature: default source is set, sourceName is ignored")) : x = l || null, !x)
      return Ct.error("features.addGeoJsonFeature: missing sourceName"), null;
    const M = this.getFeatureShapeByGeoJson(n);
    return M ? this.createFeature({
      featureId: n.id,
      shapeGeoJson: {
        ...n,
        properties: { ...n.properties, shape: M }
      },
      sourceName: x
    }) : (Ct.error("features.addGeoJsonFeature: unknown shape", M), null);
  }
  createLayers() {
    const n = [];
    return ti(this.sources).forEach((l) => {
      ti(this.gm.options.layerStyles).forEach((p) => {
        this.gm.options.layerStyles[p][l].forEach((x) => {
          const M = this.createGenericLayer({
            sourceName: l,
            shapeNames: [p],
            partialStyle: x
          });
          M && n.push(M);
        });
      });
    }), n;
  }
  createGenericLayer({
    sourceName: n,
    shapeNames: l,
    partialStyle: p
  }) {
    const x = this.getGenericLayerName({ sourceName: n, shapeNames: l, partialStyle: p });
    if (!x)
      throw new Error(`Can't create a layer, for ${{ sourceName: n, shapeNames: l, partialStyle: p }}`);
    const M = {
      ...p,
      id: x,
      source: n,
      filter: ["in", ["get", `${ns}shape`], ["literal", l]]
    };
    return this.gm.mapAdapter.addLayer(M);
  }
  getGenericLayerName({
    sourceName: n,
    shapeNames: l,
    partialStyle: p
  }) {
    const x = l.length === 1 ? l[0] : "mixed", M = (u) => `${n}-${x}__${p.type}-layer-${u}`;
    let S = null;
    for (let u = 0; u < 100; u += 1) {
      const R = M(u);
      if (!this.gm.mapAdapter.getLayer(R))
        return S = R, S;
    }
    return null;
  }
  getFeatureShapeByGeoJson(n) {
    const l = {
      Point: "marker",
      LineString: "line",
      MultiLineString: "line",
      Polygon: "polygon",
      MultiPolygon: "polygon"
    }, p = n.properties;
    return p?.shape && ol.includes(p?.shape) ? p?.shape : l[n.geometry.type] || null;
  }
  createMarkerFeature({
    parentFeature: n,
    coordinate: l,
    type: p,
    sourceName: x
  }) {
    return this.createFeature({
      sourceName: x,
      parent: n,
      shapeGeoJson: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: l
        },
        properties: {
          [`${ns}shape`]: `${p}_marker`
        }
      }
    });
  }
  updateMarkerFeaturePosition(n, l) {
    n.updateGeoJsonGeometry({
      type: "Point",
      coordinates: l
    });
  }
  fireFeatureCreatedEvent(n) {
    if (Kl(n.shape, ol)) {
      const l = {
        name: `${Ot}:draw:feature_created`,
        level: "system",
        actionType: "draw",
        mode: n.shape,
        action: "feature_created",
        featureData: n
      };
      this.gm.events.fire(`${Ot}:draw`, l);
    }
  }
}
class sz {
  getEuclideanNearestLngLat(n, l) {
    const p = this.project(l);
    let x = [0, 0], M = 1 / 0;
    return q2(n, (S) => {
      const u = this.project(S.start.coordinate), R = this.project(S.end.coordinate), z = UR(
        u,
        R,
        p
      ), U = gg(p, z);
      U < M && (M = U, x = [z[0], z[1]]);
    }), this.unproject(x);
  }
  getDistance(n, l) {
    return B2(n, l, { units: "meters" });
  }
}
class az {
  isInstanceAvailable() {
    return this.layerInstance ? !0 : (Ct.error("layerInstance is not available"), !1);
  }
}
class $_ extends az {
  gm;
  layerInstance = null;
  mapInstance;
  constructor({
    gm: n,
    layerId: l,
    options: p
  }) {
    super(), this.gm = n, this.mapInstance = this.gm.mapAdapter.mapInstance, p ? this.layerInstance = this.createLayer(p) : this.layerInstance = this.mapInstance.getLayer(l) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.id;
  }
  get source() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.source;
  }
  createLayer(n) {
    let l = this.mapInstance.getLayer(n.id);
    return l ? Ct.warn(`Layer "${n.id}" already exists, skipping`) : (this.mapInstance.addLayer(n), l = this.mapInstance.getLayer(n.id)), l ?? null;
  }
  remove() {
    this.isInstanceAvailable() && this.mapInstance.removeLayer(this.id), this.layerInstance = null;
  }
}
class oz extends lv {
  markerInstance;
  constructor({
    mapInstance: n,
    options: l,
    lngLat: p
  }) {
    super(), this.markerInstance = new Gg.Marker(l).setLngLat(p).addTo(n);
  }
  getElement() {
    return this.isMarkerInstanceAvailable() && this.markerInstance?.getElement() || null;
  }
  setLngLat(n) {
    this.isMarkerInstanceAvailable() && this.markerInstance?.setLngLat(n);
  }
  getLngLat() {
    return this.isMarkerInstanceAvailable() ? this.markerInstance?.getLngLat().toArray() || [0, 0] : [0, 0];
  }
  remove() {
    this.markerInstance?.remove();
  }
}
class lz {
  isInstanceAvailable() {
    return this.popupInstance ? !0 : (Ct.error("Popup instance is not available"), !1);
  }
}
class uz extends lz {
  popupInstance;
  constructor({
    mapInstance: n,
    options: l,
    lngLat: p
  }) {
    super(), this.popupInstance = new Gg.Popup(l).addTo(n), p && this.setLngLat(p);
  }
  getLngLat() {
    return this.isInstanceAvailable() ? this.popupInstance.getLngLat().toArray() || [0, 0] : [0, 0];
  }
  setLngLat(n) {
    this.isInstanceAvailable() && this.popupInstance.setLngLat(n);
  }
  setHtml(n) {
    this.isInstanceAvailable() && this.popupInstance.setHTML(n);
  }
  remove() {
    this.isInstanceAvailable() && this.popupInstance.remove();
  }
}
class B1 extends nz {
  gm;
  mapInstance;
  sourceInstance;
  constructor({ gm: n, geoJson: l, sourceId: p }) {
    super(), this.gm = n, this.mapInstance = this.gm.mapAdapter.mapInstance, l ? this.sourceInstance = this.createSource({ geoJson: l, sourceId: p }) : this.sourceInstance = this.mapInstance.getSource(p) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.id;
  }
  get loaded() {
    return this.mapInstance.isSourceLoaded(this.id);
  }
  createSource({ geoJson: n, sourceId: l }) {
    let p = this.mapInstance.getSource(l);
    return p ? Ct.warn(`Source "${p.id}" already exists, skipping`) : (this.mapInstance.addSource(l, {
      type: "geojson",
      data: n,
      promoteId: Ws
    }), p = this.mapInstance.getSource(l)), p ?? null;
  }
  getGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.serialize().data;
  }
  getGmGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    const n = {
      type: "FeatureCollection",
      features: []
    };
    return this.gm.features.filteredForEach(
      (l) => l.source.id === this.sourceInstance?.id
    )((l) => {
      ol.includes(l.shape) && n.features.push(l.getGeoJson());
    }), n;
  }
  async setData(n) {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    await this.sourceInstance.setData(n, !0);
  }
  async updateData(n) {
    if (!this.isInstanceAvailable())
      return;
    const l = this.convertUniversalDiffToMlDiff(n);
    await this.sourceInstance.updateData(l, !0);
  }
  convertUniversalDiffToMlDiff(n) {
    return {
      add: n.add?.map(this.sanitizeFeatureForAdd.bind(this)),
      update: n.update?.map(this.convertFeatureToMlUpdateDiff.bind(this)),
      remove: n.remove
    };
  }
  /**
   * Sanitize a feature for addition to the source by removing undefined property values.
   * MapLibre's protobuf encoding does not support undefined values (per MapBox vector tile spec).
   */
  sanitizeFeatureForAdd(n) {
    if (!n.properties)
      return n;
    const l = {};
    for (const [p, x] of Object.entries(n.properties))
      x !== void 0 && (l[p] = x);
    return {
      ...n,
      properties: l
    };
  }
  convertFeatureToMlUpdateDiff(n) {
    const l = [], p = [];
    return Object.entries(n.properties || {}).forEach(([x, M]) => {
      M === void 0 ? p.push(x) : l.push({ key: x, value: M });
    }), {
      id: n.properties?.[Ws],
      newGeometry: n.geometry,
      addOrUpdateProperties: l,
      removeProperties: p
    };
  }
  remove() {
    this.isInstanceAvailable() && (this.gm.mapAdapter.eachLayer((n) => {
      n.source === this.sourceInstance.id && this.gm.mapAdapter.removeLayer(n.id);
    }), this.mapInstance.removeSource(this.sourceInstance.id));
  }
}
const cz = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchcancel"
], Z_ = (a) => cz.includes(a);
class hz extends sz {
  gm;
  mapType = "maplibre";
  mapInstance;
  constructor(n, l) {
    super(), this.gm = l, this.mapInstance = n;
  }
  getMapInstance() {
    return this.mapInstance;
  }
  isLoaded() {
    return this.mapInstance._loaded;
  }
  getContainer() {
    return this.mapInstance.getContainer();
  }
  getCanvas() {
    return this.mapInstance.getCanvas();
  }
  addControl(n) {
    this.mapInstance.addControl(n);
  }
  removeControl(n) {
    this.mapInstance.removeControl(n);
  }
  async loadImage({ id: n, image: l }) {
    if (!this.mapInstance.hasImage(n)) {
      const p = await this.mapInstance.loadImage(l);
      this.mapInstance.addImage(n, p.data);
    }
  }
  removeImage(n) {
    try {
      this.mapInstance.hasImage(n) && this.mapInstance.removeImage(n);
    } catch {
    }
  }
  getBounds() {
    return this.mapInstance.getBounds().toArray();
  }
  fitBounds(n, l) {
    this.mapInstance.fitBounds(n, l);
  }
  setCursor(n) {
    this.mapInstance.getCanvas().style.cursor = n;
  }
  disableMapInteractions(n) {
    n.forEach((l) => {
      this.mapInstance[l].disable();
    });
  }
  enableMapInteractions(n) {
    n.forEach((l) => {
      this.mapInstance[l].enable();
    });
  }
  setDragPan(n) {
    n ? this.mapInstance.dragPan.enable() : this.mapInstance.dragPan.disable();
  }
  queryFeaturesByScreenCoordinates({
    queryCoordinates: n = void 0,
    sourceNames: l
  }) {
    return pb(
      this.mapInstance.queryRenderedFeatures(n).map((p) => ({
        featureId: p.properties[Ws],
        featureSourceName: p.source
      })),
      $h
    ).map(({ featureId: p, featureSourceName: x }) => p === void 0 || !l.includes(x) ? null : this.gm.features.get(x, p) || null).filter((p) => !!p);
  }
  queryGeoJsonFeatures({
    queryCoordinates: n = void 0,
    sourceNames: l
  }) {
    const p = (x, M) => x?.id === M?.id;
    return pb(
      this.mapInstance.queryRenderedFeatures(n).map((x) => {
        const M = this.convertToGeoJsonImportFeature(x);
        return M ? {
          id: x.properties[Ws],
          sourceName: x.source,
          geoJson: M
        } : null;
      }),
      p
    ).filter((x) => !!x && x.id !== void 0 && x.geoJson && l.includes(x.sourceName));
  }
  convertToGeoJsonImportFeature(n) {
    const l = n.properties[Ws];
    return l === void 0 || n.geometry.type === "GeometryCollection" ? null : {
      id: l,
      type: "Feature",
      properties: n.properties,
      geometry: n.geometry
    };
  }
  addSource(n, l) {
    return new B1({ gm: this.gm, sourceId: n, geoJson: l });
  }
  getSource(n) {
    return new B1({ gm: this.gm, sourceId: n });
  }
  addLayer(n) {
    const l = n.id;
    return new $_({ gm: this.gm, layerId: l, options: n });
  }
  getLayer(n) {
    return this.mapInstance.getLayer(n) ? new $_({ gm: this.gm, layerId: n }) : null;
  }
  removeLayer(n) {
    const l = this.getLayer(n);
    l && l.remove();
  }
  eachLayer(n) {
    this.mapInstance.getStyle().layers.forEach((l) => {
      n(new $_({ gm: this.gm, layerId: l.id }));
    });
  }
  createDomMarker(n, l) {
    return new oz({
      mapInstance: this.mapInstance,
      options: n,
      lngLat: l
    });
  }
  createPopup(n, l) {
    return new uz({
      mapInstance: this.mapInstance,
      options: n,
      lngLat: l
    });
  }
  project(n) {
    const l = this.mapInstance.project(n);
    return [l.x, l.y];
  }
  unproject(n) {
    const l = this.mapInstance.unproject(n);
    return [l.lng, l.lat];
  }
  coordBoundsToScreenBounds(n) {
    const l = new Gg.LngLatBounds(n), p = this.project(l.getSouthWest().toArray()), x = this.project(l.getNorthEast().toArray());
    return [p, x];
  }
  fire(n, l) {
    this.mapInstance.fire(n, l);
  }
  on(n, l, p) {
    if (typeof l == "string" && p && Z_(n))
      this.mapInstance.on(n, l, p);
    else if (typeof l == "function")
      this.mapInstance.on(n, l);
    else
      throw new Error("Invalid arguments passed to 'on' method");
  }
  once(n, l, p) {
    if (typeof l == "string" && p && Z_(n))
      this.mapInstance.once(n, l, p);
    else if (typeof l == "function")
      this.mapInstance.once(n, l);
    else
      throw new Error("Invalid arguments passed to 'once' method.");
  }
  off(n, l, p) {
    if (typeof l == "string" && p && Z_(n))
      this.mapInstance.off(n, l, p);
    else if (typeof l == "function")
      this.mapInstance.off(n, l);
    else
      throw new Error("Invalid arguments passed to 'off' method");
  }
}
const dz = (a, n) => new hz(n, a), fz = (a, n) => {
  if (!Array.isArray(a) || !Array.isArray(n))
    return;
  if (n.some((x) => !iF(x))) {
    Ct.warn("Wrong partial layer detected for layer styles");
    return;
  }
  const l = CA(a, "type"), p = pA(n, "type");
  if (Object.values(p).some((x) => x > 1))
    throw new Error(
      'Multiple layers for the same shape are detected. Use "useDefaultLayers: false" and define layers manually.'
    );
  return n.forEach((x) => {
    l[x.type] ? PA(l[x.type], x) : l[x.type] = Qs(x);
  }), SA(l);
};
class pz {
  gm;
  settings;
  controls;
  layerStyles;
  constructor(n, l) {
    this.gm = n;
    const p = this.getMergedOptions(l);
    this.settings = p.settings, this.controls = p.controls, this.layerStyles = p.layerStyles;
  }
  getMergedOptions(n = {}) {
    const l = ny();
    return typeof n.settings?.controlsUiEnabledByDefault == "boolean" && (l.settings.controlsUiEnabledByDefault = n.settings.controlsUiEnabledByDefault), ZA(l), xA(l, n, fz);
  }
  enableMode(n, l) {
    const p = this.isModeEnabled(n, l), x = this.isModeAvailable(n, l);
    if (x || Ct.warn(`Unable to enable mode, "${n}:${l}" is not available`), p || !x)
      return;
    const M = this.controls[n][l];
    M ? (M.active = !0, this.fireModeEvent(n, l, "mode_start"), this.fireControlEvent(n, l, "on"), this.fireModeEvent(n, l, "mode_started")) : Ct.error("Can't find control section for", n, l);
  }
  disableMode(n, l) {
    const p = this.isModeEnabled(n, l), x = this.isModeAvailable(n, l);
    if (!p || !x)
      return;
    const M = this.controls[n][l];
    M ? (M.active = !1, this.fireModeEvent(n, l, "mode_end"), this.fireControlEvent(n, l, "off"), this.fireModeEvent(n, l, "mode_ended")) : Ct.error("Can't find control section for", n, l);
  }
  syncModeState(n, l) {
    const p = this.controls[n][l], x = this.isModeAvailable(n, l);
    p && (x ? p.active ? this.enableMode(n, l) : this.disableMode(n, l) : (console.log(`Not available mode: ${n}:${l}`), p.active = !1, p.uiEnabled = !1));
  }
  toggleMode(n, l) {
    this.isModeEnabled(n, l) ? this.disableMode(n, l) : this.enableMode(n, l);
  }
  isModeEnabled(n, l) {
    return !!Object.entries(this.gm.actionInstances).find(([p, x]) => p === `${n}__${l}` && x);
  }
  isModeAvailable(n, l) {
    return n === "draw" && Kl(l, T2) ? !!this.gm.drawClassMap[l] : n === "edit" && Kl(l, I2) ? !!this.gm.editClassMap[l] : n === "helper" && Kl(l, k2) ? !!this.gm.helperClassMap[l] : !1;
  }
  getControlOptions({
    modeType: n,
    modeName: l
  }) {
    return n && l && this.controls[n][l] || null;
  }
  fireModeEvent(n, l, p) {
    const x = {
      name: `${Ot}:${l}:mode`,
      level: "system",
      actionType: n,
      mode: l,
      action: p
    };
    Ev(x) && (_v(x) ? this.gm.events.fire(`${Ot}:${n}`, x) : Xh(x) ? this.gm.events.fire(`${Ot}:${n}`, x) : gv(x) ? this.gm.events.fire(`${Ot}:${n}`, x) : Ct.warn("Unknown mode event: ", x));
  }
  fireControlEvent(n, l, p) {
    const x = {
      name: `${Ot}:control:switch`,
      level: "system",
      actionType: "control",
      section: n,
      mode: l,
      action: p
    };
    this.gm.events.fire(`${Ot}:control`, x);
  }
}
class gz {
  gm;
  marker = null;
  tmpMarker = null;
  snapping = !1;
  oldSnapping = void 0;
  constructor(n) {
    this.gm = n, this.initEventHandlers();
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  initEventHandlers() {
    this.throttledMethods = bc(
      {
        onMouseMove: this.onMouseMove
      },
      this,
      this.gm.options.settings.throttlingDelay
    ), this.eventHandlers = {
      mousemove: this.throttledMethods.onMouseMove.bind(this)
    };
  }
  setSnapping(n) {
    if (n && !this.snappingHelper) {
      Ct.error("MarkerPointer: snapping is not available");
      return;
    }
    this.snapping = n;
  }
  pauseSnapping() {
    this.oldSnapping !== void 0 && Ct.error("MarkerPointer: snapping is already paused"), this.oldSnapping = this.snapping, this.setSnapping(!1);
  }
  resumeSnapping() {
    this.oldSnapping === void 0 ? (Ct.error("MarkerPointer: resumeSnapping is called before pauseSnapping"), this.setSnapping(!0)) : (this.setSnapping(this.oldSnapping), this.oldSnapping = void 0);
  }
  enable({ lngLat: n, customMarker: l, invisibleMarker: p } = {
    lngLat: [0, 0],
    customMarker: void 0,
    invisibleMarker: !1
  }) {
    if (!QR()) {
      if (l && p)
        throw new Error("MarkerPointer: customMarker and invisibleMarker can't be used together");
      if (this.marker)
        throw new Error("MarkerPointer: marker is already enabled");
      this.gm.events.bus.attachEvents(this.eventHandlers), p ? this.marker = this.createInvisibleMarker(n || [0, 0]) : this.marker = l || this.createMarker(n || [0, 0]), this.gm.getActiveDrawModes().length && this.gm.mapAdapter.setCursor("crosshair");
    }
  }
  disable() {
    this.marker && (this.gm.events.bus.detachEvents(this.eventHandlers), this.marker.remove(), this.marker = null), this.gm.mapAdapter.setCursor("");
  }
  createMarker(n = [0, 0]) {
    return this.gm.mapAdapter.createDomMarker(
      {
        anchor: "center",
        element: this.gm.createSvgMarkerElement("control", { pointerEvents: "none" })
      },
      n
    );
  }
  createInvisibleMarker(n = [0, 0]) {
    const l = document.createElement("div");
    return l.style.width = "0px", l.style.height = "0px", this.gm.mapAdapter.createDomMarker(
      {
        anchor: "center",
        element: l
      },
      n
    );
  }
  onMouseMove(n) {
    if (Yn(n, { warning: !0 }) && this.marker)
      if (this.snapping && this.snappingHelper) {
        const l = [n.point.x, n.point.y], p = this.snappingHelper.getSnappedLngLat(n.lngLat.toArray(), l);
        this.marker.setLngLat(p);
      } else
        this.marker.setLngLat(n.lngLat.toArray());
    return { next: !0 };
  }
  syncTmpMarker(n) {
    this.tmpMarker || (this.tmpMarker = this.createMarker(n)), this.tmpMarker.setLngLat(n);
  }
}
const mz = ["mode_start", "mode_started", "mode_end", "mode_ended"], Ev = (a) => hl(a) && Kl(a.action, mz);
class _z {
  mapAdapterInstance = null;
  globalLngLatBounds = this.getGlobalLngLatBounds();
  features;
  loaded = !1;
  destroyed = !1;
  options;
  events;
  control;
  actionInstances = {};
  markerPointer;
  constructor(n, l = {}) {
    this.options = this.initCoreOptions(l), this.events = this.initCoreEvents(), this.features = this.initCoreFeatures(), this.control = this.initCoreControls(), this.markerPointer = this.initMarkerPointer();
    const p = Object.assign(n, { gm: this });
    this.mapAdapterInstance = dz(this, p), this.waitForBaseMap().then(this.init.bind(this)).catch((x) => {
      Ct.error("Geoman initialization failed:", x), this.destroy();
    });
  }
  get drawClassMap() {
    return by;
  }
  get editClassMap() {
    return Ny;
  }
  get helperClassMap() {
    return Oy;
  }
  get mapAdapter() {
    if (this.mapAdapterInstance)
      return this.mapAdapterInstance;
    throw Ct.trace("Map adapter is not initialized"), new Error("Map adapter is not initialized");
  }
  initCoreOptions(n = {}) {
    return new pz(this, n);
  }
  initCoreEvents() {
    return new tz(this);
  }
  initCoreFeatures() {
    return new iz(this);
  }
  initCoreControls() {
    return new mR(this);
  }
  initMarkerPointer() {
    return new gz(this);
  }
  addControls(n = void 0) {
    return new Promise((l) => {
      (async () => {
        n ? this.control.createControls(n) : this.mapAdapter.addControl(this.control), await this.onMapLoad(), l();
      })().then();
    });
  }
  async waitForBaseMap() {
    const n = this.mapAdapter.mapInstance;
    if (!rF(n)) {
      Ct.error('Map instance does not have a "once" method', n);
      return;
    }
    return this.mapAdapter.isLoaded() || await $b(
      new Promise((l) => {
        const p = () => l(n);
        n.once("load", p), this.mapAdapter.isLoaded() && (n.off("load", p), l(n));
      }),
      "waitForBaseMap failed"
    ), n;
  }
  async waitForGeomanLoaded() {
    if (this.loaded)
      return this;
    if (this.destroyed)
      return;
    const n = await this.waitForBaseMap();
    if (!n) {
      Ct.error("Map instance is not available", n);
      return;
    }
    const l = `${Ni}:loaded`;
    return await $b(
      new Promise((p) => {
        const x = () => p(this);
        n.once(l, x), this.loaded && (n.off(l, x), p(this));
      }),
      "waitForGeomanLoaded failed"
    ), this;
  }
  async init() {
    this.destroyed || (this.features.init(), !this.destroyed && await this.addControls());
  }
  /**
   * Destroys the Geoman instance and cleans up resources.
   *
   * This method can be called at any point in the lifecycle:
   * - Before initialization completes: cancels pending init and cleans up synchronously
   * - After initialization completes: performs full cleanup including controls
   *
   * For React StrictMode compatibility, this method performs synchronous cleanup
   * of the `gm` reference on the map instance, allowing immediate re-initialization.
   */
  async destroy({ removeSources: n } = { removeSources: !1 }) {
    if (this.destroyed = !0, this.mapAdapterInstance && "gm" in this.mapAdapterInstance.mapInstance && delete this.mapAdapterInstance.mapInstance.gm, this.loaded ? (this.removeControls(), this.mapAdapter.removeImage("default-marker")) : this.events.bus.detachAllEvents(), n)
      for (const l of Object.values(this.features.sources))
        l && l.remove();
  }
  removeControls() {
    this.disableAllModes(), this.mapAdapter.removeControl(this.control);
  }
  async onMapLoad() {
    if (this.loaded || this.destroyed || (await this.mapAdapter.loadImage({
      id: "default-marker",
      image: JT
    }), this.destroyed))
      return;
    const n = {
      name: `${Ot}:control:load`,
      level: "system",
      actionType: "control",
      action: "loaded"
    };
    this.events.fire(`${Ot}:control`, n), this.loaded = !0;
  }
  disableAllModes() {
    ti(this.actionInstances).forEach((n) => {
      const [l, p] = n.split("__");
      $F(l) && WF(p) && this.options.disableMode(l, p);
    });
  }
  getActiveDrawModes() {
    return ti(this.actionInstances).map((n) => {
      const l = this.actionInstances[n];
      return l instanceof _l ? l.mode : null;
    }).filter((n) => n !== null);
  }
  getActiveEditModes() {
    return ti(this.actionInstances).map((n) => {
      const l = this.actionInstances[n];
      return l instanceof qf ? l.mode : null;
    }).filter((n) => n !== null);
  }
  getActiveHelperModes() {
    return ti(this.actionInstances).map((n) => {
      const l = this.actionInstances[n];
      return l instanceof nu ? l.mode : null;
    }).filter((n) => n !== null);
  }
  getGlobalLngLatBounds() {
    const n = 85.051129;
    return [
      [-179.99999, -n],
      [179.99999, n]
    ];
  }
  setGlobalEventsListener(n = null) {
    this.events.bus.forwarder.globalEventsListener = n;
  }
  createSvgMarkerElement(n, l = void 0) {
    const p = this.options.settings.markerIcons;
    p[n] || Ct.error(`createMarkerElement: marker type "${n}" not found`);
    const x = document.createElement("div");
    x.classList.add("marker-wrapper"), x.style.lineHeight = "0", x.innerHTML = p[n] || "NO_ICON";
    const M = x.firstChild;
    if (typeof M != "object")
      throw Ct.error(`createMarkerElement: no icon "${n}" found`), new Error(`No icon "${n}" found`);
    return l && Object.assign(M.style, l), x;
  }
  enableMode(n, l) {
    this.options.enableMode(n, l);
  }
  disableMode(n, l) {
    this.options.disableMode(n, l);
  }
  toggleMode(n, l) {
    this.options.toggleMode(n, l);
  }
  isModeEnabled(n, l) {
    return this.options.isModeEnabled(n, l);
  }
  // helper methods for compatibility with the old API
  // draw (draw:*)
  enableDraw(n) {
    this.options.enableMode("draw", n);
  }
  disableDraw() {
    this.getActiveDrawModes().forEach((n) => this.options.disableMode("draw", n));
  }
  toggleDraw(n) {
    this.options.toggleMode("draw", n);
  }
  drawEnabled(n) {
    return this.options.isModeEnabled("draw", n);
  }
  // drag(edit:drag)
  enableGlobalDragMode() {
    this.options.enableMode("edit", "drag");
  }
  disableGlobalDragMode() {
    this.options.disableMode("edit", "drag");
  }
  toggleGlobalDragMode() {
    this.options.toggleMode("edit", "drag");
  }
  globalDragModeEnabled() {
    return this.options.isModeEnabled("edit", "drag");
  }
  // edit (edit:change)
  enableGlobalEditMode() {
    this.options.enableMode("edit", "change");
  }
  disableGlobalEditMode() {
    this.options.disableMode("edit", "change");
  }
  toggleGlobalEditMode() {
    this.options.toggleMode("edit", "change");
  }
  globalEditModeEnabled() {
    return this.options.isModeEnabled("edit", "change");
  }
  // rotate (edit:rotate)
  enableGlobalRotateMode() {
    this.options.enableMode("edit", "rotate");
  }
  disableGlobalRotateMode() {
    this.options.disableMode("edit", "rotate");
  }
  toggleGlobalRotateMode() {
    this.options.toggleMode("edit", "rotate");
  }
  globalRotateModeEnabled() {
    return this.options.isModeEnabled("edit", "rotate");
  }
  // cut (edit:cut)
  enableGlobalCutMode() {
    this.options.enableMode("edit", "cut");
  }
  disableGlobalCutMode() {
    this.options.disableMode("edit", "cut");
  }
  toggleGlobalCutMode() {
    this.options.toggleMode("edit", "cut");
  }
  globalCutModeEnabled() {
    return this.options.isModeEnabled("edit", "cut");
  }
  // remove (edit:delete)
  enableGlobalRemovalMode() {
    this.options.enableMode("edit", "delete");
  }
  disableGlobalRemovalMode() {
    this.options.disableMode("edit", "delete");
  }
  toggleGlobalRemovalMode() {
    this.options.toggleMode("edit", "delete");
  }
  globalRemovalModeEnabled() {
    return this.options.isModeEnabled("edit", "delete");
  }
}
class yz extends HTMLElement {
  static observedAttributes = ["title", "zoom", "lat", "lng", "enableToggle"];
  el = null;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  map = null;
  // ml.Map or MapInstanceWithGeoman??
  geoman = null;
  mapLibreStyle = {
    version: 8,
    glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
    sources: {
      "osm-tiles": {
        type: "raster",
        tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
        tileSize: 256,
        attribution: " OpenStreetMap contributors"
      }
    },
    layers: [
      {
        id: "osm-tiles-layer",
        type: "raster",
        source: "osm-tiles",
        minzoom: 0,
        maxzoom: 19
      }
    ]
  };
  connectedCallback() {
    this.#e(), this.#i(), this.#r();
  }
  #e() {
    this.innerHTML = `
      <style>
        .simple-map__top:has(#show-map:not(:checked)) ~ .simple-map__container { display: none; }
        .simple-map__top:has(#show-map:checked) ~ .simple-map__container { display: block; }
        .simple-map .simple-map__container { width: 100%; }
        .simple-map .simple-map__map, .simple-map #map { border: 1px solid #000; width: 100%; height: 400px; }
      </style>
      <div class="simple-map">
        <div class="simple-map__top">
          <h2 class="govuk-heading-m">${this.getAttribute("title")}</h2>
          ${this.#t()}
        </div>
        <div class="simple-map__container">
          <div id="map" class="simple-map__map"></div>
        </div>
      </div>
    `, this.el = this.querySelector(".simple-map");
  }
  #t() {
    return this.getAttribute("enableToggle") !== "true" ? "" : `
      <div class="simple-map__actions">
        <p class="govuk-body">
          <a href="${this.getAttribute("basePath")}/map" class="govuk-link govuk-link--no-visited-state" rel="noreferrer noopener" target="_blank">Open <span class="govuk-visually-hidden">map</span> in new window</a>
        </p>
        <fieldset class="govuk-fieldset">
          <legend class="govuk-fieldset__legend govuk-fieldset__legend--m govuk-visually-hidden">
            Show and hide map preview
          </legend>
          <div class="govuk-checkboxes govuk-checkboxes--small" data-module="govuk-checkboxes">
            <div class="govuk-checkboxes__item">
              <input class="govuk-checkboxes__input" id="show-map" name="show-map" type="checkbox" value="show-map" checked="checked">
              <label class="govuk-label govuk-checkboxes__label" for="show-map">
                Show map
              </label>
            </div>
          </div>
        </fieldset>
      </div>
    `;
  }
  #i() {
    if (!this.el) return;
    const n = this.el.querySelector("#map");
    this.map = new Gg.Map({
      container: n,
      // style: "http://localhost:8081/api/map-style-os",
      style: this.mapLibreStyle,
      center: [
        Number(this.getAttribute("lng")),
        Number(this.getAttribute("lat"))
      ],
      zoom: Number(this.getAttribute("zoom"))
    });
  }
  #r() {
    if (!this.map) return;
    const n = {
      settings: {
        controlsUiEnabledByDefault: !1
      }
    };
    this.geoman = new _z(this.map, n), this.map.on("gm:loaded", () => {
      console.log("Geoman fully loaded");
      const l = {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [
            Number(this.getAttribute("lng")),
            Number(this.getAttribute("lat"))
          ]
        },
        properties: {}
      };
      this.geoman?.features.importGeoJsonFeature(l);
    });
  }
  // attributeChangedCallback(
  //   name: string,
  //   oldValue: string | null,
  //   newValue: string | null
  // ) {
  //   console.log(
  //     `Attribute ${name} has changed from ${oldValue} to ${newValue}.`
  //   );
  // }
}
customElements.define("simple-map", yz);
class bf extends HTMLElement {
  // props
  static POLL_INTERVAL = 2e3;
  // ms
  static observedAttributes = ["job-id", "job-title", "api-path"];
  static jobStatusList = [
    "awaiting_start",
    "in_progress",
    "completed",
    "failed"
  ];
  #e = null;
  #t = null;
  #i = null;
  // elements
  #r = null;
  #n = null;
  // state
  #a = !1;
  #s = "unknown";
  #o = null;
  constructor() {
    super();
  }
  /**
   * Handle component being added to the DOM.
   */
  connectedCallback() {
    this.#l(), this.#c(), this.#e && this.#t && this.#i && (this.polling = !0);
  }
  /**
   * Handle component being removed from the DOM.
   */
  disconnectedCallback() {
    this.#h();
  }
  /**
   * Handle attribute changes.
   * @param name The name of the attribute that changed.
   * @param _oldValue The old value of the attribute.
   * @param newValue The new value of the attribute.
   */
  attributeChangedCallback(n, l, p) {
    n === "job-id" && (this.#e = p), n === "job-title" && (this.#t = p), n === "api-path" && (this.#i = p), this.#e && this.#t && this.#i && (this.#f(), this.#l(), this.#c(), this.polling = !0);
  }
  /**
   * Initialise the status checker component so that it
   * has the structure and elements it needs for the rest
   * of the component to function
   * @returns void
   */
  #l() {
    if (this.classList.add("status-checker"), this.#e && this.#t && this.#i) {
      this.#r = this.#y();
      const n = this.#r.textContent?.trim() ?? "unknown";
      this.#s = bf.jobStatusList.includes(
        n
      ) ? n : "unknown", this.querySelector(".status-checker__alert") ? this.#n = this.querySelector(
        ".status-checker__alert"
      ) : (this.#n = this.#g(), this.appendChild(this.#n)), this.#u();
    }
  }
  /**
   * Apply Govuk Tag styles to the status element based on current status.
   * @returns void
   */
  #u() {
    if (this.#r && this.#r.classList.contains("govuk-tag") !== !1)
      switch (this.#r.classList.remove(
        "govuk-tag--green",
        "govuk-tag--red",
        "govuk-tag--grey"
      ), this.#s) {
        case "completed":
          this.#r.classList.add("govuk-tag--green");
          break;
        case "failed":
          this.#r.classList.add("govuk-tag--red");
          break;
        default:
          this.#r.classList.add("govuk-tag--grey");
      }
  }
  /**
   * Reset the status checker to its initial state.
   * @returns void
   */
  #h() {
    this.classList.remove("status-checker"), this.#n && this.contains(this.#n) && this.removeChild(this.#n), this.#r = null, this.#n = null, this.#s = "unknown", this.#f();
  }
  /**
   * Update the status element and alert region with the current status.
   * @returns void
   */
  #c() {
    this.#s !== "unknown" && (this.#r && (this.#r.textContent = this.#s.trim(), this.#u()), this.#n && (this.#n.textContent = `${this.#t ?? "Job"} is ${this.#s.trim()}`));
  }
  /**
   * Get or set the polling state.
   */
  get polling() {
    return this.#a;
  }
  /**
   * Set the polling state.
   * @param value The new polling state.
   */
  set polling(n) {
    this.#a !== n && (this.#a = n, n ? this.#d() : this.#f());
  }
  /**
   * Start polling the backend for job status.
   * @returns void
   */
  async #d() {
    this.classList.add("status-checker--active"), this.#n && (this.#n.setAttribute("aria-busy", "true"), this.#n.textContent = "Checking status");
    const { status: n } = await this.#p();
    this.#n && this.#n.setAttribute("aria-busy", "false"), this.#s = n, this.#c(), n !== "completed" && n !== "failed" && n !== "unknown" ? this.#o = window.setTimeout(
      () => this.#d(),
      bf.POLL_INTERVAL
    ) : this.#o = null;
  }
  /**
   * Stop polling the backend for job status.
   * @returns void
   */
  #f() {
    this.classList.remove("status-checker--active"), this.#o !== null && (clearTimeout(this.#o), this.#o = null);
  }
  /**
   * Fetch the job status from the backend API.
   * @returns JobStatusResponse The job status response.
   */
  async #p() {
    const n = {
      id: this.#e ?? "",
      jobType: "",
      status: "unknown"
    }, l = `${this.#i?.replace(/\/$/, "")}/${this.#e}`;
    if (!l) return n;
    try {
      const p = await fetch(l);
      if (!p.ok) throw new Error("Network error");
      const x = await p.json(), M = bf.jobStatusList.includes(
        x.status
      ) ? x.status : "unknown";
      return await new Promise((S) => setTimeout(S, 5e3)), {
        id: x.id,
        jobType: x.job_type,
        status: M
      };
    } catch (p) {
      return console.error("Error fetching status:", p), n;
    }
  }
  /**
   * Create the alert region for screen readers.
   * @returns HTMLSpanElement The created alert region element.
   */
  #g() {
    const n = document.createElement("span");
    return n.className = "status-checker__alert", n.setAttribute("aria-live", "polite"), n.setAttribute("aria-busy", "false"), n.setAttribute("role", "alert"), n.textContent = `${this.#t ?? "Job"} is ${this.#s?.trim() ?? "unknown"}`, n;
  }
  /**
   * Returns the element that contains the status text, if its not wrapped already then it will wrap it in a span.
   * Also removes any existing text nodes and returns the status tag element.
   * @returns HTMLSpanElement The status tag element.
   */
  #y() {
    let n = this.querySelector(
      ":scope > *:not(.status-checker__alert)"
    );
    if (!n) {
      const l = this.textContent?.trim() ?? "";
      for (; this.firstChild; )
        this.removeChild(this.firstChild);
      n = document.createElement("span"), n.textContent = l, this.appendChild(n);
    }
    return n;
  }
}
customElements.define("status-checker", bf);
class vz extends HTMLElement {
  static observedAttributes = ["text"];
  #e = null;
  #t = null;
  connectedCallback() {
    this.#i(), this.#e = this.querySelector("button"), this.#t = this.querySelector(".copy-text__feedback"), this.#e && this.#e.addEventListener("click", () => this.#r());
  }
  #i() {
    this.getAttribute("styled") === "true" && this.classList.add("copy-text");
    const n = this.innerHTML || "Copy", l = this.getAttribute("label") || "Copy to clipboard", p = this.getAttribute("feedback") || "Copied!";
    this.innerHTML = `
      <button type="button" aria-label="${l}" class="copy-text__button">
        <slot>${n}</slot>
      </button>
      <span class="copy-text__feedback" aria-live="polite" style="display:none;">${p}</span>
    `;
  }
  #r() {
    const n = this.getAttribute("text") || "";
    n && navigator.clipboard.writeText(n).then(() => {
      this.#t && (this.#t.style.display = "inline", setTimeout(() => {
        this.#t && (this.#t.style.display = "none");
      }, 2e3));
    });
  }
}
customElements.define("copy-text", vz);
class xz extends HTMLElement {
  static observedAttributes = ["title", "url", "enableToggle"];
  el = null;
  connectedCallback() {
    this.#e();
  }
  #e() {
    this.innerHTML = `
      <style>
        .view-pdf__top:has(#show-pdf:not(:checked)) ~ .view-pdf__container { display: none; }
        .view-pdf__top:has(#show-pdf:checked) ~ .view-pdf__container { display: block; }
        .view-pdf .view-pdf__container { width: 100%; }
        .view-pdf .view-pdf__map, .view-pdf #pdf { border: 1px solid #000; width: 100%; height: 400px; }
      </style>
      <div class="view-pdf">
        <div class="view-pdf__top">
          <h2 class="govuk-heading-m">${this.getAttribute("title")}</h2>
          ${this.#t()}
        </div>
        <div class="view-pdf__container">
          <iframe class="view-pdf__pdf" id="pdf" src="${this.getAttribute("url")}"></iframe>
        </div>
      </div>
    `, this.el = this.querySelector(".view-pdf");
  }
  #t() {
    return this.getAttribute("enableToggle") !== "true" ? "" : `
      <div class="view-pdf__actions">
        <p class="govuk-body">
          <a href="${this.getAttribute("url")}" class="govuk-link govuk-link--no-visited-state" rel="noreferrer noopener" target="_blank">Open <span class="govuk-visually-hidden">PDF</span> in new window</a>
        </p>
        <fieldset class="govuk-fieldset">
          <legend class="govuk-fieldset__legend govuk-fieldset__legend--m govuk-visually-hidden">
            Show and hide PDF preview
          </legend>
          <div class="govuk-checkboxes govuk-checkboxes--small" data-module="govuk-checkboxes">
            <div class="govuk-checkboxes__item">
              <input class="govuk-checkboxes__input" id="show-pdf" name="show-pdf" type="checkbox" value="show-pdf" checked="checked">
              <label class="govuk-label govuk-checkboxes__label" for="show-pdf">
                Show PDF
              </label>
            </div>
          </div>
        </fieldset>
      </div>
    `;
  }
  // attributeChangedCallback(
  //   name: string,
  //   oldValue: string | null,
  //   newValue: string | null
  // ) {
  //   console.log(
  //     `Attribute ${name} has changed from ${oldValue} to ${newValue}.`
  //   );
  // }
}
customElements.define("view-pdf", xz);
export {
  vz as CopyText,
  ZT as LoadingSpinner,
  $T as MyBox,
  xz as PdfComponent,
  yz as SimpleMap,
  bf as StatusChecker
};
